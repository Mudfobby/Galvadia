/*	NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES NOTES 
1. Update UI to flexbox
2. Have energy and mana for special attacks?
3. Make a visual inventory on the right side and allow unpacking slot numbers like "unpack 1" or "unpack 2"
*/
let NPCConversationIntervals = {

}
let bossTimeouts = {

}

let playerBuffIntervals = {

}
let shiftKeyPressed = false;
document.addEventListener('keyup', function(event) {
	if (event.shiftKey) {
		shiftKeyPressed = false;
	}
});

const cooldownBar = document.querySelector('.bar-1')
let empowerPlayerTimeout
let playerBuffs = []
let catalystTimeout
let sinisterMarksTimeout
let piercingArrowTimeout
let piercingArrowInterval
let buff1Interval
let noMove = 'you cannot move in that direction'
let commandLine = document.getElementById('commandLine')
commandLine.focus()
let pushMonster = []
let roomEnemies = []
let directionMoved
let dialogueSpeed = 0
//classes
let yellow = 'yellow'
let red = 'red'
let blue = 'blue'
let orange = 'orange'
let green = 'green'
let purple = 'purple'
let white = 'white'
let brown = 'brown'
let pink = 'pink'
let black = 'black'
//HTML elements
//____________________________________________________++SWING VOCABULARY++__________________________________________
//expertise, swing, weapon, enemy, number damage
let blockedDamage
// let playerBlockedDamage
function blankSpace() {
	if (masterArea.lastChild != undefined && masterArea.lastChild.classList.contains('hide')) {
	} else {
		let space = document.createElement('div')
		masterArea.appendChild(space)
		space.textContent = 'SPACE'
		space.classList.add('hide')
	}
	updateScroll()
}

function expertise(weapon) {
	console.log('expertise ran')
	let playerExpertiseLevel
	let playerExpertiseAdjective
	if (weapon.type.oneHanded == true) {
		playerExpertiseLevel = player.oneHanded.level
	} else if (weapon.type.twoHanded == true) {
		playerExpertiseLevel = player.twoHanded.level
	} else if (weapon.type.unarmed == true) {
		playerExpertiseLevel = player.unarmed.level
	} else if (weapon.type.daggers == true) {
		playerExpertiseLevel = player.daggers.level
	}

	if (playerExpertiseLevel <= 4) {
		playerExpertiseAdjective = 'clumsily '
	} else if (playerExpertiseLevel <= 7) {
		playerExpertiseAdjective = 'novicely '
	}

	return playerExpertiseAdjective
}


function oneHandedSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		oneHandedMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(' and miss!', 'white', line1)
		blankSpace()
	} else {
		oneHandedHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}
function bowSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		bowMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`fire an arrow from your `, 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} `, 'white', line1) //at
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord('and miss!', 'white', line1)
		blankSpace()
	} else {
		bowHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`fire an arrow from your `, 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}

function daggerSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		daggerMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord('and miss!', 'white', line1)
		blankSpace()
	} else {
		daggerHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}
// weapon, enemy, damage, penName, playerSwingType, atIntoOnto
function twoHandedSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		twoHandedMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord('and miss!', 'white', line1)
		blankSpace()
	} else {
		blankSpace()
		twoHandedHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}
function unarmedSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		unarmedMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`swing `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(' and miss!', 'white', line1)
		blankSpace()
	} else {
		unarmedHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage.', 'green', line2)
		customizeEachWord(` (Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		// blankSpace()
		console.log('TEST TEST TEST')
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}

function words(wordOrWords, color) {
	const messageSpan = document.createElement('span')
	messageSpan.textContent = wordOrWords
	messageSpan.classList.add(color)
	return messageSpan
}

function quickMessage(message, classChange) {
	const messageDiv = document.createElement('div')
	messageDiv.appendChild(words(message, classChange))
	masterArea.appendChild(messageDiv)
	updateScroll()
}

const dialoguePlay = document.createElement('audio')
dialoguePlay.setAttribute('src', 'galvadia_text_lufia.mp3')
////////////////////////////////////////////////////////////SPELLS
const fireSpellConjure = document.createElement('audio')
const fireflamesPlay1 = document.createElement('audio')
const fireflamesPlay2 = document.createElement('audio')
const fireflamesPlay3 = document.createElement('audio')
const infernoPlay1 = document.createElement('audio')
const infernoPlay2 = document.createElement('audio')
const infernoPlay3 = document.createElement('audio')
const meteorPlay1 = document.createElement('audio')
const meteorPlay2 = document.createElement('audio')
const meteorPlay3 = document.createElement('audio')
const fireflamesArray = [fireflamesPlay1, fireflamesPlay2, fireflamesPlay3]
const infernoArray = [infernoPlay1, infernoPlay2, infernoPlay3]
const meteorArray = [meteorPlay1, meteorPlay2, meteorPlay3]
fireSpellConjure.setAttribute('src', './magic/fire/conjure/fire conjure.mp3')
fireflamesPlay1.setAttribute('src', './magic/fire/fireflames/fireflames.mp3')
fireflamesPlay2.setAttribute('src', './magic/fire/fireflames/fireflames higher.mp3')
fireflamesPlay3.setAttribute('src', './magic/fire/fireflames/fireflames lower.mp3')
infernoPlay1.setAttribute('src', './magic/fire/inferno/inferno.mp3')
infernoPlay2.setAttribute('src', './magic/fire/inferno/inferno higher.mp3')
infernoPlay3.setAttribute('src', './magic/fire/inferno/inferno lower.mp3')
meteorPlay1.setAttribute('src', './magic/fire/meteor/meteor.mp3')
meteorPlay2.setAttribute('src', './magic/fire/meteor/meteor higher.mp3')
meteorPlay3.setAttribute('src', './magic/fire/meteor/meteor lower.mp3')


const iceSpellConjure = document.createElement('audio')
const frostfreezePlay1 = document.createElement('audio')
const frostfreezePlay2 = document.createElement('audio')
const frostfreezePlay3 = document.createElement('audio')
const blizzardPlay1 = document.createElement('audio')
const blizzardPlay2 = document.createElement('audio')
const blizzardPlay3 = document.createElement('audio')
const cryoclastPlay1 = document.createElement('audio')
const cryoclastPlay2 = document.createElement('audio')
const cryoclastPlay3 = document.createElement('audio')
const frostfreezeArray = [frostfreezePlay1, frostfreezePlay2, frostfreezePlay3]
const blizzardArray = [blizzardPlay1, blizzardPlay2, blizzardPlay3]
const cryoclastArray = [cryoclastPlay1, cryoclastPlay2, cryoclastPlay3]
iceSpellConjure.setAttribute('src', './magic/ice/conjure/ice conjure.mp3')
frostfreezePlay1.setAttribute('src', './magic/ice/frostfreeze/frostfreeze.mp3')
frostfreezePlay2.setAttribute('src', './magic/ice/frostfreeze/frostfreeze higher.mp3')
frostfreezePlay3.setAttribute('src', './magic/ice/frostfreeze/frostfreeze lower.mp3')
blizzardPlay1.setAttribute('src', './magic/ice/blizzard/blizzard.mp3')
blizzardPlay2.setAttribute('src', './magic/ice/blizzard/blizzard higher.mp3')
blizzardPlay3.setAttribute('src', './magic/ice/blizzard/blizzard lower.mp3')
cryoclastPlay1.setAttribute('src', './magic/ice/cryoclast/cryoclast.mp3')
cryoclastPlay2.setAttribute('src', './magic/ice/cryoclast/cryoclast higher.mp3')
cryoclastPlay3.setAttribute('src', './magic/ice/cryoclast/cryoclast lower.mp3')


const lightningSpellConjure = document.createElement('audio')
const flashboltPlay1 = document.createElement('audio')
const flashboltPlay2 = document.createElement('audio')
const flashboltPlay3 = document.createElement('audio')
const chainLightningPlay1 = document.createElement('audio')
const chainLightningPlay2 = document.createElement('audio')
const chainLightningPlay3 = document.createElement('audio')
const gigavoltPlay1 = document.createElement('audio')
const gigavoltPlay2 = document.createElement('audio')
const gigavoltPlay3 = document.createElement('audio')
const flashboltArray = [flashboltPlay1, flashboltPlay2, flashboltPlay3]
const chainLightningArray = [chainLightningPlay1, chainLightningPlay2, chainLightningPlay3]
const gigavoltArray = [gigavoltPlay1, gigavoltPlay2, gigavoltPlay3]
lightningSpellConjure.setAttribute('src', './magic/lightning/conjure/lightning conjure.mp3')
flashboltPlay1.setAttribute('src', './magic/lightning/flashbolt/flashbolt.mp3')
flashboltPlay2.setAttribute('src', './magic/lightning/flashbolt/flashbolt higher.mp3')
flashboltPlay3.setAttribute('src', './magic/lightning/flashbolt/flashbolt lower.mp3')
chainLightningPlay1.setAttribute('src', './magic/lightning/chain lightning/chain lightning.mp3')
chainLightningPlay2.setAttribute('src', './magic/lightning/chain lightning/chain lightning higher.mp3')
chainLightningPlay3.setAttribute('src', './magic/lightning/chain lightning/chain lightning lower.mp3')
gigavoltPlay1.setAttribute('src', './magic/lightning/gigavolt/gigavolt.mp3')
gigavoltPlay2.setAttribute('src', './magic/lightning/gigavolt/gigavolt higher.mp3')
gigavoltPlay3.setAttribute('src', './magic/lightning/gigavolt/gigavolt lower.mp3')

////////////////////////////////////////////////////////////
const shortswordHitPlay1 = document.createElement('audio')
const shortswordHitPlay2 = document.createElement('audio')
const shortswordHitPlay3 = document.createElement('audio')
const shortswordHitPlay4 = document.createElement('audio')
const shortswordHitPlay5 = document.createElement('audio')
const oneHandedHitArray1 = [shortswordHitPlay1, shortswordHitPlay2, shortswordHitPlay3, shortswordHitPlay4, shortswordHitPlay5]

shortswordHitPlay1.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_1.wav')
shortswordHitPlay2.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_2.wav')
shortswordHitPlay3.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_3.wav')
shortswordHitPlay4.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_4.wav')
shortswordHitPlay5.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_5.wav')

const shortswordMissPlay1 = document.createElement('audio')
const shortswordMissPlay2 = document.createElement('audio')
const shortswordMissPlay3 = document.createElement('audio')
const shortswordMissPlay4 = document.createElement('audio')
const shortswordMissPlay5 = document.createElement('audio')
const oneHandedMissArray1 = [shortswordMissPlay1, shortswordMissPlay2, shortswordMissPlay3, shortswordMissPlay4, shortswordMissPlay5]

shortswordMissPlay1.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_1.wav')
shortswordMissPlay2.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_2.wav')
shortswordMissPlay3.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_3.wav')
shortswordMissPlay4.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_4.wav')
shortswordMissPlay5.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_5.wav')
////////////////////////////////////////////////////////////
const longswordHitPlay1 = document.createElement('audio')
const longswordHitPlay2 = document.createElement('audio')
const longswordHitPlay3 = document.createElement('audio')
const longswordHitPlay4 = document.createElement('audio')
const longswordHitPlay5 = document.createElement('audio')
const twoHandedHitArray1 = [longswordHitPlay1, longswordHitPlay2, longswordHitPlay3, longswordHitPlay4, longswordHitPlay5]

longswordHitPlay1.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_1.wav')
longswordHitPlay2.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_2.wav')
longswordHitPlay3.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_3.wav')
longswordHitPlay4.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_4.wav')
longswordHitPlay5.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_5.wav')

const longswordMissPlay1 = document.createElement('audio')
const longswordMissPlay2 = document.createElement('audio')
const longswordMissPlay3 = document.createElement('audio')
const longswordMissPlay4 = document.createElement('audio')
const longswordMissPlay5 = document.createElement('audio')
const twoHandedMissArray1 = [longswordMissPlay1, longswordMissPlay2, longswordMissPlay3, longswordMissPlay4, longswordMissPlay5]

longswordMissPlay1.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_1.wav')
longswordMissPlay2.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_2.wav')
longswordMissPlay3.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_3.wav')
longswordMissPlay4.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_4.wav')
longswordMissPlay5.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_5.wav')
////////////////////////////////////////////////////////////
const shivHitPlay1 = document.createElement('audio')
const shivHitPlay2 = document.createElement('audio')
const shivHitPlay3 = document.createElement('audio')
const shivHitPlay4 = document.createElement('audio')
const shivHitPlay5 = document.createElement('audio')
const daggerHitArray1 = [shivHitPlay1, shivHitPlay2, shivHitPlay3, shivHitPlay4, shivHitPlay5]

shivHitPlay1.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_1.wav')
shivHitPlay2.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_2.wav')
shivHitPlay3.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_3.wav')
shivHitPlay4.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_4.wav')
shivHitPlay5.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_5.wav')

const shivMissPlay1 = document.createElement('audio')
const shivMissPlay2 = document.createElement('audio')
const shivMissPlay3 = document.createElement('audio')
const shivMissPlay4 = document.createElement('audio')
const shivMissPlay5 = document.createElement('audio')
const daggerMissArray1 = [shivMissPlay1, shivMissPlay2, shivMissPlay3, shivMissPlay4, shivMissPlay5]

shivMissPlay1.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_1.wav')
shivMissPlay2.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_2.wav')
shivMissPlay3.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_3.wav')
shivMissPlay4.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_4.wav')
shivMissPlay5.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_5.wav')
////////////////////////////////////////////////////////////
const shortbowHitPlay1 = document.createElement('audio')
const shortbowHitPlay2 = document.createElement('audio')
const shortbowHitPlay3 = document.createElement('audio')
const shortbowHitPlay4 = document.createElement('audio')
const shortbowHitPlay5 = document.createElement('audio')
const bowHitArray1 = [shortbowHitPlay1, shortbowHitPlay2, shortbowHitPlay3, shortbowHitPlay4, shortbowHitPlay5]

shortbowHitPlay1.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_1.wav')
shortbowHitPlay2.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_2.wav')
shortbowHitPlay3.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_3.wav')
shortbowHitPlay4.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_4.wav')
shortbowHitPlay5.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_5.wav')

const shortbowMissPlay1 = document.createElement('audio')
const shortbowMissPlay2 = document.createElement('audio')
const shortbowMissPlay3 = document.createElement('audio')
const shortbowMissPlay4 = document.createElement('audio')
const shortbowMissPlay5 = document.createElement('audio')
const bowMissArray1 = [shortbowMissPlay1, shortbowMissPlay2, shortbowMissPlay3, shortbowMissPlay4, shortbowMissPlay5]

shortbowMissPlay1.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_1.wav')
shortbowMissPlay2.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_2.wav')
shortbowMissPlay3.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_3.wav')
shortbowMissPlay4.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_4.wav')
shortbowMissPlay5.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_5.wav')
////////////////////////////////////////////////////////////
const unarmedHitPlay1 = document.createElement('audio')
const unarmedHitPlay2 = document.createElement('audio')
const unarmedHitPlay3 = document.createElement('audio')
const unarmedHitPlay4 = document.createElement('audio')
const unarmedHitPlay5 = document.createElement('audio')
const unarmedHitArray1 = [unarmedHitPlay1, unarmedHitPlay2, unarmedHitPlay3, unarmedHitPlay4, unarmedHitPlay5]

unarmedHitPlay1.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_1.wav')
unarmedHitPlay2.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_2.wav')
unarmedHitPlay3.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_3.wav')
unarmedHitPlay4.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_4.wav')
unarmedHitPlay5.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_5.wav')

const unarmedMissPlay1 = document.createElement('audio')
const unarmedMissPlay2 = document.createElement('audio')
const unarmedMissPlay3 = document.createElement('audio')
const unarmedMissPlay4 = document.createElement('audio')
const unarmedMissPlay5 = document.createElement('audio')
const unarmedMissArray1 = [unarmedMissPlay1, unarmedMissPlay2, unarmedMissPlay3, unarmedMissPlay4, unarmedMissPlay5]

unarmedMissPlay1.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_1.wav')
unarmedMissPlay2.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_2.wav')
unarmedMissPlay3.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_3.wav')
unarmedMissPlay4.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_4.wav')
unarmedMissPlay5.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_5.wav')
////////////////////////////////////////////////////////////
function dialogue(gameDialogue, textColor) {
	dialogueFinished = false
	let stopSound = false
	player.dialogueStasis = true
	const text = gameDialogue
	let timer
	let i = 0
	let textBox = document.createElement('span')
	if (textColor != undefined) {
		textBox.classList.add(textColor)
	} else {
		textBox.classList.add(textColor, 'light-blue')
	}
	setTimeout(() => {
		masterArea.appendChild(textBox)
		if (dialogueSpeed == 0 || dialogueSpeed == 'instant') {
			player.dialogueStasis = false
			let textNode = document.createTextNode(text)
			textBox.appendChild(textNode)
			updateScroll()
		} else {
			dialoguePlay.play()
			function dialogueInterval() {
				let textNode = document.createTextNode(text[i])
				// playSound()
				textBox.appendChild(textNode)
				updateScroll()
				i++

				if (i == text.length) {
					player.dialogueStasis = false
					stopSound = true
					if (stopSound == true) {
						dialoguePlay.pause()
					}
				}
				if (i >= text.length) {
					dialogueFinished = true
					clearInterval(timer)
				}
			}
			timer = setInterval(dialogueInterval, dialogueSpeed)
		}
	}, 200)
}
function npcDialogue(gameDialogue, textColor) {
	dialogueFinished = false
	let stopSound = false
	player.dialogueStasis = true
	const beginQuote = document.createElement('span')
	beginQuote.classList.add('white')
	beginQuote.textContent = '"'
	const endQuote = document.createElement('span')
	endQuote.classList.add('white')
	endQuote.textContent = '"'
	const text = gameDialogue
	let timer
	let i = 0
	let textBox = document.createElement('div')
	textBox.classList.add('npc-dialogue')
	if (textColor != undefined) {
		textBox.classList.add(textColor)
	} else {
		textBox.classList.add(textColor, 'orange')
	}
	setTimeout(() => {
		blankSpace()
		masterArea.appendChild(textBox)
		if (dialogueSpeed == 0 || dialogueSpeed == 'instant') {
			player.dialogueStasis = false
			let textNode = document.createTextNode(`${text}`)
			textBox.appendChild(beginQuote)
			textBox.appendChild(textNode)
			textBox.appendChild(endQuote)
			updateScroll()
		} else {
			dialoguePlay.play()
			textBox.appendChild(beginQuote)
			function dialogueInterval() {
				let textNode = document.createTextNode(text[i])
				// playSound()
				textBox.appendChild(textNode)
				updateScroll()
				i++

				if (i == text.length) {
					player.dialogueStasis = false
					stopSound = true
					if (stopSound == true) {
						dialoguePlay.pause()
						textBox.appendChild(endQuote)
					}
				}
				if (i >= text.length) {
					blankSpace()
					dialogueFinished = true
					clearInterval(timer)
				}
			}
			timer = setInterval(dialogueInterval, dialogueSpeed)
		}
	}, 0)
}

function gameDialogue(gameDialogue) {
	dialogueFinished = false
	player.dialogueStasis = true
	const text = gameDialogue
	let timer
	let i = 0
	let textBox = document.createElement('span')
	textBox.classList.add('game-dialogue')
	setTimeout(() => {
		blankSpace()
		masterArea.appendChild(textBox)
		if (dialogueSpeed == 0 || dialogueSpeed == 'instant') {
			player.dialogueStasis = false
			let textNode = document.createTextNode(text)
			textBox.appendChild(textNode)
			blankSpace()
			updateScroll()
		} else {
			function dialogueInterval() {
				let textNode = document.createTextNode(text[i])
				// playSound()
				textBox.appendChild(textNode)
				updateScroll()
				i++
				if (i == text.length) {
					player.dialogueStasis = false
				}
				if (i >= text.length) {
					dialogueFinished = true
					clearInterval(timer)
				}
			}
			timer = setInterval(dialogueInterval, dialogueSpeed)
		}
	}, 200)
}

function sellItemDialog(itemName, sellValue) {
	let line1 = document.createElement('div')
	blankSpace()
	customizeEachWord(`You sell your `, 'white', line1)
	customizeEachWord(`${itemName} `, 'green', line1)
	customizeEachWord(`for `, 'white', line1)
	customizeEachWord(`${sellValue} `, 'yellow', line1)
	customizeEachWord(`gold piece(s)`, 'white', line1)
	blankSpace()
}
function createDivElement(text, classNames = []) {
	const div = document.createElement('div');
	div.textContent = text;
	div.classList.add(...classNames);
	return div;
}
function weaponDescription(item) {
	const mainDiv = document.createElement('div');
	mainDiv.classList.add('item-description');

	//type
	let damageOrDefenseDiv = item.type.weapon ? 'Damage' : 'Armor'

	const itemNameDiv = createDivElement(item.name, ['item-description-name', item.color]);
	const typeDiv = createDivElement(`Type: ${item.type.skillUsed}`);
	const swingTypeDiv = createDivElement(`Swing Type: ${item.type.swingType}`) 
	const damageDiv = createDivElement(`${damageOrDefenseDiv}:`, ['row-flex'])
	let damageNumberDiv 
	if (item.type.weapon) {
		damageNumberDiv = createDivElement(`${item.botDamage} - ${item.topDamage}`, ['light-blue', 'small-left-margin']);
	}
	if (item.type.armor) {
		damageNumberDiv = createDivElement(`${item.mods.armor}`, ['light-blue', 'small-left-margin']);

	}
	const sellValueDiv = createDivElement('', ['row-flex']);
	const sellWordDiv = createDivElement('Value:');
	const sellNumberDiv = createDivElement(`${item.sellValue}`, ['yellow', 'small-left-margin']);

	damageDiv.appendChild(damageNumberDiv);
	sellValueDiv.appendChild(sellWordDiv);
	sellValueDiv.appendChild(sellNumberDiv);
	mainDiv.appendChild(itemNameDiv);
	mainDiv.appendChild(typeDiv);
	mainDiv.appendChild(swingTypeDiv);
	mainDiv.appendChild(damageDiv);
	masterArea.appendChild(mainDiv);
	if (item.mods) {
		const modsContainer = createDivElement()
		modsContainer.classList.add('simple-flex-column')
		const modHeader = createDivElement()
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		let wordsAndColors = []
		for (let mod in item.mods) {
			let modAbbreviation = mod
			if (mod == 'str') {mod = 'Strength'}
			if (mod == 'con') {mod = 'Constitution'}
			if (mod == 'dex') {mod = 'Dexterity'}
			if (mod == 'agi') {mod = 'Agility'}
			if (mod == 'int') {mod = 'Intelligence'}
			if (mod == 'wis') {mod = 'Wisdom'}
			if (mod == 'slashingPen') {mod = 'Slashing Penetration'}
			if (mod == 'piercingPen') {mod = 'Piercing Penetration'}
			if (mod == 'bluntPen') {mod = 'Blunt Penetration'}
			console.log(mod)
			console.log(modAbbreviation)
			console.log(item[mod])
			if (item.mods[modAbbreviation] > 0) {
			if (mod != 'armor' && !item.type.armor) {
				wordsAndColors.push({number: item.mods[modAbbreviation], word: mod, color: 'green'})
			}
		}
		}
		wordsAndColors.forEach(item => {
			let span = document.createElement('span')
			let numberSpan = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(span)
			mainSpan.appendChild(numberSpan)
			numberSpan.classList.add(item.color)
			span.textContent = capitalizeFirstLetter(item.word)
			numberSpan.textContent = ' ' +  '+' + item.number 
			
			modsContainer.appendChild(mainSpan)
		})
	}
	mainDiv.appendChild(sellValueDiv)
	if (item.requirements) {
		if (Object.keys(item.requirements).length != 0) {
		const modsContainer = createDivElement()
		const modHeader = document.createElement('span')
		modHeader.textContent = 'Requirements'
		modHeader.classList.add('red')
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		modsContainer.classList.add('simple-flex-column', 'requirements')

		let wordsAndColors = []
		for (let requirement in item.requirements) {
			let originalRequirement = requirement
			if (requirement == 'str') {requirement = 'Strength'}
			if (requirement == 'con') {requirement = 'Constitution'}
			if (requirement == 'dex') {requirement = 'Dexterity'}
			if (requirement == 'agi') {requirement = 'Agility'}
			if (requirement == 'int') {requirement = 'Intelligence'}
			if (requirement == 'wis') {requirement = 'Wisdom'}
			wordsAndColors.push({number: item.requirements[originalRequirement], word: requirement, color: 'yellow'})
		}
		wordsAndColors.forEach(item => {
			let wordSpan = document.createElement('span')
			let numberSpan = document.createElement('span')
			let openParenth = document.createElement('span')
			let closeParenth = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(wordSpan)
			mainSpan.appendChild(openParenth)
			mainSpan.appendChild(numberSpan)
			mainSpan.appendChild(closeParenth)
			wordSpan.textContent = item.word
			openParenth.textContent = ' ('
			numberSpan.classList.add(item.color)
			numberSpan.textContent = item.number
			closeParenth.textContent = ')'
			modsContainer.appendChild(mainSpan)
		})
	}

	}
	mainDiv.appendChild(createDivElement(item.description, ['item-flavor-text']));
	// mainDiv.appendChild(createDivElement(`Location: ${item.roomId}`))
}
function armorDescription(item) {
	quickMessage(`armor description ran`)
	const mainDiv = document.createElement('div');
	mainDiv.classList.add('item-description');
	function createDivElement(text, classNames = []) {
		const div = document.createElement('div');
		div.textContent = text;
		div.classList.add(...classNames);
		return div;
	}
	//weight
	let defense = 'Armor'

	const itemNameDiv = createDivElement(item.name, ['item-description-name', item.color]);
	const typeDiv = createDivElement(`Type: ${item.type.armorType}`);
	const defenseDiv = createDivElement(`${defense}:`, ['row-flex'])
	const weightDiv = createDivElement(`Weight: `, ['row-flex'])
	let armorNumberDiv
	let weightNumberDiv = createDivElement(`${item.mods.weight}`, ['light-blue', 'small-left-margin'])
	if (item.type.armor) {
		armorNumberDiv = createDivElement(`${item.mods.armor}`, ['light-blue', 'small-left-margin']);
	}
	const sellValueDiv = createDivElement('', ['row-flex']);
	const sellWordDiv = createDivElement('Value:', 'white');
	const sellNumberDiv = createDivElement(`${item.sellValue}`, ['yellow', 'small-left-margin']);

	defenseDiv.appendChild(armorNumberDiv);
	weightDiv.appendChild(weightNumberDiv);
	sellValueDiv.appendChild(sellWordDiv);
	sellValueDiv.appendChild(sellNumberDiv);

	mainDiv.appendChild(itemNameDiv);
	mainDiv.appendChild(createDivElement(item.description, ['item-flavor-text']));
	mainDiv.appendChild(typeDiv);
	mainDiv.appendChild(defenseDiv);
	mainDiv.appendChild(weightDiv);

	if (item.mods) {
		const modsContainer = createDivElement()
		modsContainer.classList.add('simple-flex-column')
		const modHeader = createDivElement()
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		let wordsAndColors = []
		for (let mod in item.mods) {
			let modAbbreviation = mod
			if (mod == 'str') {mod = 'Strength'}
			if (mod == 'con') {mod = 'Constitution'}
			if (mod == 'dex') {mod = 'Dexterity'}
			if (mod == 'agi') {mod = 'Agility'}
			if (mod == 'int') {mod = 'Intelligence'}
			if (mod == 'wis') {mod = 'Wisdom'}
			if (mod == 'slashingPen') {mod = 'Slashing Penetration'}
			if (mod == 'piercingPen') {mod = 'Piercing Penetration'}
			if (mod == 'bluntPen') {mod = 'Blunt Penetration'}
			console.log(mod)
			console.log(modAbbreviation)
			console.log(item[mod])
			if (item.mods[modAbbreviation] > 0) {
			if (mod != 'armor' && mod != 'weight') {
				wordsAndColors.push({number: item.mods[modAbbreviation], word: mod, color: 'green'})
			}
		}
		}
		wordsAndColors.forEach(item => {
			let span = document.createElement('span')
			let numberSpan = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(numberSpan)
			mainSpan.appendChild(span)
			numberSpan.classList.add(item.color)
			numberSpan.textContent = '+' + item.number + ' '
			span.textContent = item.word
			modsContainer.appendChild(mainSpan)
		})
	}

	if (item.requirements) {
		if (Object.keys(item.requirements).length != 0) {
		const modsContainer = createDivElement()
		const modHeader = document.createElement('span')
		modHeader.textContent = 'Requirements'
		modHeader.classList.add('red')
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		modsContainer.classList.add('simple-flex-column', 'requirements')

		let wordsAndColors = []
		for (let requirement in item.requirements) {
			let originalRequirement = requirement
			if (requirement == 'str') {requirement = 'Strength'}
			if (requirement == 'con') {requirement = 'Constitution'}
			if (requirement == 'dex') {requirement = 'Dexterity'}
			if (requirement == 'agi') {requirement = 'Agility'}
			if (requirement == 'int') {requirement = 'Intelligence'}
			if (requirement == 'wis') {requirement = 'Wisdom'}
			wordsAndColors.push({number: item.requirements[originalRequirement], word: requirement, color: 'yellow'})
		}
		wordsAndColors.forEach(item => {
			let wordSpan = document.createElement('span')
			let numberSpan = document.createElement('span')
			let openParenth = document.createElement('span')
			let closeParenth = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(wordSpan)
			mainSpan.appendChild(openParenth)
			mainSpan.appendChild(numberSpan)
			mainSpan.appendChild(closeParenth)
			wordSpan.textContent = item.word
			openParenth.textContent = ' ('
			numberSpan.classList.add(item.color)
			numberSpan.textContent = item.number
			closeParenth.textContent = ')'
			modsContainer.appendChild(mainSpan)
		})
	}
	}
	mainDiv.appendChild(sellValueDiv)
	masterArea.appendChild(mainDiv);
}


// function armorDescription(item) {
// 	const mainDiv = document.createElement('div')
// 	mainDiv.classList.add('item-description')
// 	// const locationDiv = document.createElement('div')
// 	// const locationNode = document.createTextNode(`Location: ${item.roomId}`)
// 	// locationDiv.appendChild(locationNode)
// 	const itemNameDiv = document.createElement('div')
// 	itemNameDiv.classList.add(item.color)
// 	itemNameDiv.classList.add('item-description-name')
// 	const itemNameNode = document.createTextNode(`${item.name}`)
// 	itemNameDiv.appendChild(itemNameNode)
// 	const itemDescriptionDiv = document.createElement('p')
// 	itemDescriptionDiv.classList.add('grey', 'italic')
// 	const itemDescriptionNode = document.createTextNode(`${item.description}`)
// 	itemDescriptionDiv.appendChild(itemDescriptionNode)
// 	mainDiv.appendChild(itemNameDiv)
// 	let itemValues = Object.values(item.mods)
// 	let itemKeys = Object.keys(item.mods)

// 	for (let i = 0; i < itemKeys.length; i++) {
// 		if (itemKeys[i] == 'armor') {
// 			itemKeys[i] = 'Armor'
// 			const armorDiv = document.createElement('div')
// 			const armorWordDiv = document.createElement('div')
// 			const armorNumberDiv = document.createElement('div')
// 			armorDiv.classList.add('row-flex')
// 			armorNumberDiv.classList.add('light-blue')
// 			armorNumberDiv.classList.add('small-left-margin')
// 			const armorWord = document.createTextNode(`Armor:`)
// 			const armorNumber = document.createTextNode(`${itemValues[i]}`)
// 			armorWordDiv.appendChild(armorWord)
// 			armorNumberDiv.appendChild(armorNumber)
// 			armorWordDiv.appendChild(armorWord)
// 			armorNumberDiv.appendChild(armorNumber)
// 			armorDiv.appendChild(armorWordDiv)
// 			armorDiv.appendChild(armorNumberDiv)
// 			mainDiv.appendChild(armorDiv)
// 			itemKeys.splice(itemKeys.indexOf(itemKeys[i]), 1)
// 		}
// 	}
// 	const modsContainer = document.createElement('div')
// 	modsContainer.classList.add('column-flex')
// 	const modHeader = document.createElement('div')
// 	modsContainer.appendChild(modHeader)
// 	const modText = document.createTextNode(`Stat Bonus`)
// 	modHeader.appendChild(modText)
// 	mainDiv.appendChild(modsContainer)
// 	for (let i = 0; i < itemKeys.length; i++) {
// 		let textDiv = document.createElement('div')
// 		if (itemKeys[i] == 'armor') {
// 		} else if (itemKeys[i] == 'str') {
// 			itemKeys[i] = 'Strength'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'dex') {
// 			itemKeys[i] = 'Dexterity'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'agi') {
// 			itemKeys[i] = 'Agility'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'con') {
// 			itemKeys[i] = 'Constitution'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'int') {
// 			itemKeys[i] = 'Intellect'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'wis') {
// 			itemKeys[i] = 'Wisdom'
// 			textDiv.classList.add('green')
// 		} else {
// 			let textNode = document.createTextNode(`+${itemValues[i]} ${itemKeys[i]} `)
// 			textDiv.appendChild(textNode)
// 			modsContainer.appendChild(textDiv)
// 		}
// 	}
// 	const sellValueDiv = document.createElement('div')
// 	const sellWordDiv = document.createElement('div')
// 	const sellNumberDiv = document.createElement('div')
// 	sellNumberDiv.classList.add('small-left-margin')
// 	sellValueDiv.classList.add('row-flex')
// 	sellValueDiv.appendChild(sellWordDiv)
// 	sellValueDiv.appendChild(sellNumberDiv)

// 	const sellWordNode = document.createTextNode(`Value:`)
// 	const sellNumberNode = document.createTextNode(`${item.sellValue}`)

// 	sellWordDiv.appendChild(sellWordNode)
// 	sellNumberDiv.appendChild(sellNumberNode)

// 	sellNumberDiv.classList.add('yellow')
// 	mainDiv.appendChild(sellValueDiv)
// 	// mainDiv.appendChild(locationDiv)
// 	mainDiv.appendChild(itemDescriptionDiv)
// 	masterArea.appendChild(mainDiv)
// }

function allItemDescription(item) {
	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')
	masterArea.appendChild(mainDiv)

	const itemNameDiv = document.createElement('div')
	const itemNameNode = document.createTextNode(`${item.name}`)
	itemNameDiv.classList.add(item.color)
	itemNameDiv.classList.add('item-description-name')
	itemNameDiv.appendChild(itemNameNode)
	mainDiv.appendChild(itemNameDiv)

	//slashingarmor
	if (item.type?.skillUsed) {
		const itemTypeDiv = document.createElement('div')
		const itemTypeNode = document.createTextNode(`Skill Used: ${item.type.skillUsed}`)
		itemTypeDiv.appendChild(itemTypeNode)
		mainDiv.appendChild(itemTypeDiv)
	}
	if (item.type?.armorType) {
		const damageTypeDiv = document.createElement('div')
		const damageTypeNode = document.createTextNode(`Armor Type: ${item.type.armorType}`)
		damageTypeDiv.appendChild(damageTypeNode)
		mainDiv.appendChild(damageTypeDiv)
	}
	if (item.mods?.slashingArmor) {
		const slashingArmorDiv = document.createElement('div')
		const slashingArmorWordDiv = createDivElement(`Slashing Armor: `, ['row-flex'])
		const slashingArmorValueDiv = createDivElement((`${item.mods.slashingArmor}`), ['light-blue', 'small-left-margin'])
		slashingArmorWordDiv.appendChild(slashingArmorValueDiv)
		slashingArmorDiv.appendChild(slashingArmorWordDiv)
		mainDiv.appendChild(slashingArmorDiv)
	}

	if (item.mods?.piercingArmor) {
		const piercingArmorDiv = document.createElement('div')
		const piercingArmorWordDiv = createDivElement(`Piercing Armor: `, ['row-flex'])
		const piercingArmorValueDiv = createDivElement((`${item.mods.piercingArmor}`), ['light-blue', 'small-left-margin'])
		piercingArmorWordDiv.appendChild(piercingArmorValueDiv)
		piercingArmorDiv.appendChild(piercingArmorWordDiv)
		mainDiv.appendChild(piercingArmorDiv)
	}
	if (item.mods?.bluntArmor) {
		const bluntArmorDiv = document.createElement('div')
		const bluntArmorWordDiv = createDivElement(`Blunt Armor: `, ['row-flex'])
		const bluntArmorValueDiv = createDivElement((`${item.mods.bluntArmor}`), ['light-blue', 'small-left-margin'])
		bluntArmorWordDiv.appendChild(bluntArmorValueDiv)
		bluntArmorDiv.appendChild(bluntArmorWordDiv)
		mainDiv.appendChild(bluntArmorDiv)
	}
	if (item.type?.damageType) {
		const damageTypeDiv = document.createElement('div')
		const damageTypeNode = document.createTextNode(`Damage Type: ${item.type.damageType}`)
		damageTypeDiv.appendChild(damageTypeNode)
		mainDiv.appendChild(damageTypeDiv)
	}
	if (item.type?.food) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Type: Food`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
		if (item.cookable) {
			const cookableDiv = document.createElement('div')
			const cookableNode = document.createTextNode(`Cookable: Yes`)
			cookableDiv.appendChild(cookableNode)
			mainDiv.appendChild(cookableDiv)
		} else {
			const cookableDiv = document.createElement('div')
			const cookableNode = document.createTextNode(`Cookable: No`)
			cookableDiv.appendChild(cookableNode)
			mainDiv.appendChild(cookableDiv)
		}
	}
	if (item.type?.quest) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Type: Quest Item/Sellable`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
	}
	if (item.type?.sell) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Use: Its only use is to be sold`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
	}
	if (item.type?.crafting) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Type: Crafting Material`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
	}
	if (item?.buff) {
		if (item.buff?.healthBonus > 0) {
			const healthRecoveredDiv = createDivElement(`Health: `, ['row-flex'])
			const healthValueRecoveredNode = createDivElement(`${item.buff.healthBonus} `, ['light-blue', 'small-left-margin'])
			const recoveredTextNode = createDivElement(`recovered per tick`, ['small-left-margin'])
			healthRecoveredDiv.appendChild(healthValueRecoveredNode)
			healthRecoveredDiv.appendChild(recoveredTextNode)
			mainDiv.appendChild(healthRecoveredDiv)
		}
		if (item.buff?.manaBonus > 0) {
			const manaRecoveredDiv = createDivElement(`Mana: `, ['row-flex'])
			const manaValueRecoveredNode = createDivElement(`${item.buff.manaBonus} `, ['light-blue', 'small-left-margin'])
			const recoveredTextNode = createDivElement(`recovered per tick`, ['small-left-margin'])
			manaRecoveredDiv.appendChild(manaValueRecoveredNode)
			manaRecoveredDiv.appendChild(recoveredTextNode)
			mainDiv.appendChild(manaRecoveredDiv)
		}

	}
	if (item?.botDamage) {
		const damageWordDiv = createDivElement(`Damage: `, ['row-flex'])
		const damageValuesDiv = createDivElement(`${item.botDamage} - ${item.topDamage}`, ['light-blue', 'small-left-margin'])
		damageWordDiv.appendChild(damageValuesDiv)
		// const damageNode = document.createTextNode(`${item.botDamage} - ${item.topDamage}`)
		// damageDiv.appendChild(damageNode)
		mainDiv.appendChild(damageWordDiv)
	}

	if (item?.mods) {
		const modsContainer = createDivElement()
		const modHeader = document.createElement('span')
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		let wordsAndColors = []
		for (let mod in item.mods) {
			let modAbbreviation = mod
			if (mod == 'str') {mod = 'Strength: '}
			if (mod == 'con') {mod = 'Constitution: '}
			if (mod == 'dex') {mod = 'Dexterity: '}
			if (mod == 'agi') {mod = 'Agility: '}
			if (mod == 'int') {mod = 'Intelligence: '}
			if (mod == 'wis') {mod = 'Wisdom: '}
			if (mod == 'slashingPen') {mod = 'Slashing Penetration: '}
			if (mod == 'piercingPen') {mod = 'Piercing Penetration: '}
			if (mod == 'bluntPen') {mod = 'Blunt Penetration: '}
			if (mod == 'slashingArmor') {mod = 'Slashing Armor: '}
			if (mod == 'piercingArmor') {mod = 'Piercing Armor: '}
			if (mod == 'bluntArmor') {mod = 'Blunt Armor: '}
			if (mod == 'weight') {mod = 'Weight: '}
			if (item.mods[modAbbreviation] > 0) {
				if (mod != 'Slashing Armor: ' && mod != 'Piercing Armor: ' && mod != 'Blunt Armor: ' && mod != 'Weight: ') {
					wordsAndColors.push({number: item.mods[modAbbreviation], word: mod, color: 'green'})
					modHeader.textContent = 'Bonuses'
					modsContainer.classList.add('simple-flex-column', 'requirements')
					modHeader.classList.add('green')
				}
			}
		}
//requirements
		if (item?.requirements) {
			if (Object.keys(item.requirements).length != 0) {
			const modsContainer = createDivElement()
			const modHeader = document.createElement('span')
			modHeader.textContent = 'Requirements'
			modHeader.classList.add('red')
			modsContainer.appendChild(modHeader)
			mainDiv.appendChild(modsContainer)
			modsContainer.classList.add('simple-flex-column', 'requirements')
	
			let wordsAndColors = []
			for (let requirement in item.requirements) {
				let originalRequirement = requirement
				if (requirement == 'str') {requirement = 'Strength'}
				if (requirement == 'con') {requirement = 'Constitution'}
				if (requirement == 'dex') {requirement = 'Dexterity'}
				if (requirement == 'agi') {requirement = 'Agility'}
				if (requirement == 'int') {requirement = 'Intelligence'}
				if (requirement == 'wis') {requirement = 'Wisdom'}
				wordsAndColors.push({number: item.requirements[originalRequirement], word: requirement, color: 'yellow'})
			}
			wordsAndColors.forEach(item => {
				let wordSpan = document.createElement('span')
				let numberSpan = document.createElement('span')
				let openParenth = document.createElement('span')
				let closeParenth = document.createElement('span')
				let mainSpan = document.createElement('span')
				mainSpan.appendChild(wordSpan)
				mainSpan.appendChild(openParenth)
				mainSpan.appendChild(numberSpan)
				mainSpan.appendChild(closeParenth)
				wordSpan.textContent = item.word
				openParenth.textContent = ' ('
				numberSpan.classList.add(item.color)
				numberSpan.textContent = item.number
				closeParenth.textContent = ')'
				modsContainer.appendChild(mainSpan)
			})
		}
	}
		wordsAndColors.forEach(item => {
			let span = document.createElement('span')
			let numberSpan = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(span)
			mainSpan.appendChild(numberSpan)
			numberSpan.classList.add(item.color)
			span.textContent = capitalizeFirstLetter(item.word)
			numberSpan.textContent = ' ' +  '+' + item.number 
			
			modsContainer.appendChild(mainSpan)
		})
	}
	if (item.mods?.weight) {
		const weightDiv = document.createElement('div')
		const weightWordDiv = createDivElement(`Weight: `, ['row-flex'])
		const weightValueDiv = createDivElement((`${item.mods.weight}`), ['light-blue', 'small-left-margin'])
		weightWordDiv.appendChild(weightValueDiv)
		weightDiv.appendChild(weightWordDiv)
		mainDiv.appendChild(weightDiv)
	}
	if (item?.sellValue) {
		const sellWordDiv = document.createElement('div')
		const sellWordNode = document.createTextNode(`Value:`)
		const sellValueDiv = document.createElement('div')
		const sellNumberDiv = document.createElement('div')
		const sellNumberNode = document.createTextNode(`${item.sellValue}`)
		sellNumberDiv.classList.add('small-left-margin')
		sellValueDiv.classList.add('row-flex')
		sellValueDiv.appendChild(sellWordDiv)
		sellValueDiv.appendChild(sellNumberDiv)
		sellWordDiv.appendChild(sellWordNode)
		sellNumberDiv.appendChild(sellNumberNode)
		sellNumberDiv.classList.add('yellow')
		mainDiv.appendChild(sellValueDiv)
	}
	if (item.description) {
		const itemDescriptionDiv = document.createElement('p')
		const itemDescriptionNode = document.createTextNode(`${item.description}`)
		itemDescriptionDiv.classList.add('grey', 'italic')
		itemDescriptionDiv.appendChild(itemDescriptionNode)
		mainDiv.appendChild(itemDescriptionDiv)
	}
updateScroll()
}

function miscItemDescription(item) {
	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')
	const itemNameDiv = document.createElement('div')
	itemNameDiv.classList.add(item.color)
	itemNameDiv.classList.add('item-description-name')
	const itemNameNode = document.createTextNode(`${item.name}`)
	itemNameDiv.appendChild(itemNameNode)
	const itemDescriptionDiv = document.createElement('p')
	itemDescriptionDiv.classList.add('grey', 'italic')
	const itemDescriptionNode = document.createTextNode(`${item.description}`)
	itemDescriptionDiv.appendChild(itemDescriptionNode)

	const sellValueDiv = document.createElement('div')
	const sellWordDiv = document.createElement('div')
	const sellNumberDiv = document.createElement('div')
	sellNumberDiv.classList.add('small-left-margin')
	sellValueDiv.classList.add('row-flex')
	sellValueDiv.appendChild(sellWordDiv)
	sellValueDiv.appendChild(sellNumberDiv)

	const sellWordNode = document.createTextNode(`Value:`)
	const sellNumberNode = document.createTextNode(`${item.sellValue}`)

	sellWordDiv.appendChild(sellWordNode)
	sellNumberDiv.appendChild(sellNumberNode)

	sellNumberDiv.classList.add('yellow')

	mainDiv.appendChild(itemNameDiv)
	mainDiv.appendChild(sellValueDiv)
	mainDiv.appendChild(itemDescriptionDiv)
	masterArea.appendChild(mainDiv)
}

function npcDescription(npc) {
	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')
	const npcNameDiv = document.createElement('div')
	npcNameDiv.classList.add(npc.nameColor)
	npcNameDiv.classList.add('item-description-name')
	const npcNameNode = document.createTextNode(`${npc.name}`)
	npcNameDiv.appendChild(npcNameNode)
	const raceDiv = document.createElement('div')
	const raceNode = document.createTextNode(`Race: ${npc.race}`)
	raceDiv.appendChild(raceNode)
	const occupationDiv = document.createElement('div')
	const occupationNode = document.createTextNode(`Occupation: ${npc.occupation}`)
	occupationDiv.appendChild(occupationNode)
	const npcDescriptionDiv = document.createElement('p')
	npcDescriptionDiv.classList.add(npc.nameColor, 'italic')
	const npcDescriptionNode = document.createTextNode(`${npc.description}`)
	npcDescriptionDiv.appendChild(npcDescriptionNode)
	mainDiv.appendChild(npcNameDiv)
	mainDiv.appendChild(raceDiv)
	mainDiv.appendChild(occupationDiv)
	mainDiv.appendChild(npcDescriptionDiv)
	masterArea.appendChild(mainDiv)
}

function itemDescription(item) {
	allItemDescription(item)
	// console.log(item)
	// if (item.type.weapon) {
	// 	weaponDescription(item)
	// } else if (item.type.armor) {
	// 	armorDescription(item)
	// } else if (item.type.consumable) {
	// 	consumableDescription(item)
	// } else if (item.type.quest) {
	// 	miscItemDescription(item)
	// }
}

function enemyDescription(enemy, description) {
	let enemyHitChance =  calculateEnemyHitChance(enemy)
	let playerHitChance = calculatePlayerAccuracy() - calculateEnemyDodgeChance(enemy)

	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')

	const enemyNameDiv = document.createElement('div')
	const enemyNameNode = document.createTextNode(`${enemy.name}`)
	enemyNameDiv.classList.add('enemy-description-name', enemy.color)
	enemyNameDiv.appendChild(enemyNameNode)

	const enemyLevelDiv = document.createElement('div')
	const enemyLevelNode = document.createTextNode(`Level: ${enemy.level}`)
	enemyLevelDiv.appendChild(enemyLevelNode)

	const healthDiv = document.createElement('div')
	const healthNode = document.createTextNode(`Health: ${enemy.health}`)
	healthDiv.appendChild(healthNode)

	const attackPowerDiv = document.createElement('div')
	attackPowerDiv.classList.add('white')
	const attackPowerNode = document.createTextNode(`Attack Power: ${enemy.enemyAttackPower}`)
	attackPowerDiv.appendChild(attackPowerNode)

	const accuracyDiv = document.createElement('div')
	accuracyDiv.classList.add('white')
	const accuracyNode = document.createTextNode(`Accuracy: ${enemy.accuracy}`)
	accuracyDiv.appendChild(accuracyNode)

	const dodgeDiv = document.createElement('div')
	dodgeDiv.classList.add('white')
	const dodgeNode = document.createTextNode(`Dodge: ${enemy.dodge}`)
	dodgeDiv.appendChild(dodgeNode)

	const armorDiv = document.createElement('div')
	armorDiv.classList.add('white')
	const armorNode = document.createTextNode(`Armor: ${enemy.armor}`)
	armorDiv.appendChild(armorNode)

	const slashingArmorDiv = document.createElement('div')
	slashingArmorDiv.classList.add('white')
	const slashingArmorNode = document.createTextNode(`Slashing Armor: ${enemy.slashingArmor}`)
	slashingArmorDiv.appendChild(slashingArmorNode)

	const piercingArmorDiv = document.createElement('div')
	piercingArmorDiv.classList.add('white')
	const piercingArmorNode = document.createTextNode(`Piercing Armor: ${enemy.piercingArmor}`)
	piercingArmorDiv.appendChild(piercingArmorNode)

	const bluntArmorDiv = document.createElement('div')
	bluntArmorDiv.classList.add('white')
	const bluntArmorNode = document.createTextNode(`Blunt Armor: ${enemy.bluntArmor}`)
	bluntArmorDiv.appendChild(bluntArmorNode)

	const enemyHitChanceDiv = document.createElement('div')
	const enemyHitChanceNode = document.createTextNode(`Enemy chance to hit you: ${enemyHitChance}%`)
	enemyHitChanceDiv.appendChild(enemyHitChanceNode)

	const playerHitChanceDiv = document.createElement('div')
	const playerHitChanceNode = document.createTextNode(`Your chance to hit: ${playerHitChance}%`)
	playerHitChanceDiv.appendChild(playerHitChanceNode)

	const descriptionDiv = document.createElement('div')
	descriptionDiv.classList.add('grey', 'italic', 'enemy-description-description')
	const descriptionNode = document.createTextNode(description)
	descriptionDiv.appendChild(descriptionNode)

	mainDiv.appendChild(enemyNameDiv)
	mainDiv.appendChild(enemyLevelDiv)
	mainDiv.appendChild(healthDiv)
	mainDiv.appendChild(attackPowerDiv)
	mainDiv.appendChild(accuracyDiv)
	mainDiv.appendChild(dodgeDiv)
	mainDiv.appendChild(armorDiv)
	mainDiv.appendChild(slashingArmorDiv)
	mainDiv.appendChild(piercingArmorDiv)
	mainDiv.appendChild(bluntArmorDiv)
	mainDiv.appendChild(enemyHitChanceDiv)
	mainDiv.appendChild(playerHitChanceDiv)
	mainDiv.appendChild(descriptionDiv)
	masterArea.appendChild(mainDiv)
}

// function armorDescription(itemId, itemName, mods, description) {
// 	const mainDiv = document.createElement('div')
// 	mainDiv.classList.add('item-description')

// 	const messageP = document.createElement('div')
// 	messageP.appendChild(words(`Location: ${itemId}`))

// 	const messageP2 = document.createElement('div')
// 	messageP2.appendChild(words(`${itemName}`, 'darkGold'))

// 	const messageP3 = document.createElement('div')
// 	messageP3.appendChild(words(`Damage: ${botDamage} - ${topDamage}`))

// 	mainDiv.appendChild(messageP)
// 	mainDiv.appendChild(messageP2)
// 	mainDiv.appendChild(messageP3)

// 	let itemValues = Object.values(mods)
// 	let itemKeys = Object.keys(mods)
// 	for (let i = 0; i < itemKeys.length; i++) {
// 		if (itemValues[i] != 0) {
// 			if (itemKeys[i] == 'armor') {
// 				let textDiv = document.createElement('div')
// 				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
// 				textDiv.appendChild(textNode)
// 				mainDiv.appendChild(textDiv)
// 			} else {
// 				let textDiv = document.createElement('div')
// 				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
// 				textDiv.appendChild(textNode)
// 				mainDiv.appendChild(textDiv)
// 			}
// 		}
// 	}
// 	masterArea.appendChild(mainDiv)
// }
function shieldDescription(itemId, itemName, mods, description) {
	const messageP = document.createElement('div')
	messageP.appendChild(words(`_____________________________________________________________`))
	masterArea.appendChild(messageP)

	const messageP2 = document.createElement('div')
	messageP2.appendChild(words(`Location: ${itemId}`))
	masterArea.appendChild(messageP2)

	const messageP3 = document.createElement('div')
	messageP3.appendChild(words(`${itemName}`, 'darkGold'))
	masterArea.appendChild(messageP3)

	showItemDescription(mods)

	quickMessage(description, 'descriptions')
}
//____________________________________SWING VARIABLES AND FUNCTIONS TO INJECT_________________
function playerPenetrationNameFunc(penName) {
	const messageSpan = document.createElement('span')
	messageSpan.textContent = penName
	messageSpan.classList.add(white)
	return messageSpan
}

function damageOverTime() {
	let count = 0
	let tick = setInterval(() => {
		console.log(count)
		player.health--
		count++
		updatePlayerStats()
		if (count >= 5) {
			clearInterval(tick)
		}
	}, 1000)
}

function playerWeaponName(weapon) {
	let swingType = weapon.name.toLowerCase() + ' '
	const messageSpan = document.createElement('span')
	messageSpan.textContent = swingType
	messageSpan.classList.add('brown')
	return messageSpan
}
function enemyName(enemy) {
	//if enemy == enemy return 'at the' - if enemy == person return 'at'
	let enemyName = enemy
	const messageSpan = document.createElement('span')
	messageSpan.textContent = enemyName.toLowerCase() + ' '
	messageSpan.classList.add(red)
	return messageSpan
}
function damageNumber(damage) {
	let damageNumber = damage
	const messageSpan = document.createElement('span')
	messageSpan.textContent = damageNumber
	messageSpan.classList.add('yellow')
	return messageSpan
}
//area specific classes
let galvadianGreen = 'galvadian-green'
let castleGrey = 'castle-grey'
let dirtPath = 'dirt-path'
let town = 'town'
//

let descriptions = 'descriptions'
let masterArea = document.getElementById('masterArea')
let descName = document.getElementById('descName')
let zoneExits = document.getElementById('zoneExits')
let additional = document.getElementById('additional')
let enemys = document.getElementById('enemys')
let scrollable = document.getElementById('scrollable')
let allDirections = ['north', 'n', 'northeast', 'ne', 'east', 'e', 'southeast', 'se', 'south', 's', 'southwest', 'sw', 'west', 'w', 'northwest', 'nw', 'up', 'u', 'down', 'd']
let pushItem = []

let backpack = 'backpack'
let equipped = 'equipped'
let wielded = 'wielded'
let slot1 = 'right hand'
let slot2 = 'left hand'
let slot3 = 'head'
let slot4 = 'necklace'
let slot5 = 'shoulders'
let slot6 = 'chest'
let slot7 = 'back'
let slot9 = 'hands'
let slot10 = 'waist'
let slot11 = 'legs'
let slot12 = 'feet'
let slot13 = 'ring 1'
let slot14 = 'ring 2'
let slot15 = 'shield'
let empty = 'empty'
let armor = 'armor'
let shield = 'shield'
let sword = 'sword'
let bow = 'bow'
let drink = 'drink'
let oneSecond = 1
let twoSeconds = 2
let threeSeconds = 3
let fourSeconds = 4
// let swingTimer
let advanceTimer
let retreatTimer
let spellCastTimer
// let spellConjureTimer
// let spellChannelTimer
let trainedSkillName
let trainedSpellname
const regExp = /[a-zA-Z]/g
//player classes
const warrior = 'Warrior'
let cleaveCounter = 0

let futureArea
function futureAreaFunc(direction) {
	let futureX = currentArea.x
	let futureY = currentArea.y
	let futureZ = currentArea.z
	switch (direction) {
		case 'northwest':
		case 'nw':
			futureX += -1
			futureY += 1
			break
		case 'north':
		case 'n':
			futureY += 1
			break
		case 'northeast':
		case 'ne':
			futureX += 1
			futureY += 1
			break
		case 'east':
		case 'e':
			futureX += 1
			break
		case 'southeast':
		case 'se':
			futureX += 1
			futureY += -1
			break
		case 'south':
		case 's':
			futureY += -1
			break
		case 'southwest':
		case 'sw':
			futureX += -1
			futureY += -1
			break
		case 'west':
		case 'w':
			futureX += -1
			break
		case 'up':
		case 'u':
			futureZ += 1
			break
		case 'down':
		case 'd':
			futureZ += -1
			break
	}
	futureArea = allAreas.find(area => area.x == futureX && area.y == futureY && area.z == futureZ)
}

function questCheck() {
	if (currentArea.quests != undefined) {
		if (currentArea.quests.onEntry != undefined) {
			currentArea.quests.onEntry()
		}
	}
}

function pushItemByRoomId(roomIdCommand) {
	let roomIdItem = pushItem.find(item => item.roomId == roomIdCommand)
	if (roomIdItem != undefined) {
		return roomIdItem
	} else if (player.rightHand == empty) {
		return player.rightFist
	} else {
		return empty
	}
}
function pushItemByKeyword(secondCommand) {
	return pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand === keyword && roomId === currentArea.id))
}

function pushItemAllItemsInRoom() {
	let allItems = pushItem.filter(allItemsInRoom => allItemsInRoom.roomId == currentArea.id)
	if (allItems != undefined) {
		return allItems
	} else {
		return undefined
	}
}
function pushItemInBackpack() {
	return pushItem.filter(allItems => allItems.roomId == backpack)
}

function quest1Dialogue() {}

let spacer = `\u00A0`
let spacer5 = `\u00A0\u00A0\u00A0\u00A0\u00A0`
let spacer10 = `\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0` // spacer10 is 10 spaces long
let spacer20 = spacer10 + spacer10
let spacer30 = spacer20 + spacer10
let spacer40 = spacer20 + spacer20
let spacer50 = spacer40 + spacer10
let spacer100 = spacer50 + spacer50
let spacer200 = spacer100 + spacer100

//allows you to press enter to submit commands

let currentArea = {
	hostile: null,
	id: 0,
	x: 0,
	y: 0,
	npc: null,
	descriptions: {
		areaName: null,
		desc: null,
		zoneExits: null,
		zoneExitsBool: {
			north: null,
			northwest: null,
			west: null,
			southwest: null,
			south: null,
		},
	},
	interactables: {
		mushrooms: {
			pick: null,
			stomp: null,
			eat: null,
		},
	},
	enemys: {
		blob: {
			name: null,
			health: null,
			visual: null,
			spawnChance: null,
		},
	},
}
let previousArea
//STASIS
//game start
//swing
//rest
//spell cast
//spell target

//MODES?
//combat
//
//
//
commandLine.addEventListener('keypress', function (event) {
	if (event.keyCode === 13 && commandLine.value.length !== 0) {
		if (!player.combat && !player.stasis) {
			handleInputs(commandLine.value)
		} else if (player.combat && !player.stasis) {
			handleCombatInputs(commandLine.value)
		} else if (player.stasis) {
			handleCombatStasisInputs(commandLine.value)
		} 
		event.preventDefault()
	}
})

function handleInputs(commandLineInput) {
	const inputsLowerCase = commandLineInput.toLowerCase()
	const inputsSplitBySpace = inputsLowerCase.split(' ')
	let command = inputsSplitBySpace[0]
	const secondCommand = inputsSplitBySpace[1]
	let thirdCommand = inputsSplitBySpace[2]
	let fourthCommand = inputsSplitBySpace[3]
	for (let i = 4; i < inputsSplitBySpace.length; i++) {
		fourthCommand += inputsSplitBySpace[i]
	}
	commandLine.value = ''
	commandLine.focus()
	if (advanceAndRetreatCheck()) {return}
		switch (command) {
			case 'roll':
				evasiveRollFunction()
				break;
			case 'taunt':
				tauntingShoutFunction()
				break;
			case 'spells':
				playerSpellsList()
				break;
			case 'skills':
				playerSkillsList()
				break;
			case 'abilities':
				playerAbilitiesList()
				break;
			case 'pick':
			case 'gather':
				gatherFunction(secondCommand)
				break;
			case 'mine':
				mineFunction(secondCommand)
				break;
			case 'cook':
				cookFunction(secondCommand)
				break;
			case 'revive':
				revive()
				break;
			case 'help':
				help(secondCommand)
				break
			case 'block':
				block()
				break
			case 'ripslash':
				ripslashFunction(secondCommand, thirdCommand)
				break
			case 'cyclone':
				cycloneFunction(secondCommand, thirdCommand)
				break
			case 'dualstrike':
				dualStrikeFunction(secondCommand, thirdCommand)
				break
			case 'cata':
				cataclysmFunction(secondCommand, thirdCommand)
				break
			case 'bladeblitz':
				bladeBlitzFunction(secondCommand, thirdCommand)
				break
			case 'boomingmight':
				boomingMightFunction(secondCommand, thirdCommand)
				break
			case 'ambush':
				ambushFunction(secondCommand, thirdCommand)
				break
			case 'backstab':
				backstabFunction(secondCommand, thirdCommand)
				break
			case 'empoweringstrike':
				empoweringStrikeFunction(secondCommand, thirdCommand)
				break
			case 'catalyst':
				catalystFunction(secondCommand, thirdCommand)
				break
			case 'tempest':
				tempestFunction(secondCommand, thirdCommand)
				break
			case 'fireseal':
				fireSealFunction(secondCommand, thirdCommand)
				break
			case 'flamestrike':
				flameStrikeFunction(secondCommand, thirdCommand)
				break
			case 'waterseal':
				waterSealFunction(secondCommand, thirdCommand)
				break
			case 'wavefist':
				waveFistFunction(secondCommand, thirdCommand)
				break
			case 'blazingfist':
				blazingFistFunction(secondCommand, thirdCommand)
				break
			case 'riptide':
				riptideFistFunction(secondCommand, thirdCommand)
				break
			case 'piercingarrow':
				piercingArrowFunction(secondCommand, thirdCommand)
				break
			case 'hydraarrow':
				hydraArrowFunction(secondCommand, thirdCommand)
				break
			case 'aimedshot':
				aimedShotFunction(secondCommand, thirdCommand)
				break
			case 'charge':
				chargeFunction(secondCommand)
				break
			case '1':
				useAbilityByNumber(command)
				break
			case 2:
				useAbilityByNumber(command)
				break
			case 3:
				useAbilityByNumber(command)
				break
			case 4:
				useAbilityByNumber(command)
				break
			case 5:
				useAbilityByNumber(command)
				break
			case 6:
				useAbilityByNumber(command)
				break
			case 7:
				useAbilityByNumber(command)
				break
			case 8:
				useAbilityByNumber(command)
				break
			case 9:
				useAbilityByNumber(command)
				break
			case 'cast':
				spellFunction(secondCommand)
				break
			case 'target':
			case 't':
				target(secondCommand, thirdCommand)
				break
			case 'ambush':
				ambushFunction(secondCommand)
				break
			case 'hide':
				stealthAbility()
				break
			case 'unhide':
				unhide()
				break
			case 'macro':
				setMacro(secondCommand, thirdCommand)
				break
			case 'rest':
				restFunction()
				break
			case 'eat':
				eat(secondCommand)
				break
			case 'load':
				load(secondCommand)
				break
			case 'save':
				save(secondCommand)
				break
			case 'increase':
				increaseStat(secondCommand)
				break
			case 're':
			case 'retreat':
				retreat(secondCommand)
				break
			case 'unlock':
				unlock(secondCommand)
				break
			case 'pull':
				pull(secondCommand)
				break
			case 'nw':
			case 'northwest':
				moveDirection(command)
				break
			case 'n':
			case 'north':
				moveDirection(command)
				break
			case 'ne':
			case 'northeast':
				moveDirection(command)
				break
			case 'e':
			case 'east':
				moveDirection(command)
				break
			case 'se':
			case 'southeast':
				moveDirection(command)
				break
			case 's':
			case 'south':
				moveDirection(command)
				break
			case 'sw':
			case 'southwest':
				moveDirection(command)
				break
			case 'w':
			case 'west':
				moveDirection(command)
				break
			case 'u':
			case 'up':
				moveDirection(command)
				break
			case 'd':
			case 'down':
				moveDirection(command)
				break
			case 'attack':
			case 'a':
				attack(secondCommand, thirdCommand)
				break
			case 'l':
			case 'look':
				look(command, secondCommand, currentArea)
				break
			case 'examine':
			case 'ex':
				examine(secondCommand, thirdCommand)
				break
			case 'in':
			case 'ins':
			case 'insp':
			case 'inspect':
				inspect(secondCommand, thirdCommand)
				break
			case 'i':
			case 'inv':
			case 'show inventory':
				showInventory(player.inventory) //fix
				break
			case 'spawn':
				itemRoll()
				break
			case 'clean':
				clean()
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, currentArea)
				break
			case 'drop':
				dropItem(secondCommand, currentArea)
				break
			case 'pack':
			case 'p':
				pack(secondCommand)
				break
			case 'unpack':
				unpack(secondCommand, thirdCommand)
				break
			case 'swap':
				swap()
				break
			case 'ad':
			case 'advance':
				advance()
				break
			case 'speak':
			case 'talk':
				speak(secondCommand)
				break
			case 'quest':
				showQuest(secondCommand)
				break
			case 'offer':
				offerQuest(secondCommand)
				break
			case 'show':
				show(secondCommand, thirdCommand)
				break
			case 'trade':
				trade(secondCommand)
				break
			case 'stats':
				stats()
				break
			case 'skills':
				skills()
				break
			case 'exp':
				exp()
				break
			case 'don':
			case 'wear':
			case 'equip':
				donWearEquip(secondCommand)
				break
			case 'unequip':
			case 'remove':
				unequipRemove(secondCommand)
				break
			case 'drink':
				statDrink(secondCommand)
				break
			case 'buy':
				buyCommand(secondCommand, thirdCommand)
				break
			case 'sell':
				sell(secondCommand, thirdCommand)
				break
			case 'train':
				trainSkill(secondCommand, thirdCommand)
				break
			case 'increase':
				increaseStat(secondCommand)
				break
			case 'learn':
				learnSpell(secondCommand, thirdCommand)
				break
			case 'read':
				read(secondCommand)
				break
			case 'recall':
				recall(secondCommand, thirdCommand, fourthCommand)
				break
			case 'god':
				godMode(secondCommand)
				break;
			case 'dialogue':
				dialogueSpeedFunc(secondCommand)
				break
			case 'repeat':
				repeat(secondCommand)
				break
			case 'wake':
				wakeUp()
				break
			default:
				invalidCommand(commandLineInput)
				break
	}
	commandLine.value = ''
	commandLine.focus()
	updateScroll()
}

function handleCombatInputs(commandLineInput) {
	const inputsLowerCase = commandLineInput.toLowerCase()
	const inputsSplitBySpace = inputsLowerCase.split(' ')
	const command = inputsSplitBySpace[0]
	const secondCommand = inputsSplitBySpace[1]
	let thirdCommand = inputsSplitBySpace[2]
	let fourthCommand = inputsSplitBySpace[3]
	for (let i = 4; i < inputsSplitBySpace.length; i++) {
		fourthCommand += inputsSplitBySpace[i]
	}
	const directionCheck = allDirections.find(noMove => noMove === command)
	commandLine.value = ''
	commandLine.focus()
	if (advanceAndRetreatCheck()) {return}
		switch (command) {
			case 'roll':
				evasiveRollFunction()
				break;
			case 'taunt':
				tauntingShoutFunction()
				break;
			case 'spells':
				playerSpellsList()
			break;
			case 'skills':
				playerSkillsList()
				break;
			case 'abilities':
				playerAbilitiesList()
			break;
			case 'pick':
			case 'gather':
				gatherFunction(secondCommand)
				break;
			case 'mine':
				mineFunction(secondCommand)
				break;
			case 'cook':
				cookFunction(secondCommand)
				break;
			case 'revive':
				revive()
				break
			case 'help':
				help(secondCommand)
				break
			case 'block':
				block()
				break
			case 'charge':
				chargeFunction(secondCommand)
				break
			case 'cast':
				spellFunction(secondCommand)
				break
			case 'target':
			case 't':
				target(secondCommand, thirdCommand)
				break
			case 'ripslash':
				ripslashFunction(secondCommand, thirdCommand)
				break
			case 'dualstrike':
				dualStrikeFunction(secondCommand, thirdCommand)
				break
			case 'cata':
				cataclysmFunction(secondCommand, thirdCommand)
				break
			case 'cyclone':
				cycloneFunction(secondCommand, thirdCommand)
				break
			case 'bladeblitz':
				bladeBlitzFunction(secondCommand, thirdCommand)
				break
			case 'boomingmight':
				boomingMightFunction(secondCommand, thirdCommand)
				break
			case 'ambush':
				ambushFunction(secondCommand, thirdCommand)
				break
			case 'backstab':
				backstabFunction(secondCommand, thirdCommand)
				break
			case 'empoweringstrike':
				empoweringStrikeFunction(secondCommand, thirdCommand)
				break
			case 'catalyst':
				catalystFunction(secondCommand, thirdCommand)
				break
			case 'tempest':
				tempestFunction(secondCommand, thirdCommand)
				break
			case 'fireseal':
				fireSealFunction(secondCommand, thirdCommand)
				break
			case 'flamestrike':
				flameStrikeFunction(secondCommand, thirdCommand)
				break
			case 'waterseal':
				waterSealFunction(secondCommand, thirdCommand)
				break
			case 'wavefist':
				waveFistFunction(secondCommand, thirdCommand)
				break
			case 'blazingfist':
				blazingFistFunction(secondCommand, thirdCommand)
				break
			case 'riptide':
				riptideFistFunction(secondCommand, thirdCommand)
				break
			case 'piercingarrow':
				piercingArrowFunction(secondCommand, thirdCommand)
				break
			case 'hydraarrow':
				hydraArrowFunction(secondCommand, thirdCommand)
				break
			case 'aimedshot':
				aimedShotFunction(secondCommand, thirdCommand)
				break
			case 'bash':
				bashFunction()
				break
			case 'increase':
				increaseStat(secondCommand)
				break
			case 'unlock':
				unlock(secondCommand)
				break
			case 'pull':
				pull(secondCommand)
				break
			case 'eat':
				eat(secondCommand)
				break
			//combat functions
			case 'a':
			case 'attack':
				attack(secondCommand, thirdCommand)
				break
			case 'don':
			case 'wear':
			case 'equip':
				donWearEquip(secondCommand)
				break
			case 'unequip':
			case 'remove':
				unequipRemove(secondCommand)
				break
			case 'ad':
				attack(secondCommand, thirdCommand)
				break
			case 're':
			case 'retreat':
				retreat(secondCommand)
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, thirdCommand)
				break
			//normal functions
			case directionCheck:
				quickMessage('you cannot move while engaged in combat!')
				break
			case 'look':
			case 'l':
				look(command)
				break
			case 'examine':
			case 'ex':
				examine(secondCommand, thirdCommand)
				break
			case 'in':
			case 'ins':
			case 'insp':
			case 'inspect':
				inspect(secondCommand, thirdCommand)
				break
			case 'i':
			case 'inv':
			case 'show inventory':
				showInventory(player.inventory) //fix
				break
			case 'speak':
			case 'talk':
				speak(secondCommand)
				break
			case 'quest':
				showQuest(secondCommand)
				break
			case 'offer':
				offerQuest(secondCommand)
				break
			case 'show':
				show(secondCommand, thirdCommand)
				break
			case 'trade':
				trade(secondCommand)
				break
			case 'stats':
				stats()
				break
			case 'skills':
				skills()
				break
			case 'exp':
				exp()
				break
			case 'spawn':
				itemRoll()
				break
			case 'clean':
				clean()
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, thirdCommand)
				break
			case 'drop':
				dropItem(secondCommand, currentArea)
				break
			case 'pack':
			case 'p':
				pack(secondCommand)
				break
			case 'unpack':
				unpack(secondCommand, thirdCommand)
				break
			case 'swap':
				swap()
				break
			case 'recall':
				recall(secondCommand, thirdCommand, fourthCommand)
				break
			case 'dialogue':
				dialogueSpeedFunc(secondCommand)
				break
			case 'repeat':
				repeat(secondCommand)
				break
			default:
				invalidCommand(commandLineInput)
		}
	commandLine.value = ''
	commandLine.focus()
	updateScroll()
}

function handleCombatStasisInputs(commandLineInput) {
	const inputsLowerCase = commandLineInput.toLowerCase()
	const inputsSplitBySpace = inputsLowerCase.split(' ')
	const command = inputsSplitBySpace[0]
	const secondCommand = inputsSplitBySpace[1]
	let thirdCommand = inputsSplitBySpace[2]
	let fourthCommand = inputsSplitBySpace[3]
	for (let i = 4; i < inputsSplitBySpace.length; i++) {
		fourthCommand += inputsSplitBySpace[i]
	}
	if (player.dialogueStasis) {return} 
	commandLine.value = ''
	commandLine.focus()
	if (advanceAndRetreatCheck()) {return}		
		switch (command) {
			case 'roll':
				evasiveRollFunction()
				break;
			case 'taunt':
				tauntingShoutFunction()
				break;
			case 'spells':
				playerSpellsList()
			break;
			case 'skills':
				playerSkillsList()
				break;
			case 'abilities':
				playerAbilitiesList()
				break;
			case 'exp':
				exp()
				break;
			case 'stats':
				stats()
				break;
			case 'pick':
			case 'gather':
				gatherFunction(secondCommand)
				break;
			case 'mine':
				mineFunction(secondCommand)
				break;
			case 'cook':
				cookFunction(secondCommand)
				break;
			case 'revive':
				revive()
				break;
			case 'help':
				help(secondCommand)
				break
			case 'bash':
				bashFunction()
				break
			case 'ripslash':
				ripslashFunction(secondCommand, thirdCommand)
				break
			case 'cyclone':
				cycloneFunction(secondCommand, thirdCommand)
				break
			case 'bladeblitz':
				bladeBlitzFunction(secondCommand, thirdCommand)
				break
			case 'boomingmight':
				boomingMightFunction(secondCommand, thirdCommand)
				break
			case 'dualstrike':
				dualStrikeFunction(secondCommand, thirdCommand)
				break
			case 'cata':
				cataclysmFunction(secondCommand, thirdCommand)
				break
			case 'ambush':
				ambushFunction(secondCommand, thirdCommand)
				break
			case 'backstab':
				backstabFunction(secondCommand, thirdCommand)
				break
			case 'empoweringstrike':
				empoweringStrikeFunction(secondCommand, thirdCommand)
				break
			case 'catalyst':
				catalystFunction(secondCommand, thirdCommand)
				break
			case 'tempest':
				tempestFunction(secondCommand, thirdCommand)
				break
			case 'fireseal':
				fireSealFunction(secondCommand, thirdCommand)
				break
			case 'flamestrike':
				flameStrikeFunction(secondCommand, thirdCommand)
				break
			case 'waterseal':
				waterSealFunction(secondCommand, thirdCommand)
				break
			case 'wavefist':
				waveFistFunction(secondCommand, thirdCommand)
				break
			case 'blazingfist':
				blazingFistFunction(secondCommand, thirdCommand)
				break
			case 'riptide':
				riptideFistFunction(secondCommand, thirdCommand)
				break
			case 'piercingarrow':
				piercingArrowFunction(secondCommand, thirdCommand)
				break
			case 'hydraarrow':
				hydraArrowFunction(secondCommand, thirdCommand)
				break
			case 'aimedshot':
				aimedShotFunction(secondCommand, thirdCommand)
				break
			case 'increase':
				increaseStat(secondCommand)
				break
			case 'unlock':
				unlock(secondCommand)
				break
			case 'pull':
				pull(secondCommand)
				break
			case 'eat':
				eat(secondCommand)
				break
			case 'look':
			case 'l':
				look(command)
				break
			case 'examine':
			case 'ex':
				examine(secondCommand, thirdCommand)
				break
			case 'in':
			case 'ins':
			case 'insp':
			case 'inspect':
				inspect(secondCommand, thirdCommand)
				break
			case 'i':
			case 'inv':
				showInventory(player.inventory)
				break
			case 'clean':
				clean()
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, thirdCommand)
				break
			case 'drop':
				dropItem(secondCommand, thirdCommand)
				break
			case 'pack':
			case 'p':
				pack(secondCommand)
				break
			case 'unpack':
				unpack(secondCommand, thirdCommand)
				break
			case 'swap':
				swap()
				break
			case 'recall':
				recall(secondCommand, thirdCommand, fourthCommand)
				break
			case 'dialogue':
				dialogueSpeedFunc(secondCommand)
				break
			case 'repeat':
				repeat(secondCommand)
				break
			default:
				actionWait()
		}
	commandLine.value = ''
	commandLine.focus()
	updateScroll()
}

function abvDirectionToFullDirection(command) {
	switch (command) {
		case 'nw':
			return 'northwest'
		case 'n':
			return 'north'
		case 'ne':
			return 'northeast'
		case 'e':
			return 'east'
		case 'se':
			return 'southeast'
		case 's':
			return 'south'
		case 'sw':
			return 'southwest'
		case 'w':
			return 'west'
		case 'u':
			return 'up'
		case 'd':
			return 'down'
		default:
			console.log(`Abv direction to full function did not work`)
	}
}

//Out of combat commands


function dialogueWait(milliseconds) {
    return new Promise(resolve => {
        player.dialogueStasis = true
        setTimeout(() => {
            player.dialogueStasis = false
            resolve()
        }, milliseconds)
    });
}
function wait(milliseconds) {
	quickMessage(`Wait milliseconds: ${milliseconds}`)
    return new Promise(resolve => {
        player.stasis = true
        setTimeout(() => {
			quickMessage(`Wait milliseconds: ${milliseconds}`)
            player.stasis = false
            resolve()
        }, milliseconds)
    });
}
function actionWait() {
	const line1 = lineFunc()
	let waitTime
	if (player.stasis) {
		if (player.swingTimer > 0) {
			waitTime = Math.floor(player.swingTimer * 10) / 10
			customizeEachWord(`You are exhausted and must wait before taking another swing [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		} else if (player.channelTimer > 0) {
			waitTime = Math.floor(player.channelTimer * 10) / 10
			customizeEachWord(`You are currently channeling a spell [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		} else if (player.conjureTimer > 0) {
			waitTime = Math.floor(player.conjureTimer * 10) / 10
			customizeEachWord(`You are exhausted and must wait before conjuring another spell [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		} else if (player.abilityTimer > 0) {
			waitTime = Math.floor(player.abilityTimer * 10) / 10
			customizeEachWord(`You must wait before doing anything else [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		}
		quickMessage(`Default must wait`)
		return true
	}
}

function save(secondCommand, thirdCommand) {
	localStorage.setItem(secondCommand, JSON.stringify(player))
	localStorage.setItem('items', JSON.stringify(pushItem))
	quickMessage(`Game saved under the name: ${secondCommand}`)
}

function load(secondCommand) {
	let loadPlayer = localStorage.getItem(secondCommand)
	let loadItems = localStorage.getItem('items')
	player = JSON.parse(loadPlayer)
	pushItem = JSON.parse(loadItems)
	updateScroll()
	quickMessage(`Save file ${secondCommand} loaded`)
}

function godMode(secondCommand) {
	player.gold = 10000
	player.skillPoints = 1000
	player.attributePoints = 1000
	if (secondCommand == 'health') {
		player.con = 100
		updatePlayerStats()
		player.health = player.maxHealth
		updatePlayerStats()
		return
	}
	if (secondCommand == 'mana') {
		player.mods.maxMana = 1000
		updatePlayerStats()
		player.mana = player.maxMana
		updatePlayerStats()
		return
	}
	if (secondCommand == 'weapon') {
		player.currentWeaponSkill.level = 20
		updatePlayerStats()
		return
	}
	if (secondCommand == '2') {
		player.level = 2
		player.experience = 15
		player.daggers.level = 2
		player.unarmed.level = 2
		player.bows.level = 2
		player.oneHanded.level = 2
		player.twoHanded.level = 2
		player.str = player.guild == 'Warrior' ? 2 : 
		player.dex = player.guild == 'Sinistral' ? 2 : 
		player.dex = player.guild == 'Monk' ? 2 : 
		player.agi = player.guild == 'Ranger' ? 2 : 
		player.int = player.guild == 'Mage' ? 2 : 
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '3') {
		player.level = 3
		player.experience = 45
		player.daggers.level = 3
		player.unarmed.level = 3
		player.bows.level = 3
		player.oneHanded.level = 3
		player.twoHanded.level = 3
		player.str = player.guild == 'Warrior' ? 3 : 
		player.dex = player.guild == 'Sinistral' ? 3 : 
		player.dex = player.guild == 'Monk' ? 3 : 
		player.agi = player.guild == 'Ranger' ? 3 : 
		player.int = player.guild == 'Mage' ? 3 : 
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '4') {
		player.level = 4
		player.experience = 100
		player.daggers.level = 4
		player.unarmed.level = 4
		player.bows.level = 4
		player.oneHanded.level = 4
		player.twoHanded.level = 4
		player.str = player.guild == 'Warrior' ? 4 : 
		player.dex = player.guild == 'Sinistral' ? 4 : 
		player.dex = player.guild == 'Monk' ? 4 : 
		player.agi = player.guild == 'Ranger' ? 4 : 
		player.int = player.guild == 'Mage' ? 4 : 
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '5') {
		player.level = 5
		player.experience = 190
		player.daggers.level = 5
		player.unarmed.level = 5
		player.bows.level = 5
		player.oneHanded.level = 5
		player.twoHanded.level = 5
		player.str = player.guild == 'Warrior' ? 5 :
		player.dex = player.guild == 'Sinistral' ? 5 :
		player.dex = player.guild == 'Monk' ? 5 :
		player.agi = player.guild == 'Ranger' ? 5 :
		player.int = player.guild == 'Mage' ? 5 :
		player.con = 1
		updatePlayerStats()
		return
		}
	if (secondCommand == '6') {
		player.level = 6
		player.experience = 330
		player.daggers.level = 6
		player.unarmed.level = 6
		player.bows.level = 6
		player.oneHanded.level = 6
		player.twoHanded.level = 6
		player.str = player.guild == 'Warrior' ? 6 : 
		player.dex = player.guild == 'Sinistral' ? 6 : 
		player.dex = player.guild == 'Monk' ? 6 : 
		player.agi = player.guild == 'Ranger' ? 6 : 
		player.int = player.guild == 'Mage' ? 6 : 
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '7') {
		player.level = 7
		player.experience = 522
		player.daggers.level = 7
		player.unarmed.level = 7
		player.bows.level = 7
		player.oneHanded.level = 7
		player.twoHanded.level = 7
		player.str = player.guild == 'Warrior' ? 7 : 
		player.dex = player.guild == 'Sinistral' ? 7 : 
		player.dex = player.guild == 'Monk' ? 7 : 
		player.agi = player.guild == 'Ranger' ? 7 : 
		player.int = player.guild == 'Mage' ? 7 :
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '8') {
		player.level = 8
		player.experience = 797
		player.daggers.level = 8
		player.unarmed.level = 8
		player.bows.level = 8
		player.oneHanded.level = 8
		player.twoHanded.level = 8
		player.str = player.guild == 'Warrior' ? 8 : 
		player.dex = player.guild == 'Sinistral' ? 8 : 
		player.dex = player.guild == 'Monk' ? 8 :
		player.agi = player.guild == 'Ranger' ? 8 : 
		player.int = player.guild == 'Mage' ? 8 : 
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '9') {
		player.level = 9
		player.experience = 1115
		player.daggers.level = 9
		player.unarmed.level = 9
		player.bows.level = 9
		player.oneHanded.level = 9
		player.twoHanded.level = 9
		player.str = player.guild == 'Warrior' ? 9 : 
		player.dex = player.guild == 'Sinistral' ? 9 : 
		player.dex = player.guild == 'Monk' ? 9 : 
		player.agi = player.guild == 'Ranger' ? 9 : 
		player.int = player.guild == 'Mage' ? 9 : 
		player.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '10') {
		player.level = 10
		player.experience = 1474
		player.daggers.level = 10
		player.unarmed.level = 10
		player.bows.level = 10
		player.oneHanded.level = 10
		player.twoHanded.level = 10
		player.str = player.guild == 'Warrior' ? 10 : 
		player.dex = player.guild == 'Sinistral' ? 10 : 
		player.dex = player.guild == 'Monk' ? 10 : 
		player.agi = player.guild == 'Ranger' ? 10 : 
		player.int = player.guild == 'Mage' ? 10 :
		player.con = 1
		updatePlayerStats()
		return
	}
	if (!secondCommand) {
		player.level = 10
		player.experience = 1520
		player.daggers.level = 30
		player.unarmed.level = 30
		player.bows.level = 30
		player.oneHanded.level = 30
		player.twoHanded.level = 30
		player.stealth.level = 6
		player.con = 10
		player.str = 10
		player.dex = 10
		player.agi = 10
		player.int = 20
		updatePlayerStats()
		return
	}
	else {
	player.might = 1000
	player.adrenaline = 1000
	player.focus = 1000
	player.health = player.maxHealth
	player.dodging.level = 100
	player.mods.accuracy = 1000
	updatePlayerStats()
	quickMessage(`God mode activated`)
	}
}

function combatCount(seconds) {
	player.stasis = true
	player.swingTimer = Math.round(seconds * 10) / 10
	player.combatTicker = setInterval(() => {
		seconds = seconds - 0.1
		player.swingTimer = Math.round(seconds * 10) / 10
		seconds = Math.round(seconds * 10) / 10
		if (seconds <= 0) {
			player.swingTimer = 0
			player.stasis = false
			clearInterval(player.combatTicker)
		}
	}, 100)
	// let combatTicker = setInterval(() => {
	// 	seconds = seconds - 0.1
	// 	player.swingTimer = Math.round(seconds * 10) / 10
	// 	seconds = Math.round(seconds * 10) / 10
	// 	if (seconds <= 0) {
	// 		player.swingTimer = 0
	// 		player.stasis = false
	// 		clearInterval(combatTicker)
	// 	}
	// }, 100)
}

function abilityCount(seconds) {
	quickMessage(`ability count initialized - ${seconds}`)
	player.stasis = true
	let abilityTicker = setInterval(() => {
		seconds = seconds - 0.1
		player.abilityTimer = Math.floor(seconds * 10) / 10
		seconds = Math.round(seconds * 10) / 10
		if (seconds <= 0) {
			player.abilityTimer = 0
			player.stasis = false
			clearInterval(abilityTicker)
		}
	}, 100)
}
function advanceCount(seconds) {
	player.stasis = true
	let advanceTicker = setInterval(() => {
		seconds = seconds - 0.1
		advanceTimer = Math.round(seconds * 10) / 10
		if (seconds <= 0) {
			advanceTimer = 0
			player.stasis = false
			clearInterval(advanceTicker)
		}
	}, 100)
}
function retreatCount(seconds) {
	player.stasis = true
	let retreatTicker = setInterval(() => {
		retreatTimer = Math.round(seconds * 10) / 10
		seconds = seconds - 0.1
		if (seconds <= 0) {
			retreatTimer = 0
			player.stasis = false
			clearInterval(retreatTicker)
		}
	}, 100)
}
function spellConjureCount(spell) {
	player.conjureTimer = spell.conjureTime() / 1000
	let spellConjureTicker = setInterval(() => {
		player.conjureTimer = player.conjureTimer - 0.1
		if (player.conjureTimer <= 0) {
			player.conjureTimer = 0
			player.isConjuring = false
			spell.chambered = true
			let line1 = document.createElement('div')
			customizeEachWord(`${spell.name} `, `${spell.color}`, line1)
			customizeEachWord(`is ready to cast`, 'white', line1)
			clearInterval(spellConjureTicker)
		}
	}, 100)
}
function spellChannelCount(channelTime) {
	player.channelTimer = channelTime / 1000
	let spellChannelTicker = setInterval(() => {
		player.channelTimer = player.channelTimer - 0.1
		if (player.channelTimer <= 0) {
			player.channelTimer = 0
			clearInterval(spellChannelTicker)
		}
	}, 100)
}

//THIS FUNCTION ACCUMULATES MARKS ON THE PLAYER EACH TIME AN ATTACK IS MADE AND RESETS AFTER 
//	A SET AMOUNT OF TIME (5 SECONDS CURRENTLY IN THIS FUNCTION)

//CURRENTLY INACTIVE. USE THIS AS A TEMPLATE FOR A FUTURE RESOURCE
function rogueSinisterMarks() {
	function startTimeout() {
		sinisterMarksTimeout = setTimeout(() => {
			player.sinisterMarks = 0
			quickMessage(`SINISTER MARKS RESET`)
		}, 5000)
	}
	function resetTimeout() {
		clearTimeout(sinisterMarksTimeout)
		startTimeout()
	}
	if (player.playerClass.name == 'Thief') {
		player.sinisterMarks < 5 ? player.sinisterMarks += 1 : quickMessage(`max stacks reached`)
		resetTimeout()
	}
	quickMessage(`Sinister Marks - ${player.sinisterMarks}`)
}

//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
function tacticsBonus() {
	if (player.tactics.level > 0) {
		applyBuff(player.tactics.buff)
	}
}
function advance() {
	player.isStealthed = false
	const targetedMonster = roomEnemies.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
	if (targetedMonster) {
		tacticsBonus()
		player.combat = true
		targetedMonster.combat = player.combat
		targetedMonster.hostile = true
		player.stasis = true
		player.advancing = true
		advanceCount(player.advanceTimer)
		const line1 = document.createElement('div')
		const line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You engage the `, 'white', line1)
		customizeEachWord(`${targetedMonster.name}`, 'red', line1)
		customizeEachWord(`. Seconds until you can act`, 'white', line1)
		customizeEachWord(` [`, 'white', line1)
		customizeEachWord(`${player.advanceTimer}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
		setTimeout(() => {
			player.stasis = false
			player.advancing = false
		}, player.advanceTimer * 1000)
	} else {
		quickMessage('There must be a enemy in the room for you to advance')
	}
}

function retreat(secondCommand) {
	let direction = () => {
		if (secondCommand == 'nw') {
			return 'northwest'
		} else if (secondCommand == 'n') {
			return 'north'
		} else if (secondCommand == 'ne') {
			return 'northeast'
		} else if (secondCommand == 'e') {
			return 'east'
		} else if (secondCommand == 'se') {
			return 'southeast'
		} else if (secondCommand == 's') {
			return 'south'
		} else if (secondCommand == 'sw') {
			return 'southwest'
		} else if (secondCommand == 'w') {
			return 'west'
		} else if (secondCommand == 'u') {
			return 'up'
		} else if (secondCommand == 'd') {
			return 'down'
		} else {
			return secondCommand
		}
	}
	const retreatedDirection = allDirections.find(reDir => reDir == direction() && currentArea.descriptions.zoneExitsBool[reDir] == true)
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')

	//use filter then foreach to do something to a group of enemys
	pushMonster.forEach(enemy => (enemy.combat = false)) //if this line works, delete the pushMonster.combat = player.combat below
	if (player.combat == false && secondCommand == undefined) {
		quickMessage(`You are not in combat therefore you cannot retreat`)
	} else if (player.combat == false && secondCommand != undefined) {
		retreatDirection(secondCommand)
	} else if (direction() == retreatedDirection && secondCommand !== undefined) {
		player.combat = false
		pushMonster.combat = player.combat //change this to find the enemys to change combat otherwise this is dead code
		player.stasis = true
		player.retreating = true
		retreatCount(player.retreatTimer)
		blankSpace()
		retreatDirection(secondCommand)
		customizeEachWord(`You disengage combat and retreat. `, 'white', line1)
		customizeEachWord(`Seconds until you can act [`, 'white', line1)
		customizeEachWord(`${player.retreatTimer}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
		setTimeout(() => {
			player.stasis = false
			player.retreating = false
		}, player.retreatTimer * 1000)
	} else {
		player.stasis = true
		player.retreating = true
		retreatCount(player.retreatTimer)
		blankSpace()
		customizeEachWord(`You disengage combat and retreat. `, 'white', line1)
		customizeEachWord(`Seconds until you can act [`, 'white', line1)
		customizeEachWord(`${player.retreatTimer}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
		setTimeout(() => {
			player.stasis = false
			player.retreating = false
		}, player.retreatTimer * 1000)
		player.combat = false
		pushMonster.combat = player.combat //change this to find the enemys to change combat otherwise this is dead code
	}
}
function combatCheck() {
	const enemyCombatCheck = pushMonster.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z && enemy.combat == true)
	if (enemyCombatCheck) {
		player.combat = true
	} else {
		player.combat = false
	}
}

//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
function look(command, secondCommand) {
	if (secondCommand == 'nw' || secondCommand == 'northwest') {
		lookNorthwest('northwest')
	} else if (secondCommand == 'n' || secondCommand == 'north') {
		lookNorth('north')
	} else if (secondCommand == 'ne' || secondCommand == 'northeast') {
		lookNortheast('northeast')
	} else if (secondCommand == 'e' || secondCommand == 'east') {
		lookEast('east')
	} else if (secondCommand == 'se' || secondCommand == 'southeast') {
		lookSoutheast('southeast')
	} else if (secondCommand == 's' || secondCommand == 'south') {
		lookSouth('south')
	} else if (secondCommand == 'sw' || secondCommand == 'southwest') {
		lookSouthwest('southwest')
	} else if (secondCommand == 'w' || secondCommand == 'west') {
		lookWest('west')
	} else if (secondCommand == 'u' || secondCommand == 'up') {
		lookUp('up')
	} else if (secondCommand == 'd' || secondCommand == 'down') {
		lookDown('down')
	} else if (command === 'l' || command === 'look') {
		areaCompiler(currentArea)
		updateScroll()
	}
	blankSpace()
}

function lookNorthwest(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x - 1 && areaToLook.y == currentArea.y + 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookNorth(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.y == currentArea.y + 1 && areaToLook.x == currentArea.x && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookNortheast(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x + 1 && areaToLook.y == currentArea.y + 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookEast(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x + 1 && areaToLook.y == currentArea.y && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookSoutheast(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x + 1 && areaToLook.y == currentArea.y - 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookSouth(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.y == currentArea.y - 1 && areaToLook.x == currentArea.x && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookSouthwest(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x - 1 && areaToLook.y == currentArea.y - 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookWest(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x - 1 && areaToLook.y == currentArea.y && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookUp(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.z == currentArea.z + 1 && areaToLook.x == currentArea.x && areaToLook.y == currentArea.y)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookDown(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.z == currentArea.z - 1 && areaToLook.x == currentArea.x && areaToLook.y == currentArea.y)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
// areaCompiler(currentArea)

const youMoveToThe = (input, area, classChange) => {
	//move direction block
	const masterArea = document.getElementById('masterArea')
	if (masterArea.childElementCount >= 500) {
		//This will remove elements at the top of the scroll page if they exceed or == 500
		let elementCount = masterArea.childElementCount - 500
		for (let i = 0; i < elementCount; i++) {
			masterArea.removeChild(masterArea.firstElementChild)
		}
	}
	const moveDiv = document.createElement('div')
	const moveNode = document.createTextNode(input)
	moveDiv.classList.add(classChange)

	moveDiv.appendChild(moveNode)
	masterArea.appendChild(moveDiv)

	questCheck()
	areaCompiler(area)
	onRoomEntry()
	updateScroll()
}

//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
const roomImages = {
	galvadia_town: "images/exteriors/main/galvadia_square/galvadia_square.jpg",
	galvadia_guild_square: "images/exteriors/main/galvadia_guild_square/galvadia_guild_square.jpg",
	galvadia_graveyard: "images/exteriors/graveyard/galvadia graveyard.png",
	galvadia_residential_east: "images/exteriors/town travel/galvadia/galvadia_residential_east.jpg",
	galvadia_exterior_north: "images/exteriors/castle walls/galvadia_exterior_north.jpg",
	galvadia_fields_north: "images/exteriors/landscapes/fields/galvadia fields/galvadia fields north.jpg",
	galvadia_training_fields: "images/exteriors/landscapes/fields/galvadia fields/galvadia training fields.jpg",
	galvadia_fields_west: "images/exteriors/landscapes/fields/galvadia fields/galvadia fields west.jpg",
	galvadia_fields_main: "images/exteriors/landscapes/fields/galvadia fields/galvadia fields main.jpg",
	galvadia_basement: "images/interiors/castle interiors/basement halls/basement halls.jpg",
	galvadia_egberts_room: "images/interiors/castle interiors/egbert's room/egbert's room.jpg",
	galvadia_training_halls_common_room: "images/interiors/castle interiors/common room/common room.jpg",
	galvadia_advanced_training_rooms: "images/interiors/castle interiors/advanced training rooms/advanced training rooms.jpg",
	galvadian_glade_center: "images/exteriors/landscapes/forests/galvadian glade center/galvadian glade center.jpg",
	galvadian_glade_entrance: "images/exteriors/landscapes/forests/galvadian glade entrance/galvadian glade entrance.jpg",
	kobold_cave_main: "images/interiors/cave interiors/kobold cave/kobold main/kobold main.jpg",
	kobold_cave_tunnels: "images/interiors/cave interiors/kobold cave/kobold tunnels/kobold tunnels.jpg",
	kobold_cave_chief_room: "images/interiors/cave interiors/kobold cave/kobold chief room/kobold chief room.jpg",
	the_shallows: "images/exteriors/landscapes/forests/the shallows/the shallows.jpg",
}
function changeRoomPicture(roomId) {
    let roomPictureDisplay = document.getElementById('room-picture');
    // Check if the room ID exists in the roomImages object
    if (roomId in roomImages) {
        roomPictureDisplay.src = roomImages[roomId];
    } else {
        // Default image if the room ID is not found
        roomPictureDisplay.src = "images/no_room.jpg"
    }
}
function updateNpcPicture() {
	let allNpcBoxes = document.querySelectorAll('.npc-box')
	let allNpcsInRoom = getAllNpcsInRoom()
	if (allNpcsInRoom.length === 0) {
		allNpcBoxes.forEach(box => {
			box.classList.add('hide')
		})
	} else {
		allNpcBoxes.forEach((box, index) => {
			if (index < allNpcsInRoom.length) {
				box.src = allNpcsInRoom[index].picture
				box.classList.remove('hide');
			} else {
				box.classList.add('hide');
			}
		});
	}
}
// function updateNpcPicture() {
// 	let allNpcBoxes = document.querySelectorAll('.npc-box')
// 	let allNpcsInRoom = getAllNpcsInRoom()
// 	if (allNpcsInRoom.length === 0) {
// 		//if no npcs are in the room, hides all NPC portrait windows
// 		allNpcBoxes.forEach(box => {
// 			box.classList.add('hide')
// 		})
// 	} else {
// 		//if there are 1 or more npcs, this
// 		allNpcBoxes.forEach((box, index) => {
// 			box.classList.add('hide')
// 			quickMessage(`adding hide class to ${index}`)
// 		})
// 		allNpcBoxes.forEach((box, index) => {
// 			if (index < allNpcsInRoom.length) {
// 				box.classList.remove('hide');
// 				box.src = allNpcsInRoom[index].picture
// 			} else {
// 				console.log(box)
// 				box.classList.add('hide');
// 				box.src = ""
// 			}
// 		});
// 	}
// }


// function updateNpcPicture() {
// 	let allNpcBoxes = document.querySelectorAll('.npc-box')
// 	let allNpcsInRoom = getAllNpcsInRoom()
// 	allNpcBoxes.forEach((box, index) => {
// 		box.src = ""
// 		box.classList.add('hide')
// 		box.classList.remove('hide')
// 		if (allNpcsInRoom[index]) {
// 			box.src = allNpcsInRoom[index].picture
// 		}
// 	})
// }
// function updateNpcPicture() {
// 	let allNpcBoxes = document.querySelectorAll('.npc-box');
// 	let allNpcsInRoom = getAllNpcsInRoom();

// 	if (allNpcsInRoom.length === 0) {
// 		allNpcBoxes.forEach(box => {
// 			box.classList.add('hide');
// 			box.src = ''; // Set the src to an empty string
// 		});
// 	} else {
// 		allNpcBoxes.forEach((box, index) => {
// 			if (index < allNpcsInRoom.length) {
// 				box.onload = function () {
// 					// Image loaded, now set the src
// 					box.src = allNpcsInRoom[index].picture;
// 					// Trigger a reflow to apply the transition
// 					void box.offsetWidth;
// 					// Fade in the element
// 					box.classList.remove()
// 				};
// 			} else {
// 				// Fade out the element before hiding
// 				box.classList.add('hide');
// 				box.src = '';
// 			}
// 		});
// 	}
// }

function displayArea(area, addClass) {
	let areaDescription = area.descriptions.desc
	let areaActionWord = area.descriptions.actionWord
	// let areaDescriptionSplit = areaDescription.split(/\s|\./)
	let areaDescriptionSplit = areaDescription.split(' ')
	let slicedWordIndexArray = []
	let slicedWords = []
	changeRoomPicture(area.descriptions.zoneType)
	updateNpcPicture()
	// let roomPictureDisplay = document.getElementById('room-picture')
	// roomPictureDisplay.src = "images/forest.jpg"
	if (area.descriptions.actionWord) {
		areaActionWord.forEach(keyword => slicedWordIndexArray.push(areaDescriptionSplit.indexOf(keyword)))
		slicedWordIndexArray = slicedWordIndexArray.sort(function (a, b) {
			return a - b
		})
		for (let i = 0; i < slicedWordIndexArray.length; i++) {
			slicedWords.push(areaDescriptionSplit[slicedWordIndexArray[i]])
		}
		function compileDescription() {
			// let splitDirections = currentArea.descriptions.zoneExits.split()
			const areaMasterDiv = document.createElement('div')
			const areaNameDiv = document.createElement('div')
			const areaNameNode = document.createTextNode(area.descriptions.areaName)
			const areaDescDiv = document.createElement('div')
			areaDescDiv.classList.add('area-desc')

			const areaNestedExitsAndDirections = document.createElement('div')
			const areaExitsDiv = document.createElement('div')
			if (addClass) {areaExitsDiv.classList.add(addClass)}
			const areaExitsNode = document.createTextNode('Obvious Exits: ')
			const areaDirectionsDiv = document.createElement('div')
			// const areaDirectionsNode = document.createTextNode(area.descriptions.zoneExits)
			areaDescriptionSplit.forEach(word => {
				if (word != slicedWords[0] && word != slicedWords[1] && word != slicedWords[2] && word != slicedWords[3]) {
					const areaDescSpan = document.createElement('span')
					if (addClass) {
						areaDescSpan.classList.add(addClass)
					}
					const areaDescNode = document.createTextNode(word + ' ') // new code
					areaDescSpan.appendChild(areaDescNode)
					areaDescDiv.appendChild(areaDescSpan)
				}
				for (let i = 0; i < slicedWords.length; i++) {
					if (word == slicedWords[i]) {
						let actionWordColor = area.interactables[slicedWords[i].toLowerCase()].color
						let areaDescSpan = document.createElement('span')
						let areaDescNode = document.createTextNode(slicedWords[i] + ' ')
						areaDescSpan.appendChild(areaDescNode)
						areaDescSpan.classList.add(actionWordColor())
						areaDescDiv.appendChild(areaDescSpan)
					}
				}

				areaNameDiv.classList.add(area.descriptions.areaNameClass)
				areaNameDiv.classList.add('area-name')
				areaNestedExitsAndDirections.classList.add('nested-exits-directions')
				areaExitsDiv.classList.add('area-exits')
				areaDirectionsDiv.classList.add('area-directions')
				areaNameDiv.appendChild(areaNameNode)
				areaExitsDiv.appendChild(areaExitsNode)
				// areaDirectionsDiv.appendChild(areaDirectionsNode)
				areaNestedExitsAndDirections.appendChild(areaExitsDiv)
				areaNestedExitsAndDirections.appendChild(areaDirectionsDiv)
				areaMasterDiv.appendChild(areaNameDiv)
				areaMasterDiv.appendChild(areaDescDiv)
				areaMasterDiv.appendChild(areaNestedExitsAndDirections)
				masterArea.appendChild(areaMasterDiv)
			})
			let test = Object.entries(area.descriptions.zoneExitsBool)
			test.forEach(element => {
				if (element[1] == 'locked') {
					let directionSpan = document.createElement('span')
					directionSpan.classList.add('yellow')
					let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
					directionSpan.appendChild(directionNode)
					areaDirectionsDiv.appendChild(directionSpan)
				} else if (element[1] == 'blocked') {
					let directionSpan = document.createElement('span')
					directionSpan.classList.add('red')
					let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
					directionSpan.appendChild(directionNode)
					areaDirectionsDiv.appendChild(directionSpan)
				} else {
					let directionSpan = document.createElement('span')
					directionSpan.classList.add('area-directions')
					let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
					directionSpan.appendChild(directionNode)
					areaDirectionsDiv.appendChild(directionSpan)
				}
			})
		}
		compileDescription()
	} else {
		let splitDirections = area.descriptions.zoneExits.split(/\s|\./)
		const areaMasterDiv = document.createElement('div')
		const areaNameDiv = document.createElement('div')
		const areaNameNode = document.createTextNode(area.descriptions.areaName)
		const areaDescDiv = document.createElement('div')
		areaDescDiv.classList.add('area-desc')


		const areaNestedExitsAndDirections = document.createElement('div')
		const areaExitsDiv = document.createElement('div')
		const areaExitsNode = document.createTextNode('Obvious Exits: ')
		const areaDirectionsDiv = document.createElement('div')
		const areaDescNode = document.createTextNode(area.descriptions.desc)

		let test = Object.entries(area.descriptions.zoneExitsBool)
		test.forEach(element => {
			if (element[1] == 'locked') {
				let directionSpan = document.createElement('span')
				directionSpan.classList.add('yellow')
				let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
				directionSpan.appendChild(directionNode)
				areaDirectionsDiv.appendChild(directionSpan)
			} else if (element[1] == 'blocked') {
				let directionSpan = document.createElement('span')
				directionSpan.classList.add('red')
				let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
				directionSpan.appendChild(directionNode)
				areaDirectionsDiv.appendChild(directionSpan)
			} else {
				let directionSpan = document.createElement('span')
				directionSpan.classList.add('area-directions')
				let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
				directionSpan.appendChild(directionNode)
				areaDirectionsDiv.appendChild(directionSpan)
			}
		})

		// let directionSpan = document.createElement('span')
		// directionSpan.classList.add(colorDirections())
		// let directionNode = document.createTextNode(direction + ' ')
		// directionSpan.appendChild(directionNode)
		// areaDirectionsDiv.appendChild(directionSpan)
		areaNameDiv.classList.add(area.descriptions.areaNameClass)
		areaNameDiv.classList.add('area-name')
		areaDescDiv.classList.add('area-desc')
		areaNestedExitsAndDirections.classList.add('nested-exits-directions')
		areaExitsDiv.classList.add('area-exits')
		areaDirectionsDiv.classList.add('area-directions')
		areaNameDiv.appendChild(areaNameNode)
		areaDescDiv.appendChild(areaDescNode)
		areaExitsDiv.appendChild(areaExitsNode)
		areaNestedExitsAndDirections.appendChild(areaExitsDiv)
		areaNestedExitsAndDirections.appendChild(areaDirectionsDiv)

		areaMasterDiv.appendChild(areaNameDiv)
		areaMasterDiv.appendChild(areaDescDiv)
		areaMasterDiv.appendChild(areaNestedExitsAndDirections)
		masterArea.appendChild(areaMasterDiv)
		if (addClass != undefined) {
			areaNameDiv.classList.add('grey')
			areaDescDiv.classList.add('grey')
			areaExitsDiv.classList.add('grey')
			areaDirectionsDiv.classList.add('grey')
		}
	}
	updateMonsterBox()
}

function displayNpc(area, color) {
	const findNpc = area.npc
	if (findNpc[0] && findNpc[1] == undefined) {
		const peopleDiv = document.createElement('div')
		const peopleSpan = document.createElement('span')
		const peopleNode = document.createTextNode(`People:`)

		peopleDiv.classList.add('people-div')
		peopleSpan.classList.add('people-span')

		peopleSpan.appendChild(peopleNode)
		peopleDiv.appendChild(peopleSpan)
		masterArea.appendChild(peopleDiv)
		findNpc[0].displayName(peopleDiv)
	} else if (findNpc[1]) {
		const peopleDiv = document.createElement('div')
		const peopleSpan = document.createElement('span')
		const peopleNode = document.createTextNode(`People:`)

		peopleDiv.classList.add('people-div')
		peopleSpan.classList.add('people-span')

		peopleSpan.appendChild(peopleNode)
		peopleDiv.appendChild(peopleSpan)
		masterArea.appendChild(peopleDiv)
		findNpc[0].displayName(peopleDiv)
		findNpc.slice(1).forEach(npc => {
			let morePeopleDiv = document.createElement('div')
			let morePeopleSpan = document.createElement('span')
			morePeopleDiv.classList.add('extra-people')
			masterArea.appendChild(morePeopleDiv)
			morePeopleDiv.appendChild(morePeopleSpan)
			npc.displayName(morePeopleDiv)
		})
	}
}
function displayItems() {
	const findItem = pushItem.filter(({ roomId }) => roomId === currentArea.id)
	const findItemName = pushItem.filter(({ roomId }) => roomId === currentArea.id)
	if (findItem.length > 0) {
		const itemsDiv = document.createElement('div')
		const itemNames = findItemName.map(item => itemToNode(item))
		const itemsNode = document.createTextNode(`Items: `)
		itemsDiv.appendChild(itemsNode)
		itemNames.forEach(itemNode => {
			itemsDiv.appendChild(itemNode)
		})
		itemsDiv.classList.add('items')
		masterArea.appendChild(itemsDiv)
	}
}

function displayGold(area) {
	if (area.gold > 0) {
		const goldDiv = document.createElement('div')
		const goldNumberSpan = document.createElement('span')
		const goldNode = document.createTextNode(`Gold: `)
		const goldNumberNode = document.createTextNode(`${area.gold}`)
		goldNumberSpan.classList.add('yellow')
		goldDiv.appendChild(goldNode)
		goldNumberSpan.appendChild(goldNumberNode)
		goldDiv.appendChild(goldNumberSpan)
		masterArea.appendChild(goldDiv)
	}
}

function displayMonsters(area, color, enemyColor) {
	// let mappedArea = area != undefined ? area : currentArea
	// const enemyMapMe = pushMonster.filter(({ x, y, z }) => x == mappedArea.x && y == mappedArea.y && z == mappedArea.z)
	if (!coordinatesMatch(player, area)) {
		const mapEnemiesInNextRoom = getAllEnemiesInNextRoom(area)
		if (mapEnemiesInNextRoom.length > 0) {
			const enemyDiv = document.createElement('div')
			const enemyNames = mapEnemiesInNextRoom.map(enemy => enemyToNode(enemy, enemyColor))
			const enemysNode = document.createTextNode('Monsters: ')
			enemyDiv.appendChild(enemysNode)
			enemyNames.forEach(enemyNode => {
				enemyDiv.appendChild(enemyNode)
			})
			enemyDiv.classList.add(color)
			masterArea.appendChild(enemyDiv)
		}
		} else {
		const enemyMapMe = getAllEnemiesInRoom()
		if (enemyMapMe.length > 0) {
			const enemyDiv = document.createElement('div')
			const enemyNames = enemyMapMe.map(enemy => enemyToNode(enemy, enemyColor))
			const enemysNode = document.createTextNode('Monsters: ')
			enemyDiv.appendChild(enemysNode)
			enemyNames.forEach(enemyNode => {
				enemyDiv.appendChild(enemyNode)
			})
			enemyDiv.classList.add(color)
			masterArea.appendChild(enemyDiv)
		}
	}
}

function displayPlaceholder() {
	const placeholder = document.createElement('p')
	masterArea.appendChild(placeholder)
	masterArea.appendChild(placeholder)
}
//compiles functions to display the area, items, and enemys if they exist
function areaCompiler(area, color, enemyColor) {
	blankSpace()
	displayArea(area, color)
	displayNpc(area, color)
	displayItems(area, color)
	displayGold(area, color)
	displayMonsters(area, color, enemyColor)
	// displayPlaceholder()
}
function itemToNode(item) {
	let spanNode = document.createElement('span')
	spanNode.classList.add('item')
	let newTextNode = document.createTextNode(`${item.name} `)
	spanNode.appendChild(newTextNode)
	return spanNode
}
function npcToNode(npc) {
	npc.displayName()
	// let spanNode = document.createElement('span')
	// spanNode.classList.add('npc')
	// let newTextNode = document.createTextNode(`${npc.displayName()} `)
	// spanNode.appendChild(newTextNode)
	// return spanNode
}
function npcItemsToNode(item) {
	let spanNode = document.createElement('span')
	let breakNode = document.createElement('br')
	let newTextNode = document.createTextNode(`${item.name} `)
	spanNode.appendChild(newTextNode)
	spanNode.appendChild(breakNode)
	return spanNode
}
function npcSkillsToNode(skill) {
	let spanNode = document.createElement('span')
	let breakNode = document.createElement('br')
	let newTextNode = document.createTextNode(`${skill} `)
	spanNode.appendChild(newTextNode)
	spanNode.appendChild(breakNode)
	return spanNode
}
function enemyToNode(enemy, enemyClass) {
	let enemySpanNode = document.createElement('span')
	enemySpanNode.classList.add(enemyClass ? enemyClass : enemy.color)
	enemySpanNode.classList.add('enemy-margin')
	let newTextNode = document.createTextNode(`${enemy.name} `)
	enemySpanNode.appendChild(newTextNode)
	return enemySpanNode
}

function stats() {
	let playerKeys = Object.keys(player)
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	let line3 = document.createElement('div')
	customizeEachWord(`SKILLS`, 'white', line1)
	customizeEachWord(`Skill Points: ${player.skillPoints}`, 'white', line2)
	customizeEachWord(`Attribute Points: ${player.attributePoints}`, 'white', line3)

	// quickMessage('STATS', 'yellow')
	// quickMessage(`You are currently a level -player.guildLevel- -insert guild rank- of the -insert guild name- guild`)
	// quickMessage(`You are currently world level ${player.level}`)
	// quickMessage(`You are x percent of the way to level x`)
	// quickMessage(`You have gained a total of ${player.experience} experience points in your adventures`)
	// quickMessage(`You have x skill points to spend`)
	// quickMessage(`You have x attribute points to spend`)
	// quickMessage(`Currently wielding ${player.rightHand == empty ? 'nothing' : 'a ' + player.rightHand} in your right hand and ${player.leftHand == empty ? 'nothing' : 'a ' + player.leftHand} in your left hand`)
	// quickMessage(`STR: ${player.str}`)
	// quickMessage(`DEX: ${player.dex}`)
	// quickMessage(`AGI: ${player.agi}`)
	// quickMessage(`INT: ${player.int}`)
	// quickMessage(`WIS: ${player.wis}`)
	// quickMessage(`CON: ${player.con}`)
	// quickMessage(`Max HP: ${player.maxHealth}`)
	// quickMessage(`Max MP: ${player.maxMana}`)
}

function spells() {
	let line1 = document.createElement('div')
	customizeEachWord(`Spells`, 'purple', line1)

	if (player.spells[0] != undefined) {
		player.spells.forEach(spell => {
			let line2 = document.createElement('div')
			customizeEachWord(`${spell.name} `, 'purple', line2)
			customizeEachWord(`${spell.level}`, 'white', line2)
		})
	}
}

function skills() {}
function exp() {
	let currentExp = player.experience
	let currentExpBracket = player.experienceNeededToLevel[player.level - 1]
	let nextExpBracket = player.experienceNeededToLevel[player.level]

	let bracketBase = nextExpBracket - currentExpBracket
	let newExpBase = currentExp - currentExpBracket
	let percentOfTheWayThere = parseInt((newExpBase / bracketBase) * 100).toFixed(2)
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	let line4 = lineFunc()
	let line5 = lineFunc()
	let line6 = lineFunc()
	let line7 = lineFunc()
	blankSpace()
	customizeEachWord(`You are a level `, 'white', line1)
	customizeEachWord(`${player.level} `, 'green', line1)
	customizeEachWord(`${player.race} `, 'white', line1)
	customizeEachWord(`${player.playerClass.name}`, player.playerClass.color, line1)
	customizeEachWord(`Your total experience gained is `, 'white', line2)
	customizeEachWord(`${player.experience}`, 'light-blue', line2)
	customizeEachWord(`You are `, 'white', line3)
	customizeEachWord(`${percentOfTheWayThere}`, 'light-blue', line3)
	customizeEachWord(`% of the way to level `, 'white', line3)
	customizeEachWord(`${player.level + 1}`, 'green', line3)

	customizeEachWord(`You have `, 'white', line5)
	customizeEachWord(`${player.skillPoints} `, 'light-blue', line5)
	customizeEachWord(`skill points`, 'white', line5)

	customizeEachWord(`You have `, 'white', line6)
	customizeEachWord(`${player.attributePoints} `, 'light-blue', line6)
	customizeEachWord(`attribute points`, 'white', line6)
}

function randomClassColor() {
	let allColorClasses = [
		'gray',
		'light-gray',
		'dark-gray',
		'yellow',
		'light-yellow',
		'dark-yellow',
		'green',
		'light-green',
		'dark-green',
		'orange',
		'light-orange',
		'dark-orange',
		'red',
		'light-red',
		'dark-red',
		'purple',
		'light-purple',
		'dark-purple',
		'blue',
		'light-blue',
		'dark-blue',
		'brown',
		'light-brown',
		'dark-brown',
	]
	let colorClassLength = allColorClasses.length
	let randomNumber = randomNumberRange(0, colorClassLength)
	return allColorClasses[randomNumber]
}

function experienceNeededToLevel() {
	return Math.floor(((100 * player.experience) / player.experienceNeededToLevel) * 100) / 100
}

function updateInventory() {
	const pushItemCheck = pushItem.filter(items => items.roomId == 'backpack')
	player.backpack = pushItemCheck.map(items => items.name)
	player.backpack.sort((a, b) => (a.name > b.name ? 1 : -1))
}
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////

function dialogueSpeedFunc(speed) {
	dialogueSpeed = speed
}

function read(objectThatIsRead) {
	//for reading books, pages, signs, scrolls, etc
	if (objectThatIsRead == 'map') {
		let img = document.createElement('img')
		img.src = 'images/galvadia_minimap.png'
		img.style.height = '500px'
		img.style.width = '500px'
		masterArea.appendChild(img)
	}
	if (currentArea.descriptions.sign && objectThatIsRead == 'sign') {
		currentArea.descriptions.sign()
	} else if (!currentArea.descriptions.sign && objectThatIsRead == 'sign') {
		quickMessage(`You do not see a ${objectThatIsRead} to read`)
	} else if (objectThatIsRead == undefined) {
		quickMessage(`You must specify what you want to read`)
	} else if (objectThatIsRead != 'sign') {
		quickMessage(`You do not see a ${objectThatIsRead} to read`)
	}
	updateScroll()
}

////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS
////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS
function recall(playerX, playerY, playerZ) {
	player.combat = false
	pushMonster.forEach(enemy => {
		enemy.combat = false
	})
	console.log(playerX, playerY, playerZ)
	// if (!playerX && !playerY && !playerZ && egbert.questSequence.fifteenth == true && player.level <= 10) {
	// }
	//Add the above conditional to allow the player to recall after completing the tutorial and if under level 10
	if (playerX == 'square') {
		currentArea = galvadiaTownSquare
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return	
	} 
	if (playerX == 'kobold') {
		currentArea = koboldCavesRoom1
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'graveyard') {
		currentArea = graveyard1
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'guild') {
		currentArea = galvadiaGuildSquare
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'glade') {
		currentArea = centralGlade
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (!playerX) {
		currentArea = trainingHallsCommonRoom
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	}
	//parameters are the x, y values of the targeted room to recall to
	const recallRoom = allAreas.find(area => area.x == playerX && area.y == playerY && area.z == playerZ)
	if (recallRoom != undefined) {
		currentArea.isPlayerHere = false
		currentArea = recallRoom
	} else {
		quickMessage(`Room not found`)
	}
	player.combat = false
	player.x = recallRoom.x
	player.y = recallRoom.y
	player.z = recallRoom.z
	// newLocation()
	areaCompiler(recallRoom)
	updateScroll()
}
function revive() {
	if (player.isAlive) {
		quickMessage(`You are already alive!`)
		return
	}
	player.isAlive = true
	player.health = player.maxHealth - player.maxHealth + 1
	player.mana = player.maxMana - player.maxMana + 1
	player.gold = player.gold / 2
	updatePlayerStats()
	recall(-7, 4, 0)
}
async function unlock(secondCommand) {	
	let direction = () => {
		if (secondCommand == 'nw') {
			return 'northwest'
		} else if (secondCommand == 'n') {
			return 'north'
		} else if (secondCommand == 'ne') {
			return 'northeast'
		} else if (secondCommand == 'e') {
			return 'east'
		} else if (secondCommand == 'se') {
			return 'southeast'
		} else if (secondCommand == 's') {
			return 'south'
		} else if (secondCommand == 'sw') {
			return 'southwest'
		} else if (secondCommand == 'w') {
			return 'west'
		} else if (secondCommand == 'u') {
			return 'up'
		} else if (secondCommand == 'd') {
			return 'down'
		} else {
			return secondCommand
		}
	}
	let playerKey = pushItem.find(item => item.roomToUnlock == currentArea.descriptions.areaName && (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand'))
	let playerKeyIndex = pushItem.indexOf(playerKey)
	if (currentArea.descriptions.zoneExitsBool[direction()] == true || currentArea.descriptions.zoneExitsBool[direction()] == undefined) {
		quickMessage(`There is no locked door in that direction.`)
	} else if (currentArea.descriptions.zoneExitsBool[direction()] == 'locked') {
		if (playerKey == undefined) {
			quickMessage(`You do not have a key to unlock this door.`)
		} else if (playerKey != undefined) {
			currentArea.descriptions.zoneExitsBool[direction()] = true
			pushItem.splice(playerKeyIndex, 1)
			await dialogueWait(200)
			quickMessage(`You have unlocked the way to the ${direction()}.`)
			blankSpace()
			await dialogueWait(200)
			quickMessage(`The key disappears in a puff of smoke.`)
			blankSpace()
		} else {
			quickMessage(`Not a valid direction to unlock.`)
		}
	}
}

////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS
////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS

function clean() {
	for (let i = 0; i < pushItem.length; i++) {
		if (currentArea.id === pushItem[i].roomId) {
			pushItem.splice(i, 1)
			i--
		}
	}
	quickMessage('you clean the room')
}

function pickupItem(secondCommand, thirdCommand) {
	let allItems = pushItemAllItemsInRoom()
	let itemPickedUp = pushItemByKeyword(secondCommand)
	let line1 = document.createElement('div')
	const backpackObjects = pushItem.filter(items => items.roomId == 'backpack')
	if (secondCommand == 'all') {
		if (currentArea.gold <= 0 && allItems[0] == undefined) {
			blankSpace()
			customizeEachWord('There is nothing in the room for you to pick up', `white`, line1)
			blankSpace()
		} else if (currentArea.gold > 0 && allItems[0] !== undefined) {
			customizeEachWord(`You pick up all the items in the room and `, 'white', line1)
			blankSpace()
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s)`, 'white', line1)
			blankSpace()
			allItems.forEach(item => (item.roomId = 'backpack'))
			player.backpack = backpackObjects.map(items => items.name)
			player.gold = player.gold + currentArea.gold
			currentArea.gold = 0
		} else if (currentArea.gold > 0 && allItems[0] == undefined) {
			blankSpace()
			customizeEachWord(`You pick up `, 'white', line1)
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s). There are no items on the ground to pick up`, 'white', line1)
			blankSpace()
			player.gold = player.gold + currentArea.gold
			currentArea.gold = 0
		} else if (currentArea.gold <= 0 && allItems[0] !== undefined) {
			blankSpace()
			customizeEachWord(`You pick up all the items in the room and `, 'white', line1)
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s)`, 'white', line1)
			blankSpace()
			allItems.forEach(item => (item.roomId = 'backpack'))
			player.backpack = backpackObjects.map(items => items.name)
		}
	} else if (secondCommand !== 'all') {
		if (itemPickedUp) {
			blankSpace()
			customizeEachWord('You pick up a ', 'white', line1)
			customizeEachWord(`${itemPickedUp.name} `, `${itemPickedUp.color}`, line1)
			customizeEachWord(`and put it in your backpack`, `white`, line1)
			blankSpace()
			itemPickedUp.roomId = 'backpack'
			player.backpack = backpackObjects.map(items => items.name)
		} else if (secondCommand != 'gold' && itemPickedUp == undefined) {
			blankSpace()
			customizeEachWord(`There is no ${secondCommand} to pick up`, 'white', line1)
			blankSpace()
		}
		if (currentArea.gold > 0 && secondCommand == 'gold') {
			blankSpace()
			customizeEachWord(`You pick up `, 'white', line1)
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s)`, 'white', line1)
			blankSpace()
			player.gold = player.gold + currentArea.gold
			currentArea.gold = 0
		}
	}
	updateInventory()
}

function dropItem(secondCommand) {
	let itemDropped = pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand === keyword && roomId === 'backpack'))
	let itemDroppedFromRightHand = pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand == keyword && roomId == 'right hand'))
	let itemDroppedFromLeftHand = pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand == keyword && roomId == 'left hand'))
	let line1 = document.createElement('div')
	if (itemDropped != undefined) {
		customizeEachWord(`You drop your `, 'white', line1)
		customizeEachWord(`${itemDropped.name}`, `${itemDropped.color}`, line1)
		itemDropped.roomId = currentArea.id
		updateInventory()
	} else if (itemDroppedFromLeftHand != undefined) {
		customizeEachWord(`You drop your `, 'white', line1)
		customizeEachWord(`${itemDropped.name}`, `${itemDroppedFromLeftHand.color}`, line1)
		itemDroppedFromLeftHand.roomId = currentArea.id
		player.leftHand = empty
	} else if (itemDroppedFromRightHand != undefined) {
		customizeEachWord(`You drop your `, 'white', line1)
		customizeEachWord(`${itemDropped.name}`, `${itemDroppedFromRightHand.color}`, line1)
		itemDroppedFromRightHand.roomId = currentArea.id
		player.rightHand = empty
	} else {
		customizeEachWord(`You do not have a ${secondCommand} to drop`, 'white', line1)
	}
}
//PACK components
function packTwoHanded(twoHandedItem) {
	if (player.rightHand != empty || player.leftHand != empty) {
		let line1 = document.createElement('div')
		twoHandedItem.roomId = backpack
		player.rightHand = empty
		player.leftHand = empty
		weaponOrShieldRemovePlayerAttribute(twoHandedItem)
		weaponOrShieldAddPlayerAttribute(player.rightFist)
		weaponOrShieldAddPlayerAttribute(player.leftFist)
		customizeEachWord(`You pack your `, 'white', line1)
		customizeEachWord(`${twoHandedItem.name}`, twoHandedItem.color, line1)
	}
}
function packRight(rightItem) {
	if (player.rightHand != empty) {
		let line1 = document.createElement('div')
		rightItem.roomId = backpack
		player.rightHand = empty
		weaponOrShieldRemovePlayerAttribute(rightItem)
		weaponOrShieldAddPlayerAttribute(player.rightFist)
		customizeEachWord(`You pack your `, 'white', line1)
		customizeEachWord(`${rightItem.name}`, rightItem.color, line1)
	} else {
		quickMessage(`You don't have anything in your right hand to pack`)
	}
}
function packLeft(leftItem) {
	if (player.leftHand != empty) {
		let line1 = document.createElement('div')
		leftItem.roomId = backpack
		player.leftHand = empty
		weaponOrShieldRemovePlayerAttribute(leftItem)
		weaponOrShieldAddPlayerAttribute(player.leftFist)
		customizeEachWord(`You pack your `, 'white', line1)
		customizeEachWord(`${leftItem.name}`, leftItem.color, line1)
	} else {
		quickMessage(`You don't have anything in your left hand to pack`)
	}
}

function updateWeaponIcons() {
	let playerWeaponRight = getWeapon1()
	let playerWeaponLeft = getWeapon2()
	let rightHandImage = document.querySelector('.right-hand-image')
	let leftHandImage = document.querySelector('.left-hand-image')
	//is two handed
	if (playerWeaponRight.type.twoHanded) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture}')`;
		rightHandImage.textContent = ''
		leftHandImage.style.backgroundImage = `url('${playerWeaponRight.picture}')`;
		leftHandImage.textContent = ''
		return
	}
	if (playerWeaponRight.type.fists) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture.right}')`;
		rightHandImage.textContent = ''
		leftHandImage.style.backgroundImage = `url('${playerWeaponRight.picture.left}')`;
		leftHandImage.textContent = ''
		return
	}
	if (playerWeaponRight.type.weapon) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture.right}')`;
		rightHandImage.textContent = ''
	}
	if (playerWeaponLeft.type.weapon) {
		leftHandImage.style.backgroundImage = `url('${playerWeaponLeft.picture.left}')`;
		leftHandImage.textContent = ''
	}
	if (playerWeaponRight.type.shield) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture}')`
		rightHandImage.textContent = ''
	}
	if (playerWeaponLeft.type.shield) {
		leftHandImage.style.backgroundImage = `url('${playerWeaponLeft.picture}')`
		leftHandImage.textContent = ''
	}
	//right item is not a weapon and is not a shield
	if ((!playerWeaponRight.type.weapon && !playerWeaponRight.type.shield)) {
		rightHandImage.style.backgroundImage = ''
		rightHandImage.textContent = playerWeaponRight.name
		rightHandImage.classList.add('green')
	}
	//left item is not a weapon and is not a shield
	if (!playerWeaponLeft.type.weapon && !playerWeaponLeft.type.shield) {
		leftHandImage.style.backgroundImage = ''
		leftHandImage.textContent = playerWeaponLeft.name
		leftHandImage.classList.add('green')
	}
	//empty hands, but class is either monk to display a fist or class is not a monk to display empty hands
	if (playerWeaponRight.name == 'Right Fist') {
		if (player.guild == 'Monk') {
			rightHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/right fist.png')`;
			rightHandImage.textContent = ''
		} else {
			rightHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/empty hand right.png')`;
			rightHandImage.textContent = ''
		}
	}
	if (playerWeaponLeft.name == 'Left Fist') {
		if (player.guild == 'Monk') {
			leftHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/left fist.png')`;
			leftHandImage.textContent = ''
		} else {
			leftHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/empty hand left.png')`;
			leftHandImage.textContent = ''
		}
	}
}

function pack(secondCommand) {
	const selectedItemRight = pushItem.find(allItems => allItems.roomId == slot1)
	const selectedItemLeft = pushItem.find(allItems => allItems.roomId == slot2)
	//for packing away two handed item - only coded to have a roomId of 'right hand' / slot1
	const selectedItemTwoHandedBoolean = function () {
		if (selectedItemRight == undefined) {
			return undefined
		} else if (selectedItemRight.type.twoHanded || selectedItemRight.type.martialArts) {
			return true
		} else {
			return false
		}
	}
	const selectedItemTwoHandedBooleanLeft = function () {
		if (selectedItemLeft == undefined) {
			return undefined
		} else if (selectedItemLeft.type.twoHanded || selectedItemLeft.type.martialArts) {
			return true
		} else {
			return false
		}
	}
	if (secondCommand == 'right') {
		if (selectedItemTwoHandedBoolean() == true) {
			packTwoHanded(selectedItemRight)
		} else if (selectedItemTwoHandedBoolean() == false) {
			packRight(selectedItemRight)
			if (player.rightHand == empty && player.leftHand == empty) {
			}
		} else {
			quickMessage(`You have nothing in your right hand to pack.`)
		}
	}
	if (secondCommand == 'left') {
		if (selectedItemTwoHandedBooleanLeft() == true) {
			packTwoHanded(selectedItemLeft)
		} else if (selectedItemTwoHandedBooleanLeft() == false) {
			packLeft(selectedItemLeft)
			if (player.rightHand == empty && player.leftHand == empty) {
			}
		} else {
			quickMessage(`You have nothing in your left hand to pack.`)
		}
	}
	updateWeaponIcons()
	updateInventory()
	updatePlayerStats()
}
function testerer() {
	player.backpack.forEach(item => {
		player.backpack.forEach(bpItem => {
			item.name == bpItem && item.roomId == 'backpack'
		})
	})
}
//UNPACK components
function unpackTwoHanded(twoHandedItem) {
	if (twoHandedItem.type.twoHanded && player.rightHand == empty && player.leftHand == empty) {
		let line1 = document.createElement('div')
		twoHandedItem.roomId = slot1
		player.rightHand = twoHandedItem.name
		player.leftHand = twoHandedItem.name
		weaponOrShieldAddPlayerAttribute(twoHandedItem)
		weaponOrShieldRemovePlayerAttribute(player.rightFist)
		weaponOrShieldRemovePlayerAttribute(player.leftFist)
		customizeEachWord(`You wield your `, 'white', line1)
		customizeEachWord(`${twoHandedItem.name} `, twoHandedItem.color, line1)
		customizeEachWord(`using both hands`, 'white', line1)
	} else if (player.rightHand != empty && player.leftHand != empty) {
		quickMessage(`Both hands must be free in order to wield a two handed weapon`)
	} else {
		quickMessage(`You cannot dual wield two handed weapons`)
	}
}
function unpackMartialArtsWeapon(martialArtsWeapon) {
	if (martialArtsWeapon.type.martialArts && player.rightHand == empty && player.leftHand == empty) {
		let line1 = document.createElement('div')
		martialArtsWeapon.roomId = slot1
		player.rightHand = martialArtsWeapon.name
		player.leftHand = martialArtsWeapon.name
		weaponOrShieldAddPlayerAttribute(martialArtsWeapon)
		weaponOrShieldRemovePlayerAttribute(player.rightFist)
		weaponOrShieldRemovePlayerAttribute(player.leftFist)
		customizeEachWord(`You don your `, 'white', line1)
		customizeEachWord(`${martialArtsWeapon.name} `, martialArtsWeapon.color, line1)
	} else if (player.rightHand != empty && player.leftHand != empty) {
		quickMessage(`Both hands must be free in order to wield your ${martialArtsWeapon.name}`)
	} else {
		quickMessage(`You already have ${martialArtsWeapon.name} equipped on both hands`)
	}
}
function unpackOneHanded(oneHandedItem) {
	if (player.rightHand == empty) {
		let line1 = document.createElement('div')
		oneHandedItem.roomId = slot1
		player.rightHand = oneHandedItem.name
		weaponOrShieldAddPlayerAttribute(oneHandedItem)
		weaponOrShieldRemovePlayerAttribute(player.rightFist)
		player.stance = ''
		customizeEachWord(`You wield your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.name} `, oneHandedItem.color, line1)
		customizeEachWord(`in your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.roomId}`, 'white', line1)
	} else if (player.leftHand == empty && player.rightHand != empty) {
		let line1 = document.createElement('div')
		oneHandedItem.roomId = slot2
		player.leftHand = oneHandedItem.name
		weaponOrShieldAddPlayerAttribute(oneHandedItem)
		weaponOrShieldRemovePlayerAttribute(player.leftFist)
		player.stance = ''
		customizeEachWord(`You wield your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.name} `, oneHandedItem.color, line1)
		customizeEachWord(`in your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.roomId}`, 'white', line1)
	} else if (player.rightHand != empty && player.leftHand != empty) {
		quickMessage(`You cannot unpack anything else with your hands full`)
	}
}
function unpackFail(selectedItem, secondCommand) {
	if (secondCommand == undefined) {
		quickMessage(`You must specify what you want to unpack`)
	} else if (selectedItem == undefined) {
		quickMessage(`You do not have a ${secondCommand} to unpack`)
	} else {
		quickMessage('unpackFail invoked, but nothing executed')
	}
}
//UNPACK function
function unpack(secondCommand, thirdCommand) {
	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack')
	allItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))
	const allSpecifiedItems = allItemsInBackpack.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	const selectedItem = isNaN(secondCommand) == false ? allItemsInBackpack[secondCommand] : allItemsInBackpack.find(({ keywords }) => keywords.some(keyword => secondCommand === keyword))
	if (requirementsMet(selectedItem) == false) {
		return
	}
	if (!isNaN(secondCommand) && thirdCommand) {
		quickMessage(`You must specify either the item slot number or the name of the item you want to unpack.`)
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] == undefined) {
		quickMessage(`You do not have an item in that slot to unpack`)
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] != undefined) {
		if (allItemsInBackpack[secondCommand - 1].type.twoHanded) {
			unpackTwoHanded(allItemsInBackpack[secondCommand - 1])
		} else if (allItemsInBackpack[secondCommand - 1].type.martialArts) {
			unpackMartialArtsWeapon(allItemsInBackpack[secondCommand - 1])
		} else {
			unpackOneHanded(allItemsInBackpack[secondCommand - 1])
		}
	} else if (isNaN(secondCommand) && isNaN(thirdCommand) && thirdCommand != undefined && allSpecifiedItems != undefined) {
		let twoKeywordItem = allSpecifiedItems.find(item => item.keywords.some(keyword => keyword == secondCommand + ' ' + thirdCommand))
		if (twoKeywordItem != undefined && twoKeywordItem.type.twoHanded) {
			unpackTwoHanded(twoKeywordItem)
		} else if (twoKeywordItem != undefined && twoKeywordItem.type.martialArts) {
			unpackMartialArtsWeapon(twoKeywordItem)
		} else if (twoKeywordItem != undefined) {
			console.log(twoKeywordItem, ' TWO KEYWORD ITEM')
			unpackOneHanded(twoKeywordItem)
		}
	} else if (isNaN(secondCommand) && !isNaN(thirdCommand) && allSpecifiedItems[thirdCommand - 1] == undefined) {
		quickMessage(`You do not have that number of ${secondCommand} to unpack.`)
	} else if (isNaN(secondCommand) && !isNaN(thirdCommand) && allSpecifiedItems[thirdCommand - 1] != undefined) {
		if (allSpecifiedItems[thirdCommand - 1].type.twoHanded) {
			unpackTwoHanded(allSpecifiedItems[thirdCommand - 1])
		}
		else if (allSpecifiedItems[thirdCommand - 1].type.martialArts) {
			unpackMartialArtsWeapon(allSpecifiedItems[thirdCommand - 1])
		} else {
			unpackOneHanded(allSpecifiedItems[thirdCommand - 1])
		}
	} else if (selectedItem != undefined) {
		if (selectedItem.type.twoHanded) {
			unpackTwoHanded(selectedItem)
		} else if (selectedItem.type.martialArts) {
			unpackMartialArtsWeapon(selectedItem)
		} else {
			unpackOneHanded(selectedItem)
		}
	} else {
		unpackFail(selectedItem, secondCommand)
	}
	updateWeaponIcons()
	updatePlayerStats()
	updateInventory()
}

function swap() {
	let line1 = lineFunc()
	let rightItem = getWeapon1()
	let leftItem = getWeapon2()
	let holdR = rightItem
	let holdL = leftItem
	if (rightItem.type.twoHanded) {
		quickMessage(`You cannot swap a two handed weapon`)
	} else if (rightItem.type.martialArts) {
		quickMessage(`You cannot swap martial arts weapons`)
	} else if (rightItem.type.unarmed && leftItem.type.unarmed) {
		quickMessage('You have nothing in your hands to swap!')
	} else if (rightItem.roomId == 'right hand' && !rightItem.type.unarmed && leftItem.roomId == 'left hand' && !leftItem.type.unarmed) {
		customizeEachWord(`You move your `, 'white', line1)
		customizeEachWord(`${rightItem.name} `, rightItem.color, line1)
		customizeEachWord(`to your left hand and your `, 'white', line1)
		customizeEachWord(`${leftItem.name} `, leftItem.color, line1)
		customizeEachWord(`to your right hand`, 'white', line1)

		rightItem.roomId = 'left hand'
		leftItem.roomId = 'right hand'
		player.rightHand = holdL.name
		player.leftHand = holdR.name
	} else if (rightItem.refName == 'rightFist') {
		let line1 = document.createElement('div')
		customizeEachWord(`You move your `, 'white', line1)
		customizeEachWord(`${player.leftHand} `, 'green', line1)
		customizeEachWord(`to your right hand`, 'white', line1)
		player.rightHand = player.leftHand
		leftItem.roomId = slot1
		player.leftHand = empty
	} else if (leftItem.refName == 'leftFist') {
		let line1 = document.createElement('div')
		customizeEachWord(`You move your `, 'white', line1)
		customizeEachWord(`${player.rightHand} `, 'green', line1)
		customizeEachWord(`to your left hand`, 'white', line1)
		player.leftHand = player.rightHand
		rightItem.roomId = slot2
		player.rightHand = empty
	} else {
		quickMessage(`None of these`)
	}
	updateWeaponIcons()
	updatePlayerStats()
}

function cookFunction(secondCommand) {
	let foodItem = pushItem.find(({ keywords }) => keywords.some(keyword => secondCommand == keyword))
	let doesFireExist
	if (secondCommand == undefined) {
		quickMessage(`You do not have that to cook`)
		return
	}
	if (!foodItem) {
		quickMessage(`You do not have a(n) ${secondCommand} to cook`)
		return
	}
	if (currentArea.descriptions.fireflames || pushItem.find(item => item.type.fireSource && item.roomId == currentArea.id)) {
		doesFireExist = true
	}
	if (!doesFireExist) {
		quickMessage(`You must be at a source of fire to cook food`)
		return
	}
	if (!foodItem.type.food) {
		quickMessage(`You can only cook food items!`)
		return
	}
	if (!foodItem.cookable) {
		quickMessage(`This food item is not cookable!`)
		return
	}
	if (foodItem.cookable) {
		let cookedDish = foodItem.cookedVersion()
		let uncookedFoodIndex = pushItem.indexOf(foodItem)
		pushItem.splice(uncookedFoodIndex, 1)
		pushItem.push(cookedDish)
		cookedDish.roomId = 'backpack'
		cookedDish.cookPhrase()
	}

}

function mineFunction(secondCommand) {
	let rightItem = getWeapon1()
	let leftItem = getWeapon2()
	if (rightItem?.keywords.find(item => item == 'pickaxe') || leftItem?.keywords.find(item => item == 'pickaxe')) {

	
	let allVeinTypes = ['copper', 'iron', 'mithril', 'gold', 'silver', 'platinum', 'titanium']
	let areaVeinTypes = []
	for (let veinType in currentArea.interactables) {
		if (allVeinTypes.includes(veinType)) {
			areaVeinTypes.push(veinType)
		}
	}
	let doesCommandMatchAreaVein = areaVeinTypes.includes(secondCommand)
	if (!doesCommandMatchAreaVein) {
		quickMessage(`There is no vein of that type to mine here`)
		return
	}
	let areaInteractableObject = currentArea.interactables[secondCommand]
	if (areaInteractableObject.empty) {
		quickMessage(`This vein is empty`)
		return
	}

	areaInteractableObject.empty = true
	areaInteractableObject.respawn()
	switch (secondCommand) {
		case 'copper':
			craftingMaterialGen(copperOre(currentArea))
			break;
		case 'iron':
			craftingMaterialGen(ironOre(currentArea))
			break;
		case 'silver':
			craftingMaterialGen(silverOre(currentArea))
			break;
		case 'gold':
			craftingMaterialGen(goldOre(currentArea))
			break;
	}
	quickMessage(`You successfully mine some ore!`)
} else {
	quickMessage(`You must be wielding a pickaxe to mine ore`)
}
}


async function gatherFunction(secondCommand) {
	let allPlantTypes = ['clover', 'orchid', 'lily', 'rose', 'ivy', 'sage', 'fern', 'daisy', 'thistle', 'lotus', 'poppy']
	let areaPlantTypes = []
	for (let plantType in currentArea.interactables) {
		if (allPlantTypes.includes(plantType)) {
			areaPlantTypes.push(plantType)
		}
	}
	let doesCommandMatchAreaPlant = areaPlantTypes.includes(secondCommand)
	if (intelligenceCheck())
	if (!doesCommandMatchAreaPlant) {
		quickMessage(`There is no plant of that type to gather here`)
		return
	}
	let areaInteractableObject = currentArea.interactables[secondCommand]
	if (areaInteractableObject.empty) {
		quickMessage(`This plant is bare`)
		return
	}
	let line1 = lineFunc()
	switch (secondCommand) {
		case 'clover':
			if (intelligenceCheck(2)) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You pick a blossom of `, 'white', line1)
				customizeEachWord(`Clover`, 'green', line1)
				customizeEachWord(`and refine it into a `, 'white', line1)
				customizeEachWord(`Thin Fiber`, 'green', line1)
				blankSpace()
				craftingMaterialGen(thinFiber(currentArea))
				areaInteractableObject.empty = true
				areaInteractableObject.respawn()
			} else {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You feel as though you aren't smart enough to pick the `, 'white', line1)
				customizeEachWord(`Clover `, 'green', line1)
				customizeEachWord(`without tearing it`, 'white', line1)
				blankSpace()
			}
			break;
		case 'lily':
			// oreGen(ironOre(currentArea))
			break;
		case 'rose':
			// oreGen(silverOre(currentArea))
			break;
		case 'sage':
			// oreGen(goldOre(currentArea))
			break;
	}
}

//
const invalidCommand = input => {
	const invalidCommandDiv = document.createElement('div')
	const invalidCommandNode = document.createTextNode(input + ' is not a proper command')
	invalidCommandDiv.classList.add('output-text')
	invalidCommandDiv.appendChild(invalidCommandNode)
	masterArea.appendChild(invalidCommandDiv)
}
//show skills-spells-items

//Inventory
const showInventory = () => {
	updateInventory()
	let leftRing = pushItem.find(item => item.roomId == 'left ring') != undefined ? pushItem.find(item => item.roomId == 'left ring') : 'white'
	let rightRing = pushItem.find(item => item.roomId == 'right ring') != undefined ? pushItem.find(item => item.roomId == 'right ring') : 'white'
	let leftHand = pushItem.find(item => item.roomId == 'left hand') != undefined ? pushItem.find(item => item.roomId == 'left hand') : 'white'
	let rightHand = pushItem.find(item => item.roomId == 'right hand') != undefined ? pushItem.find(item => item.roomId == 'right hand') : 'white'
	let head = pushItem.find(item => item.roomId == 'head') != undefined ? pushItem.find(item => item.roomId == 'head') : 'white'
	let necklace = pushItem.find(item => item.roomId == 'necklace') != undefined ? pushItem.find(item => item.roomId == 'necklace') : 'white'
	let shoulders = pushItem.find(item => item.roomId == 'shoulders') != undefined ? pushItem.find(item => item.roomId == 'shoulders') : 'white'
	let chest = pushItem.find(item => item.roomId == 'chest') != undefined ? pushItem.find(item => item.roomId == 'chest') : 'white'
	let back = pushItem.find(item => item.roomId == 'back') != undefined ? pushItem.find(item => item.roomId == 'back') : 'white'
	// let arms = pushItem.find(item => item.roomId == 'arms') != undefined ? pushItem.find(item => item.roomId == 'arms') : 'white'
	let hands = pushItem.find(item => item.roomId == 'hands') != undefined ? pushItem.find(item => item.roomId == 'hands') : 'white'
	let waist = pushItem.find(item => item.roomId == 'waist') != undefined ? pushItem.find(item => item.roomId == 'waist') : 'white'
	let legs = pushItem.find(item => item.roomId == 'legs') != undefined ? pushItem.find(item => item.roomId == 'legs') : 'white'
	let feet = pushItem.find(item => item.roomId == 'feet') != undefined ? pushItem.find(item => item.roomId == 'feet') : 'white'

	const equipmentAndBackpackContainer = document.createElement('div')
	const equipmentContainer = document.createElement('div')
	const equipmentHeading = document.createElement('h2')
	const equipmentHeadingTextNode = document.createTextNode('Equipment')
	const equipmentRowsContainer = document.createElement('div')
	const equipmentRow1 = document.createElement('div') //LH RH and rings
	const equipmentRow2 = document.createElement('div') // upper body
	const equipmentRow3 = document.createElement('div') // mid body
	const equipmentRow4 = document.createElement('div') // lower body
	const equipmentRow5 = document.createElement('div') // gold
	const equipmentSlotAndItemContainer1 = document.createElement('div')
	const equipmentSlotAndItemContainer2 = document.createElement('div')
	const equipmentSlotAndItemContainer3 = document.createElement('div')
	const equipmentSlotAndItemContainer4 = document.createElement('div')
	const equipmentSlotAndItemContainer5 = document.createElement('div')
	const equipmentSlotAndItemContainer6 = document.createElement('div')
	const equipmentSlotAndItemContainer7 = document.createElement('div')
	const equipmentSlotAndItemContainer8 = document.createElement('div')
	const equipmentSlotAndItemContainer9 = document.createElement('div')
	const equipmentSlotAndItemContainer10 = document.createElement('div')
	const equipmentSlotAndItemContainer11 = document.createElement('div')
	const equipmentSlotAndItemContainer12 = document.createElement('div')
	const equipmentSlotAndItemContainer13 = document.createElement('div')
	const equipmentSlotAndItemContainer14 = document.createElement('div')
	const equipmentSlotAndItemContainer15 = document.createElement('div') // just here in case I need to add another row
	//
	const LHRingSlotDiv = document.createElement('div')
	const LHRingItemDiv = document.createElement('div')
	const LHWeaponSlotDiv = document.createElement('div')
	const LHWeaponItemDiv = document.createElement('div')

	const RHRingSlotDiv = document.createElement('div')
	const RHRingItemDiv = document.createElement('div')

	const RHWeaponSlotDiv = document.createElement('div')
	const RHWeaponItemDiv = document.createElement('div')

	const headSlotDiv = document.createElement('div')
	const headItemDiv = document.createElement('div')

	const necklaceSlotDiv = document.createElement('div')
	const necklaceItemDiv = document.createElement('div')

	const shoulderSlotDiv = document.createElement('div')
	const shoulderItemDiv = document.createElement('div')

	const chestSlotDiv = document.createElement('div')
	const chestItemDiv = document.createElement('div')

	const backSlotDiv = document.createElement('div')
	const backItemDiv = document.createElement('div')

	// const armsSlotDiv = document.createElement('div')
	// const armsItemDiv = document.createElement('div')

	const handsSlotDiv = document.createElement('div')
	const handsItemDiv = document.createElement('div')

	const waistSlotDiv = document.createElement('div')
	const waistItemDiv = document.createElement('div')

	const legsSlotDiv = document.createElement('div')
	const legsItemDiv = document.createElement('div')

	const feetSlotDiv = document.createElement('div')
	const feetItemDiv = document.createElement('div')
	//
	const LHRingSlot = document.createTextNode(`Left Ring: `)
	const LHRingItem = document.createTextNode(`${player.leftHandRing}`)
	const RHRingSlot = document.createTextNode(`Right Ring: `)
	const RHRingItem = document.createTextNode(`${player.rightHandRing}`)
	const LHWeaponSlot = document.createTextNode('Left Hand: ')
	const LHWeaponItem = document.createTextNode(`${player.leftHand}`)
	const RHWeaponSlot = document.createTextNode('Right Hand: ')
	const RHWeaponItem = document.createTextNode(`${player.rightHand}`)
	const headSlot = document.createTextNode(`Head: `)
	const headItem = document.createTextNode(`${player.head}`)
	const necklaceSlot = document.createTextNode(`Necklace: `)
	const necklaceItem = document.createTextNode(`${player.necklace}`)
	const shoulderSlot = document.createTextNode(`Shoulders: `)
	const shoulderItem = document.createTextNode(`${player.shoulders}`)
	const chestSlot = document.createTextNode(`Chest: `)
	const chestItem = document.createTextNode(`${player.chest}`)
	const backSlot = document.createTextNode(`Back: `)
	const backItem = document.createTextNode(`${player.back}`)
	// const armsSlot = document.createTextNode(`Arms: `)
	// const armsItem = document.createTextNode(`${player.arms}`)
	const handsSlot = document.createTextNode(`Hands: `)
	const handsItem = document.createTextNode(`${player.hands}`)
	const waistSlot = document.createTextNode(`Waist: `)
	const waistItem = document.createTextNode(`${player.waist}`)
	const legsSlot = document.createTextNode(`Legs: `)
	const legsItem = document.createTextNode(`${player.legs}`)
	const feetSlot = document.createTextNode(`Feet: `)
	const feetItem = document.createTextNode(`${player.feet}`)
	const goldSlot = document.createTextNode(`Gold: `)
	const goldAmount = document.createTextNode(`${player.gold}`)

	/////////////////////////////////////////////////////////////////////////////////
	//EQ ROW 1
	//LEFT RING
	LHRingSlotDiv.appendChild(LHRingSlot)
	LHRingItemDiv.appendChild(LHRingItem)
	equipmentSlotAndItemContainer1.classList.add('slot-item-container')
	LHRingSlotDiv.classList.add('all-slots')
	LHRingItemDiv.classList.add(leftRing.color, 'inventory-item')
	//LEFT WEAPON

	LHWeaponSlotDiv.appendChild(LHWeaponSlot)
	LHWeaponItemDiv.appendChild(LHWeaponItem)
	equipmentSlotAndItemContainer2.classList.add('slot-item-container')
	LHWeaponSlotDiv.classList.add('all-slots')
	LHWeaponItemDiv.classList.add(leftHand.color, 'inventory-item')
	if (rightHand && rightHand.type && (rightHand.type.twoHanded || rightHand.type.martialArts)) {
		LHWeaponItemDiv.classList.add(rightHand.color)
	} else {
		LHWeaponItemDiv.classList.add(leftHand.color)
	}

	//RIGHT RING
	RHRingSlotDiv.appendChild(RHRingSlot)
	RHRingItemDiv.appendChild(RHRingItem)
	equipmentSlotAndItemContainer3.classList.add('slot-item-container-end')
	RHRingSlotDiv.classList.add('all-slots')
	RHRingItemDiv.classList.add(rightRing.color, 'inventory-item')
	//RIGHT WEAPON

	RHWeaponSlotDiv.appendChild(RHWeaponSlot)
	RHWeaponItemDiv.appendChild(RHWeaponItem)
	equipmentSlotAndItemContainer4.classList.add('slot-item-container-end')
	RHWeaponSlotDiv.classList.add('all-slots')
	RHWeaponItemDiv.classList.add(rightHand.color, 'inventory-item')
	//HEAD
	headSlotDiv.appendChild(headSlot)
	headItemDiv.appendChild(headItem)
	equipmentSlotAndItemContainer5.classList.add('slot-item-container')
	headSlotDiv.classList.add('all-slots')
	headItemDiv.classList.add(head.color, 'inventory-item')
	//NECKLACE
	necklaceSlotDiv.appendChild(necklaceSlot)
	necklaceItemDiv.appendChild(necklaceItem)
	equipmentSlotAndItemContainer6.classList.add('slot-item-container-middle')
	necklaceSlotDiv.classList.add('all-slots')
	necklaceItemDiv.classList.add(necklace.color, 'inventory-item')
	//SHOULDER
	shoulderSlotDiv.appendChild(shoulderSlot)
	shoulderItemDiv.appendChild(shoulderItem)
	equipmentSlotAndItemContainer7.classList.add('slot-item-container-end')
	shoulderSlotDiv.classList.add('all-slots')
	shoulderItemDiv.classList.add(shoulders.color, 'inventory-item')
	//CHEST
	chestSlotDiv.appendChild(chestSlot)
	chestItemDiv.appendChild(chestItem)
	equipmentSlotAndItemContainer8.classList.add('slot-item-container')
	chestSlotDiv.classList.add('all-slots')
	chestItemDiv.classList.add(chest.color, 'inventory-item')
	//BACK
	backSlotDiv.appendChild(backSlot)
	backItemDiv.appendChild(backItem)
	equipmentSlotAndItemContainer9.classList.add('slot-item-container-middle')
	backSlotDiv.classList.add('all-slots')
	backItemDiv.classList.add(back.color, 'inventory-item')
	//ARMS
	// armsSlotDiv.appendChild(armsSlot)
	// armsItemDiv.appendChild(armsItem)
	// equipmentSlotAndItemContainer10.classList.add('slot-item-container-end')
	// armsSlotDiv.classList.add('all-slots')
	// armsItemDiv.classList.add(arms.color, 'inventory-item')
	//HANDS
	handsSlotDiv.appendChild(handsSlot)
	handsItemDiv.appendChild(handsItem)
	equipmentSlotAndItemContainer11.classList.add('slot-item-container-end')
	handsSlotDiv.classList.add('all-slots')
	handsItemDiv.classList.add(hands.color, 'inventory-item')
	//WAIST
	waistSlotDiv.appendChild(waistSlot)
	waistItemDiv.appendChild(waistItem)
	equipmentSlotAndItemContainer12.classList.add('slot-item-container')
	waistSlotDiv.classList.add('all-slots')
	waistItemDiv.classList.add(waist.color, 'inventory-item')
	//LEGS
	legsSlotDiv.appendChild(legsSlot)
	legsItemDiv.appendChild(legsItem)
	equipmentSlotAndItemContainer13.classList.add('slot-item-container-middle')
	legsSlotDiv.classList.add('all-slots')
	legsItemDiv.classList.add(legs.color, 'inventory-item')
	//FEET
	feetSlotDiv.appendChild(feetSlot)
	feetItemDiv.appendChild(feetItem)
	equipmentSlotAndItemContainer14.classList.add('slot-item-container-end')
	feetSlotDiv.classList.add('all-slots')
	feetItemDiv.classList.add(feet.color, 'inventory-item')

	equipmentSlotAndItemContainer1.appendChild(LHRingSlotDiv)
	equipmentSlotAndItemContainer1.appendChild(LHRingItemDiv)
	equipmentSlotAndItemContainer2.appendChild(LHWeaponSlotDiv)
	equipmentSlotAndItemContainer2.appendChild(LHWeaponItemDiv)
	equipmentSlotAndItemContainer3.appendChild(RHWeaponSlotDiv)
	equipmentSlotAndItemContainer3.appendChild(RHWeaponItemDiv)
	equipmentSlotAndItemContainer4.appendChild(RHRingSlotDiv)
	equipmentSlotAndItemContainer4.appendChild(RHRingItemDiv)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer1)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer2)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer3)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer4)
	//EQ ROW 2
	equipmentSlotAndItemContainer5.appendChild(headSlotDiv)
	equipmentSlotAndItemContainer5.appendChild(headItemDiv)
	equipmentSlotAndItemContainer6.appendChild(necklaceSlotDiv)
	equipmentSlotAndItemContainer6.appendChild(necklaceItemDiv)
	equipmentSlotAndItemContainer7.appendChild(shoulderSlotDiv)
	equipmentSlotAndItemContainer7.appendChild(shoulderItemDiv)
	equipmentRow2.appendChild(equipmentSlotAndItemContainer5)
	equipmentRow2.appendChild(equipmentSlotAndItemContainer6)
	equipmentRow2.appendChild(equipmentSlotAndItemContainer7)
	//EQ ROW 3
	equipmentSlotAndItemContainer8.appendChild(chestSlotDiv)
	equipmentSlotAndItemContainer8.appendChild(chestItemDiv)
	equipmentSlotAndItemContainer9.appendChild(backSlotDiv)
	equipmentSlotAndItemContainer9.appendChild(backItemDiv)
	// equipmentSlotAndItemContainer10.appendChild(armsSlotDiv)
	// equipmentSlotAndItemContainer10.appendChild(armsItemDiv)
	equipmentSlotAndItemContainer11.appendChild(handsSlotDiv)
	equipmentSlotAndItemContainer11.appendChild(handsItemDiv)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer8)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer9)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer10)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer11)
	//EQ ROW 4
	equipmentSlotAndItemContainer12.appendChild(waistSlotDiv)
	equipmentSlotAndItemContainer12.appendChild(waistItemDiv)
	equipmentSlotAndItemContainer13.appendChild(legsSlotDiv)
	equipmentSlotAndItemContainer13.appendChild(legsItemDiv)
	equipmentSlotAndItemContainer14.appendChild(feetSlotDiv)
	equipmentSlotAndItemContainer14.appendChild(feetItemDiv)
	equipmentRow4.appendChild(equipmentSlotAndItemContainer12)
	equipmentRow4.appendChild(equipmentSlotAndItemContainer13)
	equipmentRow4.appendChild(equipmentSlotAndItemContainer14)
	//EQ ROW 5 - GOLD
	equipmentSlotAndItemContainer15.appendChild(goldSlot)
	equipmentSlotAndItemContainer15.appendChild(goldAmount)
	equipmentRow5.appendChild(equipmentSlotAndItemContainer15)
	//EQ row container (orange box)
	equipmentRowsContainer.appendChild(equipmentRow1)
	equipmentRowsContainer.appendChild(equipmentRow2)
	equipmentRowsContainer.appendChild(equipmentRow3)
	equipmentRowsContainer.appendChild(equipmentRow4)
	equipmentRowsContainer.appendChild(equipmentRow5)
	equipmentHeading.appendChild(equipmentHeadingTextNode)
	equipmentContainer.appendChild(equipmentHeading)
	equipmentContainer.appendChild(equipmentRowsContainer)
	equipmentAndBackpackContainer.appendChild(equipmentContainer)
	///////////////////////////////////////CLASSES/////////////////////////////////////////
	equipmentAndBackpackContainer.classList.add('equipment-and-backpack')
	equipmentContainer.classList.add('equipment-container')
	equipmentHeading.classList.add('equipment-heading')
	equipmentRowsContainer.classList.add('equipment-row-container')
	equipmentRow1.classList.add('equipment-row-1')
	equipmentRow2.classList.add('equipment-row-2')
	equipmentRow3.classList.add('equipment-row-3')
	equipmentRow4.classList.add('equipment-row-4')
	equipmentRow5.classList.add('gold-row')

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	const backpackContainer = document.createElement('div')
	const backpackHeading = document.createElement('h2')
	const backpackHeadingTextNode = document.createTextNode('Backpack')
	const backpackColumnsContainer = document.createElement('div')
	const backpackColumn1 = document.createElement('div')
	const backpackColumn2 = document.createElement('div')
	const backpackColumn3 = document.createElement('div')

	const backpackContents = pushItem.filter(item => item.roomId == 'backpack').sort((a, b) => (a.name > b.name ? 1 : -1))
	const backpack1Through20 = backpackContents.filter((item, index) => index <= 9 && item.roomId == 'backpack')
	const backpack21Through40 = backpackContents.filter((item, index) => index >= 10 && index <= 19 && item.roomId == 'backpack')
	const backpack41Through60 = backpackContents.filter((item, index) => index >= 20 && index <= 29 && item.roomId == 'backpack')

	if (backpack1Through20[0]) {
		backpack1Through20.forEach((item, i, arr) => {
			let slotNumber = i + 1
			const backpackSlotAndItemContainer1 = document.createElement('div')
			const slot1Div = document.createElement('div')
			const item1Div = document.createElement('div')

			item1Div.classList.add('backpack-item-name')
			const slot1 = document.createTextNode(`${slotNumber}. `)
			const item1 = document.createTextNode(`${item.name}`)

			slot1Div.appendChild(slot1)
			item1Div.appendChild(item1)

			item1Div.classList.add(item.color)

			backpackSlotAndItemContainer1.appendChild(slot1Div)
			backpackSlotAndItemContainer1.appendChild(item1Div)
			backpackColumn1.appendChild(backpackSlotAndItemContainer1) //
			backpackSlotAndItemContainer1.classList.add('backpack-slot-and-item-container')
		})
	}
	if (backpack21Through40[0]) {
		backpack21Through40.forEach((item, i, arr) => {
			let slotNumber = i + 11
			const backpackSlotAndItemContainer1 = document.createElement('div')
			const slot1Div = document.createElement('div')
			const item1Div = document.createElement('div')

			item1Div.classList.add('backpack-item-name')
			const slot1 = document.createTextNode(`${slotNumber}. `)
			const item1 = document.createTextNode(`${item.name}`)

			slot1Div.appendChild(slot1)
			item1Div.appendChild(item1)

			item1Div.classList.add(item.color)

			backpackSlotAndItemContainer1.appendChild(slot1Div)
			backpackSlotAndItemContainer1.appendChild(item1Div)
			backpackColumn2.appendChild(backpackSlotAndItemContainer1) //
			backpackSlotAndItemContainer1.classList.add('backpack-slot-and-item-container')
		})
	}
	if (backpack41Through60[0]) {
		backpack41Through60.forEach((item, i, arr) => {
			let slotNumber = i + 21
			const backpackSlotAndItemContainer1 = document.createElement('div')
			const slot1Div = document.createElement('div')
			const item1Div = document.createElement('div')

			item1Div.classList.add('backpack-item-name')
			const slot1 = document.createTextNode(`${slotNumber}. `)
			const item1 = document.createTextNode(`${item.name}`)

			slot1Div.appendChild(slot1)
			item1Div.appendChild(item1)

			item1Div.classList.add(item.color)

			backpackSlotAndItemContainer1.appendChild(slot1Div)
			backpackSlotAndItemContainer1.appendChild(item1Div)
			backpackColumn3.appendChild(backpackSlotAndItemContainer1) //
			backpackSlotAndItemContainer1.classList.add('backpack-slot-and-item-container')
		})
	}
	backpackContainer.appendChild(backpackHeading)
	backpackContainer.appendChild(backpackColumnsContainer)
	backpackColumnsContainer.appendChild(backpackColumn1)
	backpackColumnsContainer.appendChild(backpackColumn2)
	backpackColumnsContainer.appendChild(backpackColumn3)
	backpackColumn1.classList.add('backpack-column-1')
	backpackColumn2.classList.add('backpack-column-2')
	backpackColumn3.classList.add('backpack-column-3')

	backpackHeading.appendChild(backpackHeadingTextNode)
	equipmentAndBackpackContainer.appendChild(backpackContainer)
	masterArea.appendChild(equipmentAndBackpackContainer)

	// const backpackColumn2 = document.createElement('div')
	// const backpackColumn3 = document.createElement('div')

	// const backpackSlotAndItemContainer2 = document.createElement('div')
	// const backpackSlotAndItemContainer3 = document.createElement('div')
	// const backpackSlotAndItemContainer4 = document.createElement('div')
	// const backpackSlotAndItemContainer5 = document.createElement('div')
	// const backpackSlotAndItemContainer6 = document.createElement('div')
	// const backpackSlotAndItemContainer7 = document.createElement('div')
	// const backpackSlotAndItemContainer8 = document.createElement('div')
	// const backpackSlotAndItemContainer9 = document.createElement('div')
	// const backpackSlotAndItemContainer10 = document.createElement('div')
	// const backpackSlotAndItemContainer11 = document.createElement('div')
	// const backpackSlotAndItemContainer12 = document.createElement('div')
	// const backpackSlotAndItemContainer13 = document.createElement('div')
	// const backpackSlotAndItemContainer14 = document.createElement('div')
	// const backpackSlotAndItemContainer15 = document.createElement('div')
	// const backpackSlotAndItemContainer16 = document.createElement('div')
	// const backpackSlotAndItemContainer17 = document.createElement('div')
	// const backpackSlotAndItemContainer18 = document.createElement('div')
	// const backpackSlotAndItemContainer19 = document.createElement('div')
	// const backpackSlotAndItemContainer20 = document.createElement('div')
	// const backpackSlotAndItemContainer21 = document.createElement('div')
	// const backpackSlotAndItemContainer22 = document.createElement('div')
	// const backpackSlotAndItemContainer23 = document.createElement('div')
	// const backpackSlotAndItemContainer24 = document.createElement('div')
	// const backpackSlotAndItemContainer25 = document.createElement('div')
	// const backpackSlotAndItemContainer26 = document.createElement('div')
	// const backpackSlotAndItemContainer27 = document.createElement('div')
	// const backpackSlotAndItemContainer28 = document.createElement('div')
	// const backpackSlotAndItemContainer29 = document.createElement('div')
	// const backpackSlotAndItemContainer30 = document.createElement('div')

	// const slot2 = document.createTextNode(`2. `)
	// const item2 = document.createTextNode(`${player.backpack[1]}`)
	// const slot3 = document.createTextNode(`3. `)
	// const item3 = document.createTextNode(`${player.backpack[2]}`)
	// const slot4 = document.createTextNode(`4. `)
	// const item4 = document.createTextNode(`${player.backpack[3]}`)
	// const slot5 = document.createTextNode(`5. `)
	// const item5 = document.createTextNode(`${player.backpack[4]}`)
	// const slot6 = document.createTextNode(`6. `)
	// const item6 = document.createTextNode(`${player.backpack[5]}`)
	// const slot7 = document.createTextNode(`7. `)
	// const item7 = document.createTextNode(`${player.backpack[6]}`)
	// const slot8 = document.createTextNode(`8. `)
	// const item8 = document.createTextNode(`${player.backpack[7]}`)
	// const slot9 = document.createTextNode(`9. `)
	// const item9 = document.createTextNode(`${player.backpack[8]}`)
	// const slot10 = document.createTextNode(`10. `)
	// const item10 = document.createTextNode(`${player.backpack[9]}`)
	// const slot11 = document.createTextNode(`11. `)
	// const item11 = document.createTextNode(`${player.backpack[10]}`)
	// const slot12 = document.createTextNode(`12. `)
	// const item12 = document.createTextNode(`${player.backpack[11]}`)
	// const slot13 = document.createTextNode(`13. `)
	// const item13 = document.createTextNode(`${player.backpack[12]}`)
	// const slot14 = document.createTextNode(`14. `)
	// const item14 = document.createTextNode(`${player.backpack[13]}`)
	// const slot15 = document.createTextNode(`15. `)
	// const item15 = document.createTextNode(`${player.backpack[14]}`)
	// const slot16 = document.createTextNode(`16. `)
	// const item16 = document.createTextNode(`${player.backpack[15]}`)
	// const slot17 = document.createTextNode(`17. `)
	// const item17 = document.createTextNode(`${player.backpack[16]}`)
	// const slot18 = document.createTextNode(`18. `)
	// const item18 = document.createTextNode(`${player.backpack[17]}`)
	// const slot19 = document.createTextNode(`19. `)
	// const item19 = document.createTextNode(`${player.backpack[18]}`)
	// const slot20 = document.createTextNode(`20. `)
	// const item20 = document.createTextNode(`${player.backpack[19]}`)
	// const slot21 = document.createTextNode(`21. `)
	// const item21 = document.createTextNode(`${player.backpack[20]}`)
	// const slot22 = document.createTextNode(`22. `)
	// const item22 = document.createTextNode(`${player.backpack[21]}`)
	// const slot23 = document.createTextNode(`23. `)
	// const item23 = document.createTextNode(`${player.backpack[22]}`)
	// const slot24 = document.createTextNode(`24. `)
	// const item24 = document.createTextNode(`${player.backpack[23]}`)
	// const slot25 = document.createTextNode(`25. `)
	// const item25 = document.createTextNode(`${player.backpack[24]}`)
	// const slot26 = document.createTextNode(`26. `)
	// const item26 = document.createTextNode(`${player.backpack[25]}`)
	// const slot27 = document.createTextNode(`27. `)
	// const item27 = document.createTextNode(`${player.backpack[26]}`)
	// const slot28 = document.createTextNode(`28. `)
	// const item28 = document.createTextNode(`${player.backpack[27]}`)
	// const slot29 = document.createTextNode(`29. `)
	// const item29 = document.createTextNode(`${player.backpack[28]}`)
	// const slot30 = document.createTextNode(`30. `)
	// const item30 = document.createTextNode(`${player.backpack[29]}`)
	// const goldSlot = document.createTextNode(`Gold: `)
	// const goldAmount = document.createTextNode(`${player.gold}`)

	// backpackSlotAndItemContainer2.appendChild(slot2)
	// backpackSlotAndItemContainer2.appendChild(item2)
	// backpackSlotAndItemContainer3.appendChild(slot3)
	// backpackSlotAndItemContainer3.appendChild(item3)
	// backpackSlotAndItemContainer4.appendChild(slot4)
	// backpackSlotAndItemContainer4.appendChild(item4)
	// backpackSlotAndItemContainer5.appendChild(slot5)
	// backpackSlotAndItemContainer5.appendChild(item5)
	// backpackSlotAndItemContainer6.appendChild(slot6)
	// backpackSlotAndItemContainer6.appendChild(item6)
	// backpackSlotAndItemContainer7.appendChild(slot7)
	// backpackSlotAndItemContainer7.appendChild(item7)
	// backpackSlotAndItemContainer8.appendChild(slot8)
	// backpackSlotAndItemContainer8.appendChild(item8)
	// backpackSlotAndItemContainer9.appendChild(slot9)
	// backpackSlotAndItemContainer9.appendChild(item9)
	// backpackSlotAndItemContainer10.appendChild(slot10)
	// backpackSlotAndItemContainer10.appendChild(item10)
	// backpackSlotAndItemContainer11.appendChild(slot11)
	// backpackSlotAndItemContainer11.appendChild(item11)
	// backpackSlotAndItemContainer12.appendChild(slot12)
	// backpackSlotAndItemContainer12.appendChild(item12)
	// backpackSlotAndItemContainer13.appendChild(slot13)
	// backpackSlotAndItemContainer13.appendChild(item13)
	// backpackSlotAndItemContainer14.appendChild(slot14)
	// backpackSlotAndItemContainer14.appendChild(item14)
	// backpackSlotAndItemContainer15.appendChild(slot15)
	// backpackSlotAndItemContainer15.appendChild(item15)
	// backpackSlotAndItemContainer16.appendChild(slot16)
	// backpackSlotAndItemContainer16.appendChild(item16)
	// backpackSlotAndItemContainer17.appendChild(slot17)
	// backpackSlotAndItemContainer17.appendChild(item17)
	// backpackSlotAndItemContainer18.appendChild(slot18)
	// backpackSlotAndItemContainer18.appendChild(item18)
	// backpackSlotAndItemContainer19.appendChild(slot19)
	// backpackSlotAndItemContainer19.appendChild(item19)
	// backpackSlotAndItemContainer20.appendChild(slot20)
	// backpackSlotAndItemContainer20.appendChild(item20)
	// backpackSlotAndItemContainer21.appendChild(slot21)
	// backpackSlotAndItemContainer21.appendChild(item21)
	// backpackSlotAndItemContainer22.appendChild(slot22)
	// backpackSlotAndItemContainer22.appendChild(item22)
	// backpackSlotAndItemContainer23.appendChild(slot23)
	// backpackSlotAndItemContainer23.appendChild(item23)
	// backpackSlotAndItemContainer24.appendChild(slot24)
	// backpackSlotAndItemContainer24.appendChild(item24)
	// backpackSlotAndItemContainer25.appendChild(slot25)
	// backpackSlotAndItemContainer25.appendChild(item25)
	// backpackSlotAndItemContainer26.appendChild(slot26)
	// backpackSlotAndItemContainer26.appendChild(item26)
	// backpackSlotAndItemContainer27.appendChild(slot27)
	// backpackSlotAndItemContainer27.appendChild(item27)
	// backpackSlotAndItemContainer28.appendChild(slot28)
	// backpackSlotAndItemContainer28.appendChild(item28)
	// backpackSlotAndItemContainer29.appendChild(slot29)
	// backpackSlotAndItemContainer29.appendChild(item29)
	// backpackSlotAndItemContainer30.appendChild(slot30)
	// backpackSlotAndItemContainer30.appendChild(item30)

	// backpackColumn1.appendChild(backpackSlotAndItemContainer2)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer3)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer4)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer5)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer6)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer7)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer8)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer9)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer10)

	// backpackColumn2.appendChild(backpackSlotAndItemContainer11)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer12)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer13)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer14)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer15)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer16)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer17)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer18)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer19)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer20)

	// backpackColumn3.appendChild(backpackSlotAndItemContainer21)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer22)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer23)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer24)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer25)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer26)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer27)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer28)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer29)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer30)

	// backpackColumnsContainer.appendChild(backpackColumn2)
	// backpackColumnsContainer.appendChild(backpackColumn3)

	//CLASSES ADDED
	// backpackSlotAndItemContainer2.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer3.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer4.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer5.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer6.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer7.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer8.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer9.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer10.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer11.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer12.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer13.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer14.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer15.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer16.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer17.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer18.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer19.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer20.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer21.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer22.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer23.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer24.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer25.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer26.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer27.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer28.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer29.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer30.classList.add('backpack-slot-and-item-container')
	backpackContainer.classList.add('backpack-container')
	backpackHeading.classList.add('backpack-heading')
	backpackColumnsContainer.classList.add('backpack-columns-container')
	// backpackColumn2.classList.add('backpack-column-2')
	// backpackColumn3.classList.add('backpack-column-3')
}

//weaponSwing is only for displaying the swing messages in the game
// function weaponSwing(enemy, damage1, damage2, penName, onHitDamage1, onHitDamage2) {
// 	let swingType
// 	let preposition
// 	let weapon1 = getWeapon1()
// 	let weapon2 = getWeapon2()
// 	function playerSwingType() {
// 		if (penName == 'piercing ' && weapon1.type.daggers != undefined && weapon1.type.daggers == 'daggers') {
// 			swingType = 'stab '
// 		} else if (penName == 'slashing ') {
// 			swingType = 'slash '
// 		} else if (penName == 'piercing ') {
// 			swingType = 'thrust '
// 		} else if (penName == 'blunt ') {
// 			swingType = 'slam '
// 		} else if (penName == 'unarmed ') {
// 			swingType = 'slam '
// 		} else if (penName == 'miss') {
// 			swingType = 'swing '
// 		}
// 	}
// 	playerSwingType()
// 	function atIntoOnto() {
// 		if (penName == 'slashing ') {
// 			preposition = 'at the '
// 		} else if (penName == 'piercing ') {
// 			preposition = 'into the '
// 		} else if (penName == 'unarmed ') {
// 			preposition = 'into the '
// 		} else if (penName == 'blunt ') {
// 			preposition = 'onto the '
// 		} else if (penName == 'miss') {
// 			preposition = 'at the '
// 		}
// 	}
// 	atIntoOnto()
// 	if (damage2 == undefined && damage1 != undefined) {
// 		if (player.isStealthed == true) {
// 			player.stealth.stealthSwing(enemy, weapon1, damage1)
// 		} else {
// 			weapon1.swing(weapon1, enemy, damage1, penName, swingType, preposition)
// 		}
// 		if (!isNaN(onHitDamage1[0]) && !isNaN(damage1)) {
// 			for (let i = 0; i < onHitDamage1.length; i++) {
// 				weapon1.enchantment[i].onHit(weapon1, onHitDamage1[i], enemy)
// 			}
// 		}
// 	} else if (damage1 == undefined && damage2 != undefined) {
// 		if (player.isStealthed == true) {
// 			player.stealth.stealthSwing(enemy, weapon2, damage2)
// 		} else {
// 			weapon2.swing(weapon2, enemy, damage2, penName, swingType, preposition)
// 		}
// 		if (onHitDamage2 != undefined && !isNaN(onHitDamage2[0]) && !isNaN(damage2)) {
// 			for (let i = 0; i < onHitDamage2.length; i++) {
// 				weapon2.enchantment[i].onHit(weapon2, onHitDamage2[i], enemy)
// 			}
// 		}
// 	}
// 	if (!isNaN(damage1) || !isNaN(damage2)) {
// 		addMight()
// 		addSinisterMark(enemy)
// 	}
// 	if (!isNaN(damage1) || !isNaN(damage2)) {
// 		if (Object.keys(player.buffs).length == 0) {
// 			return
// 		} else {
// 			for (let keys in player.buffs) {
// 				let buff = player.buffs[keys]
// 				let line1 = lineFunc()
// 				if (buff.type == 'extra damage') {
// 					let damage = buff.damage()
// 					console.log(player.buffs[keys], ' PLAYER BUFF KEYS')
// 					customizeEachWord(`You deal an additional `, 'white', line1)
// 					customizeEachWord(`${damage} `, buff.color, line1)
// 					customizeEachWord(`damage.`, 'white', line1)
// 					enemy.health -= damage
// 					enemy.death()
// 					blankSpace()
// 				} else if (buff.type == 'self heal') {
// 					console.log(buff, ' 90349058438792347580234')
// 					let heal = buff.heal()
// 					if (player.health + heal > player.maxHealth) {
// 						heal = player.maxHealth - player.health
// 					}
// 					customizeEachWord(`You heal yourself for `, 'white', line1)
// 					customizeEachWord(`${heal} `, 'green', line1)
// 					customizeEachWord(`life!`, 'white', line1)
// 					player.health += heal
// 					blankSpace()
// 					}
// 			}
// 		} 
// 	}
// 	blankSpace()
// }
function dualWeaponSwing(enemy, playerWeapon, playerDamage, penName, onHitDamage) {
	console.log('DUAL WEPAON SWING RAN')
	let swingType
	let preposition
	function playerSwingType(weaponType) {
		if (penName == 'piercing ' && weaponType != undefined && weaponType == 'daggers') {
			swingType = 'stab '
		} else if (penName == 'slashing ') {
			swingType = 'slash '
		} else if (penName == 'piercing ') {
			swingType = 'thrust '
		} else if (penName == 'blunt ') {
			swingType = 'slam '
		} else if (penName == 'unarmed ') {
			swingType = 'slam '
		}
	}
	playerSwingType()
	function atIntoOnto() {
		if (penName == 'slashing ') {
			preposition = 'at the '
		} else if (penName == 'piercing ') {
			preposition = 'into the '
		} else if (penName == 'blunt ') {
			preposition = 'onto the '
		} else if (penName == 'unarmed ') {
			preposition = 'into the '
		} else if (penName == 'miss') {
			preposition = 'at the '
		}
	}
	atIntoOnto()
	if (player.isStealthed == true) {
		player.stealth.stealthSwing(enemy, playerWeapon, playerDamage)
	} else {
		playerWeapon.swing(playerWeapon, enemy, playerDamage, penName, swingType, preposition)
	}
	if (!isNaN(onHitDamage[0])) {
		for (let i = 0; i < onHitDamage.length; i++) {
			playerWeapon.enchantment[i].onHit(playerWeapon, onHitDamage[i], enemy)
		}
		// onHitDamage.forEach(damageAmount => {
		// 	enchantment.onHit(playerWeapon, damageAmount, enemy)

		// })
	}
	if (!isNaN(playerDamage)) {
		console.log(playerDamage, 'THIS IS PLAYER DAMAGE')
		addMight()
		addSinisterMark(enemy)
	}
	if (!isNaN(playerDamage)) {
		let playerDamageBuffs = player.mods
		let elements = ['fireDamage', 'waterDamage', 'earthDamage', 'lightningDamage', 'iceDamage', 'airDamage']
		let elementColor
		for (let buff in playerDamageBuffs) {
			if (playerDamageBuffs[buff] != 0 && elements.includes(buff)) {
				switch(buff) {
					case 'fireDamage':
					elementColor = 'fire'
				}
				let line1 = lineFunc()
				customizeEachWord(`You deal an additional `, 'white', line1)
				customizeEachWord(`${playerDamageBuffs[buff]} `, elementColor, line1)
				customizeEachWord(`damage.`, 'white', line1)
			}
		}
	}
	// playerWeapon.enchantment.forEach(enchant => {
	// 	if (enchant != undefined && !isNaN(onHitDamage) && !isNaN(playerDamage)) {
	// 		playerWeapon.enchantment.onHit(playerWeapon, onHitDamage, enemy)
	// 	}
	// })
}
function isPlayerConjuring() {
	let line1 = lineFunc()
	if (player.conjuring) {
		customizeEachWord(`You cannot attack while conjuring a spell without the appropriate skill!`, 'white', line1)
		return true
	} else { 
		return false
	}
}
function doesEnemyExist() {
	let line1 = lineFunc()
	let doesEnemyExist = pushMonster.find(enemy => coordinatesMatch(player, enemy))
	if (!player.isAlive) {
		quickMessage(`You are dead! You must revive before being able to do anything else.`)
		return
	}
	if (doesEnemyExist) {return true}
	if (!doesEnemyExist) {
		customizeEachWord(`There is no enemy for you to attack`, 'white', line1)
		return false
	}
}
function doesValidTargetExist(enemy) {
	let line1 = lineFunc()
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let isPlayerInCombat = 	allEnemiesInRoom.some(enemy => enemy.combat)
	//if player does not have a bow equipped or is in stealth + enemy is not in combat
	if (!rangeCheck() && !isPlayerInCombat) {
		customizeEachWord(`You must be in combat with the enemy to attack it!`, 'white', line1)
		return false
	} else if (!rangeCheck() && isPlayerInCombat) {
		// customizeEachWord(`Player is melee, valid target exists`, 'white', line1)
		return true
	} else if (rangeCheck() && allEnemiesInRoom[0]) {
		// quickMessage(`Player is ranged, valid target exists`, 'white', line1)
		return true
	} else {
		customizeEachWord(`There must be an enemy in the room for you to attack it!`, 'white', line1)
	}
}
function rangeCheck() {
	if (player.currentWeaponSkill.refName == 'bows' || player.isStealthed) {return true}
	else {return false}
}
function currentRightHandWeapon() {
	return pushItem.find(item => item.roomId == 'right hand') == undefined ? player.rightFist : pushItem.find(item => item.roomId == 'right hand')
}
function currentLeftHandWeapon() {
	return pushItem.find(item => item.roomId == 'left hand') == undefined ? player.leftFist : pushItem.find(item => item.roomId == 'left hand')
}

function testWeaponObject() {
	let weapon = {
		rightWeapon: {},
		rightPenType: 'slashing',
		rightRawDamage: 20,

		leftWeapon: {},
		leftPenType: 'piercing',
		leftRawDamage: 10,

	}
}

function singleOrDualSwing(rightItem, leftItem) {
	let weaponsObject = {
		right: {
			totalDamage: 0
		},
		left: {
			totalDamage: 0
		},
	}

	if (rightItem.refName == 'rightFist' && leftItem.refName == 'leftFist') {
		// quickMessage(`Unarmed x2`)
		weaponsObject.right.weapon = rightItem
		weaponsObject.left.weapon = leftItem
	}
	else if (rightItem.type.weapon && !rightItem.type.unarmed && leftItem.type.weapon && !leftItem.type.unarmed) {
		// quickMessage(`Dual wield swing with weapons`)
		weaponsObject.right.weapon = rightItem
		weaponsObject.left.weapon = leftItem
	}
	else if ((rightItem.refName == 'rightFist' || !rightItem.type.weapon) && (leftItem.type.weapon && !leftItem.type.unarmed)) {
		// quickMessage(`LEFT only weapon swing - no fist should swing here`)
		weaponsObject.left.weapon = leftItem
		weaponsObject.doesPlayerCleave = doesPlayerCleave(weaponsObject)
	} else if ((leftItem.refName == 'leftFist' || !leftItem.type.weapon) && (rightItem.type.weapon && !rightItem.type.unarmed)) {
		// quickMessage(`RIGHT only weapon swing - no fist should swing here`)
		weaponsObject.right.weapon = rightItem
		weaponsObject.doesPlayerCleave = doesPlayerCleave(weaponsObject)
	} else if (!rightItem.type.weapon && leftItem.refName == 'leftFist') {
		// quickMessage(`Right hand has a non-weapon item, only left unarmed swing should happen`)
		weaponsObject.left.weapon = leftItem
	} else if (!leftItem.type.weapon && rightItem.refName == 'rightFist') {
		// quickMessage(`Left hand has a non-weapon item, only right unarmed swing should happen`)
		weaponsObject.right.weapon = rightItem
	} else if (!leftItem.type.weapon && !rightItem.type.weapon) {
		// quickMessage(`You cannot attack with those items in your hands!`)
		return false
	}
	calculateNumberOfStrikes(weaponsObject)
	return weaponsObject

}
function doesPlayerCleave() {
	if (player.currentWeaponSkill.refName != 'twoHanded' || 
		player.currentWeaponSkill.refName != 'oneHanded' ||
		player.cleave.level == 0
		) {
		return false
	} else {
		return true
	}
}

function calculateCleaveTargets(targetEnemy, allEnemies) {
	let mainTarget = targetEnemy
	let allEnemiesInCombat = allEnemies
	allEnemiesInCombat.splice(allEnemiesInCombat.indexOf(mainTarget), 1)
	let cleaveTargets = []
	for (let i = 0; i < player.cleave.level; i++) {
		if (allEnemiesInCombat[i]) {
			cleaveTargets.push(allEnemiesInCombat[i])
		}
	}
	if (cleaveTargets[0]) {
		return cleaveTargets
	} else {
		return []
	}
}

function sneakAttack(enemy) {
	stealthBreak()
	resourceGained(backstab, 5, 'maxAdrenaline')
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`You jump out in a `, 'white', line1)
	customizeEachWord(`Sneak attack`, 'orange', line1)
	customizeEachWord(`!`, 'white', line1)
	player.isStealthed = false
	player.combat = true
	enemy.combat = true
}


function updatePlayerMight() {
	if (player.might < player.maxMight)
		player.might++
}
function updatePlayerAdrenaline() {

}
function updatePlayerFocus() {

}

function increasePlayerResource() {
	switch (player.playerClass) {
		case 'Warrior':
			updatePlayerMight()
		case 'Thief':
			updatePlayerAdrenaline()
		case 'Monk':
			updatePlayerFocus()
		case 'Ranger':
		case 'Mage':
	}
}
	// weaponsObject { THIS IS WHAT THE WEAPONSOBJECT LOOKS LIKE
	// 	right: {
	// 		rawDamage:
	// 		penetrationType:
	// 		swingType:
	// 		totalDamage:
	// 		blockedDamage:
	//		verb:
	//		preposition:
	// 	}
	// 	left: {
	// 		rawDamage:
	// 		penetrationType:
	// 		swingType:
	// 		totalDamage:
	// 		blockedDamage:
	//		verb:
	//		preposition:
	// 	}
	// }
// function perceptionCheck(obstacle) {
// 	let playerLevel = player.level
// 	let playerPerception = player.perception.effectiveness()
// 	let playerTotalPerception = playerLevel + playerPerception
// 	return playerTotalPerception >= obstacle
// }

function strengthCheck(check) {
	if (player.str >= check) {
		return true
	} else {
		return false
	}
}
function dexterityCheck(check) {
	if (player.dex >= check) {
		return true
	} else {
		return false
	}
}
function agilityCheck(check) {
	if (player.agi >= check) {
		return true
	} else {
		return false
	}
}
function wisdomCheck(check) {
	if (player.wis >= check) {
		return true
	} else {
		return false
	}
}
function intelligenceCheck(check) {
	if (player.int >= check) {
		return true
	} else {
		return false
	}
}
function constitutionCheck(check) {
	if (player.con >= check) {
		return true
	} else {
		return false
	}
}

function calculateCritDamage(rightOrLeftObject) {
	let damage = 0
	let roll = randomNumberRange(1, 100)
	if (player.headshot.level > 0) {
		if (player.headshot.procChance() >= roll) {
			damage = (rightOrLeftObject.baseDamage * player.headshot.percentBonus()) - rightOrLeftObject.baseDamage
			quickMessage(`HEADSHOT: ${damage} bonus`)
		}
	}
	if (player.backstabbing.level > 0) {
		if (player.backstabbing.procChance() >= roll) {
			damage = (rightOrLeftObject.baseDamage * player.backstabbing.percentBonus()) - rightOrLeftObject.baseDamage
			quickMessage(`BACKSTAB: ${damage} bonus`)
		}
	}
	if (player.brutalBlows.level > 0) {
		if (player.brutalBlows.procChance() >= roll) {
			damage = (rightOrLeftObject.baseDamage * player.brutalBlows.percentBonus()) - rightOrLeftObject.baseDamage
			quickMessage(`BRUTAL BLOW: ${damage} bonus`)
		}
	}
	return Math.ceil(damage)
}




function attack(secondCommand, thirdCommand) {
	//FAIL CHECKS BELOW
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let allEnemiesInCombat = getAllEnemiesInCombat()
	let enemiesGettingHit = []
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	enemiesGettingHit.push(targetEnemy)
	// if (actionWait()) {return}
	// if (!doesEnemyExist()) {return} 
	if (!doesValidTargetExist(targetEnemy)) {return}
	if (isPlayerConjuring()) {return}
	let playerWeaponRight = currentRightHandWeapon()
	let playerWeaponLeft = currentLeftHandWeapon()
	let weaponsObject = singleOrDualSwing(playerWeaponRight, playerWeaponLeft)
	let weaponSkillSpeed = player.currentWeaponSkill.speed
	let cleaveTargets = calculateCleaveTargets(targetEnemy, allEnemiesInCombat)
	enemiesGettingHit = enemiesGettingHit.concat(cleaveTargets)
	handleAttack(enemiesGettingHit, weaponsObject)
	combatCount(weaponSkillSpeed)
	updatePlayerStats()
	updateMonsterBox()
	updateScroll()
}
function handleAttack(enemy, weaponsObject) {
	handleRightAttack(enemy, weaponsObject)
	handleLeftAttack(enemy, weaponsObject)
}
function handleRightAttack(enemy, weaponsObject){
	let rightObject = weaponsObject.right
	if (rightObject.weapon) {
		enemy.forEach(enemy => {
		if (enemy.health <= 0) {return}
		for (let i = 0; i < rightObject.numberOfExtraStrikes + 1; i++) {
			if (enemy.health <= 0) {return}
			rightObject.doesSwingHit = calculateHitOrMiss(enemy)
			if (!rightObject.doesSwingHit) {
				rightObject.penetrationVerb = calculatePenetrationVerb(rightObject)
				rightObject.preposition = atIntoOnto(rightObject)
				displaySwing(enemy, rightObject)
				// return
			}
			if (rightObject.doesSwingHit) {
			rightObject.classOnHitDisplay = {}
			rightObject.playerBuffOnHit = {}
			rightObject.weaponEnchantment = {}
			rightObject.weaponHealingEnchantment = {}

			rightObject.penetrationVerb = calculatePenetrationVerb(rightObject)
			rightObject.preposition = atIntoOnto(rightObject)
			rightObject.penetrationType = calculatePenetrationType(enemy, rightObject)
			rightObject.baseDamage = baseAttackDamageRight() //Raw base damage
			rightObject.critDamage = calculateCritDamage(rightObject)
			rightObject.totalDamage = calculateDamageWithBonusesAndAfterEnemyMitigation(enemy, rightObject) //base damage after enemy mitigation
			// rightObject.blockedDamage = rightObject.baseDamage - rightObject.totalDamage
			rightObject.blockedDamage = rightObject.damagePreMitigation - rightObject.totalDamage
			quickMessage(`${rightObject.baseDamage} Base Damage`)
			quickMessage(`${rightObject.damagePreMitigation} Damage Pre Mitigation`)
			quickMessage(`${rightObject.critDamage} Crit Damage`)
			quickMessage(`${rightObject.totalDamage} Total Damage`)
			quickMessage(`${rightObject.blockedDamage} Blocked Damage`)
			rightObject.buffDamage = calculateBuffDamage(enemy, rightObject)
			rightObject.weaponEnchantmentDamage = calculateWeaponEnchantmentDamage(enemy, rightObject)
			rightObject.weaponEnchantmentHeal = calculateWeaponEnchantmentHeal(rightObject)
			rightObject.onHitDamage = calculateOnHitDamage(enemy, rightObject) //0, 10, 15
			rightObject.doesPlayerStun = calculateStunningBlow()
			rightObject.realTotalDamage = rightObject.totalDamage + rightObject.onHitDamage + rightObject.buffDamage
			rightObject.damageToApplyToEnemy = Math.ceil(rightObject.totalDamage + rightObject.onHitDamage + rightObject.buffDamage + rightObject.weaponEnchantmentDamage)
			displaySwing(enemy, rightObject)
			applyDamageToEnemy(enemy, rightObject.damageToApplyToEnemy)
			calculateClassAdditionalEffects(enemy)
			gainClassResourceOnAttack(rightObject.doesSwingHit)
			// applyBuffForReal(rightObject)
			applyOnHitSkillBuffs(rightObject)
			applyStunningBlow(enemy, rightObject)
			console.log(rightObject)
			}
		}
	})
	} 
}
function handleLeftAttack(enemy, weaponsObject) {
	let leftObject = weaponsObject.left
	if (leftObject.weapon) {
		enemy.forEach(enemy => {
			if (enemy.health <= 0) {return}
			for (let i = 0; i < leftObject.numberOfExtraStrikes + 1; i++) {
				if (enemy.health <= 0) {return}
				leftObject.doesSwingHit = calculateHitOrMiss(enemy)
				if (!leftObject.doesSwingHit) {
					leftObject.penetrationVerb = calculatePenetrationVerb(leftObject)
					leftObject.preposition = atIntoOnto(leftObject)
					displaySwing(enemy, leftObject)
					// return
				}
				if (leftObject.doesSwingHit) {
				leftObject.classOnHitDisplay = {}
				leftObject.playerBuffOnHit = {}
				leftObject.weaponEnchantment = {}
				leftObject.weaponHealingEnchantment = {}
	
				leftObject.penetrationVerb = calculatePenetrationVerb(leftObject)
				leftObject.preposition = atIntoOnto(leftObject)
				leftObject.penetrationType = calculatePenetrationType(enemy, leftObject)
				leftObject.baseDamage = baseAttackDamageLeft() //Raw base damage
				leftObject.critDamage = calculateCritDamage(leftObject)
				leftObject.totalDamage = calculateDamageWithBonusesAndAfterEnemyMitigation(enemy, leftObject) //base damage after enemy mitigation
				// leftObject.blockedDamage = leftObject.baseDamage - leftObject.totalDamage
				leftObject.blockedDamage = leftObject.damagePreMitigation - leftObject.totalDamage
	
				leftObject.buffDamage = calculateBuffDamage(enemy, leftObject)
				leftObject.weaponEnchantmentDamage = calculateWeaponEnchantmentDamage(enemy, leftObject)
				leftObject.weaponEnchantmentHeal = calculateWeaponEnchantmentHeal(leftObject)
				leftObject.onHitDamage = calculateOnHitDamage(enemy, leftObject) //0, 10, 15
				leftObject.doesPlayerStun = calculateStunningBlow()

				leftObject.realTotalDamage = leftObject.totalDamage + leftObject.onHitDamage + leftObject.buffDamage
				leftObject.damageToApplyToEnemy = Math.ceil(leftObject.totalDamage + leftObject.onHitDamage + leftObject.buffDamage + leftObject.weaponEnchantmentDamage)
				displaySwing(enemy, leftObject)
				applyDamageToEnemy(enemy, leftObject.damageToApplyToEnemy)
				calculateClassAdditionalEffects(enemy)
				gainClassResourceOnAttack(leftObject.doesSwingHit)
				// applyBuffForReal(leftObject)
				applyOnHitSkillBuffs(leftObject)
				applyStunningBlow(enemy, leftObject)
				console.log(leftObject)
			}
		}
	})
	}
}

function studySpell(secondCommand, thirdCommand) {
	let npcSpellIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	let masterSpell = this.spellsOffered[npcSpellIndex]
	let npcSpellMaxLevel = masterSpell != undefined ? this.spellsMaxLevel[masterSpell.refName] : undefined
	let playerSpell = player[masterSpell.refName]
	let playerGold = player.gold
	let playerPoints = player.skillPoints
	let goldCost = playerSpell != undefined ? playerSpell.goldToUpgrade() : masterSpell.goldToUpgrade()
	let pointsCost = playerSpell != undefined ? playerSpell.pointsToUpgrade() : masterSpell.pointsToUpgrade()

	let line1 = document.createElement('div')
	console.log('JOCH SKILSL RAN')
	if (player.guild != 'Mage') {
	if (masterSpell == undefined) {
		customizeEachWord(`That skill is not one of the choices`, 'white', line1)
	} else if (playerGold < goldCost) {
		quickMessage(`You do not have enough gold to learn this skill!`)
	} else if (playerPoints < pointsCost) {
		quickMessage(`You do not have enough ability points to learn this spell!`)
	} else if (playerSpell == undefined && masterSpell != undefined) {
		player[masterSpell.refName] = { ...masterSpell }
		customizeEachWord(`You have learned the `, 'white', line1)
		customizeEachWord(`${masterSpell.refName} `, masterSpell.color, line1)
		customizeEachWord(`spell!`, 'white', line1)
		player.gold -= goldCost
		player.skillPoints -= pointsCost
	} else if (playerSpell.level < npcSpellMaxLevel) {
		player[masterSpell.refName].level++
		customizeEachWord(`You have furthered your knowledge of the `, 'white', line1)
		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
		customizeEachWord(`spell! You have increased its level to `, 'white', line1)
		customizeEachWord(`${playerSpell.level}`, `light-blue`, line1)
		player.gold -= goldCost
		player.skillPoints -= pointsCost
	} else {
		customizeEachWord(`${this.name} `, this.nameColor, line1)
		customizeEachWord(`cannot teach you any more of the `, 'white', line1)
		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
		customizeEachWord(`spell`, 'white', line1)
	}
} else {
	quickMessage(`You must be a Mage Initiate to learn from Scylla`)
}
}

function calculateTotalDamage(swingObject) {
	let {onHitDamage, damageAfterMitigation} = swingObject
	if (!onHitDamage) {
		onHitDamage = 0
	}
	return damageAfterMitigation + onHitDamage
}

function unarmedProficiencyCheck() {
	return player.unarmed.level > 0
}

function applyStunningBlow(enemy, weaponObject) {
	if (!weaponObject.doesPlayerStun) {return}
	enemy.isStunned = true
	enemy.capturedAttackTimer = enemy.attackTimer
	// player.stunningBlows.flavorText(enemy)
	if (enemy.stunDuration) {
		clearTimeout(enemy.stunDuration)
	}
	clearTimeout(enemy.attackTimerInterval)
	enemy.stunDuration = setTimeout(() => {
		if (enemy.health > 0) {
			quickMessage(`Enemy is no longer stunned`)
		}
		enemy.isStunned = false
		if (!enemy.isBehaviorRunning) {
			enemy.enemyBehavior()
		}
	}, player.stunningBlows.stunningBlowsDuration())
}

function displayOnHitBonusSwing(enemy, swingObject) {
	if (enemy.debuffs) {
		for (const debuff in enemy.debuffs) {
			console.log(enemy.debuffs[debuff])
			if (enemy.debuffs[debuff].flavorText) {
				enemy.debuffs[debuff].flavorText(enemy, swingObject)
			}
		}
	}
}

function baseWeightDamage() {
	//using player.mods.weight because player.weight factors in strength which removes weight from player.weight
	let playerWeight = player.mods.weight
	let baseDamage = playerWeight * 0.5
	return Math.ceil(baseDamage)
}

function baseAttackDamageRight() {
	// THIS FUNCTION CALCULATES THE PLAYER'S BASE ATTACK DAMAGE FOR THE RIGHT WEAPON
	const playerWeapon = player.currentWeaponRight();
	if (!playerWeapon) {return 0}
	if (playerWeapon.type.shield) {return playerWeapon.mods.armor}
	const { attackPower, botMultiplier, topMultiplier } = player[playerWeapon.skillUsed]
	const { botDamage, topDamage } = playerWeapon;
	const lowDamage = Math.ceil(attackPower * (botMultiplier * botDamage));
	const highDamage = Math.ceil(attackPower * (topMultiplier * topDamage));
	const baseDamage = Math.max(0, randomNumberRange(lowDamage, highDamage))
	console.log(lowDamage, 'LOW DAMAGE')
	console.log(highDamage, 'HIGH DAMAGE')
	console.log(baseDamage, 'CHOSEN DAMAGE')
	return baseDamage
}

function baseAttackDamageLeft() {
	// THIS FUNCTION CALCULATES THE PLAYER'S BASE ATTACK DAMAGE FOR THE RIGHT WEAPON
	const playerWeapon = player.currentWeaponLeft();
	if (!playerWeapon) {return 0}
	if (playerWeapon.type.shield) {return playerWeapon.mods.armor}
	const { attackPower, botMultiplier, topMultiplier } = player[playerWeapon.skillUsed]
	const { botDamage, topDamage } = playerWeapon;
	const lowDamage = Math.ceil(attackPower * (botMultiplier * botDamage));
	const highDamage = Math.ceil(attackPower * (topMultiplier * topDamage));
	console.log(lowDamage, ' LOW DAMAGE')
	console.log(highDamage, ' HIGH DAMAGE')
	console.log(playerWeapon)
	return Math.max(0, randomNumberRange(lowDamage, highDamage));
}


function calculateNumberOfStrikes(rightOrLeft) {
	let numberOfExtraStrikes = 0
	if (player.multipleStrikes.level > 0) {
		let multipleStrikesNumber = player.multipleStrikes.extraStrikesNumber()
		let multipleStrikeChance = player.multipleStrikes.extraStrikesChance()
		if (rightOrLeft.right.weapon && rightOrLeft.left.weapon) {
			multipleStrikeChance = multipleStrikeChance / 2
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.right.numberOfExtraStrikes = numberOfExtraStrikes
			numberOfExtraStrikes = 0
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.left.numberOfExtraStrikes = numberOfExtraStrikes
			return
		}
		if (rightOrLeft.right.weapon) {
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.right.numberOfExtraStrikes = numberOfExtraStrikes
			return
		}
		if (rightOrLeft.left.weapon) {
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.left.numberOfExtraStrikes = numberOfExtraStrikes
		}
	}
	if (player.extraStrike.level > 0) {
		numberOfExtraStrikes += player.extraStrike.nthStrike()
	}
	if (player.doubleDraw.level > 0) {
		if (player.doubleDraw.counter == player.doubleDraw.nthStrike()) {
			numberOfExtraStrikes++
			player.doubleDraw.counter = 0
		} else {
			player.doubleDraw.counter++
		}
	}
	rightOrLeft.right.numberOfExtraStrikes = numberOfExtraStrikes
	rightOrLeft.left.numberOfExtraStrikes = numberOfExtraStrikes
	// console.log(extraStrikeChance, ' CHANCE OF GETTING AN EXTRA STRIKE')
	// return numberOfExtraStrikes
}


function calculateHitOrMiss(enemy) {
	let hitChance = calculatePlayerAccuracy() - calculateEnemyDodgeChance(enemy)
	let randomRoll = randomNumberRange(1, 100)
	console.log(hitChance, ' PLAYER HIT CHANCE')
	if (hitChance >= randomRoll) {
		increasePlayerResource()
		return true
	} else if (hitChance < randomRoll) {
		return false
	} else {
		quickMessage(`HIT CHANCE IS BUGGED ENEMY PROBABLY HAS FUCKY DODGE STAT`)
		return true
	}
}
function calculateRawAttackDamage(rightOrLeft) {
	if (rightOrLeft.doesSwingHit) {
		const topDamage = Math.ceil(parseFloat((player.currentWeaponSkill.attackPower * (player.currentWeaponSkill.topMultiplier * rightOrLeft.weapon.topDamage))))
		const botDamage = Math.ceil(parseFloat((player.currentWeaponSkill.attackPower * (player.currentWeaponSkill.botMultiplier * rightOrLeft.weapon.botDamage))))
		return randomNumberRange(botDamage, topDamage)
	} else {
		return 0
	}
}



function calculatePenetrationVerb(rightOrLeft) {
	let penetrationTypes = []
	if (rightOrLeft.weapon.mods.hasOwnProperty('slashingPen')) {penetrationTypes.push('slashingPen')}
	if (rightOrLeft.weapon.mods.hasOwnProperty('piercingPen')) {penetrationTypes.push('piercingPen')}
	if (rightOrLeft.weapon.mods.hasOwnProperty('bluntPen')) {penetrationTypes.push('bluntPen')}
	let penetrationIndex = randomNumberRange(0, penetrationTypes.length - 1)
	let penType = penetrationTypes[penetrationIndex]
	if (rightOrLeft.weapon.type.bow) {
		return 'fire'
	}
	switch (penType) {
		case 'slashingPen':
			return 'swing'
		case 'piercingPen':
			return 'thrust'
		case 'bluntPen':
			return  'slam'
		default:
			console.log(`DEFAULT: UNDEFINED PENETRATION TYPE`)
			return undefined
	}
}
function calculatePenetrationType(enemy, rightOrLeft) {
	if (enemy.armor > 0) {return undefined}
	switch (rightOrLeft.penetrationVerb) {
		case 'swing':
			return 'slashing'
		case 'thrust':
			return 'piercing'
		case 'fire':
			return 'piercing'
		case 'slam':
			return  'blunt'
		default:
			console.log(`DEFAULT: UNDEFINED PENETRATION TYPE`)
			return undefined
	}
}
function calculateMagicDamageWithResist(damage, magicResist, playerPenetration) {
	let playerPen = !playerPenetration ? 0 : playerPenetration
	let enemyMagicResist = !magicResist ? 0 : magicResist - playerPen < 0 ? 0 : magicResist - playerPen
	console.log(playerPen, ' PLAYER PEN')
	console.log(enemyMagicResist, ' ENEMY MAGIC RESIST')
 	// let damageAfterResist = Math.ceil(damage * (1 - enemyMagicResist / (enemyMagicResist + 60)))
	let damageAfterResist = Math.ceil((damage - enemyMagicResist) * (1000 / (1000 + enemyMagicResist)) <= 0 ? 0 : (damage - enemyMagicResist) * (1000 / (1000 + enemyMagicResist)))
	console.log(damageAfterResist, ' DAMAGE AFTER RESIST')
	return damageAfterResist
}
function calculateMagicDamage(enemy, spell, numberOfEnemiesToSplit) {
	console.log(spell, 'SPELL')
	let element = spell.element
	let resistType
	let playerPen
	if (element == 'fire') {
		resistType = 'fireResist'
		playerPen = 'firePen'
	}
	if (element == 'water') {
		resistType = 'waterResist'
		playerPen = 'waterPen'

	}
	if (element == 'earth') {
		resistType = 'earthResist'
		playerPen = 'earthPen'

	}
	if (element == 'ice') {
		resistType = 'iceResist'
		playerPen = 'icePen'

	}
	if (element == 'wind') {
		resistType = 'windResist'
		playerPen = 'windPen'

	}
	if (element == 'lightning') {
		resistType = 'lightningResist'
		playerPen = 'lightningPen'

	}
	if (element == 'shadow') {
		resistType = 'shadowResist'
		playerPen = 'shadowPen'

	}
	if (element == 'poison') {
		resistType = 'poisonResist'
		playerPen = 'poisonPen'
	}
	let playerMagicPenetration = player[playerPen] ? player[playerPen] : 0
	let enemyMagicResist = enemy[resistType] ? enemy[resistType] : 0
	let totalEnemyResist = enemyMagicResist - playerMagicPenetration < 0 ? 0 : enemyMagicResist - playerMagicPenetration
	console.log(playerMagicPenetration, ' PLAYER MAGIC PENETRATION')
	console.log(enemyMagicResist, ' ENEMY MAGIC RESIST')
	console.log(totalEnemyResist, ' ENEMY MAGIC RESIST AFTER SUBRACTING PLAYER PENETRATION')
	let damageObject = {
		damageBeforeMagicResist: 0,
		damageAfterMagicResist: 0,
		damageResisted: 0,
		penetrationType: element,
	}
	damageObject.damageBeforeMagicResist = spell.damage(enemy)
	console.log(damageObject.damageBeforeMagicResist)
	if (numberOfEnemiesToSplit && numberOfEnemiesToSplit > 1) {
		damageObject.damageBeforeMagicResist /= numberOfEnemiesToSplit
	}
	console.log(damageObject.damageBeforeMagicResist)
	damageObject.damageAfterMagicResist = Math.ceil((damageObject.damageBeforeMagicResist - totalEnemyResist) * (1000 / (1000 + totalEnemyResist)) <= 0 ? 0 : (damageObject.damageBeforeMagicResist - totalEnemyResist) * (1000 / (1000 + totalEnemyResist)))
	damageObject.damageResisted = Math.ceil(damageObject.damageBeforeMagicResist - damageObject.damageAfterMagicResist)
	
	console.log(damageObject, 'MAGIC DAMAGE OBJECT')

	return damageObject
}



function calculateDamageWithBonusesAndAfterEnemyMitigation(enemy, rightOrLeft) {
	if (!rightOrLeft.doesSwingHit) {
		rightOrLeft.totalDamage = 0
		return
	}
	let damageBeforeMitigation = rightOrLeft.baseDamage + rightOrLeft.critDamage
	rightOrLeft.damagePreMitigation = damageBeforeMitigation
	if (enemy.armor > 0) {
		const damageAfterMitigation = damageBeforeMitigation * (1000 / (1000 + enemy.armor)) <= 0 ? 0 : Math.floor(damageBeforeMitigation * (1000 / (1000 + enemy.armor)))
		return damageAfterMitigation
	} else if (enemy.armor == 0) {
		let slashingPiercingOrBlunt = rightOrLeft.penetrationType == 'slashing' ? 'slashingPen' : rightOrLeft.penetrationType == 'piercing' ? 'piercingPen' : 'bluntPen'
		let enemyArmor = rightOrLeft.penetrationType == 'slashing' ? enemy.slashingArmor : rightOrLeft.penetrationType == 'piercing' ? enemy.piercingArmor : enemy.bluntArmor
		let armorAfterPen = enemyArmor - player[slashingPiercingOrBlunt] <= 0 ? 0 : enemyArmor - player[slashingPiercingOrBlunt]
		const damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
		quickMessage(`${damageBeforeMitigation} damage before mitigation`)
		quickMessage(`${damageAfterMitigation} damage after mitigation`)
		return Math.floor(damageAfterMitigation)
	}
}
function calculateAbilityDamageAgainstEnemyArmor(enemy, damage, penetrationType) {
	let abilityDamage = damage
	if (enemy.armor > 0) {
		const damageAfterMitigation = abilityDamage * (1000 / (1000 + enemy.armor)) <= 0 ? 0 : Math.floor(abilityDamage * (1000 / (1000 + enemy.armor)))
		return Math.ceil(damageAfterMitigation)
	} else if (enemy.armor == 0) {
		let enemyArmor = penetrationType == 'slashingPen' ? enemy.slashingArmor : penetrationType == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
		let armorAfterPen = enemyArmor - player[penetrationType] <= 0 ? 0 : enemyArmor - player[penetrationType]
		const damageAfterMitigation = (abilityDamage - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (abilityDamage - armorAfterPen) * (1000 / (1000 + armorAfterPen))
		return Math.ceil(damageAfterMitigation)
	}
}
function calculatePenetrationRoll() {
	let weapon1 = getWeapon1()
	let weapon2 = getWeapon2()
	let weaponUsed = weapon1 && weapon2 ? weapon1 : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	let penetrationTypes = []
	if (weaponUsed.mods.hasOwnProperty('slashingPen')) {penetrationTypes.push('slashingPen')}
	if (weaponUsed.mods.hasOwnProperty('piercingPen')) {penetrationTypes.push('piercingPen')}
	if (weaponUsed.mods.hasOwnProperty('bluntPen')) {penetrationTypes.push('bluntPen')}
	let penetrationIndex = randomNumberRange(0, penetrationTypes.length - 1)
	let penType = penetrationTypes[penetrationIndex]
	return penType
}


function calculateBonusDamage(enemy) {
	let stealthBonus = 0
	let bleedBonus = 0
	if (player.isStealthed) {
		stealthBonus = player.stealth.damageBonus()
	}
	// if (enemy.debuff) {
	// 	if (enemy.debuff.bleed) {
	// 		bleedBonus = enemy.debuff.bleed.damageBonus()
	// 	}
	// }
	let totalBonus = stealthBonus + bleedBonus
	return totalBonus
}

function calculateBlockedDamage (rightOrLeft) {
	return rightOrLeft.baseDamage - rightOrLeft.totalDamage
}
function atIntoOnto(rightOrLeft) {
	if (!rightOrLeft.doesSwingHit || rightOrLeft.weapon.type.bow) {
		return 'at the'
	}
	if (rightOrLeft.penetrationVerb == 'swing') {
		return 'at the'
	} else if (rightOrLeft.penetrationVerb == 'thrust') {
		return 'into the'
	} else if (rightOrLeft.penetrationVerb == 'slam') {
		return 'into the'
	} 
}

function applyDamageToEnemy(enemy, damage) {
	if (enemy.health > 0 && player.health > 0 && damage) {
		enemy.health = enemy.health - damage
		if (enemy.health <= 0) {
			// grantBonusOnEnemyDeath(ability)
			enemy.death(enemy)
		}
	}
	updateMonsterBox()
}

function weaponSkillMaxLevel(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 10}
	if (player.level < 20) {return 20}
	if (player.level < 30) {return 30}
	if (player.level < 40) {return 40}
}

function skillMaxLevel5(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 5}
	if (player.level < 20) {return 10}
	if (player.level < 30) {return 15}
	if (player.level < 40) {return 20}
}

function skillMaxLevel4(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 4}
	if (player.level < 20) {return 8}
	if (player.level < 30) {return 12}
	if (player.level < 40) {return 16}
	if (player.level < 50) {return 20}
}
function skillMaxLevel3(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 3}
	if (player.level < 20) {return 6}
	if (player.level < 30) {return 9}
	if (player.level < 40) {return 12}
	if (player.level < 50) {return 15}
}
function skillMaxLevel2(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 2}
	if (player.level < 20) {return 4}
	if (player.level < 30) {return 6}
	if (player.level < 40) {return 8}
	if (player.level < 50) {return 10}
}
function skillMaxLevel1(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 1}
	if (player.level < 20) {return 2}
	if (player.level < 30) {return 3}
	if (player.level < 40) {return 4}
	if (player.level < 50) {return 5}
}
function skillCleaveMaxLevel(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 1}
	if (player.level < 20) {return 2}
	if (player.level < 30) {return 3}
}
function skillExtraStrikeMaxLevel(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level >= 20 && player.level < 30) {return 1}
	if (player.level >= 30) {return 2}
}


function calculatePlayerAccuracy() {
	return player.currentWeaponSkill.accuracy + player.level + 75
}
function calculateEnemyDodgeChance(enemy) {
	return enemyDodgeChance = enemy.dodge + enemy.level
}


function updateRoomEnemies(enemy) {
	pushMonster.forEach((pushedEnemy, index) => {
		if (coordinatesMatch(pushedEnemy, player)) {
			if (roomEnemies.indexOf(pushedEnemy) == -1) {
				roomEnemies.push(pushedEnemy);
			}
		}
		if (!coordinatesMatch(pushedEnemy, player)) {
			// Check if the enemy is already in the roomEnemies array
			const index = roomEnemies.indexOf(pushedEnemy);
			if (index !== -1) {
				// Remove the enemy from the array if it exists
				roomEnemies.splice(index, 1);
			}
		}	
	});
}

function getAllEnemiesInCombat() {
	return roomEnemies.filter(enemy => coordinatesMatch(enemy, player) && enemy.combat)
}
// function getAllEnemiesInRoom() {
// 	let allEnemies = pushMonster.filter(enemy => coordinatesMatch(enemy, player))
// 	allEnemies.reverse()
// 	return allEnemies
// }

function getAllEnemiesInRoom() {
	// Filter enemies in the room
	let allEnemies = roomEnemies
	return allEnemies
}

function getAllEnemiesInNextRoom(area) {
	//this is for looking in a direction
	let allEnemies = pushMonster.filter(enemy => enemy.x == area.x && enemy.y == area.y && enemy.z == area.z)
	return allEnemies
}

function getAllNpcsInRoom() {
	return currentArea.npc
}

function findEnemyInCombatByNumber(secondCommand) {
	let enemyByNumber = getAllEnemiesInCombat()
	return enemyByNumber[secondCommand - 1]
}


function findEnemyInCombatByName(secondCommand) {
	const enemyByName = getAllEnemiesInCombat().find(({ keywords }) => keywords.some(x => x == secondCommand))
	return enemyByName
}

function targetCombatEnemy(secondCommand, thirdCommand) {
	let allEnemiesInCombatArray = getAllEnemiesInCombat()
	let enemyByFirst = allEnemiesInCombatArray[0]
	let enemyByName = findEnemyInCombatByName(secondCommand)
	let enemyByNumber = findEnemyInCombatByNumber(secondCommand)
	//attack 3 goblin
	//attack goblin 3
	if (typeof(secondCommand) == 'object') {
		return secondCommand
	}
	if ((secondCommand && thirdCommand) && (!isNaN(secondCommand) || !isNaN(thirdCommand)) && enemyByName != undefined) {
		let allEnemiesWithSameName = getAllEnemiesInCombat().filter(({ keywords }) => keywords.some(x => x == secondCommand))
		let chosenNumber = !isNaN(secondCommand) ? secondCommand : !isNaN(thirdCommand) ? thirdCommand : undefined
		let chosenEnemy = allEnemiesWithSameName[chosenNumber - 1]
		if (chosenEnemy != undefined) {
			return chosenEnemy
		} else {
			return enemyByFirst
		}
	}
	if (secondCommand == undefined) { return enemyByFirst }
	if (secondCommand != undefined && enemyByName == undefined && enemyByNumber == undefined) { return enemyByFirst}
	if (!isNaN(secondCommand) && enemyByNumber != undefined) { //Finds enemy by number. Returns first enemy in the room if enemy by number is undefined
		return enemyByNumber
	}
	if (enemyByName == undefined) {
		return enemyByFirst
	} else if (enemyByName != undefined) {
		return enemyByName
	}
	return enemyByFirst

}
//MELEE TARGETING
//TARGET ENEMIES NOT IN COMBAT
function targetFirstEnemy(secondCommand, thirdCommand) {
	//if player is ranged, target based on that
	let allEnemiesInRoom = getAllEnemiesInRoom()
	if (!secondCommand) {
		return allEnemiesInRoom[0]
	}
	
}
function targetAnyEnemy(secondCommand, thirdCommand) {
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let allCombatEnemiesInRoom = getAllEnemiesInCombat()
	let enemyByFirst = rangeCheck() ? allEnemiesInRoom[0] : allCombatEnemiesInRoom[0]
	let enemyByName = getAnyEnemyByName(secondCommand)
	let enemyByNumber = getAnyEnemyByNumber(secondCommand)
	if ((secondCommand && thirdCommand) && (!isNaN(secondCommand) || !isNaN(thirdCommand)) && enemyByName != undefined) {
		let allEnemiesWithSameName = getAllEnemiesInRoom().filter(({ keywords }) => keywords.some(x => x == secondCommand))
		let chosenNumber = !isNaN(secondCommand) ? secondCommand : !isNaN(thirdCommand) ? thirdCommand : undefined
		let chosenEnemy = allEnemiesWithSameName[chosenNumber - 1]
		if (chosenEnemy != undefined) {
			return chosenEnemy
		} else {
			return enemyByFirst
		}
	}
	if (secondCommand == undefined) { 
		return enemyByFirst 
	}
	if (secondCommand != undefined && enemyByName == undefined && enemyByNumber == undefined) { 
		return enemyByFirst
	}
	if (!isNaN(secondCommand) && enemyByNumber != undefined && enemyByNumber.combat == true) { //Finds enemy by number. Returns first enemy in the room if enemy by number is undefined
		return enemyByNumber
	}
	if (enemyByName == undefined) {
		return enemyByFirst
	} else if (enemyByName != undefined) {
		return enemyByName
	}
	return enemyByFirst

}

function getAnyEnemyByName(secondCommand) {
	const enemyByName = getAllEnemiesInRoom().find(({ keywords }) => keywords.some(x => x == secondCommand))
	return enemyByName
}
function getAnyEnemyByNumber(secondCommand) {
	let enemyByNumber = getAllEnemiesInRoom()
	return enemyByNumber[secondCommand - 1]
}
function getAnyEnemyByFirst() {
	const allMonstersInRoom = getAllEnemiesInRoom()
	const firstMonster = allMonstersInRoom[0]
	return firstMonster
}

function getWeapon1() {
	let weapon1 = pushItem.find(item => item.roomId == 'right hand') //take out from && on if problems occur
	if (weapon1) {
		return weapon1
	} else {
		return player.rightFist
	}
}

function getWeapon2() {
	let weapon2 = pushItem.find(item => item.roomId == 'left hand') //take out from && on if problems occur
	if (weapon2 != undefined) {
		return weapon2
	} else {
		return player.leftFist
	}
}
//might not need to ever use this function
function weaponAndArmorModsCombiner() {
	const allMods = []
	let allEquippedArmor = pushItem.filter(item => isNaN(item.roomId) && item.roomId != backpack)
	allEquippedArmor.forEach(({ mods }) => {
		if (mods != undefined) {
			allMods.push(mods)
		}
	})
	const mergeMods = allMods.reduce((modObj, mod) => {
		for (const [modName, modValue] of Object.entries(mod)) {
			if (!modObj[modName]) {
				modObj[modName] = 0
			}
			modObj[modName] += modValue
		}
		return modObj
	}, {})
	return mergeMods
}
let penetrationArray = []



// function damageCalculator(playerWeapon, targetedMonster, wasPlayerStealthed) {
// 	if (targetedMonster != undefined) {
// 		let monsterLevel = targetedMonster.level
// 		let monsterArmor = targetedMonster.armor
// 		let playerLevel = player.level
// 		let playerWeaponSkill = player.currentWeaponSkill
// 		let penNames = []
// 		let penTypes = []
// 		let ifNoPenTypes = []
// 		let enemyPenTypes = []
// 		let penRoll = []
// 		let ifNoPenRoll = []
// 		let enemyPenRoll = []
// 		let weaponSlashingPen = playerWeapon.mods.slashingPen
// 		let weaponPiercingPen = playerWeapon.mods.piercingPen
// 		let weaponBluntPen = playerWeapon.mods.bluntPen
// 		let attackPower = function () {
// 			let attackPower = 0
// 			if (playerWeapon.skillUsed == 'oneHanded') {
// 				attackPower = player.oneHanded.attackPower
// 			} else if (playerWeapon.skillUsed == 'twoHanded') {
// 				attackPower =  player.twoHanded.attackPower
// 			} else if (playerWeapon.skillUsed == 'unarmed') {
// 				attackPower =  player.unarmed.attackPower
// 			} else if (playerWeapon.skillUsed == 'daggers') {
// 				attackPower =  player.daggers.attackPower
// 			} else if (playerWeapon.skillUsed == 'bows') {
// 				attackPower =  player.bows.attackPower
// 			}
// 			// if (wasPlayerStealthed) {
// 			// 	attackPower += player.stealth.bonusDamage()
// 			// }
// 			return attackPower
// 		}

// 		//need to change this targetedMonster to match the actual attack target in the attack function

// 		let isPenetration
// 		function findPenetration() {
// 			if (targetedMonster.armor == 0) {
// 				isPenetration = true
// 				if (weaponSlashingPen != 0) {
// 					penTypes.push(weaponSlashingPen)
// 					penNames.push('slashing ')
// 					enemyPenTypes.push(targetedMonster.slashingArmor)
// 				}
// 				if (weaponPiercingPen != 0) {
// 					penTypes.push(weaponPiercingPen)
// 					penNames.push('piercing ')
// 					enemyPenTypes.push(targetedMonster.piercingArmor)
// 				}
// 				if (weaponBluntPen != 0) {
// 					penTypes.push(weaponBluntPen)
// 					penNames.push('blunt ')
// 					enemyPenTypes.push(targetedMonster.bluntArmor)
// 				}
// 			}
// 		}
// 		function ifNoPenetration() {
// 			if (targetedMonster.armor != 0) {
// 				isPenetration = false
// 				if (weaponSlashingPen != 0) {
// 					ifNoPenTypes.push(weaponSlashingPen)
// 					penNames.push('slashing ')
// 				}
// 				if (weaponPiercingPen != 0) {
// 					ifNoPenTypes.push(weaponPiercingPen)
// 					penNames.push('piercing ')
// 				}
// 				if (weaponBluntPen != 0) {
// 					ifNoPenTypes.push(weaponBluntPen)
// 					penNames.push('blunt ')
// 				}
// 				console.log(ifNoPenTypes, ' IF NO PEN TYPES')
// 			}
// 		}
// 		ifNoPenetration()
// 		findPenetration()
// 		let arrayNumber = () => Math.floor(Math.random() * penTypes.length)
// 		let arrayNumberNoPenTypes = () => Math.floor(Math.random() * ifNoPenTypes.length)
// 		let rolled = arrayNumber()
// 		let noPenRolled = arrayNumberNoPenTypes()
// 		penRoll = penTypes[rolled]
// 		ifNoPenRoll = ifNoPenTypes[noPenRolled]
// 		if (isPenetration == true) {
// 			penetrationArray.push(penNames[rolled])
// 		} else if (isPenetration == false) {
// 			penetrationArray.push(penNames[noPenRolled])
// 		}
// 		console.log(penNames, ' PEN NAMES ------------------------------------------')
// 		function penRolled() {
// 			if (penRoll != undefined) {
// 				console.log('PENROLL IS DEFINED - PENETRATION SHOULD HAPPEN')
// 				if (penRoll == weaponSlashingPen) {
// 					playerPenetrationName = 'slashing '
// 				} else if (penRoll == weaponPiercingPen) {
// 					playerPenetrationName = 'piercing '
// 				} else if (penRoll == weaponBluntPen) {
// 					playerPenetrationName = 'blunt '
// 				} else {
// 					playerPenetrationName = 'unarmed ' //only for unarmed so that atIntoOnto will return 'into the '
// 				}
// 			} else if (ifNoPenRoll != undefined) {
// 				console.log('PENROLL IS NOT DEFINED - NO PENETRATION SHOULD BE CALCULATED')
// 				if (ifNoPenRoll == weaponSlashingPen) {
// 					playerPenetrationName = 'slashing '
// 				} else if (ifNoPenRoll == weaponPiercingPen) {
// 					playerPenetrationName = 'piercing '
// 				} else if (ifNoPenRoll == weaponBluntPen) {
// 					playerPenetrationName = 'blunt '
// 				} else {
// 					playerPenetrationName = 'unarmed ' //only for unarmed so that atIntoOnto will return 'into the '
// 				}
// 			}
// 		}
// 		penRolled()
// 		enemyPenRoll = enemyPenTypes[rolled]
// 		let hitRoll = Math.floor(Math.random() * 100) + 1
// 		let hitChance = playerAbilityHitChance(targetedMonster)
// 		function additionalBonusDamage() {
// 			let stealthDamage = player.isStealthed == true ? player.stealth.level * 5 : 0
// 			let total = stealthDamage
// 			return total
// 		}
// 		let bonusDamage = additionalBonusDamage()
// 		console.log(hitChance, ' PLAYER HIT CHANCE ------------------------------------------------')
// 		console.log(player[playerWeaponSkill], ' PLAYER WEAPON SKILL --------------------')
// 		//MONSTER HAS FLAT ARMOR
// 		if (hitChance == true && targetedMonster.armor != 0) {
// 			if (targetedMonster != undefined && playerWeapon != undefined) {
// 				if (monsterArmor == 1) {
// 					monsterArmor = 0
// 				}
// 				let botDamage = attackPower() * (playerWeaponSkill.botMultiplier * playerWeapon.botDamage)
// 				let topDamage = attackPower() * (playerWeaponSkill.topMultiplier * playerWeapon.topDamage)
// 				console.log(botDamage, 'BOT DAMAGE')
// 				console.log(topDamage, 'TOP DAMAGE')
// 				botDamage = botDamage >= 0 ? botDamage : 0
// 				topDamage = topDamage >= 0 ? topDamage : 0
// 				let rawDamage = randomNumberRange(botDamage, topDamage) + bonusDamage
// 				let squaredTweak = isNaN(Math.sqrt(monsterLevel - playerLevel)) ? 0 : Math.sqrt(monsterLevel - playerLevel)
// 				let finalDamage = rawDamage * (100 / (100 + monsterArmor)) - squaredTweak <= 0 ? 0 : Math.floor(rawDamage * (100 / (100 + monsterArmor)) - squaredTweak)
// 				blockedDamage = Math.floor(rawDamage - finalDamage)
// 				console.log(botDamage, ' bot damage')
// 				console.log(topDamage, ' top damage')
// 				console.log(rawDamage, ' raw damage')
// 				console.log(squaredTweak, ' squared tweak')
// 				console.log(finalDamage, ' final damage')
// 				return finalDamage
// 			}
// 			//MONSTER HAS PENETRATION ARMOR TYPES
// 		} else if (hitChance == true && penTypes[0] != undefined) {
// 			console.log(hitChance, 'HITCHANCE')
// 			console.log(hitRoll, 'HITROLL')
// 			if (targetedMonster != undefined && playerWeapon != undefined) {
// 				let enemyArmorType
// 				;(() => {
// 					if (playerPenetrationName == 'slashing ') {
// 						enemyArmorType = 'slashingArmor'
// 					}
// 					if (playerPenetrationName == 'piercing ') {
// 						enemyArmorType = 'piercingArmor'
// 					}
// 					if (playerPenetrationName == 'blunt ') {
// 						enemyArmorType = 'bluntArmor'
// 					}
// 				})()
// 				let botDamage = attackPower() * playerWeaponSkill.botMultiplier * playerWeapon.botDamage
// 				let topDamage = attackPower() * playerWeaponSkill.topMultiplier * playerWeapon.topDamage

// 				botDamage = botDamage >= 0 ? botDamage : 0
// 				topDamage = topDamage >= 0 ? topDamage : 0

// 				let rawDamage = randomNumberRange(botDamage, topDamage) + bonusDamage				
// 				let squaredTweak = isNaN(Math.sqrt(monsterLevel - playerLevel)) ? 0 : Math.sqrt(monsterLevel - playerLevel)
// 				let finalDamage = rawDamage * (100 / (100 + monsterArmor)) - squaredTweak <= 0 ? 0 : Math.floor(rawDamage * (100 / (100 + monsterArmor)) - squaredTweak)
// 				blockedDamage = rawDamage - damageAfterArmor
// 				console.log(botDamage, ' bot damage')
// 				console.log(topDamage, ' top damage')
// 				console.log(rawDamage, ' raw damage')
// 				console.log(squaredTweak, ' squared tweak')
// 				console.log(finalDamage, ' final damage')
// 				return finalDamage
// 			}
// 		} else if (hitChance == false) {
// 			console.log(hitChance, 'HITCHANCE')
// 			console.log(hitRoll, 'HITROLL')
// 			return 'miss'
// 		} else {
// 			console.log('UNDEFINED')
// 			return undefined
// 		}
// 	}
// }

function slashingCalculation(weaponSlashing, enemySlashingArmor) {
	if (playerWeapon.slashingPen != 0 && targetedMonster.slashingArmor != 0) {
		slashing = true
	}
}
function piercingCalculation(enemyPiercingArmor) {
	if (playerWeapon.piercingPen != 0 && targetedMonster.piercingArmor != 0) {
		piercing = true
	}
}
function bluntCalculation(enemyBluntArmor) {
	if (playerWeapon.bluntPen != 0 && targetedMonster.bluntArmor != 0) {
		blunt = true
	}
}

//races
//Human
//Elf
//Half-Elf
//Halfling
//Dwarf
//Half-Giant
function goldUpgradeCostLow(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 25}
	if (skillSpellAbility.level <= 10) {return 50}
	if (skillSpellAbility.level <= 15) {return 100}
	if (skillSpellAbility.level >= 16) {return 150}
}
function skillUpgradeCostLow(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 2}
	if (skillSpellAbility.level <= 10) {return 5}
	if (skillSpellAbility.level <= 15) {return 8}
	if (skillSpellAbility.level >= 16) {return 12}
}

function goldUpgradeCost1(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 50}
	if (skillSpellAbility.level <= 10) {return 100}
	if (skillSpellAbility.level <= 15) {return 150}
	if (skillSpellAbility.level >= 16) {return 200}
}
function skillUpgradeCost1(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 5}
	if (skillSpellAbility.level <= 10) {return 10}
	if (skillSpellAbility.level <= 15) {return 15}
	if (skillSpellAbility.level >= 16) {return 20}
}

function goldUpgradeCost2(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 100}
	if (skillSpellAbility.level <= 10) {return 200}
	if (skillSpellAbility.level <= 15) {return 300}
	if (skillSpellAbility.level >= 16) {return 500}
}
function skillUpgradeCost2(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 10}
	if (skillSpellAbility.level <= 10) {return 20}
	if (skillSpellAbility.level <= 15) {return 30}
	if (skillSpellAbility.level >= 16) {return 40}
}


function abilityGoldUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level <= 3) {return 125}
	if (skillSpellAbility.level <= 5) {return 250}
	if (skillSpellAbility.level <= 7) {return 375}
	if (skillSpellAbility.level >= 8) {return 500}
}
function abilityUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level <= 3) {return 20}
	if (skillSpellAbility.level <= 5) {return 30}
	if (skillSpellAbility.level <= 7) {return 40}
	if (skillSpellAbility.level >= 8) {return 50}
}

function spellGoldUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level == 0) {return 50}
	if (skillSpellAbility.level == 1) {return 100}
	if (skillSpellAbility.level == 2) {return 200}
	if (skillSpellAbility.level == 3) {return 300}
	if (skillSpellAbility.level == 4) {return 400}
	if (skillSpellAbility.level == 5) {return 650}
	if (skillSpellAbility.level == 6) {return 900}
	if (skillSpellAbility.level == 7) {return 1250}
	if (skillSpellAbility.level == 8) {return 1500}
	if (skillSpellAbility.level >= 9) {return 2000}
}
function spellUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level < 10) {return 10 * skillSpellAbility.level}
}



function enemyKillExperience(enemy) {
	let baseExperience = enemy.health / 2
	if (enemy.level - player.level == -1) {baseExperience *= 0.9}
	if (enemy.level - player.level == -2) {baseExperience *= 0.8}
	if (enemy.level - player.level == -3) {baseExperience *= 0.7}
	if (enemy.level - player.level == -4) {baseExperience *= 0.6}
	if (enemy.level - player.level == -5) {baseExperience *= 0.5}
	if (enemy.level - player.level == -6) {baseExperience *= 0.4}
	if (enemy.level - player.level == -7) {baseExperience *= 0.3}
	if (enemy.level - player.level == -8) {baseExperience *= 0.2}
	if (enemy.level - player.level <= -9) {baseExperience *= 0.1}
	return Math.floor(baseExperience)
}

function levelUp() {
	updatePlayerStats()
}

function playerLevelFunc() {
	updatePlayerStats()
	let playerCurrentLevel = player.level
	const levelThresholds = player.experienceNeededToLevel
	for (let level = 1; level <= levelThresholds.length; level++) {
		if (player.experience < levelThresholds[level]) {
			player.level = level;
			// player.experienceNeededToLevel = level === 1 ? 10 : levelThresholds[level - 1] - levelThresholds[level - 2];
			break;
		}
	}
	// if (player.level == 10) {
	// 	warriorsGuildGroundLevelInterior222222.npc.push(velthash)
	// 	mageGuild_Room2.npc.push(olivandra)
	// 	monksGuildRoom1.npc.push(sitoria)
	// 	rangersGuildRoom1.npc.push(tilwin)
	// 	sinistralsGuild_Room2.npc.push(zel)
	// }
	if (playerCurrentLevel != player.level) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	let line4 = document.createElement('div')
	let attributePointsIncrease = 1
	let skillPointsIncrease = player.level * 4 > 20 ? 20 : player.level * 4
	blankSpace()
	customizeEachWord(`You are now level `, 'white', line1)
	customizeEachWord(`${player.level}`, 'green', line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`You have gained `, 'white', line2)
	customizeEachWord(`${attributePointsIncrease} `, 'green', line2)
	customizeEachWord(`attribute `, 'light-blue', line2)
	customizeEachWord(`point(s)!`, 'white', line2)
	customizeEachWord(`You have gained `, 'white', line4)
	customizeEachWord(`${skillPointsIncrease} `, 'green', line4)
	customizeEachWord(`skill `, 'light-blue', line4)
	customizeEachWord(`point(s)!`, 'white', line4)
	blankSpace()
	abilityLearnedOnLevelUp()
	player.attributePoints += attributePointsIncrease
	player.skillPoints += skillPointsIncrease
	updatePlayerStats()
	}
}

function abilityLearnedOnLevelUp() {
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	if (player.playerClass.name == 'Berserker') {
		if (player.level == 3) {
			player.ripslash.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Ripslash`, player.ripslash.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.cyclone.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Cyclone`, player.cyclone.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.cataclysm.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Cataclysm`, player.ripslash.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Fighter') {
		if (player.level == 3) {
			player.dualStrike.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Dual Strike`, player.dualStrike.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.bladeBlitz.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Blade Blitz`, player.bladeBlitz.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.shred.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shred`, player.shred.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Knight') {
		if (player.level == 3) {
			player.valorStrike.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Valor Strike`, player.valorStrike.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.shieldSlam.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shield Slam`, player.shieldSlam.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.boomingMight.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Booming Might`, player.boomingMight.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Assassin') {
		if (player.level == 3) {
			player.ambush.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Ambush`, player.ambush.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.backstab.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Backstab`, player.backstab.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.guillotine.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Guillotine`, player.guillotine.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Thief') {
		if (player.level == 3) {
			player.venomBlade.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Venom Blade`, player.venomBlade.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.contagion.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Contagion`, player.contagion.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.bane.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Bane`, player.bane.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Shadowblade') {
		if (player.level == 3) {
			player.shadowDaggers.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shadow Daggers`, player.shadowDaggers.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.shadowsurge.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shadowsurge`, player.shadowsurge.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.shadowVenom.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shadow Venom`, player.shadowVenom.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Martial Monk') {
		if (player.level == 3) {
			player.catalyst.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Catalyst`, player.catalyst.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.tempest.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Tempest`, player.tempest.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		// if (player.level == 5) {
		// 	player.guillotine.level = 1
		// 	customizeEachWord(`You have learned the ability `, 'white', line1)
		// 	customizeEachWord(`Guillotine`, player.guillotine.color, line1)
		// 	customizeEachWord(`!`, 'white', line1)
		// }
	}
	if (player.playerClass.name == 'Mystic Monk') {
		if (player.level == 3) {
			player.fireSeal.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Fire Seal`, player.fireSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.waterSeal.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Water Seal`, player.waterSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.earthSeal.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Earth Seal`, player.earthSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Elemental Monk') {
		if (player.level == 3) {
			player.blazingFist.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Flaming Palm Strike`, player.blazingFist.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.tidalFist.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Tidal Fist`, player.tidalFist.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.quakeFist.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Quake Fist`, player.quakeFist.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Ranger') {
		if (player.level == 3) {
			player.piercingArrow.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Piercing Arrow`, player.piercingArrow.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.rapidFireShot.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Rapid Fire Shot`, player.rapidFireShot.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.hydraArrow.level = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Hydra Arrow`, player.hydraArrow.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Pyromancer') {
		if (player.level == 5) {
			player.inferno.level = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Inferno`, player.inferno.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 6) {
			player.meteor.level = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Meteor`, player.meteor.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Cryo Mage') {
		if (player.level == 5) {
			player.blizzard.level = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Blizzard`, player.blizzard.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 6) {
			player.cryoclast.level = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Cryoclast`, player.cryoclast.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Lightning Magus') {
		if (player.level == 5) {
			player.chainLightning.level = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Chain Lightning`, player.chainLightning.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 6) {
			player.gigavolt.level = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Gigavolt`, player.gigavolt.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
}


let player = {
	//stats
	isAlive: true,
	level: 1,
	str: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	mys: 0,
	con: 0,
	mods: {
		str: 0,
		dex: 0,
		agi: 0,
		int: 0,
		wis: 0,
		mys: 0,
		con: 0,
		attackPower: 0,
		spellPower: 0,
		mysticPower: 0,
		weaponSpeed: 0,
		maxHealth: 0,
		maxMana: 0,
		armor: 0,
		dodge: 0,
		accuracy: 0,
		slashingPen: 0,
		piercingPen: 0,
		bluntPen: 0,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		shieldBlock: 0,
		weight: 0,
		criticalHit: 0,
		fireDamage: 0,
		water: 0,
		earth: 0,
		lightning: 0,
		wind: 0,
		ice: 0,
		firePen: 0,
		waterPen: 0,
		earthPen: 0,
		icePen: 0,
		windPen: 0,
		lightningPen: 0,
		shadowPen: 0,
		poisonPen: 0,
	},
	buffs: {

	},
	magicResist: {
		fire: 0,
		ice: 0,
		lightning: 0,
		wind: 0,
		water: 0,
	},
	sealCounter: {

	},
	isAbilityQueued: false,
	adrenaline: 50,
	maxAdrenaline: 50,
	startingHealth: 0,
	health: 0,
	maxHealth: 0,
	magicShield: 0,
	spellPower: 0,
	mysticPower: 0,
	healthMultiplier: 0,
	manaMultiplier: 0,
	healthMultiplier: 0,
	raceHealthMultiplier: 0,
	manaMultiplier: 0,
	fireProficiency: 1.0,
	iceProficiency: 1.0,
	lightningProficiency: 1.0,
	arcaneKnowledge: 0,
	mana: 0,
	maxMana: 0,
	manaMultiplier: 1.0,
	accuracy: 0,
	unarmedAttackPower: 0,
	oneHandedAttackPower: 0,
	twoHandedAttackPower: 0,
	daggerAttackPower: 0,
	armor: 0,
	slashingArmor: 0,
	piercingArmor: 0,
	bluntArmor: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 2,
	firePen: 0,
	waterPen: 0,
	earthPen: 0,
	icePen: 0,
	windPen: 0,
	lightningPen: 0,
	shadowPen: 0,
	poisonPen: 0,
	weight: 0,
	dodge: 0,
	crit: 0,
	currentWeaponRight: function() {
		//returns player.rightFist because rightFist does not exist in the pushItem array
		if (player.rightHand == 'empty') {
			return player.rightFist
		} else {
			return pushItem.find(item => item.roomId == 'right hand')
		}
	},
	currentWeaponLeft: function() {
		//Can only throw left punch if trained in unarmed
		if (player.leftHand == 'empty') {
			return player.leftFist
		}
		return pushItem.find(item => item.roomId == 'left hand')
	},
	//character information
	playerClass: {},
	race: '',
	experience: 0,
	experienceNeededToLevel: [
	0, 15, 45, 100, 190, 330, 522, 797, 1115, 1474, 1889, 2382, 2983, 3732, 4641, 5718, 6962, 8463,
	10295, 12335, 14861, 17763, 
	],
	attributePoints: 0,
	skillPoints: 0,
	//location and state information
	//class specific properties
	sinisterMarks: 0,
	sinisterMarksMax: 5,
	might: 5,
	maxMight: 5,
	focus: 20,
	maxFocus: 20,
	//class specific properties
	roomId: 1,
	id: 0,
	x: 0,
	y: 0,
	z: -2,
	s: '',
	special: '',
	name: 'Zalbane',
	mount: false,
	currentWeaponSkill: [],
	combat: [],
	stasis: [],
	stasis2: {
		inStasis: function () {
			let anyStasis = this.stasis2
			if (anyStasis.advancing == true || anyStasis.retreating == true || anyStasis.swing == true || anyStasis.casting == true || anyStasis.channeling == true || anyStasis.dialogue == true) {
				return true
			} else {
				return false
			}
		},
		advancing: false,
		retreating: false,
		swing: false,
		casting: false,
		channeling: false,
		dialogue: false,
	},
	swingTimer: 0,
	channelTimer: 0,
	conjureTimer: 0,
	abilityTimer: 0,
	advanceTimer: 2,
	retreatTimer: 2,
	warriorAbilityQueue: false,
	//stasis - combat, dialogue, advancing stasis, spell cast
	stance: 'normal',
	//inventory and equipment
	gold: 0,
	backpack: [],
	rightHand: empty,
	leftHand: empty,
	leftHandRing: empty,
	rightHandRing: empty,
	head: empty,
	necklace: empty,
	shoulders: empty,
	chest: empty,
	back: empty,
	// arms: empty,
	hands: empty,
	waist: empty,
	legs: empty,
	feet: empty,
	killList: {},
	buildUpThenRelease: [],
	hidden: false,
	isStealthed: false,
	spellsConjuredMax: 2,
	spellsConjured: 0,
	conjuredSpells: [], //this is replaced by spellsConjured - delete when magic functions are fixed
	spellsConjured: [],
	chargeEffect: false,
	spells: [],
	skills: {},
	currentRightHandWeapon: () => (pushItem.find(item => item.roomId == 'right hand') == undefined ? player.rightFist : pushItem.find(item => item.roomId == 'right hand')),
	currentLeftHandWeapon: () => (pushItem.find(item => item.roomId == 'left hand') == undefined ? player.leftFist : pushItem.find(item => item.roomId == 'left hand')),
	rightFist: {
		//change object name to rightHand
		id: 'fist1',
		roomId: 'right hand',
		name: 'Right Fist',
		picture: "images/weapons/fist weapons/empty hand right.png",
		refName: 'rightFist',
		keywords: ['right fist'],
		color: 'green',
		skillUsed: 'unarmed',
		level: 0,
		botDamage: 1,
		topDamage: 3,
		speed: 3,
		accuracy: 4,
		mods: {
			str: 0,
			dex: 0,
			agi: 0,
			bluntPen: 0,
		},
		type: {
			weapon: true,
			unarmed: true,
		},
		enchantment: [],
		desc: () => {
			quickMessage('You have a fairly soft right hand', 'descriptions')
		},
		swing: (enemy, weapon) => unarmedSwing1(enemy, weapon),
		miss: (enemy, weapon) => unarmedSwing1(enemy, weapon),
	},
	leftFist: {
		//change object name to leftHand
		id: 'fist2',
		roomId: 'left hand',
		name: 'Left Fist',
		picture: "images/weapons/fist weapons/empty hand left.png",
		refName: 'leftFist',
		keywords: ['left fist'],
		color: 'green',
		skillUsed: 'unarmed',
		level: 0,
		botDamage: 1,
		topDamage: 3,
		speed: 3,
		accuracy: 4,
		mods: {
			str: 0,
			dex: 0,
			agi: 0,
			bluntPen: 0,
		},
		type: {
			weapon: true,
			unarmed: true,
		},
		enchantment: [],
		desc: () => {
			quickMessage('You have a fairly soft right hand', 'descriptions')
		},
		swing: (enemy, weapon) => unarmedSwing1(enemy, weapon),
		miss: (enemy, weapon) => unarmedSwing1(enemy, weapon),
	},
}

//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////
//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////
//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////
//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////

const perception = {
	level: 0,
	name: 'Perception',
	refName: 'perception',
	type: 'skill',
	color: 'skill',
	check: function(obstacle) {
		let playerLevel = player.level
		let playerPerception = player.perception.effectiveness()
		let playerTotalPerception = playerLevel + playerPerception
		return playerTotalPerception >= obstacle
	},
	effectiveness: function() {
		return this.level
	},
	goldToUpgrade: function () {
		return goldUpgradeCostLow(player.perception)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCostLow(player.perception)
	},
}
player.perception = {...perception}

const rest = {
	level: 1,
	name: 'Rest',
	type: 'skill',
	refName: 'rest',
	color: 'skill',
	restTimer: 10000,
	description: 'The rest ability allows you to recover health and mana. The higher the level, the more health and mana you recover. Raising the constitution and wisdom attribute will also increase the amount of health and mana you recover while resting. You can use the rest ability by using the REST command',
	healthBonus: 0,
	manaBonus: 0,
	maxLevel: 20,
	healthPerTick: function() {
		return ((player.level + 3) * player.rest.level) + player.rest.healthBonus
	},
	manaPerTick: function() {
		return ((player.level + 3) * player.rest.level) + player.rest.manaBonus

	},
	goldToUpgrade: function () {
		return goldUpgradeCostLow(player.rest)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCostLow(player.rest)
	},
}
player.rest = { ...rest }

const slashingExpertise = {
	level: 0,
	name: 'Slashing Weapons Expertise',
	refName: 'slashingExpertise',
	type: 'skill',
	color: `green`,
	maxLevel: 20,
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}	
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.slashingExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.slashingExpertise)
	},
}
player.slashingExpertise = {...slashingExpertise}

const piercingExpertise = {
	level: 0,
	name: 'Piercing Weapons Expertise',
	refName: 'piercingExpertise',
	type: 'skill',
	color: `green`,
	maxLevel: 20,
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}	
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.piercingExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.piercingExpertise)
	},
}
player.piercingExpertise = {...piercingExpertise}

const bluntExpertise = {	
	level: 0,
	name: 'Blunt Weapons Expertise',
	refName: 'bluntExpertise',
	type: 'skill',
	color: 'green',
	maxLevel: 20,
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.bluntExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.bluntExpertise)
	},
}
player.bluntExpertise = {...bluntExpertise}

const firePenetration = {	
	level: 0,
	name: 'Fire Penetration',
	refName: 'firePenetration',
	type: 'skill',
	color: 'green',
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.firePenetration)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.firePenetration)
	},
}
player.firePenetration = {...firePenetration}

const icePenetration = {	
	level: 0,
	name: 'Ice Penetration',
	refName: 'icePenetration',
	type: 'skill',
	color: 'green',
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.icePenetration)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.icePenetration)
	},
}
player.icePenetration = {...icePenetration}

const lightningPenetration = {	
	level: 0,
	name: 'Lightning Penetration',
	refName: 'lightningPenetration',
	type: 'skill',
	color: 'green',
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.lightningPenetration)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.lightningPenetration)
	},
}
player.lightningPenetration = {...lightningPenetration}

const weakSpot = {	
	level: 0,
	name: 'Weak Spot',
	refName: 'weakSpot',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	chance: function() {
		if (player.weakSpot.level == 1) {return 5}
		if (player.weakSpot.level == 2) {return 10}
		if (player.weakSpot.level == 3) {return 15}
		if (player.weakSpot.level == 4) {return 20}
		if (player.weakSpot.level >= 5) {return 25}
	},
	debuff: {
		//armor reduction debuff applied to the enemy
		name: 'Weak Spot',
		refName: 'weakSpot',
		modifiedStats: ['piercingArmor'],
		get piercingArmor() { 
			if (player.weakSpot.level == 1) { return -5 }
			if (player.weakSpot.level == 2) { return -5 }
			if (player.weakSpot.level == 3) { return -5 }
			if (player.weakSpot.level == 4) { return -5 }
			if (player.weakSpot.level == 5) { return -5 }
			if (player.weakSpot.level == 6) { return -7 }
			if (player.weakSpot.level == 7) { return -10 }
			if (player.weakSpot.level == 8) { return -13 }
			if (player.weakSpot.level == 9) { return -15 }
			if (player.weakSpot.level >= 10) { return -20 }
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return player.weakSpot.level
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.weakSpot)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.weakSpot)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Weak Spot gives you the ability to find a weak spot in the enemy's armor. Upon landing a regular attack, you have a ${this.chance}% chance of reducing the enemy's piercing armor by 5 for each application.`, 'white', line1)
		blankSpace()

	},
}
player.weakSpot = {...weakSpot}

const vigor = {
	level: 0,
	name: 'Vigor',
	refName: 'vigor',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	healthMultiplier: function() {
		if (player.vigor.level == 1) { return 0.2}
		if (player.vigor.level == 2) { return 0.4}
		if (player.vigor.level == 3) { return 0.6}
		if (player.vigor.level == 4) { return 0.8}
		if (player.vigor.level == 5) { return 1.0}
		if (player.vigor.level == 6) { return 1.2}
		if (player.vigor.level == 7) { return 1.4}
		if (player.vigor.level == 8) { return 1.6}
		if (player.vigor.level == 9) { return 1.8}
		if (player.vigor.level >= 10) { return 2.0}
		else {return 0}	
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.vigor)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.vigor)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Vigor `, this.color, line1)
		customizeEachWord(`increases the effectiveness of the Constitution attribute, gaining more hit points per point of Constitution.`, 'white', line1)
		blankSpace()
	},
}
player.vigor = { ...vigor }
const devotion = {
	level: 0,
	name: 'Devotion',
	refName: 'devotion',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	manaMultiplier: function() {
		if (player.devotion.level == 1) { return 0.1}
		if (player.devotion.level == 2) { return 0.2}
		if (player.devotion.level == 3) { return 0.3}
		if (player.devotion.level == 4) { return 0.4}
		if (player.devotion.level == 5) { return 0.5}
		if (player.devotion.level == 6) { return 0.6}
		if (player.devotion.level == 7) { return 0.7}
		if (player.devotion.level == 8) { return 0.8}
		if (player.devotion.level == 9) { return 0.9}
		if (player.devotion.level >= 10) { return 1.0}
		else {return 0}
	},	
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.devotion)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.devotion)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Devotion `, this.color, line1)
		customizeEachWord(`increases the effectiveness of the Wisdom attribute, gaining more mana per point of Wisdom.`, 'white', line1)
		blankSpace()
	},
}
player.devotion = { ...devotion }

const cleave = {
	level: 0,
	name: 'Cleave',
	type: 'skill',
	refName: 'cleave',
	color: 'green',
	maxLevel: 3,
	extraTargets: function() {
		if (player.cleave.level == 1) {return 1}
		if (player.cleave.level == 2) {return 2}
		if (player.cleave.level >= 3) {return 3}
	},
	goldToUpgrade: function () {
		if (player.cleave.level == 0) {return 500}
		if (player.cleave.level == 1) {return 1000}
		if (player.cleave.level >= 2) {return 2000}	
	},
	pointsToUpgrade: function () {
		if (player.cleave.level == 0) {return 20}
		if (player.cleave.level == 1) {return 40}
		if (player.cleave.level >= 2) {return 60}		
	},
	description: function() {
		let line1 = lineFunc()
		customizeEachWord(`Cleave allows you to hit an additional enemy each swing. The number of additional targets hit is equal to this skills level.`, 'white', line1)
	}
}
player.cleave = { ...cleave }

const multipleStrikes = {
	level: 0,
	name: 'Multiple Strikes',
	refName: 'multipleStrikes',
	type: 'skill',
	color: 'skill',
	maxLevel: 5,
	extraStrikesNumber: function() {
		if (player.multipleStrikes.level == 0) {return 0}
		if (player.multipleStrikes.level == 1) {return 1}
		if (player.multipleStrikes.level == 2) {return 1}
		if (player.multipleStrikes.level == 3) {return 2}
		if (player.multipleStrikes.level == 4) {return 2}
		if (player.multipleStrikes.level >= 5) {return 3}
	},
	extraStrikesChance: function() {
		if (player.multipleStrikes.level == 0) {return 0}
		if (player.multipleStrikes.level == 1) {return 10}
		if (player.multipleStrikes.level == 2) {return 20}
		if (player.multipleStrikes.level == 3) {return 20}
		if (player.multipleStrikes.level == 4) {return 30}
		if (player.multipleStrikes.level >= 5) {return 40}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.multipleStrikes)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.multipleStrikes)
	},
	description: function() {
		let line1 = lineFunc()
		customizeEachWord(`Multiple Strikes gives you a chance to land multiple strikes on a single target. This ability currently grants you a ${this.extraStrikesChance()}% chance to land an extra strike on an enemy. This effect can trigger ${this.extraStrikesNumber()} times.`, 'white', line1)
	}
}
player.multipleStrikes = {...multipleStrikes}

const doubleDraw = {
	level: 0,
	name: 'Double Draw',
	refName: 'doubleDraw',
	type: 'skill',
	color: 'green',
	counter: 0,
	maxLevel: 6,
	nthStrike: function() {
		if (player.doubleDraw.level == 1) {return 7}
		if (player.doubleDraw.level == 2) {return 6}
		if (player.doubleDraw.level == 3) {return 5}
		if (player.doubleDraw.level == 4) {return 4}
		if (player.doubleDraw.level == 5) {return 3} 
		if (player.doubleDraw.level >= 6) {return 2} 
	},
	goldToUpgrade: function () {
		if (player.doubleDraw.level == 0) {return 200}
		if (player.doubleDraw.level == 1) {return 500}
		if (player.doubleDraw.level == 2) {return 1000}
		if (player.doubleDraw.level == 3) {return 1500}
		if (player.doubleDraw.level == 4) {return 2000}		
		if (player.doubleDraw.level >= 5) {return 3000}		
	},
	pointsToUpgrade: function () {
		if (player.doubleDraw.level == 0) {return 20}
		if (player.doubleDraw.level == 1) {return 30}
		if (player.doubleDraw.level == 2) {return 40}
		if (player.doubleDraw.level == 3) {return 50}
		if (player.doubleDraw.level == 4) {return 60}	
		if (player.doubleDraw.level >= 5) {return 100}	
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Every nth regular attack, a Ranger will draw 2 arrows instead of 1 when firing their next shot.`, 'white', line1)
		blankSpace()
	},
}
player.doubleDraw = {...doubleDraw}
const extraStrike = {
	level: 0,
	name: 'Extra Strike',
	refName: 'extraStrike',
	type: 'skill',
	color: 'green',
	nthStrike: function() {
		if (this.level == 1) {return 1}
		if (this.level >= 2) {return 2}
	},
	goldToUpgrade: function () {
		if (player.extraStrike.level == 0) {return 1000}
		if (player.extraStrike.level >= 1) {return 5000}
		// if (player.doubleDraw.level >= 2) {return 10000}
	},
	pointsToUpgrade: function () {
		if (player.extraStrike.level == 0) {return 50}
		if (player.extraStrike.level >= 1) {return 100}
		// if (player.doubleDraw.level >= 2) {return 100}	
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Automatically grants a Monk an extra regular attack, for each fist, on every swing. Each level of this skill grants one extra attack.`, 'white', line1)
		blankSpace()
	},
}
player.extraStrike = {...extraStrike}

const stunningBlows = {
	level: 0,
	name: 'Stunning Blows',
	refName: 'stunningBlows',
	type: 'skill',
	color: 'skill',
	maxLevel: 9,
	flavorText: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You stun the ${enemy.name} for `, 'red', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${player.stunningBlows.stunningBlowsDuration() / 1000}`, 'yellow', line1)
		customizeEachWord(`] `, 'white', line1)
		customizeEachWord(`seconds!`, 'red', line1)
	},
	chanceToStun: function() {
		if (player.stunningBlows.level == 1) { return 10 }
		if (player.stunningBlows.level == 2) { return 15 }
		if (player.stunningBlows.level == 3) { return 15 }
		if (player.stunningBlows.level == 4) { return 20 }
		if (player.stunningBlows.level == 5) { return 20 }
		if (player.stunningBlows.level == 6) { return 25 }
		if (player.stunningBlows.level == 7) { return 25 }
		if (player.stunningBlows.level >= 8) { return 30 }
		else {return 0}
	},
	stunningBlowsDuration: function() {
		if (player.stunningBlows.level == 1) { return 3000}
		if (player.stunningBlows.level == 2) { return 3000}
		if (player.stunningBlows.level == 3) { return 3500}
		if (player.stunningBlows.level == 4) { return 3500}
		if (player.stunningBlows.level == 5) { return 4000}
		if (player.stunningBlows.level == 6) { return 4000}
		if (player.stunningBlows.level == 7) { return 4500}
		if (player.stunningBlows.level == 8) { return 4500}
		if (player.stunningBlows.level >= 9) { return 5000}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.stunningBlows)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.stunningBlows)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Grants the chance to stun an enemy for a duration after successfully landing a regular attack. You currently have a ${this.chanceToStun()}% chance to stun for ${this.stunningBlowsDuration() / 1000} seconds.`, 'white', line1)
		blankSpace()
	},
}
player.stunningBlows = {...stunningBlows}
const precision = {
	level: 0,
	name: 'Precision Strikes',
	refName: 'precision',
	type: 'skill',
	color: 'skill',
	maxLevel: 20,
	update: function() {
		player.unarmed.botMultiplier += 0.05
		player.oneHanded.botMultiplier += 0.05
		player.twoHanded.botMultiplier += 0.05
		player.daggers.botMultiplier += 0.05
		player.bows.botMultiplier += 0.05
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.precision)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.precision)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Precision hones in your weapon skill allowing your attacks to land more flush. This will increase the bottom end value of your damage roll.`, 'white', line1)
		blankSpace()
	},
}
player.precision = {...precision}
const warcraft = {
	level: 0,
	name: 'Warcraft',
	refName: 'warcraft',
	type: 'skill',
	color: 'skill',
	maxLevel: 20,
	update: function() {
		player.unarmed.topMultiplier += 0.05
		player.oneHanded.topMultiplier += 0.05
		player.twoHanded.topMultiplier += 0.05
		player.daggers.topMultiplier += 0.05
		player.bows.topMultiplier += 0.05
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.warcraft)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.warcraft)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Warcraft hones in your weapon skill, allowing you to hit enemies harder. This will increase the top end value of your damage roll.`, 'white', line1)
		blankSpace()
	},
}
player.warcraft = {...warcraft}

const stealth = {
	level: 0,
	type: 'ability',
	name: 'Stealth',
	refName: 'stealth',
	color: 'sinistral-color',
	maxLevel: 10,
	cooldown: function() {
		if (player.stealth.level == 1) {return 5}
		if (player.stealth.level == 2) {return 5}
		if (player.stealth.level == 3) {return 4}
		if (player.stealth.level == 4) {return 4}
		if (player.stealth.level == 5) {return 3}
		if (player.stealth.level == 6) {return 3}
		if (player.stealth.level == 7) {return 2}
		if (player.stealth.level >= 8) {return 2}
	},
	buff: {
		name: 'Stealth Break',
		refName: 'stealthBreak',
		stacks: 1,
		get dodge() {
			if (player.stealth.level == 1) { return 10 }
			if (player.stealth.level == 2) { return 15 }
			if (player.stealth.level == 3) { return 20 }
			if (player.stealth.level == 4) { return 25 }
			if (player.stealth.level == 5) { return 30 }
			if (player.stealth.level == 6) { return 35 }
			if (player.stealth.level == 7) { return 40 }
			if (player.stealth.level == 8) { return 40 }
			if (player.stealth.level >= 9) { return 50 }
		},
		get duration() {
			if (player.stealth.level == 1) { return 11000 }
			if (player.stealth.level == 2) { return 12000 }
			if (player.stealth.level == 3) { return 13000 }
			if (player.stealth.level == 4) { return 14000 }
			if (player.stealth.level == 5) { return 15000 }
			if (player.stealth.level == 6) { return 16000 }
			if (player.stealth.level == 7) { return 17000 }
			if (player.stealth.level == 8) { return 18000 }
			if (player.stealth.level == 9) { return 19000 }
			if (player.stealth.level >= 10) { return 20000 }
		},
		maxStacks: function() {
			return 1
		},
	},
	damageBonus: function() {
		if (!player.isStealthed) {return 0}
		let damageBonus = 0
		if (player.stealth.level == 1) {damageBonus = 0.25} 
		if (player.stealth.level == 2) {damageBonus = 0.50} 
		if (player.stealth.level == 3) {damageBonus = 0.75} 
		if (player.stealth.level == 4) {damageBonus = 1.0} 
		if (player.stealth.level == 5) {damageBonus = 1.25}
		if (player.stealth.level == 6) {damageBonus = 1.50}
		if (player.stealth.level == 7) {damageBonus = 1.75}
		if (player.stealth.level == 8) {damageBonus = 2.0}
		if (player.stealth.level == 9) {damageBonus = 2.25}
		if (player.stealth.level >= 10) {damageBonus = 2.50}
		damage = player.currentWeaponSkill.attackPower * damageBonus
		return Math.ceil(damage)
	},
	stealthSwing: function(enemy, swingObject) {
		let line1 = lineFunc()
		let line2 = lineFunc()
			if (!swingObject.doesSwingHit) {
				daggerMissArray1[randomNumberRange(0, 4)].play()
				blankSpace()
				customizeEachWord(`You ${swingObject.swingType} `, 'white', line1)
				customizeEachWord(`your `, 'white', line1)
				customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
				customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`and miss!`, 'white', line1)
				blankSpace()
			} else {
				daggerHitArray1[randomNumberRange(0, 4)].play()
				blankSpace()
				customizeEachWord(`You ${swingObject.swingType} `, 'white', line1)
				customizeEachWord(`your `, 'white', line1)
				customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
				customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`Sneak Attack `, this.color, line2)
				customizeEachWord(`hits for `, 'green', line2)
				customizeEachWord(`${swingObject.realTotalDamage} `, 'light-blue', line2)
				if (swingObject.penText) {
					customizeEachWord(`${swingObject.penText} `, swingObject.penText, line2)
				}				
				customizeEachWord(`damage. `, 'green', line2)
				customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
				customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
				customizeEachWord(`)`, 'white', line2)
				blankSpace()
			}
	},
	flavorTextStealthBreak: function() {
		let line1 = lineFunc()
		customizeEachWord(`Shadows follow you into combat, increasing your dodging capabilities.`, `grey`, line1)
	},
	stealthCheck: function(enemy) {
		let playerStealthRating = (player.stealth.level + player.level) * 2
		let enemyDiscoverRating = enemy.level
		let discoverChance = 100 - (playerStealthRating - enemyDiscoverRating) < 0 ? 0 : 100 - (playerStealthRating - enemyDiscoverRating)
		console.log(discoverChance, ' This is the percentage chance that the player will be discovered in stealth from an enemy')
		return discoverChance
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.stealth)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.stealth)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Stealth allows you to hide using the HIDE command. It is an essential part of the Sinistral's aresenal. Using a regular attack while stealthed will perform a Sneak Attack, instantly engaging you with the enemy while dealing bonus damage. When you break stealth with any attack or ability, you will gain a bonus to dodge for a short duration. While hidden, enemies cannot see you, though enemies do have a chance to discover you if your skill level isn't high enough.
		
		Training Stealth will increase the damage of Sneak Attack, increase its dodge bonus, increase the dodge bonus duration, and reduce the time it takes to be able to act after stealthing.`, 'white', line1)
		blankSpace()
	},
}
player.stealth = { ...stealth }

const block = {
	level: 0,
	name: 'Block',
	refName: 'block',
	type: 'skill',
	cooldown: 0,
	blockAmount: function () {
		return this.level * 2 + player.con + player.agi
	},
	blockChance: 100,
	blockRoll: function () {
		if (this.level == 0) {return false}
		if (randomNumberRange(1, 100) <= this.blockChance) {return true} 
		else {return false}
	},
	color: 'skill',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
}
player.block = { ...block }

const dodging = {
	level: 0,
	name: 'Dodging',
	refName: 'dodging',
	type: 'skill',
	color: 'green',
	maxLevel: 20,
	rating: function() {
		if (player.dodging.level == 1) {return 2}
		if (player.dodging.level == 2) {return 4}
		if (player.dodging.level == 3) {return 6}
		if (player.dodging.level == 4) {return 8}
		if (player.dodging.level == 5) {return 10}
		if (player.dodging.level == 6) {return 13}
		if (player.dodging.level == 7) {return 16}
		if (player.dodging.level == 8) {return 19}
		if (player.dodging.level == 9) {return 21}
		if (player.dodging.level == 10) {return 24}
		if (player.dodging.level == 11) {return 28}
		if (player.dodging.level == 12) {return 32}
		if (player.dodging.level == 13) {return 36}
		if (player.dodging.level == 14) {return 40}
		if (player.dodging.level == 15) {return 45}
		if (player.dodging.level == 16) {return 50}
		if (player.dodging.level == 17) {return 55}
		if (player.dodging.level == 18) {return 60}
		if (player.dodging.level == 19) {return 65}
		if (player.dodging.level >= 20) {return 70}
		else {return 0}
	},

	goldToUpgrade: function () {
		return goldUpgradeCost1(player.dodging)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.dodging)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Passively increases your chance to dodge physical attacks.`, 'white', line1)
		blankSpace()
	},
}
player.dodging = { ...dodging }
const supremeDodging = {
	level: 0,
	name: 'Supreme Dodging',
	refName: 'supremeDodging',
	maxLevel: 10,
	buff: {
		name: 'Supreme Dodging',
		refName: 'supremeDodging',
		duration: 10000,
		stacks: 1,
		get dodge() {
			if (player.supremeDodging.level == 1) {return 1}
			if (player.supremeDodging.level == 2) {return 2}
			if (player.supremeDodging.level == 3) {return 3}
			if (player.supremeDodging.level == 4) {return 4}
			if (player.supremeDodging.level == 5) {return 5}
			if (player.supremeDodging.level == 6) {return 6}
			if (player.supremeDodging.level == 7) {return 7}
			if (player.supremeDodging.level == 8) {return 8}
			if (player.supremeDodging.level == 9) {return 9}
			if (player.supremeDodging.level >= 10) {return 10}
		},
		maxStacks: function() {
			return player.supremeDodging.level + 4
		}
	},
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.supremeDodging)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.supremeDodging)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each successful attack increases your chance to dodge by ${player.supremeDodging.buff.dodge} per stack.`, 'white', line1)
		blankSpace()
	},
}
player.supremeDodging = { ...supremeDodging }
const toughness = {
	level: 0,
	name: 'Toughness',
	refName: 'toughness',
	maxLevel: 10,
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Toughness is the measure of your natural defenses. Raising this will increase your base armor.`, 'white', line1)
		blankSpace()
	},
	rating: function() {
		if (player.toughness.level == 1) {return 1}
		if (player.toughness.level == 2) {return 2}
		if (player.toughness.level == 3) {return 5}
		if (player.toughness.level == 4) {return 7}
		if (player.toughness.level == 5) {return 10}
		if (player.toughness.level == 6) {return 13}
		if (player.toughness.level == 7) {return 16}
		if (player.toughness.level == 8) {return 19}
		if (player.toughness.level == 9) {return 22}
		if (player.toughness.level == 10) {return 25}
		else {
			return 0
		}
	},
	type: 'skill',
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.toughness)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.toughness)
	},
}
player.toughness = { ...toughness }

const sideStep = {
	level: 0,
	name: 'Side Step',
	refName: 'sideStep',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	calculate: function(enemy) {
		let chance = (player.sideStep.level * 10) - enemy.level
		let roll = randomNumberRange(1, 100)
		if (chance >= roll) {
			return true
		} else {
			return false
		}
	},
	flavorText: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You side-step the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`as it tries to advance you!`, 'white', line1)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.sideStep)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.sideStep)
	},
}
player.sideStep = { ...sideStep }
const quickshot = {
	level: 0,
	name: 'Quickshot',
	refName: 'quickshot',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	calculate: function(enemy) {
		let chance = (this.level * 10) - enemy.level
		let roll = randomNumberRange(1, 100)
		if (chance >= roll) {
			return true
		} else {
			return false
		}
	},
	strike: function(enemy) {
		//chance to dodgestrike is 10% per level - the enemy's level
		let baseChance = player.quickshot.level * 10
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToQuickshot = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToQuickshot, 'side step strike chance')
		console.log(roll, ' side step strike roll')
		if (chanceToQuickshot >= roll) {
			//dodgestrike only strikes once and with a single weapon
			//damage is base attack damage of right weapon if applicable, left weapon if right weapon isn't available
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
			bowHitArray1[randomNumberRange(0, 4)].play()
			this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
			applyDamageToEnemy(enemy, damageAfterMitigation)

		} else {
			//no dodgestrike happens
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`As you `, 'white', line1)
		customizeEachWord(`side-step `, 'green', line1)
		customizeEachWord(`its advance, you fire an arrow into the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Quickshot is a Ranger skill that gives you the chance to fire a single arrow (for regular attack damage) at an enemy after side-stepping its advance. This skill can only be used if Sidestep is at least level 1.`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.quickshot)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.quickshot)
	},
}
player.quickshot = { ...quickshot }

const dodgeStrike = {
	level: 0,
	name: 'Dodge Strike',
	refName: 'dodgeStrike',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	strike: function(enemy) {
		let baseChance = player.dodgeStrike.level * 10
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToDodgeStrike = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToDodgeStrike, 'dodgestrike chance')
		console.log(roll, ' dodgestrike roll')
		if (chanceToDodgeStrike >= roll) {
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
			daggerHitArray1[randomNumberRange(0, 4)].play()
			this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
			applyDamageToEnemy(enemy, damageAfterMitigation)

		} else {
			//no dodgestrike happens
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You deliver a `, 'white', line1)
		customizeEachWord(`Dodgestrike `, 'green', line1)
		customizeEachWord(`to the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`as you dodge its attack!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.dodgeStrike)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.dodgeStrike)
	},
}
player.dodgeStrike = { ...dodgeStrike }
const preemptiveStrike = {
	level: 0,
	name: 'Preemptive Strike',
	refName: 'preemptiveStrike',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	strike: function(enemy) {
		let baseChance = player.preemptiveStrike.level * 2
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToPreemptiveStrike = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToPreemptiveStrike, 'preemptive strike chance')
		console.log(roll, ' preemptive strike roll')
		if (chanceToPreemptiveStrike >= roll) {
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
				unarmedHitArray1[randomNumberRange(0, 4)].play()
				this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
				applyDamageToEnemy(enemy, damageAfterMitigation)
		} else {
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You predict the `, 'white', line1)
		customizeEachWord(`${enemy.name}'s `, enemy.color, line1)
		customizeEachWord(`attack, landing a `, 'white', line1)
		customizeEachWord(`Preemptive Strike `, 'green', line1)
		customizeEachWord(`first!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.preemptiveStrike)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.preemptiveStrike)
	},
	description: function() {
		let line1 = lineFunc()
		customizeEachWord(`Preemptive Strike `, this.color, line1)
		customizeEachWord(`grants you the ability to strike and enemy just before they land their attack on you. The chance to execute a Preemptive Strike is based on the skills level at 10% each level. The enemy's level is also taken into consideration at -1% chance per enemy's level.`, 'white', line1)
	}
}
player.preemptiveStrike = { ...preemptiveStrike }

const lockpicking = {
	level: 0,
	name: 'Lockpicking',
	refName: 'lockpicking',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	chance: function(enemy) {
		
	},
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
}
player.lockpicking = { ...lockpicking }

const smokeBomb = {
	level: 0,
	name: 'Smoke Bomb',
	refName: 'smokeBomb',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	resourceName: 'adrenaline',
	resourceCost: 20,
	maxLevel: 1,
	flavorText: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You conjure a cloud of smoke and disappear from combat!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return 1000
	},
	pointsToUpgrade: function () {
		return 30
	},
}
player.smokeBomb = { ...smokeBomb }
const mindsEye = {
	level: 0,
	name: `Mind's Eye`,
	refName: 'mindsEye',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 2,
	goldToUpgrade: function () {
		return 250
	},
	pointsToUpgrade: function () {
		return 100
	},
}
player.mindsEye = { ...mindsEye }

const arcaneKnowledge = {
	level: 0,
	name: `Arcane Knowledge`,
	refName: 'arcaneKnowledge',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.arcaneKnowledge)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.arcaneKnowledge)
	},
}
player.arcaneKnowledge = { ...arcaneKnowledge }

const mysticismMastery = {
	level: 0,
	name: `Mysticism Mastery`,
	refName: 'mysticismMastery',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	reduction: function() {
		if (player.mysticismMastery.level == 1) {return 0.05}
		if (player.mysticismMastery.level == 2) {return 0.10}
		if (player.mysticismMastery.level == 3) {return 0.15}
		if (player.mysticismMastery.level == 4) {return 0.20}
		if (player.mysticismMastery.level == 5) {return 0.25}
		if (player.mysticismMastery.level == 6) {return 0.30}
		if (player.mysticismMastery.level == 7) {return 0.35}
		if (player.mysticismMastery.level == 8) {return 0.40}
		if (player.mysticismMastery.level == 9) {return 0.45}
		if (player.mysticismMastery.level >= 10) {return 0.50}
		else {return 1}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.mysticismMastery)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.mysticismMastery)
	},
}
player.mysticismMastery = { ...mysticismMastery }
const sorceryMastery = {
	level: 0,
	name: `Sorcery Mastery`,
	refName: 'sorceryMastery',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	reduction: function() {
		if (player.sorceryMastery.level == 1) {return 0.05}
		if (player.sorceryMastery.level == 2) {return 0.10}
		if (player.sorceryMastery.level == 3) {return 0.15}
		if (player.sorceryMastery.level == 4) {return 0.20}
		if (player.sorceryMastery.level == 5) {return 0.25}
		if (player.sorceryMastery.level == 6) {return 0.30}
		if (player.sorceryMastery.level == 7) {return 0.35}
		if (player.sorceryMastery.level == 8) {return 0.40}
		if (player.sorceryMastery.level == 9) {return 0.45}
		if (player.sorceryMastery.level == 10) {return 0.50}
		else {return 1}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.sorceryMastery)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.sorceryMastery)
	},
}
player.sorceryMastery = { ...sorceryMastery }
const clearMind = {
	level: 0,
	name: `Clear Mind`,
	refName: 'clearMind',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	reduction: function() {
		if (player.clearMind.level == 1) {return 200}
		if (player.clearMind.level == 2) {return 400}
		if (player.clearMind.level == 3) {return 600}
		if (player.clearMind.level == 4) {return 800}
		if (player.clearMind.level == 5) {return 1000}
		if (player.clearMind.level == 6) {return 1200}
		if (player.clearMind.level == 7) {return 1400}
		if (player.clearMind.level == 8) {return 1600}
		if (player.clearMind.level == 9) {return 1800}
		if (player.clearMind.level >= 10) {return 2000}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.clearMind)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.clearMind)
	},
}
player.clearMind = { ...clearMind }
const spellWeapons = {
	level: 0,
	name: `Clear Mind`,
	refName: 'clearMind',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	bonus: function() {
		if (player.spellWeapons.level == 1) {return 0.1}
		if (player.spellWeapons.level == 2) {return 0.2}
		if (player.spellWeapons.level == 3) {return 0.3}
		if (player.spellWeapons.level == 4) {return 0.4}
		if (player.spellWeapons.level == 5) {return 0.5}
		if (player.spellWeapons.level == 6) {return 0.6}
		if (player.spellWeapons.level == 7) {return 0.7}
		if (player.spellWeapons.level == 8) {return 0.8}
		if (player.spellWeapons.level == 9) {return 0.9}
		if (player.spellWeapons.level == 10) {return 1.0}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.spellWeapons)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.spellWeapons)
	},
}
player.spellWeapons = { ...spellWeapons }


const magicDexterity = {
	level: 0,
	name: `Magic Dexterity`,
	refName: 'magicDexterity',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	reduction: function() {
		if (player.magicDexterity.level == 1) {return 200}
		if (player.magicDexterity.level == 2) {return 400}
		if (player.magicDexterity.level == 3) {return 600}
		if (player.magicDexterity.level == 4) {return 800}
		if (player.magicDexterity.level == 5) {return 1000}
		if (player.magicDexterity.level == 6) {return 1200}
		if (player.magicDexterity.level == 7) {return 1400}
		if (player.magicDexterity.level == 8) {return 1600}
		if (player.magicDexterity.level == 9) {return 1800}
		if (player.magicDexterity.level >= 10) {return 2000}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.magicDexterity)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.magicDexterity)
	},
}
player.magicDexterity = { ...magicDexterity }

const barrier = {
	level: 1,
	name: `Barrier`,
	refName: 'barrier',
	type: 'restorative',
	cooldown: 0,
	color: 'green',
	conjureBarColor: 'defensive-spell',
	chambered: false,
	maxLevel: 10,
	resourceName: 'mana', 
	conjureTime: function() {
		let baseConjureTime = 6000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.barrier.level <= 1) {spellLevelReduction = 0.2}
		if (player.barrier.level == 2) {spellLevelReduction = 0.4}
		if (player.barrier.level == 3) {spellLevelReduction = 0.7}
		if (player.barrier.level == 4) {spellLevelReduction = 1.0}
		if (player.barrier.level >= 5) {spellLevelReduction = 1.5}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 6000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.barrier.level <= 1) {spellLevelReduction = 0.2}
		if (player.barrier.level == 2) {spellLevelReduction = 0.4}
		if (player.barrier.level == 3) {spellLevelReduction = 0.7}
		if (player.barrier.level == 4) {spellLevelReduction = 1.0}
		if (player.barrier.level >= 5) {spellLevelReduction = 1.5}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	maxShield: function() {
		let baseAmount = player.mysticPower
		let skillBonus
		if (player.barrier.level == 0) {skillBonus = 1}
		if (player.barrier.level == 1) {skillBonus = 1.2}
		if (player.barrier.level == 2) {skillBonus = 1.4}
		if (player.barrier.level == 3) {skillBonus = 1.6}
		if (player.barrier.level == 4) {skillBonus = 1.8}
		if (player.barrier.level == 5) {skillBonus = 2.0}
		if (player.barrier.level == 6) {skillBonus = 2.2}
		if (player.barrier.level == 7) {skillBonus = 2.4}
		if (player.barrier.level == 8) {skillBonus = 2.6}
		if (player.barrier.level == 9) {skillBonus = 2.8}
		if (player.barrier.level >= 10) {skillBonus = 3.0}
		let shieldTotal = baseAmount * skillBonus
		return Math.ceil(shieldTotal)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.barrier)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.barrier)
	},
	cast: function() {
		this.chambered = false
		applyMagicShieldToPlayer()
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (shieldAmount) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You hold your hands out in front of you and a light, blue glow surrounds your body.`, 'white', line1)		
		customizeEachWord(`You place a `, 'white', line2)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`on yourself absorbing the next `, 'white', line2)
		customizeEachWord(`${shieldAmount} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()

	},
	description: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Barrier creates a protective shield around you, absorbing damage from magic and physical attacks. Damage will be applied to barrier before being applied to your health.`, 'white', line1)
		blankSpace()
	},
}
player.barrier = {...barrier}


const battleRage = {
	level: 0,
	name: `Battle Rage`,
	refName: 'battleRage',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	activate: function() {
		applyBuff(player.battleRage.buff)
	},
	buff: {
		name: 'Battle Rage',
		refName: 'battleRage',
		get attackPower() {
			if (player.battleRage.level == 1) {return 1}
			if (player.battleRage.level == 2) {return 1}
			if (player.battleRage.level == 3) {return 2}
			if (player.battleRage.level == 4) {return 2}
			if (player.battleRage.level == 5) {return 3}
			if (player.battleRage.level == 6) {return 3}
			if (player.battleRage.level == 7) {return 4}
			if (player.battleRage.level == 8) {return 4}
			if (player.battleRage.level == 9) {return 5}
			if (player.battleRage.level >= 10) {return 5}
			else {return 0}
		},
		duration: 10000,
		stacks: 1,
		maxStacks: function() {
			if (player.battleRage.level == 1) {return 3}
			if (player.battleRage.level == 2) {return 4}
			if (player.battleRage.level == 3) {return 4}
			if (player.battleRage.level == 4) {return 5}
			if (player.battleRage.level == 5) {return 5}
			if (player.battleRage.level == 6) {return 6}
			if (player.battleRage.level == 7) {return 6}
			if (player.battleRage.level == 8) {return 7}
			if (player.battleRage.level == 9) {return 7}
			if (player.battleRage.level >= 10) {return 8}
			else {return 0}
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.battleRage)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.battleRage)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each hit you take from an enemy's offensive attack increases your offense capabilities. Attack Power increased by ${player.battleRage.buff.attackPower} and stacks up to ${player.battleRage.buff.maxStacks()} times.`, 'white', line1)
		blankSpace()
	},
}
player.battleRage = { ...battleRage }
const resilience = { //DEFENSE RAISED BY LANDING ATTACKS
	level: 0,
	name: `Resilience`,
	refName: 'resilience',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Resilience',
		refName: 'resilience',
		duration: 10000,
		stacks: 1,
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		maxStacks: function() {
			if (player.resilience.level == 1) {return 1}
			if (player.resilience.level == 2) {return 2}
			if (player.resilience.level == 3) {return 3}
			if (player.resilience.level == 4) {return 4}
			if (player.resilience.level == 5) {return 5}
			if (player.resilience.level == 6) {return 6}
			if (player.resilience.level == 7) {return 7}
			if (player.resilience.level == 8) {return 8}
			if (player.resilience.level == 9) {return 9}
			if (player.resilience.level >= 10) {return 10}
		}

	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.resilience)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.resilience)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each regular attack you land increases your defenses. All armor types increased by ${player.resilience.attackPower} and stacks up to ${player.resilience.maxStacks()} times.`, 'white', line1)
		blankSpace()
	},
}
player.resilience = { ...resilience }

const hardenedSkin = {//DEFENSE RAISED BY TAKING HITS
	level: 0,
	name: 'Hardened Skin',
	refName: 'hardenedSkin',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	activate: function() {
		applyBuff(buff)
	},
	buff: {
		name: 'Hardened Skin',
		refName: 'hardenedSkin',
		duration: 10000,
		get slashingArmor() {
			if (player.hardenedSkin.level == 1) {return 1}
			if (player.hardenedSkin.level == 2) {return 2}
			if (player.hardenedSkin.level == 3) {return 3}
			if (player.hardenedSkin.level == 4) {return 4}
			if (player.hardenedSkin.level >= 5) {return 5}
		},
		get slashingArmor() {
			if (player.hardenedSkin.level == 1) {return 1}
			if (player.hardenedSkin.level == 2) {return 2}
			if (player.hardenedSkin.level == 3) {return 3}
			if (player.hardenedSkin.level == 4) {return 4}
			if (player.hardenedSkin.level >= 5) {return 5}
		},		
		get slashingArmor() {
			if (player.hardenedSkin.level == 1) {return 1}
			if (player.hardenedSkin.level == 2) {return 2}
			if (player.hardenedSkin.level == 3) {return 3}
			if (player.hardenedSkin.level == 4) {return 4}
			if (player.hardenedSkin.level >= 5) {return 5}
		},		
		stacks: 1,
		maxStacks: function() {
			return 5
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.hardenedSkin)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.hardenedSkin)
	},
}
player.hardenedSkin = { ...hardenedSkin }

const knightsResolve = {//WEIGHT ADDS ATTACK POWER
	level: 0,
	name: `Knight's Resolve`,
	refName: 'knightsResolve',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	bonusDamage: function() {
		if (this.level == 1) {return player.mods.weight * 0.1}
		if (this.level == 2) {return player.mods.weight * 0.2}
		if (this.level == 3) {return player.mods.weight * 0.3}
		if (this.level == 4) {return player.mods.weight * 0.4}
		if (this.level == 5) {return player.mods.weight * 0.5}
		if (this.level == 6) {return player.mods.weight * 0.6}
		if (this.level == 7) {return player.mods.weight * 0.7}
		if (this.level == 8) {return player.mods.weight * 0.8}
		if (this.level == 9) {return player.mods.weight * 0.9}
		if (this.level >= 10) {return player.mods.weight * 1.0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.knightsResolve)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.knightsResolve)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Knight's Resolve `, this.color, line1)
		customizeEachWord(`grants knights additional damage based on their weight. This skill takes into consideration the Knight's weight before it is mitigated by Strength and other factors.`, 'white', line1)
	},
}
player.knightsResolve = { ...knightsResolve }
const weaponTempering = {
	level: 0,
	name: `Weapon Tempering`,
	refName: 'weaponTempering',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
}
player.weaponTempering = { ...weaponTempering }
const armorTempering = {
	level: 0,
	name: `Armor Tempering`,
	refName: 'armorTempering',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
}
player.armorTempering = { ...armorTempering }
const evasiveRoll = {
	level: 0,
	name: `Evasive Roll`,
	refName: 'evasiveRoll',
	resourceName: 'focus',
	maxLevel: 1,
	get resourceCost() {
		if (this.level >= 1) {return 20}
	},
	cooldown: 0,
	type: 'skill',
	color: 'ranger-color',
	goldToUpgrade: function () {
		return 1000
	},
	pointsToUpgrade: function () {
		return 40
	},
}
player.evasiveRoll = { ...evasiveRoll }
const athletics = {
	level: 0,
	name: `Athletics`,
	refName: 'athletics',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each level of this skill counts toward rolls that require STR, DEX, or AGI. Level 1 would count as 1 STR, DEX, or AGI. Level 5 would count as 5 STR, DEX, or AGI, etc.`, 'white', line1)
		blankSpace()
	},
}
player.athletics = { ...athletics }
const ridingSkill = {
	level: 0,
	name: `Riding Skill`,
	refName: 'ridingSkill',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Allows for better handling of mounts. The higher your skill is, the higher the level of mounts you can ride.`, 'white', line1)
		blankSpace()
	},
}
player.ridingSkill = { ...ridingSkill }

const tauntingShout = {
	level: 0,
	name: `Taunting Shout`,
	refName: 'tauntingShout',
	cooldown: 0,
	resourceName: 'might',
	resourceCost: 1,
	maxLevel: 1,
	type: 'skill',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return 250
	},
	pointsToUpgrade: function () {
		return 20
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Taunts every enemy in the room, forcing them to instantly engage combat with you.`, 'white', line1)
		blankSpace()
	},
}
player.tauntingShout = { ...tauntingShout }

const berserking = {
	level: 0,
	name: `Berserking`,
	refName: 'berserking',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Crit skill for Warriors.`, 'white', line1)
		blankSpace()
	},
}
player.berserking = { ...berserking }
const headshot = {
	level: 0,
	name: `Headshot`,
	refName: 'headshot',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	procChance: function() {
		return player.headshot.level * 4
	},
	percentBonus: function() {
		return 1.75
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.headshot)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.headshot)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Headshot `, 'green', line1)
		customizeEachWord(`gives you a percent chance to land a headshot on the target dealing 75% bonus damage. Your current chance to land a headshot is ${player.headshot.procChance()} `, 'white', line1)
		blankSpace()
	},
}
player.headshot = { ...headshot }
const backstabbing = {
	level: 0,
	name: `Backstabbing`,
	refName: 'backstabbing',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	procChance: function() {
		return player.backstabbing.level * 5
	},
	percentBonus: function() {
		return 1.5
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.backstabbing)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.backstabbing)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Gives you a chance to perform a Backstabbing attack instead of a regular attack. This currently has a chance of ${player.backstabbing.procChance()}% chance to deal ${player.backstabbing.percentBonus}x damage.`, 'white', line1)
		blankSpace()
	},
}
player.backstabbing = { ...backstabbing }

const brutalBlows = {
	level: 0,
	name: `Brutal Blows`,
	refName: 'brutalBlows',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	procChance: function() {
		return player.brutalBlows.level * 3
	},
	percentBonus: function() {
		return 2.0
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.brutalBlows)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.brutalBlows)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Brutal Blows gives you a chance to land a devastating attack that deals ${player.brutalBlows.percenBonus()}x damage at a chance of ${player.brutalBlows.procChance()}%`, 'white', line1)
		blankSpace()
	},
}
player.brutalBlows = { ...brutalBlows }

const thrillOfTheKill = {
	level: 0,
	name: 'Thrill Of The Kill',
	refName: 'thrillOfTheKill',
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Thrill Of The Kill',
		refName: 'thrillOfTheKill',
		enemy: undefined,
		percentRecovered: function() {
			if (player.thrillOfTheKill.level == 1) {return 0.01}
			if (player.thrillOfTheKill.level == 2) {return 0.02}
			if (player.thrillOfTheKill.level == 3) {return 0.03}
			if (player.thrillOfTheKill.level == 4) {return 0.04}
			if (player.thrillOfTheKill.level == 5) {return 0.05}
			if (player.thrillOfTheKill.level == 6) {return 0.06}
			if (player.thrillOfTheKill.level == 7) {return 0.07}
			if (player.thrillOfTheKill.level == 8) {return 0.08}
			if (player.thrillOfTheKill.level == 9) {return 0.09}
			if (player.thrillOfTheKill.level >= 10) {return 0.10}
			else {return 0}
		},
		heal: function(enemy) {
			let healAmount
			let enemyHealthPercent = Math.ceil(player.thrillOfTheKill.buff.enemy.maxHealth * player.thrillOfTheKill.buff.percentRecovered())
			if (player.thrillOfTheKill.level >= 1) {
				healAmount = enemyHealthPercent
			}
			return healAmount
		},
		flavorText: function(healAmount) {
			let line1 = lineFunc()
			customizeEachWord(`You heal for `, 'green', line1)
			customizeEachWord(`${healAmount} `, 'light-blue', line1)
			customizeEachWord(`hit point(s).`, 'green', line1)
			blankSpace()
		},
		duration: 10000,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
	},
	heal: function() {
		return 10
	},
	activate: function(enemy) {
		player.thrillOfTheKill.buff.enemy = enemy
		applyBuff(player.thrillOfTheKill.buff)

	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.thrillOfTheKill)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.thrillOfTheKill)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel invigorated after last kill. Your regular attacks heal you for ${player.thrillOfTheKill.buff.percentRecovered()} of the enemy's health that you most recently killed.`, 'white', line1)
		blankSpace()
	},
}
player.thrillOfTheKill = { ...thrillOfTheKill}

const counterAttack = {
	level: 0,
	name: 'Counter Attack',
	refName: 'counter attack',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	strike: function(enemy) {
		let baseChance = player.counterAttack.level * 3
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToCounter = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToCounter, 'side step strike chance')
		console.log(roll, ' side step strike roll')
		if (chanceToCounter >= roll) {
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
				oneHandedHitArray1[randomNumberRange(0, 4)].play()
				this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
				applyDamageToEnemy(enemy, damageAfterMitigation)
		} else {
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You spot an opening in the `, 'white', line1)
		customizeEachWord(`${enemy.name}'s `, enemy.color, line1)
		customizeEachWord(`defense, and you land a `, 'white', line1)
		customizeEachWord(`Counter Attack`, 'green', line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.counterAttack)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.counterAttack)
	},
}
player.counterAttack = { ...counterAttack }
const fleetFooted = {
	level: 0,
	name: `Fleet Footed`,
	refName: 'fleetFooted',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 5,
	reduction: function() {
		let reductionTime = 0
		if (this.level == 0) {reductionTime = 0}
		if (this.level == 1) {reductionTime = 0.1}
		if (this.level == 2) {reductionTime = 0.2}
		if (this.level == 3) {reductionTime = 0.3}
		if (this.level == 4) {reductionTime = 0.4}
		if (this.level >= 5) {reductionTime = 0.5}
		return reductionTime
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.slashingExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.slashingExpertise)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Reduces the time penalty of retreating. Each level of Fleet Footed reduces the time you can become active after retreating by .1 second(s).`, 'white', line1)
		blankSpace()
	},
}
player.fleetFooted = { ...fleetFooted }
const initiation = {
	level: 0,
	name: `Initiation`,
	refName: 'initiation',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 5,
	reduction: function() {
		let reductionTime = 0
		if (this.level == 0) {reductionTime = 0}
		if (this.level == 1) {reductionTime = 0.2}
		if (this.level == 2) {reductionTime = 0.4}
		if (this.level == 3) {reductionTime = 0.6}
		if (this.level == 4) {reductionTime = 0.8}
		if (this.level >= 5) {reductionTime = 1.0}
		return reductionTime
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.initiation)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.initiation)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Reduces the time it takes to perform a regular attack after advancing the enemy. Each level of Initiation reduces the time you can become active after advancing an enemy by .2 second(s).`, 'white', line1)
		blankSpace()
	},
}
player.initiation = { ...initiation }
const vigilance = {
	level: 0,
	name: `Vigilance`,
	refName: 'vigilance',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Vigilance',
		refName: 'vigilance',
		get dodge() {
			if (player.vigilance.level == 1) {return 5}
			if (player.vigilance.level == 2) {return 5}
			if (player.vigilance.level == 3) {return 10}
			if (player.vigilance.level == 4) {return 10}
			if (player.vigilance.level == 5) {return 15}
			if (player.vigilance.level == 6) {return 15}
			if (player.vigilance.level == 7) {return 20}
			if (player.vigilance.level == 8) {return 20}
			if (player.vigilance.level == 9) {return 25}
			if (player.vigilance.level >= 10) {return 25}
		},
		get agi() {
			if (player.vigilance.level == 1) {return 0}
			if (player.vigilance.level == 2) {return 2}
			if (player.vigilance.level == 3) {return 2}
			if (player.vigilance.level == 4) {return 4}
			if (player.vigilance.level == 5) {return 4}
			if (player.vigilance.level == 6) {return 6}
			if (player.vigilance.level == 7) {return 6}
			if (player.vigilance.level == 8) {return 8}
			if (player.vigilance.level == 9) {return 8}
			if (player.vigilance.level >= 10) {return 10}
		},
		duration: 10000,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.vigilance)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.vigilance)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Grants a bonus after retreating.`, 'white', line1)
		blankSpace()
	},
}
player.vigilance = { ...vigilance }
const tactics = {
	level: 1,
	name: `Tactics`,
	refName: 'tactics',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Tactics',
		refName: 'tactics',
		get slashingArmor() {
			if (player.tactics.level == 1) {return 1}
			if (player.tactics.level == 2) {return 2}
			if (player.tactics.level == 3) {return 3}
			if (player.tactics.level == 4) {return 4}
			if (player.tactics.level == 5) {return 5}
			if (player.tactics.level == 6) {return 6}
			if (player.tactics.level == 7) {return 7}
			if (player.tactics.level == 8) {return 8}
			if (player.tactics.level == 9) {return 9}
			if (player.tactics.level >= 10) {return 10}
			else {return 0}
		},
		get piercingArmor() {
			if (player.tactics.level == 1) {return 1}
			if (player.tactics.level == 2) {return 2}
			if (player.tactics.level == 3) {return 3}
			if (player.tactics.level == 4) {return 4}
			if (player.tactics.level == 5) {return 5}
			if (player.tactics.level == 6) {return 6}
			if (player.tactics.level == 7) {return 7}
			if (player.tactics.level == 8) {return 8}
			if (player.tactics.level == 9) {return 9}
			if (player.tactics.level >= 10) {return 10}
			else {return 0}
		},
		get bluntArmor() {
			if (player.tactics.level == 1) {return 1}
			if (player.tactics.level == 2) {return 2}
			if (player.tactics.level == 3) {return 3}
			if (player.tactics.level == 4) {return 4}
			if (player.tactics.level == 5) {return 5}
			if (player.tactics.level == 6) {return 6}
			if (player.tactics.level == 7) {return 7}
			if (player.tactics.level == 8) {return 8}
			if (player.tactics.level == 9) {return 9}
			if (player.tactics.level >= 10) {return 10}
			else {return 0}
		},
		get str() {
			if (player.tactics.level == 1) {return 0}
			if (player.tactics.level == 2) {return 0}
			if (player.tactics.level == 3) {return 0}
			if (player.tactics.level == 4) {return 0}
			if (player.tactics.level == 5) {return 0}
			if (player.tactics.level == 6) {return 1}
			if (player.tactics.level == 7) {return 2}
			if (player.tactics.level == 8) {return 3}
			if (player.tactics.level == 9) {return 4}
			if (player.tactics.level >= 10) {return 5}
			else {return 0}
		},
		duration: function() {
			if (player.tactics.level == 1) {return 10000}
			if (player.tactics.level == 2) {return 11000}
			if (player.tactics.level == 3) {return 12000}
			if (player.tactics.level == 4) {return 13000}
			if (player.tactics.level == 5) {return 14000}
			if (player.tactics.level == 6) {return 15000}
			if (player.tactics.level == 7) {return 16000}
			if (player.tactics.level == 8) {return 17000}
			if (player.tactics.level == 9) {return 18000}
			if (player.tactics.level >= 10) {return 20000}
		},
		stacks: 1,
		maxStacks: function() {
			return 1
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.tactics)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.tactics)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Grants an armor bonus for a short duration after using the advance command to initiate combat.`, 'white', line1)
		blankSpace()
	},
}
player.tactics = { ...tactics }
const fistsOfFury = {
	level: 0,
	name: `Fists of Fury`,
	refName: 'fistsOfFury',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	update: function() {
		//Goblin Fist
		//Ogre Fist
		//Titan Fist
		//Dragon Fist
		//God Fist
		if (this.level == 1) {player.rightFist.topDamage += 2}
		if (this.level == 1) {player.leftFist.topDamage += 2}
		if (this.level == 2) {player.rightFist.topDamage += 3}
		if (this.level == 2) {player.leftFist.topDamage += 3}
		if (this.level == 3) {player.rightFist.topDamage += 4}
		if (this.level == 3) {player.leftFist.topDamage += 4}
		if (this.level == 4) {player.rightFist.topDamage += 5}
		if (this.level == 4) {player.leftFist.topDamage += 5}
		if (this.level == 5) {player.rightFist.topDamage += 6}
		if (this.level == 5) {player.leftFist.topDamage += 6}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.fistsOfFury)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.fistsOfFury)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`A skill for Monks who would rather use their fists in combat rather than rely on weapons. Fists of Fury increases the top damage value of both your fists.`, 'white', line1)
		blankSpace()
	},
}
player.fistsOfFury = { ...fistsOfFury }
const fistsOfPrecision = {
	level: 0,
	name: `Fists of Precision`,
	refName: 'fistsOfPrecision',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	update: function() {
		//Goblin Fist
		//Ogre Fist
		//Titan Fist
		//Dragon Fist
		//God Fist
		if (this.level == 1) {player.rightFist.botDamage += 2}
		if (this.level == 1) {player.leftFist.botDamage += 2}
		if (this.level == 2) {player.rightFist.botDamage += 3}
		if (this.level == 2) {player.leftFist.botDamage += 3}
		if (this.level == 3) {player.rightFist.botDamage += 4}
		if (this.level == 3) {player.leftFist.botDamage += 4}
		if (this.level == 4) {player.rightFist.botDamage += 5}
		if (this.level == 4) {player.leftFist.botDamage += 5}
		if (this.level == 5) {player.rightFist.botDamage += 6}
		if (this.level == 5) {player.leftFist.botDamage += 6}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.fistsOfPrecision)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.fistsOfPrecision)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`A skill for Monks who would rather use their fists in combat rather than rely on weapons. Fists of Calm increases the bottom damage value of both your fists.`, 'white', line1)
		blankSpace()
	},
}
player.fistsOfPrecision = { ...fistsOfPrecision }
const wayOfTheFist = {
	level: 0,
	name: `Way Of The Fist`,
	refName: 'wayOfTheFist',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	update: function() {
		let attackPowerIncrease = 0
		let bluntPenIncrease = 0
		if (player.wayOfTheFist.level == 1) {attackPowerIncrease = 1}
		if (player.wayOfTheFist.level == 1) {bluntPenIncrease = 0}
		if (player.wayOfTheFist.level == 2) {attackPowerIncrease = 2}
		if (player.wayOfTheFist.level == 2) {bluntPenIncrease = 3}
		if (player.wayOfTheFist.level == 3) {attackPowerIncrease = 3}
		if (player.wayOfTheFist.level == 3) {bluntPenIncrease = 3}
		if (player.wayOfTheFist.level == 4) {attackPowerIncrease = 5}
		if (player.wayOfTheFist.level == 4) {bluntPenIncrease = 5}
		if (player.wayOfTheFist.level == 5) {attackPowerIncrease = 6}
		if (player.wayOfTheFist.level == 5) {bluntPenIncrease = 6}
		if (player.wayOfTheFist.level == 6) {attackPowerIncrease = 7}
		if (player.wayOfTheFist.level == 6) {bluntPenIncrease = 7}
		if (player.wayOfTheFist.level == 7) {attackPowerIncrease = 9}
		if (player.wayOfTheFist.level == 7) {bluntPenIncrease = 9}
		if (player.wayOfTheFist.level == 8) {attackPowerIncrease = 10}
		if (player.wayOfTheFist.level == 8) {bluntPenIncrease = 10}
		if (player.wayOfTheFist.level == 9) {attackPowerIncrease = 11}
		if (player.wayOfTheFist.level == 9) {bluntPenIncrease = 11}
		if (player.wayOfTheFist.level >= 10) {attackPowerIncrease = 15}
		if (player.wayOfTheFist.level >= 10) {bluntPenIncrease = 15}
		// player.unarmed.botMultiplier += increaseAmount
		player.rightFist.mods.attackPower = attackPowerIncrease
		player.leftFist.mods.attackPower = attackPowerIncrease
		player.rightFist.mods.bluntPen = bluntPenIncrease
		player.leftFist.mods.bluntPen = bluntPenIncrease
		console.log(attackPowerIncrease)
		console.log(player.rightFist.mods)
		weaponOrShieldAddPlayerAttribute(player.rightFist)
		weaponOrShieldAddPlayerAttribute(player.leftFist)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.wayOfTheFist)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.wayOfTheFist)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Increases your attack power while not wielding any weapons. This is for Monks who choose to use their fists rather than rely on weapons in combat. Way Of The Fist also increases your Blunt Penetration.`, 'white', line1)
		blankSpace()
	},
}
player.wayOfTheFist = { ...wayOfTheFist }
const bleed = {
	level: 1,
	name: 'Bleed',
	refName: 'bleed',
	color: 'green',
	stacks: 0,
	duration: 15000,
	damage: function(enemy, swingObject) {
		let damage = swingObject.totalDamage
		let totalDamage = Math.ceil(damage * (enemy.debuffs.bleed.stacks * 0.1))
		console.log(totalDamage, ' BLEED BONUS DAMAGE')
		return Math.ceil(totalDamage)
		// return 0.1 * this.stacks
		//change to increment by 10% per stack
	},
	bonusModifier: function() {
		if (this.level == 1) {return 0.20}
		if (this.level == 2) {return 0.25}
		if (this.level == 3) {return 0.30}
		if (this.level == 4) {return 0.35}
		if (this.level == 5) {return 0.40}
		if (this.level == 6) {return 0.45}
		if (this.level == 7) {return 0.50}
		if (this.level == 8) {return 0.55}
		if (this.level == 9) {return 0.60}
		if (this.level >= 10) {return 0.65}
	},
	maxStacks: function() {
		return 5
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.bleed)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.bleed)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Bleed is a debuff applied to enemies by certain Warrior skills. Each stack of bleed on the target increases the damage dealt to it by all warrior abilities and regular attacks by ${player.bleed.bonusModifier() * 100}%. Damage is increased further for each stack on the target.`, 'white', line1)
		blankSpace()
	},
}
player.bleed = { ...bleed }
const burn = {
	level: 1,
	name: 'Burn',
	refName: 'burn',
	color: 'green',
	stacks: 0,
	duration: 15000,
	bonusModifier: function() {
		if (this.level == 1) {return 0.20}
		if (this.level == 2) {return 0.25}
		if (this.level == 3) {return 0.30}
		if (this.level == 4) {return 0.35}
		if (this.level == 5) {return 0.40}
		if (this.level == 6) {return 0.45}
		if (this.level == 7) {return 0.50}
		if (this.level == 8) {return 0.55}
		if (this.level == 9) {return 0.60}
		if (this.level >= 10) {return 0.65}
		else {return 0}
	},
	maxStacks: function() {
		return this.level + 2
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Burn is a debuff applied by certain fire spells. Each stack of burn increases the damage of all fire spells against the target by ${player.burn.bonusModifier()}% per stack.`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.burn)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.burn)
	},
}
player.burn = { ...burn }
const frostbite = {
	level: 1,
	name: 'Frostbite',
	refName: 'frostbite',
	color: 'green',
	stacks: 0,
	duration: 15000,
	bonusModifier: function() {
		if (this.level == 1) {return 0.20}
		if (this.level == 2) {return 0.25}
		if (this.level == 3) {return 0.30}
		if (this.level == 4) {return 0.35}
		if (this.level == 5) {return 0.40}
		if (this.level == 6) {return 0.45}
		if (this.level == 7) {return 0.50}
		if (this.level == 8) {return 0.55}
		if (this.level == 9) {return 0.60}
		if (this.level >= 10) {return 0.65}
		else {return 0}
	},
	maxStacks: function() {
		return this.level + 2
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Burn is a debuff applied by certain fire spells. Each stack of burn increases the damage of all fire spells against the target by ${player.burn.bonusModifier()}% per stack.`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.frostbite)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.frostbite)
	},
}
player.frostbite = { ...frostbite }
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////

//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
const charge = {
	//Ideas: Can hit and engage multiple enemies at once
	//
	level: 1,
	maxLevel: 5,
	name: 'Charge',
	refName: 'charge',
	type: 'ability',
	color: 'warrior-color',
	activate: function() {
		let debuffTime
		if (player.charge.level == 1) {debuffTime = 10000}
	},
	buff: {
		name: 'Charge',
		refName: 'charge',
		get slashingArmor() {
			if (player.level == 1) {return -10}
			if (player.level == 2) {return -8}
			if (player.level == 3) {return -6}
			if (player.level == 4) {return -4}
			if (player.level >= 5) {return 0}
		},
		get piercingArmor() {
			if (player.level == 1) {return -10}
			if (player.level == 2) {return -8}
			if (player.level == 3) {return -6}
			if (player.level == 4) {return -4}
			if (player.level >= 5) {return 0}	
		},
		get bluntArmor() {
			if (player.level == 1) {return -10}
			if (player.level == 2) {return -8}
			if (player.level == 3) {return -6}
			if (player.level == 4) {return -4}
			if (player.level >= 5) {return 0}		
		},
		stacks: 1,
		duration: 10000,
		maxStacks: function() {
			return 1
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.charge)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.charge)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Charge `, 'green', line1)
		customizeEachWord(`allows you to instantly engage combat while simulataneously performing a regular attack on your target. This is a reckless attack, leaving you vulnerable for a short time after charging by decreasing the value of all armor types. Training this ability to higher levels will reduce the armor penalty.`, 'white', line1)
	}
}
player.charge = { ...charge }

const ripslash = {
	level: 1,
	name: 'Ripslash',
	refName: 'ripslash',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 6000,
	cooldown: 6000,
	windUp: 6,
	numberOfSwings: function() {
		if (this.level == 1) { return 1 }
		if (this.level == 2) { return 1 }
		if (this.level == 3) { return 1 }
		if (this.level == 4) { return 1 }
		if (this.level == 5) { return 2 }
		if (this.level == 6) { return 2 }
		if (this.level == 7) { return 2 }
		if (this.level == 8) { return 2 }
		if (this.level == 9) { return 2 }
		if (this.level >= 10) { return 3 }
		else {return 1 }
	},
	resourceCost: 1,
	resourceName: 'might',
	weaponTypesUsed: ['oneHanded', 'twoHanded'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5 }
		if (this.level == 2) { levelModifier = 1.7 }
		if (this.level == 3) { levelModifier = 1.9 }
		if (this.level == 4) { levelModifier = 1.9 }
		if (this.level == 5) { levelModifier = 2.1 }
		if (this.level == 6) { levelModifier = 2.1 }
		if (this.level == 7) { levelModifier = 2.1 }
		if (this.level == 8) { levelModifier = 2.3 }
		if (this.level == 9) { levelModifier = 2.3 }
		if (this.level >= 10) { levelModifier = 2.5 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You step forward, arcing your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`upward, ripping into the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You step forward, arcing your `, 'white', line2)
			customizeEachWord(`${weapon.name} `, `${weapon.color}`, line2)
			customizeEachWord(`toward the `, 'white', line2)
			customizeEachWord(`${enemy.name}`, enemy.color, line2)
			customizeEachWord(`, but you narrowly `, 'white', line2)
			customizeEachWord(`miss`, 'red', line2)
			customizeEachWord(`!`, 'white', line2)
			blankSpace()
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Ripslash deals single target damage, increasing with each level. Ripslash gains an additional swing at levels 5 and level 10.`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.ripslash)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.ripslash)
	},
}
player.ripslash = { ...ripslash }

const cyclone = {
	level: 1,
	name: 'Cyclone',
	refName: 'cyclone',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 6000,
	cooldown: 6000,
	windUp: 6,
	numberOfTargets: function() {
		if (this.level == 1) { return 2}
		if (this.level == 2) { return 2}
		if (this.level == 3) { return 2}
		if (this.level == 4) { return 3}
		if (this.level == 5) { return 3}
		if (this.level == 6) { return 3}
		if (this.level == 7) { return 4}
		if (this.level == 8) { return 4}
		if (this.level == 9) { return 4}
		if (this.level >= 10) { return 5}
	},
	resourceName: 'might',
	resourceCost: 2,
	weaponTypesUsed: ['oneHanded', 'twoHanded'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let levelModifier
		if (this.level == 1) { levelModifier = 1.25 }
		if (this.level == 2) { levelModifier = 1.40 }
		if (this.level == 3) { levelModifier = 1.55 }
		if (this.level == 4) { levelModifier = 1.55 }
		if (this.level == 5) { levelModifier = 1.70 }
		if (this.level == 6) { levelModifier = 1.85 }
		if (this.level == 7) { levelModifier = 1.85 }
		if (this.level == 8) { levelModifier = 2.0 }
		if (this.level == 9) { levelModifier = 2.15 }
		if (this.level >= 10) { levelModifier = 2.30 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		return Math.ceil(totalDamage)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		customizeEachWord(`Your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`eviscerates the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorText2: function(weapon) {
		let line1 = lineFunc()
		customizeEachWord(`Dashing at the enemy, you spin into a `, 'white', line1)
		customizeEachWord(`cyclone `, this.color, line1)
		customizeEachWord(`of fury!`, 'white', line1)

	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Your `, 'white', line2)
		customizeEachWord(`${weapon.name} `, weapon.color, line2)
		customizeEachWord(`whirls past the `, 'white', line2)
		customizeEachWord(`${enemy.name} `, enemy.color, line2)
		customizeEachWord(`and you `, 'white', line2)
		customizeEachWord(`miss`, 'red', line2)
		customizeEachWord(`!`, 'white', line2)
		blankSpace()
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.cyclone)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.cyclone)
	},
}
player.cyclone = { ...cyclone }

const cataclysm = {
	level: 1,
	name: 'Cataclysm',
	refName: 'cataclysm',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 6000,
	cooldown: 6000,
	windUp: 6,
	resourceName: 'might',
	resourceCost: 3, //player.maxMight is what this should be when not testing things
	weaponTypesUsed: ['oneHanded', 'twoHanded'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() * 1.5
		let levelModifier
		if (this.level == 1) { levelModifier = 1.7 }
		if (this.level == 2) { levelModifier = 1.9 }
		//level 3 now hits 2 times
		if (this.level == 3) { levelModifier = 2.1 }
		if (this.level == 4) { levelModifier = 2.3 }
		//level 5 now hits 3 times
		if (this.level == 5) { levelModifier = 2.5 }
		if (this.level == 6) { levelModifier = 2.7 }
		if (this.level == 7) { levelModifier = 2.9 }
		if (this.level == 8) { levelModifier = 3.1 }
		if (this.level == 9) { levelModifier = 3.3 }
		if (this.level >= 10) { levelModifier = 3.5 }
		let basePlusLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, basePlusLevelDamage)
		let totalDamage = basePlusLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' CATACLYSM BASE DAMAGE')
		console.log(basePlusLevelDamage, ' CATACLYSM BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Cataclysm',
		refName: 'cataclysm',
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		get slashingArmor() {
			if (player.cataclysm.level == 1) {return -10}
			if (player.cataclysm.level == 2) {return -20}
			if (player.cataclysm.level == 3) {return -30}
			if (player.cataclysm.level == 4) {return -40}
			if (player.cataclysm.level >= 5) {return -50}
		},
		get piercingArmor() {
			if (player.cataclysm.level == 1) {return -10}
			if (player.cataclysm.level == 2) {return -20}
			if (player.cataclysm.level == 3) {return -30}
			if (player.cataclysm.level == 4) {return -40}
			if (player.cataclysm.level >= 5) {return -50}
		},
		get bluntArmor() {
			if (player.cataclysm.level == 1) {return -10}
			if (player.cataclysm.level == 2) {return -20}
			if (player.cataclysm.level == 3) {return -30}
			if (player.cataclysm.level == 4) {return -40}
			if (player.cataclysm.level >= 5) {return -50}
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap high into the air, crashing down with your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
	blankSpace()
	customizeEachWord(`You leap high into the air, crashing down with your `, 'white', line1)
	customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
	customizeEachWord(`, but you `, 'white', line1)
	customizeEachWord(`miss`, 'red', line1)
	customizeEachWord(`!`, 'white', line1)
	blankSpace()
	},
	specialEffect: function(enemy, damage, penetrationType, damageBlocked) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
	blankSpace()
	customizeEachWord(`The shockwave from `, `warrior-ability-text-color`, line1)
	customizeEachWord(`${this.name} `, this.color, line1)
	customizeEachWord(`blasts the `, `warrior-ability-text-color`, line1)
	customizeEachWord(`${enemy.name}`, enemy.color, line1)
	customizeEachWord(`!`, `warrior-ability-text-color`, line1)
	customizeEachWord(`${this.name} `, this.color, line2)
	customizeEachWord(`hits for `, `warrior-ability-text-color`, line2)
	customizeEachWord(`${damage} `, `light-blue`, line2)
	customizeEachWord(`${penetrationType} `, penetrationType, line2)
	customizeEachWord(`damage! `, `white`, line2)
	customizeEachWord(`(Enemy's armor blocks `, `white`, line2)
	customizeEachWord(`${damageBlocked}`, `light-blue`, line2)
	customizeEachWord(`)`, `white`, line2)
	blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.cataclysm)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.cataclysm)
	},
}
player.cataclysm = { ...cataclysm }

const dualStrike = {
	level: 1,
	name: 'Dual Strike',
	refName: 'dualStrike',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 8000,
	cooldown: 8000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 1,
	weaponTypesUsed: ['oneHanded', 'daggers'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.75 }
		if (this.level == 2) { levelModifier = 2.25 }
		if (this.level == 3) { levelModifier = 2.75 }
		if (this.level == 4) { levelModifier = 3.25 }
		if (this.level == 5) { levelModifier = 3.75 }
		if (this.level == 6) { levelModifier = 4.25 }
		if (this.level == 7) { levelModifier = 4.75 }
		if (this.level == 8) { levelModifier = 5.25 }
		if (this.level == 9) { levelModifier = 5.50 }
		if (this.level >= 10) { levelModifier = 5.75 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Fury',
		refName: 'fury',
		duration: 30000,
		stacks: 0,
		maxStacks: function() {
			return 3
		},
		get bonusModifier() {
			//50% bonus damage to regular attack at all levels
			return 0.5
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You lunge forward, pluging your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[0].name} `, `${weapon[0].color}`, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[1].name} `, `${weapon[1].color}`, line1)
		customizeEachWord(`into the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You attempt a `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`attack on the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`, but your attack goes wide and you `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.dualStrike)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.dualStrike)
	},
}
player.dualStrike = { ...dualStrike}


const bladeBlitz = {
	level: 1,
	name: 'Blade Blitz',
	refName: 'bladeBlitz',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	numberOfSwings: function() {
		return player.might
	},
	resourceName: 'might',
	resourceCost: function() {
		return	player.might == 0 ? 1 : player.might
	},
	weaponTypesUsed: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5 }
		if (this.level == 2) { levelModifier = 1.7 }
		if (this.level == 3) { levelModifier = 1.9 }
		if (this.level == 4) { levelModifier = 1.9 }
		if (this.level == 5) { levelModifier = 2.1 }
		if (this.level == 6) { levelModifier = 2.1 }
		if (this.level == 7) { levelModifier = 2.1 }
		if (this.level == 8) { levelModifier = 2.3 }
		if (this.level == 9) { levelModifier = 2.3 }
		if (this.level >= 10) { levelModifier = 2.5 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You swing furiously with your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[0].name} `, weapon[0].color, line1)
		customizeEachWord(`and `, 'warrior-color', line1)
		customizeEachWord(`${weapon[1].name} `, weapon[1].color, line1)
		customizeEachWord(`in a blur of blades, eviscerating the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},	
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`swing at the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`goes wide and you `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	numberOfHits: function(weapon1, weapon2) {
		let minimumHits
		let maximumHits
		let totalHits
		if (weapon1 != undefined && weapon2 != undefined) {
			minimumHits = 2
			maximumHits = 3 + player.bladeBlitz.level
		}
		 else if (weapon2 == undefined && weapon1 != undefined) {
			minimumHits = 1
			maximumHits = 2

		} else if (weapon1 == undefined && weapon2 != undefined) {
			minimumHits = 1
			maximumHits = 2
		}
		totalHits = randomNumberRange(minimumHits, maximumHits)
		quickMessage(`Minimum Hits: ${minimumHits}`)
		quickMessage(`Maximum Hits: ${maximumHits}`)
		quickMessage(`Number of Hits: ${totalHits}`)
		return totalHits
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.bladeBlitz)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.bladeBlitz)
	},
}
player.bladeBlitz = { ...bladeBlitz}

const shred = {
	level: 1,
	name: 'Shred',
	refName: 'shred',
	type: 'ability',
	color: 'warrior-color',
	cooldown: 10000,
	cooldownSet: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 2,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5 }
		if (this.level == 2) { levelModifier = 1.7 }
		if (this.level == 3) { levelModifier = 1.9 }
		if (this.level == 4) { levelModifier = 1.9 }
		if (this.level == 5) { levelModifier = 2.1 }
		if (this.level == 6) { levelModifier = 2.1 }
		if (this.level == 7) { levelModifier = 2.1 }
		if (this.level == 8) { levelModifier = 2.3 }
		if (this.level == 9) { levelModifier = 2.3 }
		if (this.level >= 10) { levelModifier = 2.5 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Shred',
		refName: 'shred',
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		slashingArmor: -5,
		piercingArmor: -5,
		bluntArmor: -5,
		stacks: 1,
		duration: 20000,
		maxStacks: function() {
			return 5
		},
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You aim your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[0].name} `, weapon[0].color, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[1].name} `, weapon[1].color, line1)
		customizeEachWord(`carefully, swinging at the weakest spots in the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(` armor!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},	
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You attempt to `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`, but your attack goes wide and you `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shred)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shred)
	},
}
player.shred = { ...shred }



const valorStrike = {
	level: 1,
	name: 'Valor Strike',
	refName: 'valorStrike',
	type: 'ability',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 1,
	weaponTypesUsed: ['shields', 'oneHanded'],
	valorBonus: function() {
		if (this.level == 1) {return 1.10}
		if (this.level == 2) {return 1.15}
		if (this.level == 3) {return 1.20}
		if (this.level == 4) {return 1.25}
		if (this.level == 5) {return 1.30}
		if (this.level == 6) {return 1.35}
		if (this.level == 7) {return 1.40}
		if (this.level == 8) {return 1.45}
		if (this.level == 9) {return 1.50}
		if (this.level >= 10) {return 1.55}
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight()
		let levelModifier
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.1}
		if (this.level == 3) { levelModifier = 1.2}
		if (this.level == 4) { levelModifier = 1.3}
		if (this.level == 5) { levelModifier = 1.4}
		if (this.level == 6) { levelModifier = 1.5}
		if (this.level == 7) { levelModifier = 1.6}
		if (this.level == 8) { levelModifier = 1.7}
		if (this.level == 9) { levelModifier = 1.8}
		if (this.level >= 10) { levelModifier = 1.9}
		let bonusModifier = this.valorBonus()
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage * bonusModifier
		return Math.ceil(totalDamage)
	},
	buff: {
		name: 'Valor',
		refName: 'valor',
		duration: 30000,
		stacks: 1,
		maxStacks: function() {
			return player.valorStrike.level + 5
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You manifest your Valor into your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon.name}`, weapon.color, line1)
		customizeEachWord(`, striking the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`with a vengence!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You swing your sword at the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`with your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`but `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.valorStrike)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.valorStrike)
	},
}
player.valorStrike = { ...valorStrike}

const shieldSlam = {
	level: 1,
	name: 'Shield Slam',
	refName: 'shieldSlam',
	type: 'ability',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 2,
	numberOfTargets: function() {
		return this.level + 1
	},
	weaponTypesUsed: ['shields'],
	damage: function () {
		let baseAttackDamage = baseAttackDamageRight()
		let baseWeightDamage = baseWeightDamage()
		let baseDamage = baseAttackDamage + baseWeightDamage
		let levelModifier
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.25}
		if (this.level == 3) { levelModifier = 1.50}
		if (this.level == 4) { levelModifier = 1.75}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.25}
		if (this.level == 7) { levelModifier = 2.50}
		if (this.level == 8) { levelModifier = 2.75}
		if (this.level == 9) { levelModifier = 3.0}
		if (this.level >= 10) { levelModifier = 3.25}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Shield Slam',
		refName: 'shieldSlam',
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		get slashingArmor() {
			if (player.shieldSlam.level == 1) {return -5}
			if (player.shieldSlam.level == 2) {return -10}
			if (player.shieldSlam.level == 3) {return -15}
			if (player.shieldSlam.level == 4) {return -20}
			if (player.shieldSlam.level >= 5) {return -25}
		},
		get piercingArmor() {
			if (player.shieldSlam.level == 1) {return -5}
			if (player.shieldSlam.level == 2) {return -10}
			if (player.shieldSlam.level == 3) {return -15}
			if (player.shieldSlam.level == 4) {return -20}
			if (player.shieldSlam.level >= 5) {return -25}
		},
		get bluntArmor() {
			if (player.shieldSlam.level == 1) {return -5}
			if (player.shieldSlam.level == 2) {return -10}
			if (player.shieldSlam.level == 3) {return -15}
			if (player.shieldSlam.level == 4) {return -20}
			if (player.shieldSlam.level >= 5) {return -25}
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, shield, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${shield.name} `, shield.color, line1)
		customizeEachWord(`slams into the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1 )
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorText2: function(shield) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You swing your shield in a wide arc, slamming your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${shield.name} `, shield.color, line1)
		customizeEachWord(`into the enemy!`, `warrior-ability-text-color`, line1)

	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You swing your shield in a wide arc at the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shieldSlam)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shieldSlam)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Shield Slam deals damage and lowers the armor of all penetration types of the enemy. The number of targets hit is equal to this skill's level. Shield Slam gains bonus damage based on your weight and armor.`, 'white', line1)
		blankSpace()
	},
}
player.shieldSlam = { ...shieldSlam}

const boomingMight = {
	level: 1,
	name: 'Booming Might',
	refName: 'boomingMight',
	type: 'ability',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 3,
	weaponTypesUsed: ['oneHanded', 'shields'],
	buff: {
		name: 'Valor',
		refName: 'valor',
		duration: 30000,
		stacks: 0,
		maxStacks: function() {
			return player.valorStrike.level + 5
		},
		type: 'debuff',
	},
	damage: function () {
		let baseAttackDamage = baseAttackDamageRight()
		let weightDamage = baseWeightDamage()
		let baseDamage = baseAttackDamage + weightDamage
		let levelModifier
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.25}
		if (this.level == 3) { levelModifier = 1.50}
		if (this.level == 4) { levelModifier = 1.75}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.25}
		if (this.level == 7) { levelModifier = 2.50}
		if (this.level == 8) { levelModifier = 2.75}
		if (this.level == 9) { levelModifier = 3.0}
		if (this.level >= 10) { levelModifier = 3.25}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage 
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You hurl a shockwave of `, `warrior-ability-text-color`, line1)
		customizeEachWord(`Might `, `warrior-color`, line1)
		customizeEachWord(`, blasting the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorText2: function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`Throwing back your arms with a mighty yell, you unleash a `, `warrior-ability-text-color`, line2)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`!`, `warrior-ability-text-color`, line2)
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`The shockwave goes hurling toward the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`misses`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.boomingMight)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.boomingMight)
	},
}
player.boomingMight = { ...boomingMight}

const ambush = {
	level: 1,
	name: 'Ambush',
	refName: 'ambush',
	cooldown: 5000,
	cooldownSet: 5000,
	resourceName: 'adrenaline',
	resourceCost: 15,
	weaponTypesUsed: ['daggers'],
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 2.0,
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelModifier
		if (this.level == 1) { levelModifier = 2.0}
		if (this.level == 2) { levelModifier = 2.3}
		if (this.level == 3) { levelModifier = 2.6}
		if (this.level == 4) { levelModifier = 2.9}
		if (this.level == 5) { levelModifier = 3.2}
		if (this.level == 6) { levelModifier = 3.5}
		if (this.level == 7) { levelModifier = 3.8}
		if (this.level == 8) { levelModifier = 4.1}
		if (this.level == 9) { levelModifier = 4.4}
		if (this.level >= 10) { levelModifier = 4.7}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Ambush while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap from the shadows, `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`ambushing the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`, plunging your `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon[0].name} `, weapon[0].color, line1)
		customizeEachWord(`deep into its spine!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextSpecial: function() {
		let line1 = lineFunc()
		customizeEachWord(`The kill was so deft, you were completely unheard, and you immediately leap back into the shadows.`, 'grey', line1)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`In an attempt to `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, you miscalculate and `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.ambush)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.ambush)
	},
}
player.ambush = { ...ambush }

const backstab = {
	level: 1,
	name: 'Backstab',
	refName: 'backstab',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 10,
	weaponTypesUsed: ['daggers'],
	rightWeaponTypes: ['daggers'],
	leftWeaponTypes: ['daggers'],
	damage: function () {
		let baseDamage = baseAttackDamageRight()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5}
		if (this.level == 2) { levelModifier = 2.0}
		if (this.level == 3) { levelModifier = 2.5}
		if (this.level == 4) { levelModifier = 3.0}
		if (this.level == 5) { levelModifier = 3.5}
		if (this.level == 6) { levelModifier = 4.0}
		if (this.level == 7) { levelModifier = 4.5}
		if (this.level == 8) { levelModifier = 5.0}
		if (this.level == 9) { levelModifier = 5.5}
		if (this.level >= 10) { levelModifier = 6.0}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform backstab while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	debuff: {
		name: 'Sinister Mark',
		refName: 'sinisterMark',
		stacks: 0,
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		maxLevel: 10,
		get slashingArmor() {
			if (player.sinisterMark.level == 1) {return -2}
			if (player.sinisterMark.level == 2) {return -4}
			if (player.sinisterMark.level == 3) {return -6}
			if (player.sinisterMark.level == 4) {return -8}
			if (player.sinisterMark.level == 5) {return -10}
			if (player.sinisterMark.level == 6) {return -12}
			if (player.sinisterMark.level == 7) {return -14}
			if (player.sinisterMark.level == 8) {return -16}
			if (player.sinisterMark.level == 9) {return -18}
			if (player.sinisterMark.level >= 10) {return -20}
			else {return 0}
		},
		get piercingArmor() {
			if (player.sinisterMark.level == 1) {return -2}
			if (player.sinisterMark.level == 2) {return -4}
			if (player.sinisterMark.level == 3) {return -6}
			if (player.sinisterMark.level == 4) {return -8}
			if (player.sinisterMark.level == 5) {return -10}
			if (player.sinisterMark.level == 6) {return -12}
			if (player.sinisterMark.level == 7) {return -14}
			if (player.sinisterMark.level == 8) {return -16}
			if (player.sinisterMark.level == 9) {return -18}
			if (player.sinisterMark.level >= 10) {return -20}
			else {return 0}
		},		
		get bluntArmor() {
			if (player.sinisterMark.level == 1) {return -2}
			if (player.sinisterMark.level == 2) {return -4}
			if (player.sinisterMark.level == 3) {return -6}
			if (player.sinisterMark.level == 4) {return -8}
			if (player.sinisterMark.level == 5) {return -10}
			if (player.sinisterMark.level == 6) {return -12}
			if (player.sinisterMark.level == 7) {return -14}
			if (player.sinisterMark.level == 8) {return -16}
			if (player.sinisterMark.level == 9) {return -18}
			if (player.sinisterMark.level >= 10) {return -20}
			else {return 0}
		},		
		maxStacks: function() {
			return player.backstab.level + 1
		},
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slip behind the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and sink your `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.backstab)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.backstab)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Backstab deals single target damage based on your right hand weapon. It also applies a Sinister Mark to the target lowering its slashing, piercing, and blunt armor types by a small amount. This effect stacks to an amount equal to Backstab's level + 1.`, 'white', line1)
		blankSpace()
	},
}
player.backstab = { ...backstab }

const guillotine = {
	level: 1,
	name: 'Guillotine',
	refName: 'guillotine',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 10,
	weaponTypesUsed: ['daggers'],
	rightWeaponTypes: ['daggers'],
	leftWeaponTypes: ['daggers'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let bonusEnemyMissingHealthModifier = ((enemy.maxHealth - enemy.health) / enemy.maxHealth) + 1
		let baseDamageAndBonusDamage = baseDamage * bonusEnemyMissingHealthModifier
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.25}
		if (this.level == 3) { levelModifier = 1.50}
		if (this.level == 4) { levelModifier = 1.75}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.25}
		if (this.level == 7) { levelModifier = 2.50}
		if (this.level == 8) { levelModifier = 2.75}
		if (this.level == 9) { levelModifier = 3.25}
		if (this.level >= 10) { levelModifier = 3.5}
		let baseAndLevelDamage = baseDamageAndBonusDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Guillotine while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You blink forward at the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`slashing with your `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`across its throat!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextAdrenalineGain: function() {
		let line1 = lineFunc()
		customizeEachWord(`Guillotine `, this.color, line1)
		customizeEachWord(`consumes the Sinister Marks on the target before it dies granting you Adrenaline!`, `sinistral-ability-text-color`, line1)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You blink forward at the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.guillotine)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.guillotine)
	},
}
player.guillotine = { ...guillotine }

const venomBlade = {
	level: 1,
	name: 'Venom Blade',
	refName: 'venomBlade',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		//5 and 5 = 10
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft())
		let bonusDamage = enemy.debuffs?.poison ? (enemy.debuffs?.poison.stacks * 0.2) + 1 : 0
		let baseAndBonusDamage = baseDamage + bonusDamage
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.1}
		if (this.level == 3) { levelModifier = 1.2}
		if (this.level == 4) { levelModifier = 1.3}
		if (this.level == 5) { levelModifier = 1.4}
		if (this.level == 6) { levelModifier = 1.5}
		if (this.level == 7) { levelModifier = 1.6}
		if (this.level == 8) { levelModifier = 1.7}
		if (this.level == 9) { levelModifier = 1.8}
		if (this.level >= 10) { levelModifier = 1.9}
		let totalDamage = baseAndBonusDamage * levelModifier
		return Math.ceil(totalDamage)
	},
	// debuff: {
	// 	name: 'Poison',
	// 	refName: 'poison',
	// 	stacks: 0,
	// 	damage: function(swingObject) {
	// 		return 0
	// 	},
	// 	maxStacks: function() {
	// 		return 5
	// 	},
	// },
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You lacerate the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`with your venom coated `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You swing your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`at the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to lacerate it with `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.venomBlade)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.venomBlade)
	},
}
player.venomBlade = { ...venomBlade }

const contagion = {
	level: 1,
	name: 'Contagion',
	refName: 'contagion',
	cooldown: 2500,
	cooldownSet: 2500,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 5,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft())
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.2}
		if (this.level == 3) { levelModifier = 1.4}
		if (this.level == 4) { levelModifier = 1.6}
		if (this.level == 5) { levelModifier = 1.8}
		if (this.level == 6) { levelModifier = 2.0}
		if (this.level == 7) { levelModifier = 2.2}
		if (this.level == 8) { levelModifier = 2.4}
		if (this.level == 9) { levelModifier = 2.6}
		if (this.level >= 10) { levelModifier = 2.8}
		let totalDamage = baseDamage * levelModifier
		return Math.ceil(totalDamage)
	},
	// debuff: {
	// 	name: 'Poison',
	// 	refName: 'poison',
	// 	resistType: 'poisonResist',
	// 	penType: 'poisonPen',
	// 	stacks: 0,
	// 	get duration() {
	// 		return Math.trunc(60000 * player.contagion.level)
	// 	} ,
	// 	color: 'dark-green',
	// 	damage: function(swingObject) {
	// 		let baseDamage = player.currentWeaponSkill.attackPower
	// 		let bonusDamage = this.stacks * player.contagion.level
	// 		let totalDamage = baseDamage + bonusDamage + 1000
	// 		return Math.ceil(totalDamage)
	// 	},
	// 	maxStacks: function() {
	// 		return 10
	// 	},
	// 	flavorText: function(enemy, damage, element, damageResisted) {
	// 		let line1 = lineFunc()
	// 		customizeEachWord(`You hit for `, 'green', line1)
	// 		customizeEachWord(`${damage} `, 'light-blue', line1)
	// 		customizeEachWord(`additional `, 'green', line1)
	// 		customizeEachWord(`poison `, `dark-green`, line1)
	// 		customizeEachWord(`damage. `, `green`, line1)
	// 		customizeEachWord(`(Enemy resists `, `white`, line1)
	// 		customizeEachWord(`${damageResisted}`, `light-blue`, line1)
	// 		customizeEachWord(`)`, `white`, line1)
	// 	},
	// 	flavorTextWearsOff: function() {
	// 		let line1 = lineFunc()
	// 		customizeEachWord(`${this.name} `, 'dark-green', line1)
	// 		customizeEachWord(`has faded from your weapon`, 'white', line1)
	// 	},
	// 	flavorTextApplyBuff: function() {
	// 		let line1 = lineFunc()
	// 		customizeEachWord(`Your weapon glows green with `, 'white', line1)
	// 		customizeEachWord(`${this.name}`, 'dark-green', line1)
	// 	}
	// },
	buff: {
		name: 'Poison',
		refName: 'poison',
		resistType: 'poisonResist',
		penType: 'poisonPen',
		duration: 30000,
		stacks: 0,
		damage: function(enemy) {
			let totalDamage = baseAttackDamageRight()
			if (enemy.debuffs) {
				if (enemy.debuffs.shadowMark) {
					let stacks = enemy.debuffs.shadowMark.stacks
					totalDamage = totalDamage * stacks
				}
			}
			return totalDamage
		},
		maxStacks: function() {
			return 20
		},
		flavorText: function(enemy, damage) {
			let line1 = lineFunc()
			customizeEachWord(`You hit for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`poison damage.`, 'poison', line1)
		},
		type: 'mark',
		color: 'poison',
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Contagion while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You stab the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`with your off-hand `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`injecting it with `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, ) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You stab at the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to infect it with `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`, but you `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'sinistral-ability-text-color', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.contagion)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.contagion)
	},
}
player.contagion = { ...contagion }

const bane = {
	level: 1,
	name: 'Bane',
	refName: 'bane',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let poisonStacks = enemy.debuffs?.poison?.stacks ? (enemy.debuffs.poison.stacks * 0.2) + 1 : 0
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft())
		let baseAndBonusDamage = baseDamage * poisonStacks
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.25}
		if (this.level == 2) { levelModifier = 1.75}
		if (this.level == 3) { levelModifier = 2.25}
		if (this.level == 4) { levelModifier = 2.75}
		if (this.level == 5) { levelModifier = 3.25}
		if (this.level == 6) { levelModifier = 3.5}
		if (this.level == 7) { levelModifier = 2.8}
		if (this.level == 8) { levelModifier = 3.1}
		if (this.level == 9) { levelModifier = 3.4}
		if (this.level >= 10) { levelModifier = 3.7}
		//Percent Bonus Damage currently set to 20% bonus damage per stack
		let totalDamage = baseAndBonusDamage * levelModifier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap onto the back of the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`sinking your `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back! Your blade siphons the poison from the enemy, draining its life force!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap at the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to strike it with `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`, but you narrowly `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.bane)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.bane)
	},
}
player.bane = { ...bane }

const shadowDaggers = {
	level: 1,
	name: 'Shadow Daggers',
	refName: 'shadowDaggers',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	numberOfHits: function() {
		return 2 + this.level
	},
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.2}
		if (this.level == 2) { levelModifier = 1.4}
		if (this.level == 3) { levelModifier = 1.6}
		if (this.level == 4) { levelModifier = 1.8}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.2}
		if (this.level == 7) { levelModifier = 2.4}
		if (this.level == 8) { levelModifier = 2.6}
		if (this.level == 9) { levelModifier = 2.8}
		if (this.level >= 10) { levelModifier = 3.0}
		//Percent Bonus Damage currently set to 20% bonus damage per stack
		let totalDamage = baseDamage * levelModifier
		return Math.ceil(totalDamage)	
	},
	debuff: [
		{
			name: 'Reduced Accuracy',
			refName: 'reducedAccuracy',
			modifiedStats: ['accuracy'],
			accuracy: -7,
			duration: 20000,
			stacks: 0,
			maxStacks: function() {
				return player.shadowDaggers.level
			},
		},
		{
			name: 'Reduced Defense',
			refName: 'reducedDefense',
			modifiedStats: ['slashingArmor'],
			slashingArmor: -10,
			duration: 20000,
			stacks: 0,
			maxStacks: function() {
				return player.shadowDaggers.level
			},
		},
		{
			name: 'Reduced Dodge',
			refName: 'reducedDodge',
			modifiedStats: ['dodge'],
			dodge: -10,
			duration: 20000,
			stacks: 0,
			maxStacks: function() {
				return player.shadowDaggers.level
			},
		}
	],
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked, index) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let tellPlayerWhatDebuffGotApplied = ['accuracy', 'dodge', 'armor']
		blankSpace()
		customizeEachWord(`You throw a dagger at the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`hitting it and reducing its ${tellPlayerWhatDebuffGotApplied[index]}!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You throw a `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`Shadow Dagger `, this.color, line1)
		customizeEachWord(`at the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`but `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowDaggers)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowDaggers)
	},
}
player.shadowDaggers = { ...shadowDaggers }

const shadowsurge = {
	level: 1,
	name: 'Shadowsurge',
	refName: 'shadowsurge',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	element: 'shadow',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy, doesPlayerShadowStep) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let totalDamage = 0
		if (doesPlayerShadowStep) {
			//Calculate damage for shadowstep
			let levelMultiplier
			if (player.shadowsurge.level == 1) { levelMultiplier = 1.25}
			if (player.shadowsurge.level == 2) { levelMultiplier = 1.35}
			if (player.shadowsurge.level == 3) { levelMultiplier = 1.45}
			if (player.shadowsurge.level == 4) { levelMultiplier = 1.55}
			if (player.shadowsurge.level == 5) { levelMultiplier = 1.65}
			if (player.shadowsurge.level == 6) { levelMultiplier = 1.75}
			if (player.shadowsurge.level == 7) { levelMultiplier = 1.85}
			if (player.shadowsurge.level == 8) { levelMultiplier = 1.95}
			if (player.shadowsurge.level == 9) { levelMultiplier = 2.05}
			if (player.shadowsurge.level >= 10) { levelMultiplier = 2.15}
			totalDamage = baseDamage * levelMultiplier
		} else {
			//Calculate damage for shadowsurge
			let levelMultiplier
			let shadowMarkMultiplier = enemy.debuffs?.shadowMark?.stacks ? enemy.debuffs.shadowMark.stacks * 0.2 : 0
			if (player.shadowsurge.level == 1) { levelMultiplier = 1.1 }
			if (player.shadowsurge.level == 2) { levelMultiplier = 1.2 }
			if (player.shadowsurge.level == 3) { levelMultiplier = 1.3 }
			if (player.shadowsurge.level == 4) { levelMultiplier = 1.4 }
			if (player.shadowsurge.level == 5) { levelMultiplier = 1.5 }
			if (player.shadowsurge.level == 6) { levelMultiplier = 1.6 }
			if (player.shadowsurge.level == 7) { levelMultiplier = 1.7 }
			if (player.shadowsurge.level == 8) { levelMultiplier = 1.8 }
			if (player.shadowsurge.level == 9) { levelMultiplier = 1.9 }
			if (player.shadowsurge.level >= 10) { levelMultiplier = 2.0 }
			totalDamage = (levelMultiplier + shadowMarkMultiplier) * baseDamage
		}
		return Math.ceil(totalDamage)
	},
	buff: {
		name: 'Shadowbane',
		refName: 'shadowbane',
		duration: 30000,
		stacks: 1,
		dodge: 10,
		maxStacks: function() {
			return 10
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked, doesPlayerShadowStep) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You travel through the shadows behind the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`sinking your `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
			customizeEachWord(`into its back!`, `sinistral-ability-text-color`, line1)
			customizeEachWord(`Shadow Step `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${penetrationType} `, penetrationType, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		}
		if (!doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You call upon the Shadows swirling around the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`to consume it, draining its lifeforce!`, `sinistral-ability-text-color`, line1)
			customizeEachWord(`Shadowsurge `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`shadow `, 'shadow', line2)
			customizeEachWord(`damage.`, `green`, line2)
			customizeEachWord(` (Enemy resists `, `white`, line2)
			customizeEachWord(`${damageBlocked}`, `light-blue`, line2)
			customizeEachWord(`)`, `white`, line2)
			blankSpace()
		}
	},
	flavorTextRegularHit: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You flow through the shadows behind the enemy, and in a cross-slash motion of your daggers you eviscerate the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, doesPlayerShadowStep) {
		let line0 = lineFunc()
		let line1 = lineFunc()
		if (doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You travel through the shadows behind the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`attemping to strike it with your `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
			customizeEachWord(`but `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`miss`, 'red', line1)
			customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
			blankSpace()
		}
		if (!doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You attempt to eviscerate the enemy with `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			customizeEachWord(`, but `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`miss`, `red`, line1)
			customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
			blankSpace()
		}
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowsurge)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowsurge)
	},
}
player.shadowsurge = { ...shadowsurge }
const shadowNova = {
	level: 1,
	name: 'Shadow Nova',
	refName: 'shadowNova',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let bonusDamageModifier = 1
		let totalDamage = baseDamage * bonusDamageModifier
		if (player?.buffs?.shadowbane) {
			if (player.buffs.shadowbane.stacks == 1) {bonusDamageModifier = 1.0}
			if (player.buffs.shadowbane.stacks == 2) {bonusDamageModifier = 1.1}
			if (player.buffs.shadowbane.stacks == 3) {bonusDamageModifier = 1.25}
			if (player.buffs.shadowbane.stacks == 4) {bonusDamageModifier = 1.45}
			if (player.buffs.shadowbane.stacks == 5) {bonusDamageModifier = 1.70}
			if (player.buffs.shadowbane.stacks == 6) {bonusDamageModifier = 2.0}
			if (player.buffs.shadowbane.stacks == 7) {bonusDamageModifier = 2.35}
			if (player.buffs.shadowbane.stacks == 8) {bonusDamageModifier = 2.75}
			if (player.buffs.shadowbane.stacks == 9) {bonusDamageModifier = 3.25}
			if (player.buffs.shadowbane.stacks == 10) {bonusDamageModifier = 4.0}
		}
		return Math.ceil(totalDamage)
	},
	regularDamage: function(enemy) {
		//base regular damage is combined weapon damage
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let totalDamage = 0
		//Calculate damage for shadowsurge
		let bonusDamageMod = enemy.debuffs?.shadowMark?.stacks ? enemy.debuffs.shadowMark.stacks : 0
		let bonusDamageTotal = (baseDamage * 1.20) * bonusDamageMod
		totalDamage = baseDamage + bonusDamageTotal
		return Math.ceil(totalDamage)
	}, 
	buff: {
		name: 'Shadowbane',
		refName: 'shadowbane',
		duration: 30000,
		stacks: 0,
		dodge: 10,
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You strike the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`with both daggers, releasing its stored energy and blasting it with `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			customizeEachWord(`!`, `sinistral-ability-text-color` , line1)
			customizeEachWord(`${this.name} `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`shadow `, 'shadow', line2)
			customizeEachWord(`damage.`, `green`, line2)
			customizeEachWord(` (Enemy resists `, `white`, line2)
			customizeEachWord(`${damageBlocked}`, `light-blue`, line2)
			customizeEachWord(`)`, `white`, line2)
			blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, doesPlayerShadowStep) {
		let line1 = lineFunc()
			blankSpace()
			customizeEachWord(`You dive at the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`with your daggers `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`but `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`miss`, 'red', line1)
			customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
			blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowNova)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowNova)
	},
}
player.shadowNova = { ...shadowNova }

const catalyst = {
	level: 1,
	name: 'Catalyst',
	refName: 'catalyst',
	cooldown: 4000,
	cooldownSet: 4000,
	type: 'ability',
	color: 'monk-color',
	multiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 10,
	sequence: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	duration: 10000,
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let penetrationType = calculatePenetrationRoll()
		let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
		// damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
		// damageBlocked = baseDamage - damageAfterArmor
		let quickJabLevelMultiplier
		let colossusPunchLevelMultiplier
		let gigasUppercutLevelMultiplier
		let atmaShockLevelMultiplier
		if (player.catalyst.level == 1) {quickJabLevelMultiplier = 1.1 
										colossusPunchLevelMultiplier = 1.3
										gigasUppercutLevelMultiplier  = 1.5
										atmaShockLevelMultiplier = 1.75	}		
		if (player.catalyst.level == 2) {quickJabLevelMultiplier = 1.2
										colossusPunchLevelMultiplier = 1.4
										gigasUppercutLevelMultiplier  = 1.6
										atmaShockLevelMultiplier = 1.85	}		
		if (player.catalyst.level == 3) {quickJabLevelMultiplier = 1.3 
										colossusPunchLevelMultiplier = 1.5
										gigasUppercutLevelMultiplier  = 1.7
										atmaShockLevelMultiplier = 1.95	}		
		if (player.catalyst.level == 4) {quickJabLevelMultiplier = 1.4 
										colossusPunchLevelMultiplier = 1.6
										gigasUppercutLevelMultiplier  = 1.8
										atmaShockLevelMultiplier = 2.05	}		
		if (player.catalyst.level == 5) {quickJabLevelMultiplier = 1.5 
										colossusPunchLevelMultiplier = 1.7
										gigasUppercutLevelMultiplier  = 1.9
										atmaShockLevelMultiplier = 2.15	}		
		if (player.catalyst.level == 6) {quickJabLevelMultiplier = 1.6 
										colossusPunchLevelMultiplier = 1.8
										gigasUppercutLevelMultiplier  = 2.0
										atmaShockLevelMultiplier = 2.25	}		
		if (player.catalyst.level == 7) {quickJabLevelMultiplier = 1.7 
										colossusPunchLevelMultiplier = 1.9
										gigasUppercutLevelMultiplier  = 2.1
										atmaShockLevelMultiplier = 2.35	}		
		if (player.catalyst.level == 8) {quickJabLevelMultiplier = 1.8 
										colossusPunchLevelMultiplier = 2.0
										gigasUppercutLevelMultiplier  = 2.2
										atmaShockLevelMultiplier = 2.45	}		
		if (player.catalyst.level == 9) {quickJabLevelMultiplier = 1.9
										colossusPunchLevelMultiplier = 2.1
										gigasUppercutLevelMultiplier  = 2.3
										atmaShockLevelMultiplier = 2.55	}		
		if (player.catalyst.level >= 10) {quickJabLevelMultiplier = 2.0 
										colossusPunchLevelMultiplier = 2.2
										gigasUppercutLevelMultiplier  = 2.4
										atmaShockLevelMultiplier = 2.1	}		

		let quickJabBaseDamage = Math.ceil(baseDamage * quickJabLevelMultiplier)
		let quickJabDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, quickJabBaseDamage, penetrationType)
		let quickJabDamageBlocked = quickJabBaseDamage - quickJabDamageAfterMitigation
		console.log(quickJabBaseDamage)
		console.log(quickJabDamageAfterMitigation)
		console.log(quickJabDamageBlocked)

		let colossusPunchBaseDamage = Math.ceil(baseDamage * colossusPunchLevelMultiplier)
		let colossusPunchDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, colossusPunchBaseDamage, penetrationType)
		let colossusPunchDamageBlocked = colossusPunchBaseDamage - colossusPunchDamageAfterMitigation

		let gigasUppercutBaseDamage = Math.ceil(baseDamage * gigasUppercutLevelMultiplier)
		let gigasUppercutDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, gigasUppercutBaseDamage, penetrationType)
		let gigasUppercutDamageBlocked = gigasUppercutBaseDamage - gigasUppercutDamageAfterMitigation

		let atmaShockBaseDamage = Math.ceil(baseDamage * atmaShockLevelMultiplier)
		let atmaShockDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, atmaShockBaseDamage, penetrationType)
		let atmaShockDamageBlocked = atmaShockBaseDamage - atmaShockDamageAfterMitigation

		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		//single -> double strength -> 2 - 3 successive attacks -> Strong AOE
		switch(this.sequence) {
			case 0:
			case 5:
			this.sequence = 1
			player.sequence = 1
			blankSpace()
			customizeEachWord(`You land a stiff jab on the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`! `, `monk-ability-text-color`, line1)
			customizeEachWord(`You knock it off balance lowering its dodge and accuracy!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Quick Jab `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${quickJabDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${quickJabDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, quickJabDamageAfterMitigation)
			debuff = {
				name: `Quick Jab's Blind and Hinderance`,
				refName: 'quickJab',
				modifiedStats: ['dodge', 'accuracy'],
				duration: 15000,
				dodge: -5,
				accuracy: -5,
			}
			applyDebuff(enemy, debuff)
			break
			case 1:
			this.sequence = 2
			player.sequence = 2
			customizeEachWord(`You follow up with a `, `monk-ability-text-color`, line1)
			customizeEachWord(`Colossus Punch`, `monk-ability-text-color`, line1)
			customizeEachWord(`, smashing into the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`and lowering its armor!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Colossus Punch `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${colossusPunchDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${colossusPunchDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, colossusPunchDamageAfterMitigation)
			debuff = {
				name: 'Colossus Punch: Blunt Armor Debuff',
				refName: 'colossusPunchDebuff',
				modifiedStats: ['bluntArmor'],
				duration: 15000,
				bluntArmor: -5
			}
			applyDebuff(enemy, debuff)
			break
			case 2:
			//HITS A SINGLE TARGET FOR DOUBLE DAMAGE - SHOULD CHANGE THIS ABILITY DAMAGE OR TWIN FIST STRIKE DAMAGE
			this.sequence = 3
			player.sequence = 3
			for (let i = 0; i < 3; i++) {
				let hydraStrikeBaseDamage = Math.ceil((baseAttackDamageLeft() + baseAttackDamageRight()) * 1.5)
				let hydraStrikeDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, hydraStrikeBaseDamage, penetrationType)
				let hydraStrikeBlockedDamage = hydraStrikeBaseDamage - hydraStrikeDamageAfterMitigation	
				if (enemy.health > 0) {
					let line1 = lineFunc()
					let line2 = lineFunc()
					let line3 = lineFunc()
					customizeEachWord(`You punch with blinding speed, pummeling the `, `monk-ability-text-color`, line1)
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`with `, `monk-ability-text-color`, line1)
					customizeEachWord(`Hydra Strike`, `monk-ability-text-color`, line1)
					customizeEachWord(`!`, `monk-ability-text-color`, line1)
					customizeEachWord(`Hydra Strike `, this.color, line2)
					customizeEachWord(`hits for `, 'green', line2)
					customizeEachWord(`${hydraStrikeDamageAfterMitigation} `, 'light-blue', line2)
					customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
					customizeEachWord(`damage. `, 'green', line2)
					customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
					customizeEachWord(`${hydraStrikeBlockedDamage}`, 'light-blue', line2)
					customizeEachWord(`)`, 'white', line2)
					blankSpace()
					applyDamageToEnemy(enemy, hydraStrikeDamageAfterMitigation)
				}
			}
			break;
			case 3:
			//HITS A SINGLE TARGET FOR TRIPLE DAMAGE
			//totaldamage
			this.sequence = 0
			player.sequence = 4
			customizeEachWord(`You dip down and blink forward with a `, `monk-ability-text-color`, line1)
			customizeEachWord(`Gigas Uppercut `, `monk-ability-text-color`, line1)
			customizeEachWord(`pulverizing the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Gigas Uppercut `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${gigasUppercutDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${gigasUppercutDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, gigasUppercutDamageAfterMitigation)
			break;
			case 4:
			//HITS ALL ENEMIES IN COMBAT FOR DOUBLE DAMAGE
			let getEnemiesInCombat = getAllEnemiesInCombat()
			this.sequence = 5
			player.sequence = 5
			getEnemiesInCombat.forEach(enemy => {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let line3 = lineFunc()
				customizeEachWord(`You unleash Atma Shock, smashing both fists into the ground sending a wave of energy at the `, this.color, line1)
				customizeEachWord(`${enemy.name}`, enemy.color, line1)
				customizeEachWord(`!`, this.color, line1)
				customizeEachWord(`Atma Shock `, this.color, line2)
				customizeEachWord(`hits for `, 'green', line2)
				customizeEachWord(`${atmaShockDamageAfterMitigation} `, 'light-blue', line2)
				customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
				customizeEachWord(`damage. `, 'green', line2)
				customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
				customizeEachWord(`${atmaShockDamageBlocked}`, 'light-blue', line2)
				customizeEachWord(`)`, 'white', line2)
				blankSpace()
				applyDamageToEnemy(enemy, atmaShockDamageAfterMitigation)
			})

			break;
		}
		clearTimeout(catalystTimeout)
		catalystTimeout = setTimeout(() => {
			this.sequence = 0
		}, this.duration)
		// return totalDamage
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	// flavorText: function(enemy, weapon, damage) {
	// 	let line1 = lineFunc()
	// 	let line2 = lineFunc()
	// 	customizeEachWord(`You slide behind the `, 'gray', line1)
	// 	customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
	// 	customizeEachWord(`and sink your `, 'gray', line1)
	// 	customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
	// 	customizeEachWord(`into its back!`, 'gray', line1)
	// 	customizeEachWord(`You hit for `, 'green', line2)
	// 	customizeEachWord(`${damage} `, 'light-blue', line2)
	// 	customizeEachWord(`damage.`, 'green', line2)
	// 	blankSpace()
	// },
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`swing your fist at the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.catalyst)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.catalyst)
	},
}
player.catalyst = { ...catalyst }
const tempest = {
	level: 1,
	name: 'Tempest',
	refName: 'tempest',
	color: 'monk-color',
	cooldown: 4000,
	cooldownSet: 4000,
	type: 'ability',
	multiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 10,
	sequence: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	duration: 2000,
	comboCollector:  {
		name: 'Combo Collector',
		refName: 'comboCollector',
		duration: 30000,
		stacks: 1,
		maxStacks: function() {
			return 5
		},
	},
	damage: function (enemy) {
		baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		penetrationType = calculatePenetrationRoll()
		penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
		damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
		damageBlocked = baseDamage - damageAfterArmor

		let meteorKickLevelMultiplier
		let behemothBashLevelMultiplier
		let flyingKneeLevelMultiplier
		let hurricaneKickLevelMultiplier
		if (player.tempest.level == 1) {meteorKickLevelMultiplier = 1.1 
										behemothBashLevelMultiplier = 1.3
										flyingKneeLevelMultiplier  = 1.5
										hurricaneKickLevelMultiplier = 1.75	}		
		if (player.tempest.level == 2) {meteorKickLevelMultiplier = 1.2
										behemothBashLevelMultiplier = 1.4
										flyingKneeLevelMultiplier  = 1.6
										hurricaneKickLevelMultiplier = 1.85	}		
		if (player.tempest.level == 3) {meteorKickLevelMultiplier = 1.3 
										behemothBashLevelMultiplier = 1.5
										flyingKneeLevelMultiplier  = 1.7
										hurricaneKickLevelMultiplier = 1.95	}		
		if (player.tempest.level == 4) {meteorKickLevelMultiplier = 1.4 
										behemothBashLevelMultiplier = 1.6
										flyingKneeLevelMultiplier  = 1.8
										hurricaneKickLevelMultiplier = 2.05	}		
		if (player.tempest.level == 5) {meteorKickLevelMultiplier = 1.5 
										behemothBashLevelMultiplier = 1.7
										flyingKneeLevelMultiplier  = 1.9
										hurricaneKickLevelMultiplier = 2.15	}		
		if (player.tempest.level == 6) {meteorKickLevelMultiplier = 1.6 
										behemothBashLevelMultiplier = 1.8
										flyingKneeLevelMultiplier  = 2.0
										hurricaneKickLevelMultiplier = 2.25	}		
		if (player.tempest.level == 7) {meteorKickLevelMultiplier = 1.7 
										behemothBashLevelMultiplier = 1.9
										flyingKneeLevelMultiplier  = 2.1
										hurricaneKickLevelMultiplier = 2.35	}		
		if (player.tempest.level == 8) {meteorKickLevelMultiplier = 1.8 
										behemothBashLevelMultiplier = 2.0
										flyingKneeLevelMultiplier  = 2.2
										hurricaneKickLevelMultiplier = 2.45	}		
		if (player.tempest.level == 9) {meteorKickLevelMultiplier = 1.9
										behemothBashLevelMultiplier = 2.1
										flyingKneeLevelMultiplier  = 2.3
										hurricaneKickLevelMultiplier = 2.55	}		
		if (player.tempest.level >= 10) {meteorKickLevelMultiplier = 2.0 
										behemothBashLevelMultiplier = 2.2
										flyingKneeLevelMultiplier  = 2.4
										hurricaneKickLevelMultiplier = 2.1	}

		let bonusMeteorKickDamage = Math.ceil((((enemy.health / enemy.maxHealth) * -1) + 1).toFixed(2))
		let meteorKickBaseDamage = Math.ceil((baseDamage * bonusMeteorKickDamage) + baseDamage)
		let meteorKickDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, meteorKickBaseDamage, penetrationType)
		let meteorKickDamageBlocked = meteorKickBaseDamage - meteorKickDamageAfterMitigation

		let behemothBashBaseDamage = baseDamage * behemothBashLevelMultiplier
		let behemothBashDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, behemothBashBaseDamage, penetrationType)
		let behemothBashDamageBlocked = behemothBashBaseDamage - behemothBashDamageAfterMitigation

		let flyingKneeBaseDamage = baseDamage * flyingKneeLevelMultiplier
		let flyingKneeDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, flyingKneeBaseDamage, penetrationType)
		let flyingKneeDamageBlocked = flyingKneeBaseDamage - flyingKneeDamageAfterMitigation

		let hurricaneKickBaseDamage = baseDamage * hurricaneKickLevelMultiplier
		let hurricaneKickDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, hurricaneKickBaseDamage, penetrationType)
		let hurricaneKickDamageBlocked = hurricaneKickBaseDamage - hurricaneKickDamageAfterMitigation
		
		let buff = {}
		let debuff = {}
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		switch(player.catalyst.sequence) {
			case 0:
			case 5:
			//ENEMY MISSING HEALTH BONUS DAMAGE FOR JUMP FLYING SIDE KICK
			blankSpace()
			customizeEachWord(`You leap at the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`crashing into it with Meteor Kick!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Meteor Kick `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${meteorKickDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${meteorKickDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			//MIGHT NOT NEED BUFF HERE ON THIS ABILITY
			// 	buff = {
			// 	refName: 'empoweringStrike',
			// 	duration: 200000,
			// 	maxStacks: function() {return 1}
			// 	// agi: 10,
			// }
			// applyBuff(buff)
			// loseResource(this.resourceName, this.resourceCost)
			applyDamageToEnemy(enemy, meteorKickDamageAfterMitigation)
			break
			case 1:
				buff = {
					name: 'tempest buff 1',
					refName: 'behemothBlitzBuff',
					duration: 15000,
					str: 1,
					dex: 1,
					agi: 1,
					stacks: 1,
					maxStacks: function() {return 5}
				}
			applyBuff(buff)
			blankSpace()
			customizeEachWord(`Focusing your energy to your legs, you deliver a Behemoth Blitz to the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`! `, `monk-ability-text-color`, line1)
			customizeEachWord(`You feel invigorated as you gain empowerment!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Behemoth `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${behemothBashDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${behemothBashDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, behemothBashDamageAfterMitigation)
			applyBuff(player.tempest.comboCollector)
			break
			case 2: //strength buff
			buff = {
				name: 'tempest buff 2',
				refName: 'flyingKneeBuff',
				duration: 15000,
				armor: 5,
				stacks: 1,
				maxStacks: function() {return 2}
			}
			applyBuff(buff)
			blankSpace()
			customizeEachWord(`You lunge forward with a Flying Knee smashing into the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Flying Knee `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${flyingKneeDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${flyingKneeDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, flyingKneeDamageAfterMitigation)
			applyBuff(player.tempest.comboCollector)
			break
			case 3: //agility buff
				totalDamage = Math.ceil(baseDamage)
				buff = {
				name: 'tempest buff 3',
				refName: 'agility-buff',
				duration: 20000,
				mys: 5,
				stacks: 1,
				maxStacks: function() {return 1}

			}
			applyBuff(buff)
			blankSpace()
			customizeEachWord(`You spin in a blurring whirl deliving a Hurricane Kick to the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Hurricane Kick `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${hurricaneKickDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${hurricaneKickDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, hurricaneKickDamageAfterMitigation)
			applyBuff(player.tempest.comboCollector)
			break
			case 4: //Armor Reduction on enemies
				totalDamage = Math.ceil(baseDamage)
				debuff = {
				name: 'tempest debuff 1',
				refName: 'sommerSaultKick',
				modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
				slashingArmor: -5,
				piercingArmor: -5,
				bluntArmor: -5,
				duration: 20000,
				}
				quickMessage(`Apply armor reduction to enemies`)
				let getEnemiesInCombat = getAllEnemiesInCombat()
				customizeEachWord(``, 'monk-color', line1)
				blankSpace()
				getEnemiesInCombat.forEach(enemy => {
					let line0 = lineFunc()
					let line1 = lineFunc()
					let line2 = lineFunc()
					let line3 = lineFunc()
					applyDebuff(enemy, debuff)
					totalDamage = randomNumberRange(lowDamage, highDamage)
					customizeEachWord(`**`, 'white', line0)
					customizeEachWord(`SHOCKWAVE`, 'activate-skill', line0)
					customizeEachWord(`**`, 'white', line0)
					customizeEachWord(` [4]`, 'white', line0)
					customizeEachWord(`The shockwave blasts the `, 'monk-color', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`!`, 'monk-color', line1)
					customizeEachWord(`You hit for `, 'green', line2)
					customizeEachWord(`${totalDamage} `, 'light-blue', line2)
					customizeEachWord(`damage.`, 'green', line2)
					blankSpace()
					applyDamageToEnemy(enemy, totalDamage)
					applyBuff(player.tempest.comboCollector)
				})
				break
		}
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	// flavorText: function(enemy, weapon, damage) {
	// 	let line1 = lineFunc()
	// 	let line2 = lineFunc()
	// 	customizeEachWord(`You slide behind the `, 'gray', line1)
	// 	customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
	// 	customizeEachWord(`and sink your `, 'gray', line1)
	// 	customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
	// 	customizeEachWord(`into its back!`, 'gray', line1)
	// 	customizeEachWord(`You hit for `, 'green', line2)
	// 	customizeEachWord(`${damage} `, 'light-blue', line2)
	// 	customizeEachWord(`damage.`, 'green', line2)
	// },
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.tempest)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.tempest)
	},
}
player.tempest = {...tempest}



const blazingFist = {
	level: 1,
	name: 'Blazing Fist',
	refName: 'blazingFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'fire',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.blazingFist.level == 1) { levelMultiplier = 1.1}
		if (player.blazingFist.level == 2) { levelMultiplier = 1.2}
		if (player.blazingFist.level == 3) { levelMultiplier = 1.3}
		if (player.blazingFist.level == 4) { levelMultiplier = 1.4}
		if (player.blazingFist.level == 5) { levelMultiplier = 1.5}
		if (player.blazingFist.level == 6) { levelMultiplier = 1.6}
		if (player.blazingFist.level == 7) { levelMultiplier = 1.7}
		if (player.blazingFist.level == 8) { levelMultiplier = 1.8}
		if (player.blazingFist.level == 9) { levelMultiplier = 1.9}
		if (player.blazingFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Blazing Fist',
		refName: 'blazingFist',
		duration: 15000,
		stacks: 0,
		maxStacks: function() {
			return player.blazingFist.level
		},
		type: 'seal',
		color: 'fire',
	},
	sealCombo: {
		name: 'Hydroplosion',
		refName: 'hydroplosion',
		type: 'seal combo',
		element: 'fire',
		color: 'fire',
		damage: function(enemy) {
			// let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
			let botDamage = player.mysticPower * player.blazingFist.botMultiplier
			let topDamage = player.mysticPower * player.blazingFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.blazingFist.level == 1) { levelMultiplier = 1.1}
			if (player.blazingFist.level == 2) { levelMultiplier = 1.2}
			if (player.blazingFist.level == 3) { levelMultiplier = 1.3}
			if (player.blazingFist.level == 4) { levelMultiplier = 1.4}
			if (player.blazingFist.level == 5) { levelMultiplier = 1.5}
			if (player.blazingFist.level == 6) { levelMultiplier = 1.6}
			if (player.blazingFist.level == 7) { levelMultiplier = 1.7}
			if (player.blazingFist.level == 8) { levelMultiplier = 1.8}
			if (player.blazingFist.level == 9) { levelMultiplier = 1.9}
			if (player.blazingFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the air around you into glowing orbs of fire around your hands. You dash forward, slamming them into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Blazing Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.blazingFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.blazingFist)
	},
}
player.blazingFist = { ...blazingFist }

const tidalFist = {
	level: 1,
	name: 'Tidal Fist',
	refName: 'tidalFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'water',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.tidalFist.level == 1) { levelMultiplier = 1.1}
		if (player.tidalFist.level == 2) { levelMultiplier = 1.2}
		if (player.tidalFist.level == 3) { levelMultiplier = 1.3}
		if (player.tidalFist.level == 4) { levelMultiplier = 1.4}
		if (player.tidalFist.level == 5) { levelMultiplier = 1.5}
		if (player.tidalFist.level == 6) { levelMultiplier = 1.6}
		if (player.tidalFist.level == 7) { levelMultiplier = 1.7}
		if (player.tidalFist.level == 8) { levelMultiplier = 1.8}
		if (player.tidalFist.level == 9) { levelMultiplier = 1.9}
		if (player.tidalFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'tidalFist',
		refName: 'tidalFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return player.tidalFist.level
		},
		type: 'seal',
		color: 'water',
	},
	sealCombo: {
		name: 'Hydroplosion',
		refName: 'hydroplosion',
		type: 'seal combo',
		element: 'water',
		color: 'water',
		damage: function(enemy) {
			let botDamage = player.mysticPower * player.tidalFist.botMultiplier
			let topDamage = player.mysticPower * player.tidalFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.tidalFist.level == 1) { levelMultiplier = 1.1}
			if (player.tidalFist.level == 2) { levelMultiplier = 1.2}
			if (player.tidalFist.level == 3) { levelMultiplier = 1.3}
			if (player.tidalFist.level == 4) { levelMultiplier = 1.4}
			if (player.tidalFist.level == 5) { levelMultiplier = 1.5}
			if (player.tidalFist.level == 6) { levelMultiplier = 1.6}
			if (player.tidalFist.level == 7) { levelMultiplier = 1.7}
			if (player.tidalFist.level == 8) { levelMultiplier = 1.8}
			if (player.tidalFist.level == 9) { levelMultiplier = 1.9}
			if (player.tidalFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the air around you into glowing orbs of water around your hands. You dash forward, slamming them into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Tidal Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.tidalFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.tidalFist)
	},
}
player.tidalFist = { ...tidalFist }
const quakeFist = {
	level: 1,
	name: 'Quake Fist',
	refName: 'quakeFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'earth',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Quake Fist',
		refName: 'quakeFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'seal',
		color: 'earth',
	},
	sealCombo: {
		name: 'Molten Quake',
		refName: 'moltenQuake',
		type: 'seal combo',
		element: 'earth',
		color: 'earth',
		debuff: {
			name: 'Molten Quake',
			refName: 'moltenQuake',
			duration: 15000,
			stacks: 0,
			maxStacks: function() {
				return player.quakeFist.level
			},
			// type: 'seal',
			color: 'dark-red',
		},
		damage: function(enemy) {
			// let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
			let botDamage = player.mysticPower * player.quakeFist.botMultiplier
			let topDamage = player.mysticPower * player.quakeFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.quakeFist.level == 1) { levelMultiplier = 1.1}
			if (player.quakeFist.level == 2) { levelMultiplier = 1.2}
			if (player.quakeFist.level == 3) { levelMultiplier = 1.3}
			if (player.quakeFist.level == 4) { levelMultiplier = 1.4}
			if (player.quakeFist.level == 5) { levelMultiplier = 1.5}
			if (player.quakeFist.level == 6) { levelMultiplier = 1.6}
			if (player.quakeFist.level == 7) { levelMultiplier = 1.7}
			if (player.quakeFist.level == 8) { levelMultiplier = 1.8}
			if (player.quakeFist.level == 9) { levelMultiplier = 1.9}
			if (player.quakeFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.quakeFist.level == 1) { levelMultiplier = 1.1}
		if (player.quakeFist.level == 2) { levelMultiplier = 1.2}
		if (player.quakeFist.level == 3) { levelMultiplier = 1.3}
		if (player.quakeFist.level == 4) { levelMultiplier = 1.4}
		if (player.quakeFist.level == 5) { levelMultiplier = 1.5}
		if (player.quakeFist.level == 6) { levelMultiplier = 1.6}
		if (player.quakeFist.level == 7) { levelMultiplier = 1.7}
		if (player.quakeFist.level == 8) { levelMultiplier = 1.8}
		if (player.quakeFist.level == 9) { levelMultiplier = 1.9}
		if (player.quakeFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the earth, pulling particals from the ground to form around your hands. Dashing forward, you deliver a Quake Fist to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Quake Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.quakeFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.quakeFist)
	},
}
player.quakeFist = { ...quakeFist }
const lightningFist = {
	level: 1,
	name: 'Lightning Fist',
	refName: 'lightningFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'lightning',
	color: 'yellow',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Lightning Fist',
		refName: 'lightningFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'seal',
		color: 'lightning',
	},
	sealCombo: {
		name: `Lightning Fist`,
		refName: 'lightningFist',
		type: 'seal combo',
		element: 'lightning',
		color: 'lightning',
		damage: function(enemy) {
			// let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
			let botDamage = player.mysticPower * player.lightningFist.botMultiplier
			let topDamage = player.mysticPower * player.lightningFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.lightningFist.level == 1) { levelMultiplier = 1.1}
			if (player.lightningFist.level == 2) { levelMultiplier = 1.2}
			if (player.lightningFist.level == 3) { levelMultiplier = 1.3}
			if (player.lightningFist.level == 4) { levelMultiplier = 1.4}
			if (player.lightningFist.level == 5) { levelMultiplier = 1.5}
			if (player.lightningFist.level == 6) { levelMultiplier = 1.6}
			if (player.lightningFist.level == 7) { levelMultiplier = 1.7}
			if (player.lightningFist.level == 8) { levelMultiplier = 1.8}
			if (player.lightningFist.level == 9) { levelMultiplier = 1.9}
			if (player.lightningFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.lightningFist.level == 1) { levelMultiplier = 1.1}
		if (player.lightningFist.level == 2) { levelMultiplier = 1.2}
		if (player.lightningFist.level == 3) { levelMultiplier = 1.3}
		if (player.lightningFist.level == 4) { levelMultiplier = 1.4}
		if (player.lightningFist.level == 5) { levelMultiplier = 1.5}
		if (player.lightningFist.level == 6) { levelMultiplier = 1.6}
		if (player.lightningFist.level == 7) { levelMultiplier = 1.7}
		if (player.lightningFist.level == 8) { levelMultiplier = 1.8}
		if (player.lightningFist.level == 9) { levelMultiplier = 1.9}
		if (player.lightningFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the air around you into lightning around your hands. Dashing forward, you deliver a Lightning Fist to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Lightning Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.lightningFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.lightningFist)
	},
}
player.lightningFist = { ...lightningFist }
const elementalTempest = {
	level: 1,
	name: 'Elemental Tempest',
	refName: 'elementalTempest',
	cooldown: 1000,
	cooldownSet: 1000,
	color: 'monk-color',
	topMultiplier: 2.0,
	botMultiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	buff: {
		name: 'Lightning Fist',
		refName: 'lightningFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'seal',
		color: 'lightning',
	},
	damage: function() {
		let baseDamagePhysical = baseAttackDamageRight() + baseAttackDamageLeft()
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
		let baseDamage = baseDamagePhysical + baseDamageMystic
		let levelMultiplier
		if (player.elementalTempest.level == 1) { levelMultiplier = 1.1}
		if (player.elementalTempest.level == 2) { levelMultiplier = 1.2}
		if (player.elementalTempest.level == 3) { levelMultiplier = 1.3}
		if (player.elementalTempest.level == 4) { levelMultiplier = 1.4}
		if (player.elementalTempest.level == 5) { levelMultiplier = 1.5}
		if (player.elementalTempest.level == 6) { levelMultiplier = 1.6}
		if (player.elementalTempest.level == 7) { levelMultiplier = 1.7}
		if (player.elementalTempest.level == 8) { levelMultiplier = 1.8}
		if (player.elementalTempest.level == 9) { levelMultiplier = 1.9}
		if (player.elementalTempest.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	aquaVoltDamage: function() {
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	thunderBlazeDamage: function() {
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	hydroplosionDamage: function() {
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You shape your hands, thrusting a double palm strike into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, `monk-color`, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextAquaVolt: function(enemy, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`Elemental Tempest reacts with the energy from Aqua Volt!`, `monk-ability-text-color`, line1)
		customizeEachWord(`A torrent of water and electricity erupt from your palms, blasting the `, `monk-ability-text-color`, line2)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line2)
		customizeEachWord(`!`, `monk-ability-text-color`, line2)
		customizeEachWord(`${this.name} `, penetrationType, line3)
		customizeEachWord(`hits for `, 'green', line3)
		customizeEachWord(`${damage} `, 'light-blue', line3)
		customizeEachWord(`${penetrationType} `, penetrationType, line3)
		customizeEachWord(`damage. `, 'green', line3)
		customizeEachWord(`(Enemy resists `, 'white', line3)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line3)
		customizeEachWord(`)`, 'white', line3)
		blankSpace()
	},
	flavorTextThunderBlaze: function(enemy, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Fire and lightning explode from your palms engulfing every enemy in front of you, searing and electrocuting the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, penetrationType, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextHydroplosion: function(enemy, damage, penetrationType, damageBlocked) {
		quickMessage(`${penetrationType} - penetration type`)
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Water and fire combine into a swirling orb of elemental energy before bursting in a blinding explosion, blasting the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and nearby enemies!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, penetrationType, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextHydroplosionAdditionalTargets: function(enemy, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`The blast from Hydroplosion scorches the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, `lightning`, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Lightning Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.elementalTempest)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.elementalTempest)
	},
}
player.elementalTempest = { ...elementalTempest }

const transcendence = {
	level: 1,
	name: 'Transcendence',
	refName: 'transcendence',
	cooldown: 1000,
	cooldownSet: 1000,
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	hydroplosionFire:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		skillEnhanced: {
			name: 'cleave',
			get level() {
				return player.transcendence.level
			},
		},
		buff: true,
		seal: true,
		duration: 30000,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	hydroplosionWater:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 30000,
		color: 'water',
		element: 'water',
		resistType: 'waterResist',
		penType: 'waterPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	thunderBlazeFire:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 30000,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	thunderBlazeLightning:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'lightning',
		element: 'lightning',
		resistType: 'lightningResist',
		penType: 'lightningPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	aquaVoltWater:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'water',
		element: 'water',
		resistType: 'waterResist',
		penType: 'waterPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	aquaVoltLightning:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'lightning',
		element: 'lightning',
		resistType: 'lightningResist',
		penType: 'lightningPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorTextAquaVolt: function(avatar) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You consume the energy of `, `monk-ability-text-color`, line1)
		customizeEachWord(`Aqua Volt`, `aquaVolt`, line1)
		customizeEachWord(`! Energy swirls around you, engulfing you with ${avatar}!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	flavorTextThunderBlaze: function(avatar) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You consume the energy of `, `monk-ability-text-color`, line1)
		customizeEachWord(`Thunder Blaze`, `thunderBlaze`, line1)
		customizeEachWord(`! Energy swirls around you, engulfing you with ${avatar}!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	flavorTextHydroplosion: function(avatar) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You consume the energy of `, `monk-ability-text-color`, line1)
		customizeEachWord(`Hydroplosion`, `hydroplosion`, line1)
		customizeEachWord(`! Energy swirls around you, engulfing you with ${avatar}!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.transcendence)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.transcendence)
	},
}
player.transcendence = { ...transcendence }

const callOfWind = {
	level: 1,
	name: 'Call Of Wind',
	refName: 'callOfWind',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	element: 'wind',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 5,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damageRanged: function (enemy) {
		let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
		let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	damageCombat: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		return Math.ceil(baseDamage)
	},
	debuff: {
		name: 'Call Of Wind',
		refName: 'callOfWind',
		stacks: 0,
		damage: function(swingObject) {
			return 0
		},
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorTextRanged: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You fire an energy charged ball of `, 'monk-ability-text-color', line1)
		customizeEachWord(`wind `, 'wind', line1)
		customizeEachWord(`at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, 'monk-ability-text-color', line1)
		customizeEachWord(`After the impact, a swirling orb of `, 'monk-ability-text-color', line1)
		customizeEachWord(`wind `, 'wind', line1)
		customizeEachWord(`surrounds the enemy.`, 'monk-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextCombat: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You command the wind surrounding the enemy to pull you in. You speed through the air at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`delivering to it a `, `monk-ability-text-color`, line1)
		customizeEachWord(`Flying Side-Kick`, this.color, line1)
		customizeEachWord(`!`, `white`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)		
		blankSpace()
	},
	flavorTextMissRanged: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You fire a ball of energy charged `, 'monk-ability-text-color', line1)
		customizeEachWord(`wind `, 'wind', line1)
		customizeEachWord(`at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `,  enemy.color, line1)
		customizeEachWord(`,but `, 'monk-ability-text-color', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'monk-ability-text-color', line1)
		blankSpace()
	},
	flavorTextMissCombat: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You fly toward the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `,  enemy.color, line1)
		customizeEachWord(`with a `, 'monk-ability-text-color', line1)
		customizeEachWord(`Flying Side-Kick`, this.color, line1)
		customizeEachWord(`, but `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'monk-ability-text-color', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.callOfWind)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.callOfWind)
	},
}
player.callOfWind = { ...callOfWind }
const knuckleBlitz = {
	level: 1,
	name: 'Knuckle Blitz',
	refName: 'knuckleBlitz',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	multiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 5,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5
		let levelMultiplier
		if (player.knuckleBlitz.level == 1) { levelMultiplier = 1.1}
		if (player.knuckleBlitz.level == 2) { levelMultiplier = 1.2}
		if (player.knuckleBlitz.level == 3) { levelMultiplier = 1.3}
		if (player.knuckleBlitz.level == 4) { levelMultiplier = 1.4}
		if (player.knuckleBlitz.level == 5) { levelMultiplier = 1.5}
		if (player.knuckleBlitz.level == 6) { levelMultiplier = 1.6}
		if (player.knuckleBlitz.level == 7) { levelMultiplier = 1.7}
		if (player.knuckleBlitz.level == 8) { levelMultiplier = 1.8}
		if (player.knuckleBlitz.level == 9) { levelMultiplier = 1.9}
		if (player.knuckleBlitz.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You launch a barrage of fists at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, 'monk-color', line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)		
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Your `, 'monk-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`flies just past the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'monk-ability-text-color', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.knuckleBlitz)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.knuckleBlitz)
	},
}
player.knuckleBlitz = { ...knuckleBlitz }
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////

const hydroplosionDebuff = {
	name: 'Hydroplosion',
	refName: 'hydroplosion',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'hydroplosion',
}
const moltenQuakeDebuff = {
	name: 'Molten Quake',
	refName: 'moltenQuakeDebuff',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'moltenQuake',
}
const earthTideDebuff = {
	name: 'Earth Tide',
	refName: 'earthTideDebuff',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'earthTide',
}
const thunderBlazeDebuff = {
	name: 'Thunder Blaze',
	refName: 'thunderBlaze',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'thunderBlaze',
}
const aquaVoltDebuff = {
	name: 'Aqua Volt',
	refName: 'aquaVolt',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'aquaVolt',
}
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
const hydroplosionBuff = {
	name: 'Hydroplosion Transcendence',
	refName: 'hydroplosion',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'hydroplosion',
}
const moltenQuakeBuff = {
	name: 'Molten Quake Transcendence',
	refName: 'moltenQuakeDebuff',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'moltenQuake',
}
const earthTideBuff = {
	name: 'Earth Tide Transcendence',
	refName: 'earthTideDebuff',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'earthTide',
}
const thunderBlazeBuff = {
	name: 'Thunder Blaze Transcendence',
	refName: 'thunderBlaze',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'thunderBlaze',
}
const aquaVoltBuff = {
	name: 'Aqua Volt',
	refName: 'aquaVolt',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'aquaVolt',
}


// const flameStrike = {
// 	level: 1,
// 	name: 'Flamestrike',
// 	refName: 'flameStrike',
// 	cooldown: 1000,
// 	cooldownSet: 1000,
// 	type: 'ability',
// 	color: 'activate-skill',
// 	topMultiplier: 1.5,
// 	botMultiplier: 1.0,
// 	resourceName: 'focus',
// 	resourceCost: 0,
// 	weaponTypesUsed: ['unarmed'],
// 	rightWeaponTypes: ['unarmed'],
// 	leftWeaponTypes: ['unarmed'],
// 	damage: function () {
// 		//SET THESE UP:
// 		//ABILITY DAMAGE
// 		//GIVE BASE MYSTICISM IN CHARACTER CREATION
// 		let currentAttackPower = player.currentWeaponSkill.attackPower + player.mysticPower
// 		let currentWeaponSkillBotModifier = player.currentWeaponSkill.botMultiplier
// 		let currentWeaponSkillTopModifier = player.currentWeaponSkill.topMultiplier
// 		let totalBotDamage = player.currentRightHandWeapon().botDamage == undefined ? player.currentLeftHandWeapon.botDamage : player.currentRightHandWeapon().botDamage
// 		let totalTopDamage = player.currentRightHandWeapon().topDamage == undefined ? player.currentRightHandWeapon.topDamage : player.currentRightHandWeapon().topDamage
// 		let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * totalBotDamage * (1 + this.level * 0.1))
// 		let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * totalTopDamage * (1 + this.level * 0.1))
// 		let totalDamage = randomNumberRange(lowDamage, highDamage)
// 		return totalDamage
// 	},
// 	sealBreakerDamage: function() {
// 		return randomNumberRange(10, 30)
// 	},
// 	abilityWeaponsCheck: function(weapon1, weapon2) {
// 		if (weapon1 == undefined && weapon2 == undefined) {
// 			let line1 = lineFunc()
// 			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
// 			blankSpace()
// 			return true
// 		}
// 	},
// 	flavorText: function(enemy, weapon, damage) {
// 		let line1 = lineFunc()
// 		let line2 = lineFunc()
// 		customizeEachWord(`You slide behind the `, 'gray', line1)
// 		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
// 		customizeEachWord(`and sink your `, 'gray', line1)
// 		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
// 		customizeEachWord(`into its back!`, 'gray', line1)
// 		customizeEachWord(`You hit for `, 'green', line2)
// 		customizeEachWord(`${damage} `, 'light-blue', line2)
// 		customizeEachWord(`damage.`, 'green', line2)
// 		blankSpace()
// 	},
// 	sealBreakerFlavorText: function(enemy, damage) {
// 		let line1 = lineFunc()
// 		let line2 = lineFunc()
// 		customizeEachWord(`You consume the power of your Fire Seal, unleashing a torrent of fire in every direction!`, 'fire', line1)
// 		customizeEachWord(`${enemy.name} `, enemy.color, line2)
// 		customizeEachWord(`is hit for `, 'green', line2)
// 		customizeEachWord(`${damage} `, `fire`, line2)
// 		customizeEachWord(`damage.`, 'green', line2)
// 		blankSpace()
// 	},
// 	flavorTextMiss: function(enemy, weapon) {
// 		let line1 = lineFunc()
// 		customizeEachWord(`You `, 'light-blue', line1)
// 		customizeEachWord(`dash behind the `, 'white', line1)
// 		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
// 		customizeEachWord(`attempting to  `, 'white', line1)
// 		customizeEachWord(`${this.name} `, this.color, line1)
// 		customizeEachWord(`it with your `, 'white', line1)
// 		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
// 		customizeEachWord(`, but you narrowly `, 'white', line1)
// 		customizeEachWord(`miss`, 'red', line1)
// 		customizeEachWord(`!`, 'white', line1)
// 		blankSpace()
// 	},
// 	goldToUpgrade: function () {
// 		return 9 * this.level
// 	},
// 	pointsToUpgrade: function () {
// 		return this.level + 1
// 	},
// }
// player.flameStrike = { ...flameStrike }
const fireSeal = {
	level: 1,
	name: 'Fire Seal',
	refName: 'fireSeal',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	color: 'monk-color',
	elementalType: 'fire',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Fire Seal',
		refName: 'fireSeal',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.fireSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.fireSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.fireSeal.level == 1) { levelMultiplier = 1.25}
			if (player.fireSeal.level == 2) { levelMultiplier = 1.50}
			if (player.fireSeal.level == 3) { levelMultiplier = 1.75}
			if (player.fireSeal.level == 4) { levelMultiplier = 2.0}
			if (player.fireSeal.level == 5) { levelMultiplier = 2.25}
			if (player.fireSeal.level == 6) { levelMultiplier = 2.50}
			if (player.fireSeal.level == 7) { levelMultiplier = 2.75}
			if (player.fireSeal.level == 8) { levelMultiplier = 3.0}
			if (player.fireSeal.level == 9) { levelMultiplier = 3.25}
			if (player.fireSeal.level >= 10) { levelMultiplier = 3.5}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		duration: 30000,
		stacks: 0,
		numHitsToActivate: 5,
		additionalTargets: 2,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You break the Fire Seal on the enemy! Fire erupts from your fist on impact, scorching the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, 'fire', line1)
			customizeEachWord(`Fireseal Break `, `fire`, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
			customizeEachWord(`${element} `, element, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy resists `, 'white', line2)
			customizeEachWord(`${damageResisted}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
		flavorTextCleave: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`The explosion from your Fire Seal blasts the `, 'fire', line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, 'fire', line1)
			customizeEachWord(`Fireseal Breaker `, 'fire', line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
			customizeEachWord(`${element} `, element, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy resists `, 'white', line2)
			customizeEachWord(`${damageResisted}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
	},
	buff: {
		name: 'Fire Enchant',
		refName: 'fireEnchant',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.fireSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.fireSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.fireSeal.level == 1) { levelMultiplier = 1.1}
			if (player.fireSeal.level == 2) { levelMultiplier = 1.2}
			if (player.fireSeal.level == 3) { levelMultiplier = 1.3}
			if (player.fireSeal.level == 4) { levelMultiplier = 1.4}
			if (player.fireSeal.level == 5) { levelMultiplier = 1.5}
			if (player.fireSeal.level == 6) { levelMultiplier = 1.6}
			if (player.fireSeal.level == 7) { levelMultiplier = 1.7}
			if (player.fireSeal.level == 8) { levelMultiplier = 1.8}
			if (player.fireSeal.level == 9) { levelMultiplier = 1.9}
			if (player.fireSeal.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelMultiplier
		if (player.fireSeal.level == 1) { levelMultiplier = 1.1}
		if (player.fireSeal.level == 2) { levelMultiplier = 1.2}
		if (player.fireSeal.level == 3) { levelMultiplier = 1.3}
		if (player.fireSeal.level == 4) { levelMultiplier = 1.4}
		if (player.fireSeal.level == 5) { levelMultiplier = 1.5}
		if (player.fireSeal.level == 6) { levelMultiplier = 1.6}
		if (player.fireSeal.level == 7) { levelMultiplier = 1.7}
		if (player.fireSeal.level == 8) { levelMultiplier = 1.8}
		if (player.fireSeal.level == 9) { levelMultiplier = 1.9}
		if (player.fireSeal.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slam your palm into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! A glowing red mark is left behind on the enemy.`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.fireSeal)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.fireSeal)
	},
}
player.fireSeal = { ...fireSeal }
const waterSeal = {
	level: 1,
	name: 'Water Seal',
	refName: 'waterSeal',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Water Seal',
		refName: 'waterSeal',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.waterSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.waterSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.waterSeal.level == 1) { levelMultiplier = 1.25}
			if (player.waterSeal.level == 2) { levelMultiplier = 1.50}
			if (player.waterSeal.level == 3) { levelMultiplier = 1.75}
			if (player.waterSeal.level == 4) { levelMultiplier = 2.0}
			if (player.waterSeal.level == 5) { levelMultiplier = 2.25}
			if (player.waterSeal.level == 6) { levelMultiplier = 2.50}
			if (player.waterSeal.level == 7) { levelMultiplier = 2.75}
			if (player.waterSeal.level == 8) { levelMultiplier = 3.0}
			if (player.waterSeal.level == 9) { levelMultiplier = 3.25}
			if (player.waterSeal.level >= 10) { levelMultiplier = 3.5}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		duration: 30000,
		stacks: 0,
		numHitsToActivate: 5,
		type: '',
		color: 'water',
		element: 'water',
		resistType: 'waterResist',
		penType: 'waterPen',
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You break the Water Seal on the enemy! Water erupts from your fist on impact, blasting the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Waterseal Break `, `water`, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
			customizeEachWord(`${element} `, element, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy resists `, 'white', line2)
			customizeEachWord(`${damageResisted}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
	},
	buff: {
		name: 'Water Enchant',
		refName: 'waterEnchant',
		type: 'enchantment',
		buff: true,
		seal: true,
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		heal: function() {
			let mysticPowerBot = player.mysticPower * player.waterSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.waterSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.waterSeal.level == 1) { levelMultiplier = 1.25}
			if (player.waterSeal.level == 2) { levelMultiplier = 1.50}
			if (player.waterSeal.level == 3) { levelMultiplier = 1.75}
			if (player.waterSeal.level == 4) { levelMultiplier = 2.0}
			if (player.waterSeal.level == 5) { levelMultiplier = 2.25}
			if (player.waterSeal.level == 6) { levelMultiplier = 2.50}
			if (player.waterSeal.level == 7) { levelMultiplier = 2.75}
			if (player.waterSeal.level == 8) { levelMultiplier = 3.0}
			if (player.waterSeal.level == 9) { levelMultiplier = 3.25}
			if (player.waterSeal.level >= 10) { levelMultiplier = 3.5}
			let totalHeal = (baseDamageMystic * levelMultiplier) * 0.1
			return Math.ceil(totalHeal)	
		},
		duration: 20000,
		flavorText: function(enemy, heal) {
			let line1 = lineFunc()
			customizeEachWord(`You heal yourself for `, 'green', line1)
			customizeEachWord(`${heal} `, 'light-blue', line1)
		}
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelMultiplier
		if (player.waterSeal.level == 1) { levelMultiplier = 1.1}
		if (player.waterSeal.level == 2) { levelMultiplier = 1.2}
		if (player.waterSeal.level == 3) { levelMultiplier = 1.3}
		if (player.waterSeal.level == 4) { levelMultiplier = 1.4}
		if (player.waterSeal.level == 5) { levelMultiplier = 1.5}
		if (player.waterSeal.level == 6) { levelMultiplier = 1.6}
		if (player.waterSeal.level == 7) { levelMultiplier = 1.7}
		if (player.waterSeal.level == 8) { levelMultiplier = 1.8}
		if (player.waterSeal.level == 9) { levelMultiplier = 1.9}
		if (player.waterSeal.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slam your palm into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! A glowing blue mark is left behind on the enemy.`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, 'water', line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.waterSeal)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.waterSeal)
	},
}
player.waterSeal = { ...waterSeal }
const earthSeal = {
	level: 1,
	name: 'Earth Seal',
	refName: 'earthSeal',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Earth Seal',
		refName: 'earthSeal',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.earthSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.earthSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.earthSeal.level == 1) { levelMultiplier = 1.25}
			if (player.earthSeal.level == 2) { levelMultiplier = 1.50}
			if (player.earthSeal.level == 3) { levelMultiplier = 1.75}
			if (player.earthSeal.level == 4) { levelMultiplier = 2.0}
			if (player.earthSeal.level == 5) { levelMultiplier = 2.25}
			if (player.earthSeal.level == 6) { levelMultiplier = 2.50}
			if (player.earthSeal.level == 7) { levelMultiplier = 2.75}
			if (player.earthSeal.level == 8) { levelMultiplier = 3.0}
			if (player.earthSeal.level == 9) { levelMultiplier = 3.25}
			if (player.earthSeal.level >= 10) { levelMultiplier = 3.5}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		duration: 30000,
		stacks: 0,
		numHitsToActivate: 5,
		color: 'earth',
		element: 'earth',
		resistType: 'earthResist',	
		penType: 'earthPen',	
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			blankSpace()
			customizeEachWord(`You break the Earth Seal on the enemy! Earth erupts from your fist on impact, blasting the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Earth from the explosion swirls around you, forming a shield around you increasing your armor!`, `monk-ability-text-color`, line2)
			customizeEachWord(`Earthseal Break `, 'earth', line3)
			customizeEachWord(`hits for `, 'green', line3)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line3)
			customizeEachWord(`${element} `, element, line3)
			customizeEachWord(`damage. `, 'green', line3)
			customizeEachWord(`(Enemy resists `, 'white', line3)
			customizeEachWord(`${damageResisted}`, 'light-blue', line3)
			customizeEachWord(`)`, 'white', line3)
			blankSpace()
		},
	},
	buff: {
		name: 'Earth Enchant',
		refName: 'earthEnchant',
		buff: true,
		seal: true,
		get slashingArmor() {
			return player.earthSeal.level
		},
		get slashingArmor() {
			return player.earthSeal.level
		},
		get slashingArmor() {
			return player.earthSeal.level
		},
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		duration: 20000,
		// flavorText: function() {
		// 	let line1 = lineFunc()
		// 	blankSpace()
		// 	customizeEachWord(`sdfdas`, 'white', line1)
		// 	blankSpace()
		// },
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelMultiplier
		if (player.earthSeal.level == 1) { levelMultiplier = 1.1}
		if (player.earthSeal.level == 2) { levelMultiplier = 1.2}
		if (player.earthSeal.level == 3) { levelMultiplier = 1.3}
		if (player.earthSeal.level == 4) { levelMultiplier = 1.4}
		if (player.earthSeal.level == 5) { levelMultiplier = 1.5}
		if (player.earthSeal.level == 6) { levelMultiplier = 1.6}
		if (player.earthSeal.level == 7) { levelMultiplier = 1.7}
		if (player.earthSeal.level == 8) { levelMultiplier = 1.8}
		if (player.earthSeal.level == 9) { levelMultiplier = 1.9}
		if (player.earthSeal.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slam your palm into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! A glowing earthy mark is left behind on the enemy.`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, `earth`, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.earthSeal)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.earthSeal)
	},
}
player.earthSeal = { ...earthSeal }
const mysticFist = {
	level: 1,
	name: 'Mystic Fist',
	refName: 'mysticFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Mystic Fist',
		refName: 'mysticFist',
		duration: 30000,
		stacks: 0,
		maxStacks: function() {
			return 5
		},
	},
	buff: {
		name: 'Mystic Fist',
		refName: 'mysticFist',
		seal: true,
		duration: 15000,
		stacks: 1,
		str: 1,
		maxStacks: function() {
			return 5
		},
		// flavorText: function() {
		// 	let line1 = lineFunc()
		// 	blankSpace()
		// 	customizeEachWord(`BLAST`, 'white', line1)
		// 	blankSpace()
		// },
	},
	damage: function (enemy) {
		let damage = baseAttackDamageRight() + player.mysticPower
		return Math.ceil(damage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`Your hands begin to glow and you become super-charged with electricity! `, `monk-ability-text-color`, line1)
		customizeEachWord(`You rush forward at the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`letting loose a barage of fists!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, 'earth', line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.mysticFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.mysticFist)
	},
}
player.mysticFist = { ...mysticFist }

const unleashedPower = {
	level: 1,
	name: 'Unleashed Power',
	refName: 'unleashedPower',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		// name: 'Mystic Fist',
		// refName: 'mysticFist',
		// duration: 30000,
		// stacks: 0,
		// maxStacks: function() {
		// 	return 5
		// },
	},
	buff: {
		name: 'Unleashed Power',
		refName: 'unleashedPower',
		duration: 15000,
		stacks: 1,
		get str() {
			return 1
		},
		get dex() {
			return 1	
		},
		get agi() {
			return 1		
		},
		get mys() {
			return 1
		},		
		maxStacks: function() {
			let stacksBonus = 1
			for (let buff in player.buffs) {
				if (player.buffs[buff].seal) {
					stacksBonus++
				}
			}
			return stacksBonus
		},
		// flavorText: function() {
		// 	let line1 = lineFunc()
		// 	blankSpace()
		// 	customizeEachWord(`BLAST`, 'white', line1)
		// 	blankSpace()
		// },
	},
	damage: function (enemy) {
		let bonusSealDamageStacks = 0
		for (let buff in player.buffs) {
			if (player.buffs[buff].seal) {
				bonusSealDamageStacks++
			}
		}
		let damage = (baseAttackDamageRight() + player.mysticPower) * bonusSealDamageStacks
		return Math.ceil(damage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You explode yourself and hit the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`${this.name} `, 'earth', line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.unleashedPower)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.unleashedPower)
	},
}
player.unleashedPower = { ...unleashedPower }

const waveFist = {
	level: 1,
	name: 'Flamestrike',
	refName: 'flameStrike',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'activate-skill',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function () {
		//SET THESE UP:
		//ABILITY DAMAGE
		//GIVE BASE MYSTICISM IN CHARACTER CREATION
		let currentAttackPower = player.currentWeaponSkill.attackPower + player.mysticPower
		let currentWeaponSkillBotModifier = player.currentWeaponSkill.botMultiplier
		let currentWeaponSkillTopModifier = player.currentWeaponSkill.topMultiplier
		let totalBotDamage = player.currentRightHandWeapon().botDamage == undefined ? player.currentLeftHandWeapon.botDamage : player.currentRightHandWeapon().botDamage
		let totalTopDamage = player.currentRightHandWeapon().topDamage == undefined ? player.currentRightHandWeapon.topDamage : player.currentRightHandWeapon().topDamage
		let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * totalBotDamage * (1 + this.level * 0.1))
		let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * totalTopDamage * (1 + this.level * 0.1))
		let totalDamage = randomNumberRange(lowDamage, highDamage)
		return totalDamage
	},
	heal: function() {
		let topAbilityPower = player.mysticPower * player.waterSeal.topMultiplier
		let botAbilityPower = player.mysticPower * player.waterSeal.botMultiplier
		return Math.ceil(randomNumberRange(botAbilityPower, topAbilityPower))
	},
	sealBreakerDamage: function() {
		return randomNumberRange(10, 30)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You slide behind the `, 'gray', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and sink your `, 'gray', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back!`, 'gray', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()
	},
	sealBreakerFlavorText: function(heal) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You consume the power of your Water Seal, healing yourself!`, 'water', line1)
		customizeEachWord(`You heal yourself for `, 'green', line2)
		customizeEachWord(`${heal} `, `fire`, line2)
		customizeEachWord(`!`, 'green', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.waveFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.waveFist)
	},
}
player.waveFist = { ...waveFist }


const riptideFist = {
	level: 1,
	name: 'Riptide Fist',
	refName: 'riptideFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'activate-skill',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	stacks: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function () {
		let currentAttackPower = player.currentWeaponSkill.attackPower + player.mysticPower
		let currentWeaponSkillBotModifier = player.currentWeaponSkill.botMultiplier
		let currentWeaponSkillTopModifier = player.currentWeaponSkill.topMultiplier
		let totalBotDamage = player.currentRightHandWeapon().botDamage == undefined ? player.currentLeftHandWeapon.botDamage : player.currentRightHandWeapon().botDamage
		let totalTopDamage = player.currentRightHandWeapon().topDamage == undefined ? player.currentRightHandWeapon.topDamage : player.currentRightHandWeapon().topDamage
		let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * totalBotDamage * (1 + this.level * 0.1))
		let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * totalTopDamage * (1 + this.level * 0.1))
		let stackBonus = player.riptideFist.stacks + 1
		let totalDamage = Math.ceil(randomNumberRange(lowDamage, highDamage) * stackBonus)
		quickMessage(`Stacks: ${this.stacks}`)
		return totalDamage
	},
	combo: function() {
				let topAbilityPower = player.mysticPower * player.riptideFist.topMultiplier
				let botAbilityPower = player.mysticPower * player.riptideFist.botMultiplier
				return Math.ceil(randomNumberRange(botAbilityPower, topAbilityPower))
		},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You slide behind the `, 'gray', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and sink your `, 'gray', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back!`, 'gray', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()
	},
	comboFlavorText: function(enemy, damage) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Your fist slams into the `, 'water', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`erupting a waterfall explosion!`, 'water', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.riptideFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.riptideFist)
	},
}
player.riptideFist = {...riptideFist}

//RANGER ABILITIES



const markOfTheBeast = {
	level: 1,
	name: 'Mark of the Beast',
	refName: 'markOfTheBeast',
	type: 'skill',
	color: 'green',
	descritpion: ``,
	debuff: {
		name: 'Mark of the Beast',
		refName: 'markOfTheBeast',
		duration: 6000,
		stacks: 0,
		maxStacks: function() {
			return 5
		},
		damage: function(enemy, swingObject) {
			let stacks = enemy.debuffs.markOfTheBeast.stacks
			let bonusMultiplier = 0
			if (player.markOfTheBeast.level == 1) {bonusMultiplier = 0.1 * stacks}
			if (player.markOfTheBeast.level == 2) {bonusMultiplier = 0.2 * stacks}
			if (player.markOfTheBeast.level == 3) {bonusMultiplier = 0.3 * stacks}
			if (player.markOfTheBeast.level == 4) {bonusMultiplier = 0.4 * stacks}
			if (player.markOfTheBeast.level >= 5) {bonusMultiplier = 0.5 * stacks}
			let damage = swingObject.totalDamage
			let bonusDamage = Math.ceil(damage * bonusMultiplier)
			return bonusDamage

		},
		type: 'mark',
		color: 'ranger-color',
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.markOfTheBeast)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.markOfTheBeast)
	},
}
player.markOfTheBeast = {...markOfTheBeast}


const shadowMark = {
	level: 1,
	name: 'Shadow Mark',
	refName: 'shadowMark',
	type: 'ability',
	color: 'sinistral-color',
	descritpion: ``,
	maxLevel: 10,
	debuff: {
		name: 'Shadow Mark',
		refName: 'shadowMark',
		duration: 60000,
		stacks: 0,
		maxStacks: function() {
			if (player.shadowMark.level == 1) {return 3}
			if (player.shadowMark.level == 2) {return 4}
			if (player.shadowMark.level == 3) {return 5}
			if (player.shadowMark.level == 4) {return 6}
			if (player.shadowMark.level == 5) {return 7}
			if (player.shadowMark.level == 6) {return 8}
			if (player.shadowMark.level == 7) {return 9}
			if (player.shadowMark.level == 8) {return 10}
			if (player.shadowMark.level == 9) {return 11}
			if (player.shadowMark.level >= 10) {return 12}
			else { return 1}
		},
		type: 'mark',
		color: 'shadow',
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.shadowMark)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.shadowMark)
	},
}
player.shadowMark = {...shadowMark}

const sinisterMark = {
	level: 1,
	name: 'Sinister Mark',
	refName: 'sinsiterMark',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	adrenalineBonus: function() {
		if (player.sinisterMark.level == 1) {return 2}
		if (player.sinisterMark.level == 2) {return 4}
		if (player.sinisterMark.level == 3) {return 6}
		if (player.sinisterMark.level == 4) {return 8}
		if (player.sinisterMark.level == 5) {return 10}
		if (player.sinisterMark.level == 6) {return 12}
		if (player.sinisterMark.level == 7) {return 14}
		if (player.sinisterMark.level == 8) {return 16}
		if (player.sinisterMark.level == 9) {return 18}
		if (player.sinisterMark.level >= 10) {return 20}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.sinisterMark)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.sinisterMark)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`A Sinister Mark is applied to a target by landing a successful Backstab (Assassin ability). Increasing the skill level of Sinister Mark will increase the armor reduction effect, as well as increase the bonus Adrenaline gained from killing an enemy with Guillotine, however, the amount of stacks able to be applied is equal to Backstab's level + 1.`, 'white', line1)
		blankSpace()
	},
}
player.sinisterMark = {...sinisterMark}

const shadowVenom = {
	level: 1,
	name: 'Shadow Venom',
	refName: 'shadowVenom',
	type: 'ability',
	color: 'sinistral-color',
	descritpion: ``,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	buff: {
		name: 'Shadow Venom',
		refName: 'shadowVenom',
		resistType: 'shadowResist',
		penType: 'shadowPen',
		duration: 30000,
		stacks: 0,
		damage: function(enemy) {
			let topEnd
			let botEnd
			if (player.shadowVenom.level <= 1) {
				topEnd = 1.0
				botEnd = 0.8
			}
			if (player.shadowVenom.level == 2) {
				topEnd = 1.1
				botEnd = 0.9
			}
			if (player.shadowVenom.level == 3) {
				topEnd = 1.2
				botEnd = 1.0
			}
			if (player.shadowVenom.level == 4) {
				topEnd = 1.3
				botEnd = 1.1
			}
			if (player.shadowVenom.level == 5) {
				topEnd = 1.5
				botEnd = 1.3
			}
			if (player.shadowVenom.level == 6) {
				topEnd = 1.7
				botEnd = 1.5
			}
			if (player.shadowVenom.level == 7) {
				topEnd = 1.9
				botEnd = 1.7
			}
			if (player.shadowVenom.level == 8) {
				topEnd = 2.1
				botEnd = 1.9
			}
			if (player.shadowVenom.level == 9) {
				topEnd = 2.3
				botEnd = 2.1
			}
			if (player.shadowVenom.level >= 10) {
				topEnd = 2.5
				botEnd = 2.3
			}
			let botDamage = player.currentWeaponSkill.attackPower * botEnd
			let topDamage = player.currentWeaponSkill.attackPower * topEnd
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let totalDamage = baseDamage
			if (enemy.debuffs) {
				if (enemy.debuffs.shadowMark) {
					let stacks = enemy.debuffs.shadowMark.stacks
					if (!stacks || stacks == 0) {totalDamage = baseDamage}
					if (stacks == 1) {totalDamage = baseDamage * 1.1}
					if (stacks == 2) {totalDamage = baseDamage * 1.2}
					if (stacks == 3) {totalDamage = baseDamage * 1.3}
					if (stacks == 4) {totalDamage = baseDamage * 1.4}
					if (stacks == 5) {totalDamage = baseDamage * 1.5}
					if (stacks == 6) {totalDamage = baseDamage * 1.6}
					if (stacks == 7) {totalDamage = baseDamage * 1.7}
					if (stacks == 8) {totalDamage = baseDamage * 1.8}
					if (stacks == 9) {totalDamage = baseDamage * 1.9}
					if (stacks >= 10) {totalDamage = baseDamage * 2.0}
				}
			}
			return Math.ceil(totalDamage)
		},
		maxStacks: function() {
			return 5
		},
		flavorText: function(enemy, damage, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You hit for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`shadow `, 'shadow', line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		},
		flavorTextWearsOff: function() {
			let line1 = lineFunc()
			customizeEachWord(`${this.name} `, 'shadow', line1)
			customizeEachWord(`has faded from your weapon`, 'white', line1)
		},
		flavorTextApplyBuff: function() {
			let line1 = lineFunc()
			customizeEachWord(`Your weapon glows purple with `, 'white', line1)
			customizeEachWord(`${this.name}`, 'shadow', line1)
		},
		type: 'mark',
		color: 'shadow',
	},
	debuff: {
		name: 'Shadow Mark',
		refName: 'shadowMark',
		resistType: 'shadowResist',
		penType: 'shadowPen',
		stacks: 0,
		maxStacks: function() {
			return 5
		},
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowVenom)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowVenom)
	},
}
player.shadowVenom = {...shadowVenom}

const poison = {
	level: 0,
	name: 'Poison',
	refName: 'poison',
	resistType: 'poisonResist',
	penType: 'poisonPen',
	stacks: 0,
	duration: function() {
		if (player.contagion.level == 1) {return 20000}
		if (player.contagion.level == 2) {return 30000}
		if (player.contagion.level == 3) {return 40000}
		if (player.contagion.level == 4) {return 50000}
		if (player.contagion.level >= 5) {return 60000}
		
		else {return 0}

	},
	color: 'dark-green',
	damage: function(swingObject) {
		let baseDamage = player.currentWeaponSkill.attackPower
		let bonusDamage = this.stacks * player.contagion.level
		let totalDamage = baseDamage + bonusDamage
		return Math.ceil(totalDamage)
	},
	maxStacks: function() {
		return 10
	},
	flavorText: function(enemy, damage, element, damageResisted) {
		let line1 = lineFunc()
		customizeEachWord(`You hit for `, 'green', line1)
		customizeEachWord(`${damage} `, 'light-blue', line1)
		customizeEachWord(`additional `, 'green', line1)
		customizeEachWord(`poison `, `dark-green`, line1)
		customizeEachWord(`damage. `, `green`, line1)
		customizeEachWord(`(Enemy resists `, `white`, line1)
		customizeEachWord(`${damageResisted}`, `light-blue`, line1)
		customizeEachWord(`)`, `white`, line1)
	},
	flavorTextWearsOff: function() {
		let line1 = lineFunc()
		customizeEachWord(`${this.name} `, 'dark-green', line1)
		customizeEachWord(`has faded from your weapon`, 'white', line1)
	},
	flavorTextApplyBuff: function() {
		let line1 = lineFunc()
		customizeEachWord(`Your weapon glows green with `, 'white', line1)
		customizeEachWord(`${this.name}`, 'dark-green', line1)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.poison)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.poison)
	},
}
player.poison = {...poison}


const piercingArrow = {
	level: 1,
	name: 'Piercing Arrow',
	refName: 'piercingArrow',
	color: 'ranger-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: function() {
		if (this.level == 1) { return 7000}
		if (this.level == 2) { return 6500}
		if (this.level == 3) { return 6000}
		if (this.level == 4) { return 5500}
		if (this.level == 5) { return 5000}
		if (this.level == 6) { return 4500}
		if (this.level == 7) { return 4000}
		if (this.level == 8) { return 3500}
		if (this.level == 9) { return 3000}
		if (this.level >= 10) { return 2000}
	},
	timer: function() {
		if (this.level == 1) { return 7000}
		if (this.level == 2) { return 6500}
		if (this.level == 3) { return 6000}
		if (this.level == 4) { return 5500}
		if (this.level == 5) { return 5000}
		if (this.level == 6) { return 4500}
		if (this.level == 7) { return 4000}
		if (this.level == 8) { return 3500}
		if (this.level == 9) { return 3000}
		if (this.level >= 10) { return 2000}
	},
	resourceName: 'focus',
	resourceCost: 5,
	weaponTypesUsed: ['bows'],
	debuff: {
		name: 'Piercing Arrow',
		refName: 'piercingArrow',
		damage: function(swingObject) {
			return Math.ceil(swingObject.totalDamage * 0.5)
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'mark',
		color: 'ranger-color',
		flavorText: function(enemy, damage) {
			let line1 = lineFunc()
			customizeEachWord(`Piercing Arrow mark `, 'ranger-color', line1)
			customizeEachWord(`hits for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`damage.`, 'green', line1)
			blankSpace()
		},
	},
	damage: function () {
			let bonusMultiplier = 1.0
			if (this.timer() != 0) {
				if (this.timer() < this.windUp * 0.05) {
					// quickMessage(`You hit for 3.0x damage!`)
					bonusMultiplier = 3.0
				}
				else if (this.timer() < this.windUp * 0.1) {
					bonusMultiplier = 2.5
					// quickMessage(`You hit for 2.5x damage!`)
				}
				else if (this.timer() < this.windUp * 0.2) {
					bonusMultiplier = 2.0
					// quickMessage(`You hit for 2.0x damage!`)
				}
				else if (this.timer() < this.windUp * 0.3) {
					bonusMultiplier = 1.75
					// quickMessage(`You hit for 1.75x damage!`)
				}
				else if (this.timer() < this.windUp * 0.4) {
					bonusMultiplier = 1.6
				}
				else if (this.timer() < this.windUp * 0.5) {
					bonusMultiplier = 1.5
				}
				else if (this.timer() < this.windUp * 1.0) {
					bonusMultiplier = 1.0
				}
			}
		return Math.ceil(baseAttackDamageRight() * bonusMultiplier)
	},
	initiateTimer: function(secondCommand, thirdCommand) {
		//windup
		const conjureBar = document.querySelector('.bar-1')
		conjureBar.classList.add('ranger-resource-bar')	
		//timer	
		let windUpTime = this.windUp()
		let remainingTime = windUpTime
		let width = 0
		if (this.onCooldown == false) {
			this.queued = true
			player.isAbilityQueued = true
			piercingArrowInterval = setInterval(() => {
				if (remainingTime <= 0) {
					player.isAbilityQueued = false
					this.queued = false
					conjureBar.style.width = 0
					let weaponTypesToCheck = this.weaponTypesUsed
					let weaponUsed = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
					// let totalDamage = this.damage(weaponUsed)
					let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
					let hitChance = playerAbilityHitChance(targetEnemy)
					let baseDamage = this.damage()
					let penetrationType = calculatePenetrationRoll()
					let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					let damageBlocked = baseDamage - damageAfterArmor
					if (hitChance == false) {
						this.releaseTimer()
						this.timer = this.windUp()
						this.flavorTextMiss(targetEnemy, weaponUsed)
						clearInterval(piercingArrowInterval)
					} else if (hitChance == true) {
						this.releaseTimer(weaponUsed)
						this.timer = this.windUp()
						this.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(targetEnemy, damageAfterArmor)
						updateScroll()
					} 
					clearInterval(piercingArrowInterval)
					return
				}
				width = ((windUpTime - remainingTime) / windUpTime) * 100
				conjureBar.style.width = `${width}%`
				remainingTime -= 10
				this.timer() -= 10
			}, 10)
		}
	},
	releaseTimer: function() {
		let conjureBar = document.querySelector('.bar-1')
		this.timer = this.windUp
		conjureBar.style.width = 0
		clearInterval(piercingArrowInterval)
		this.queued = false
		this.cooldown = this.cooldownSet
		updateScroll()
		
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You gather your focus as you try to time the perfect shot with `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		customizeEachWord(`After honing your full attention to this shot, you pull back the bowstring of your `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`and let fly an arrow that pierces the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `ranger-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
		customizeEachWord(`Your concentration was broken at the last second. You fire your arrow at the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, `ranger-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `ranger-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.piercingArrow)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.piercingArrow)
	},
}
player.piercingArrow = { ...piercingArrow }

const hydraArrow = {
	level: 1,
	name: 'Hydra Arrow',
	refName: 'hydraArrow',
	color: 'ranger-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 1,
	resourceName: 'focus',
	resourceCost: 5,
	statusEffect: 'huntersMark',
	debuff: {
		name: 'Hydra Arrow',
		refName: 'hydraArrow',
		damage: function(swingObject) {
			let damage = swingObject.totalDamage
			return Math.ceil(damage * 0.5)
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damage) {
			let line1 = lineFunc()
			customizeEachWord(`Hydra Arrow mark `, 'ranger-color', line1)
			customizeEachWord(`hits for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`damage.`, 'green', line1)
			blankSpace()
		},
		type: 'mark',
		color: 'ranger-color',
	},
	shotCount: function() {
		if (player.hydraArrow.level == 1) { return 3 }
		if (player.hydraArrow.level == 2) { return 3 }
		if (player.hydraArrow.level == 3) { return 3 }
		if (player.hydraArrow.level == 4) { return 3 }
		if (player.hydraArrow.level == 5) { return 4 }
		if (player.hydraArrow.level == 6) { return 4 }
		if (player.hydraArrow.level == 7) { return 4 }
		if (player.hydraArrow.level == 8) { return 4 }
		if (player.hydraArrow.level == 9) { return 5 }
		if (player.hydraArrow.level >= 10) { return 5 }
	},
	weaponTypesUsed: ['bows'],
	damage: function () {
		let baseDamage = baseAttackDamageRight()
		let levelMultiplier
		if (player.hydraArrow.level == 1) { levelMultiplier = 1.00 }
		if (player.hydraArrow.level == 2) { levelMultiplier = 1.25 }
		if (player.hydraArrow.level == 3) { levelMultiplier = 1.50 }
		if (player.hydraArrow.level == 4) { levelMultiplier = 1.75 }
		if (player.hydraArrow.level == 5) { levelMultiplier = 2.00 }
		if (player.hydraArrow.level == 6) { levelMultiplier = 2.25 }
		if (player.hydraArrow.level == 7) { levelMultiplier = 2.50 }
		if (player.hydraArrow.level == 8) { levelMultiplier = 2.75 }
		if (player.hydraArrow.level == 9) { levelMultiplier = 3.00 }
		if (player.hydraArrow.level >= 10) { levelMultiplier = 3.25 }
		let totalDamage = Math.ceil(baseDamage * levelMultiplier)
		return totalDamage
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You position arrows on your `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`, firing them all at once at the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `ranger-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		customizeEachWord(`An arrow strays just passed the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, 'white', line1)
		customizeEachWord(`misses`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.hydraArrow)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.hydraArrow)
	},
}
player.hydraArrow = {...hydraArrow}
const rapidFireShot = {
	level: 1,
	name: 'Rapid Fire Shot',
	refName: 'rapidFireShot',
	color: 'ranger-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 5,
	resourceName: 'focus',
	resourceCost: 5,
	shotCount: function() {
		return this.level + 2
	},
	weaponTypesUsed: ['bows'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let markBonus = enemy?.debuffs?.markOfTheBeast?.damage() ? enemy?.debuffs?.markOfTheBeast?.damage() : 0
		let bonusDamage = baseDamage * markBonus
		let totalDamage = Math.ceil(baseDamage + bonusDamage)
		return totalDamage
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You begin gathering the arrows needed for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You draw back several arrows with your `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`, firing them all at the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`in rapid succession!`, `ranger-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
		flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`An arrow from your volley wizzes just by the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, 'white', line1)
		customizeEachWord(`misses`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.rapidFireShot)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.rapidFireShot)
	},
}
player.rapidFireShot = {...rapidFireShot}
const aimedShot = {
	level: 1,
	requiredPlayerLevel: function() {
		if (player.aimedShot.level == 0) {
			return 5
		} else if (player.aimedShot.level == 1) {
			return 10
		} else if (player.aimedShot.level == 2) {
			return 15
		}
	},
	name: 'Aimed Shot',
	refName: 'aimedShot',
	color: 'ranger-color',
	cooldownSet: 20000,
	cooldown: 20000,
	windUp: 3,
	shotCount: function() {
		return this.level + 1
	},
	resourceName: [],
	marksThisConsumes: ['huntersMark'],
	weaponTypesUsed: ['bows'],
	damage: function (weapons, enemy) {
			let currentAttackPower = player[weapons.skillUsed].attackPower
			let currentWeaponSkillBotModifier = player[weapons.skillUsed].botMultiplier
			let currentWeaponSkillTopModifier = player[weapons.skillUsed].topMultiplier
			let currentWeaponSkillBotDamage = weapons.botDamage
			let currentWeaponSkillTopDamage = weapons.topDamage
			let currentWeaponWeight = weapons.mods.weight
			let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * currentWeaponSkillBotDamage + (1 + this.level * 0.1))
			let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * currentWeaponSkillTopDamage + (1 + this.level * 0.1))
			console.log(lowDamage, ' LOW DAMAGE')
			console.log(highDamage, ' HIGH DAMAGE')
			let weaponDamage = randomNumberRange(lowDamage, highDamage)
			let bonusDamage = Math.ceil(weaponDamage * ((player.might - 1) * .1)) + 10 //this does 10% per stack of might bonus damage + 10 flat damage rounded up
			let totalDamageWithMark = (weaponDamage + bonusDamage) * 2
			let totalDamage = weaponDamage + bonusDamage
			if (enemy.statusEffects.huntersMark) {
				return totalDamageWithMark
			}
			return totalDamage
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		let line3 = document.createElement('div')
		customizeEachWord(`With a burst of energy, you launch yourself at the enemy!`, this.color, line1)
		customizeEachWord(`Pivoting on your heel, you whirl around, swinging your `, this.color, line2)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line2)
		customizeEachWord(`in a wide arc ripping into the `, enemy.color, line2)
		customizeEachWord(`${enemy.name}`, `enemy.color`, line2)
		customizeEachWord(`!`, this.color, line2)
		customizeEachWord(`You hit for `, 'green', line3)
		customizeEachWord(`${damage} `, 'light-blue', line3)
		customizeEachWord(`damage.`, 'green', line3)
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`launch yourself toward the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`swinging your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`in a wide arc, but it moves out of the way just in time and you `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.aimedShot)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.aimedShot)
	},
}
player.aimedShot = {...aimedShot}


// const warcraft = {
// 	name: 'Warcraft',
// 	refName: 'warcraft',
// 	type: 'skill',
// 	level: 0,
// 	color: 'passive-skill',
// 	description: function() {
// 		let line1 = lineFunc()
// 		let line2 = lineFunc()
// 		blankSpace()
// 		customizeEachWord(`This is the primary skill for those specializing in one-handed weapons. Training this skill will increase your swing speed, damage, and accuracy with all one handed weapon types. Once the maximum swing speed has been reached, damage is further increased.`, 'white', line1)
// 		blankSpace()
// 		customizeEachWord(`One-handed weapons include swords, axes, maces, and other similar weapon types. One-handed weapons do not include daggers, fist weapons, bows, or shields.`, 'white', line2)
// 		blankSpace()
// 	},
// 	goldToUpgrade: function () {
// 		return 9 * this.level
// 	},
// 	pointsToUpgrade: function () {
// 		return this.level + 1
// 	},
// }

// const dualWield = {
// 	level: 0,
// 	name: 'Dual Wield',
// 	refName: 'dualWield',
// 	type: 'skill',
// 	attackPower: 0,
// 	topMultiplier: 0.4,
// 	botMultiplier: 0.4,
// 	speed: 4,
// 	accuracy: -30,
// 	slashingPen: 0,
// 	piercingPen: 0,
// 	bluntPen: 0,
// 	color: 'passive-skill',
// 	goldToUpgrade: function () {
// 		return 9 * this.level
// 	},
// 	pointsToUpgrade: function () {
// 		return this.level + 1
// 	},
// }
// player.dualWield = { ...dualWield }
const unarmed = {
	id: 1,
	name: 'Martial Arts',
	refName: 'unarmed',
	type: 'skill',
	level: 0,
	attackPower: 0,
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 4.1,
	accuracy: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 1,
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.unarmed)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.unarmed)
	},
}
player.unarmed = { ...unarmed }
const daggers = {
	id: 2,
	name: 'Daggers',
	refName: 'daggers',
	type: 'skill',
	level: 0,
	attackPower: 0,
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 4,
	accuracy: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 0,
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.daggers)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.daggers)
	},
}
player.daggers = { ...daggers }
const oneHanded = {
	id: 3,
	name: 'One Handed',
	refName: 'oneHanded',
	type: 'skill',
	level: 0,
	attackPower: 0,
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 5,
	accuracy: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 0,
	color: 'green',
	description: function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`This is the primary skill for those specializing in one-handed weapons. Training this skill will increase your swing speed, damage, and accuracy with all one handed weapon types. Once the maximum swing speed has been reached, damage is further increased.`, 'white', line1)
		blankSpace()
		customizeEachWord(`One-handed weapons include swords, axes, maces, and other similar weapon types. One-handed weapons do not include daggers, fist weapons, bows, or shields.`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.oneHanded)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.oneHanded)
	},
}
player.oneHanded = { ...oneHanded }

const twoHanded = {
	id: 4,
	name: 'Two Handed',
	refName: 'twoHanded',
	type: 'skill',
	attackPower: 0,
	level: 0,
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 6,
	accuracy: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 0,
	color: 'green',
	description: function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`This is the primary skill for those specializing in two-handed weapons. Training this skill will increase your swing speed, damage, and accuracy with all two handed weapon types. Once the maximum swing speed has been reached, damage is further increased.`, 'white', line1)
		blankSpace()
		customizeEachWord(`Two-handed weapons include swords, axes, maces, and other similar weapon types that are wielded in both hands. Two-handed weapons do not include daggers, fist weapons, bows, or shields.`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.twoHanded)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.twoHanded)
	},
}
player.twoHanded = { ...twoHanded }
const bows = {
	name: 'Bows',
	refName: 'bows',
	type: 'skill',
	attackPower: 0,
	level: 10,
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 4,
	accuracy: 0,
	slashingPen: 0,
	piercingPend: 0,
	bluntPen: 0,
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.bows)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.bows)
	},
}
player.bows = { ...bows }
const shields = {
	name: 'Shields',
	refName: 'shields',
	type: 'skill',
	attackPower: 0,
	rating: function() {
		return this.level
	},
	level: 1,
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 0,
	accuracy: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 0,
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.shields)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.shields)
	},
}
player.shields = { ...shields }


///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////
///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////
///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////
///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////

const fireflames = {
	level: 1,
	name: 'Fireflames',
	refName: 'fireflames',
	color: 'fire',
	conjureBarColor: 'fire-conjure',
	type: 'fire',
	element: 'fire',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.fireflames.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.fireflames.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.fireflames.level <= 1) {spellLevelReduction = 0}
		if (player.fireflames.level == 2) {spellLevelReduction = 0}
		if (player.fireflames.level == 3) {spellLevelReduction = 0}
		if (player.fireflames.level == 4) {spellLevelReduction = 0}
		if (player.fireflames.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.fireflames.level <= 1) {spellLevelReduction = 0}
		if (player.fireflames.level == 2) {spellLevelReduction = 0}
		if (player.fireflames.level == 3) {spellLevelReduction = 0}
		if (player.fireflames.level == 4) {spellLevelReduction = 0}
		if (player.fireflames.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		fireSpellConjure.play()
	},
	castAudio: function() {
		fireflamesArray[randomNumberRange(0, 2)].play()
	},
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.fireflames)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.fireflames)
	},
	damage: function(enemy) {
		let burnStacks = enemy?.debuffs?.burn?.stacks ? enemy?.debuffs?.burn?.stacks : 0
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damageBeforeBonus = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let burnBonusDamage = ((burnStacks * player.burn.bonusModifier()) + 1)
		let damageWithBurn = damageBeforeBonus * burnBonusDamage
		let levelMultiplier
		if (player.fireflames.level == 1) { levelMultiplier = 1.0 }
		if (player.fireflames.level == 2) { levelMultiplier = 1.2 }
		if (player.fireflames.level == 3) { levelMultiplier = 1.4 }
		if (player.fireflames.level == 4) { levelMultiplier = 1.6 }
		if (player.fireflames.level == 5) { levelMultiplier = 1.8 }
		if (player.fireflames.level == 6) { levelMultiplier = 2.0 }
		if (player.fireflames.level == 7) { levelMultiplier = 2.2 }
		if (player.fireflames.level == 8) { levelMultiplier = 2.4 }
		if (player.fireflames.level == 9) { levelMultiplier = 2.6 }
		if (player.fireflames.level >= 10) { levelMultiplier = 2.8 }
		let totalDamage = Math.ceil(damageWithBurn * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Burn',
		refName: 'burn',
		stacks: 0,
		duration: 30000,
		maxStacks: function() {
			return player.fireflames.level + 2
		},
		damage: function() {
			let damage = player.fireflames.damage() * 2
			return damage
		}
	},
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1.0,
	chambered: false,
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		calculateBurnEffect(enemy, spell, damageBeforeMagicResist)
		if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`With a wave of your arm you send a ball of `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Fire `, 'fire', line1)
		customizeEachWord(`hurling towards the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Fireflames is the first spell learned by a Pyromancer, and is the base spell for enhancing their other spells. Fireflames is a single target spell that deals damage and applies the debuff Burn to the target. Each stack of Burn increases the damage of all your fire spells against that target. See Inferno for the special interaction that it has with Burn.`, 'white', line1)
		blankSpace()
	}
}
player.fireflames = { ...fireflames }


const inferno = {
	level: 1,
	name: 'Inferno',
	refName: 'inferno',
	color: 'fire',
	conjureBarColor: 'fire-conjure',
	type: 'fire',
	element: 'fire',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.inferno.level == 1) {return 15 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 2) {return 30 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 3) {return 45 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 4) {return 60 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 5) {return 75 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 6) {return 90 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 7) {return 105 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 8) {return 120 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 9) {return 135 * player.sorceryMastery.reduction()}
		if (player.inferno.level >= 10) {return 150 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.inferno.level <= 1) {spellLevelReduction = 0}
		if (player.inferno.level == 2) {spellLevelReduction = 0}
		if (player.inferno.level == 3) {spellLevelReduction = 0}
		if (player.inferno.level == 4) {spellLevelReduction = 0}
		if (player.inferno.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.inferno.level <= 1) {spellLevelReduction = 0}
		if (player.inferno.level == 2) {spellLevelReduction = 0}
		if (player.inferno.level == 3) {spellLevelReduction = 0}
		if (player.inferno.level == 4) {spellLevelReduction = 0}
		if (player.inferno.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		fireSpellConjure.play()
	},
	castAudio: function() {
		infernoArray[randomNumberRange(0, 2)].play()
	},
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.inferno)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.inferno)
	},
	damage: function(enemy) {
		let burnStacks = enemy?.debuffs?.burn?.stacks ? enemy?.debuffs?.burn?.stacks : 0
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damageBeforeBonus = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let burnBonusDamage = ((burnStacks * player.burn.bonusModifier()) + 1)
		let damageWithBurn = damageBeforeBonus * burnBonusDamage
		let levelMultiplier
		if (player.inferno.level == 1) { levelMultiplier = 1.5 }
		if (player.inferno.level == 2) { levelMultiplier = 1.7 }
		if (player.inferno.level == 3) { levelMultiplier = 1.9 }
		if (player.inferno.level == 4) { levelMultiplier = 2.1 }
		if (player.inferno.level == 5) { levelMultiplier = 2.3 }
		if (player.inferno.level == 6) { levelMultiplier = 2.5 }
		if (player.inferno.level == 7) { levelMultiplier = 2.7 }
		if (player.inferno.level == 8) { levelMultiplier = 2.9 }
		if (player.inferno.level == 9) { levelMultiplier = 3.1 }
		if (player.inferno.level >= 10) { levelMultiplier = 3.3 }
		let totalDamage = Math.ceil(damageWithBurn * levelMultiplier)
		return totalDamage
	},
	botMod: 1.5,
	topMod: 2.5,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.inferno)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Holding out your arms, a raging `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Inferno `, 'fire', line1)
		customizeEachWord(`rapidly forms around you before it surges into the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		// if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		let allEnemiesInRoom = getAllEnemiesInRoom()
		let enemiesToTarget = allEnemiesInRoom.slice(0, allEnemiesInRoom.length);
		let enemyFireResist = enemy?.fireResist ? enemy?.fireResist : 0
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		calculateBurnEffect(enemy, spell, damageBeforeMagicResist, enemiesToTarget)
	},
	specialEffect: function(enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Inferno's `, 'fire', line1)
		customizeEachWord(`explosion blasts the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`${this.name} `, `fire`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.inferno = { ...inferno }

const meteor = {
	level: 1,
	name: 'Meteor',
	refName: 'meteor',
	color: 'fire',
	conjureBarColor: 'fire-conjure',
	type: 'fire',
	element: 'fire',
	aoe: true,
	numberOfTargets: 'all',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.meteor.level == 1) {return 25 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 2) {return 50 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 3) {return 75 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 4) {return 100 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 5) {return 125 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 6) {return 150 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 7) {return 175 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 8) {return 200 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 9) {return 225 * player.sorceryMastery.reduction()}
		if (player.meteor.level >= 10) {return 250 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.meteor.level <= 1) {spellLevelReduction = 0}
		if (player.meteor.level == 2) {spellLevelReduction = 0}
		if (player.meteor.level == 3) {spellLevelReduction = 0}
		if (player.meteor.level == 4) {spellLevelReduction = 0}
		if (player.meteor.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.meteor.level <= 1) {spellLevelReduction = 0}
		if (player.meteor.level == 2) {spellLevelReduction = 0}
		if (player.meteor.level == 3) {spellLevelReduction = 0}
		if (player.meteor.level == 4) {spellLevelReduction = 0}
		if (player.meteor.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		fireSpellConjure.play()
	},
	castAudio: function() {
		meteorArray[randomNumberRange(0, 2)].play()
	},
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.meteor)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.meteor)
	},
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	damage: function(enemy) {
		let burnStacks = enemy?.debuffs?.burn?.stacks ? enemy?.debuffs?.burn?.stacks : 0
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damageBeforeBonus = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let burnBonusDamage = ((burnStacks * player.burn.bonusModifier()) + 1)
		let damageWithBurn = damageBeforeBonus * burnBonusDamage
		let levelMultiplier
		if (player.meteor.level == 1) { levelMultiplier = 1.0 }
		if (player.meteor.level == 2) { levelMultiplier = 1.2 }
		if (player.meteor.level == 3) { levelMultiplier = 1.4 }
		if (player.meteor.level == 4) { levelMultiplier = 1.6 }
		if (player.meteor.level == 5) { levelMultiplier = 1.8 }
		if (player.meteor.level == 6) { levelMultiplier = 2.0 }
		if (player.meteor.level == 7) { levelMultiplier = 2.2 }
		if (player.meteor.level == 8) { levelMultiplier = 2.4 }
		if (player.meteor.level == 9) { levelMultiplier = 2.6 }
		if (player.meteor.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damageWithBurn * levelMultiplier)
		return totalDamage
	},
	botMod: 2.0,
	topMod: 3.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.meteor)
	},
	cast: function(enemy, spell) {
		let allEnemies = getAllEnemiesInRoom();
		let numberOfTargets = spell.numberOfTargets == 'all' ? allEnemies.length : spell.numberOfTargets;
		let enemiesToTarget = allEnemies.slice(0, numberOfTargets);
		for (let i = 0; i < enemiesToTarget.length; i++) {
			let enemy = enemiesToTarget[i];
			// let damage = Math.ceil(damage / numberOfTargets);
			let damageObject = calculateMagicDamage(enemy, spell)
			let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
			spell.chambered = false
			spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterMagicResist)
			calculateBurnEffect(enemy, spell, damageBeforeMagicResist)
			if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		}
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You hold your arms out above your head as you summon forth a massive `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Meteor`, 'fire', line1)
		customizeEachWord(`. Pulling your arms down, the ball of fire follows your motions as it speeds through the air, exploding as it crashes into the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Meteor `, 'fire', line1)
		customizeEachWord(`explodes!!! And blasts the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.meteor = { ...meteor}

const frostfreeze = {
	level: 1,
	name: 'Frostfreeze',
	refName: 'frostfreeze',
	color: 'ice',
	conjureBarColor: 'ice-conjure',
	type: 'ice',
	element: 'ice',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.frostfreeze.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.frostfreeze.level <= 1) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 2) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 3) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 4) {spellLevelReduction = 0}
		if (player.frostfreeze.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.frostfreeze.level <= 1) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 2) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 3) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 4) {spellLevelReduction = 0}
		if (player.frostfreeze.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		iceSpellConjure.play()
	},
	castAudio: function() {
		frostfreezeArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.frostfreeze.level == 1) { levelMultiplier = 1.0 }
		if (player.frostfreeze.level == 2) { levelMultiplier = 1.2 }
		if (player.frostfreeze.level == 3) { levelMultiplier = 1.4 }
		if (player.frostfreeze.level == 4) { levelMultiplier = 1.6 }
		if (player.frostfreeze.level == 5) { levelMultiplier = 1.8 }
		if (player.frostfreeze.level == 6) { levelMultiplier = 2.0 }
		if (player.frostfreeze.level == 7) { levelMultiplier = 2.2 }
		if (player.frostfreeze.level == 8) { levelMultiplier = 2.4 }
		if (player.frostfreeze.level == 9) { levelMultiplier = 2.6 }
		if (player.frostfreeze.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Frostbite',
		refName: 'frostbite',
		stacks: 0,
		maxStacks: function() {
			return 3
		},
	},
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.frostfreeze)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let enemyIceResist = enemy.iceResist
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		calculateFrostbiteEffect(enemy, spell, damageObject)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Ice particles crystallize around your hand. You swing your arm sending a barrage of ice shards into the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function(enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `cryo-mage-spell-text-color`, line1)
		blankSpace()
	},
	specialEffect2: function(enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`${this.name}'s Shatter `, this.color, line2)
		customizeEachWord(`hits `, `green`, line2)
		customizeEachWord(`${enemy.name} `, enemy.color, line2)
		customizeEachWord(`for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.frostfreeze = { ...frostfreeze }
const blizzard = {
	level: 1,
	name: 'Blizzard',
	refName: 'blizzard',
	color: 'ice',
	conjureBarColor: 'ice-conjure',
	type: 'ice',
	element: 'ice',
	aoe: true,
	get numberOfTargets() {
		return 2 + this.level
	}, 
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.blizzard.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.blizzard.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.blizzard.level <= 1) {spellLevelReduction = 0}
		if (player.blizzard.level == 2) {spellLevelReduction = 0}
		if (player.blizzard.level == 3) {spellLevelReduction = 0}
		if (player.blizzard.level == 4) {spellLevelReduction = 0}
		if (player.blizzard.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.blizzard.level <= 1) {spellLevelReduction = 0}
		if (player.blizzard.level == 2) {spellLevelReduction = 0}
		if (player.blizzard.level == 3) {spellLevelReduction = 0}
		if (player.blizzard.level == 4) {spellLevelReduction = 0}
		if (player.blizzard.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		iceSpellConjure.play()
	},
	castAudio: function() {
		blizzardArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.blizzard.level == 1) { levelMultiplier = 1.0 }
		if (player.blizzard.level == 2) { levelMultiplier = 1.2 }
		if (player.blizzard.level == 3) { levelMultiplier = 1.4 }
		if (player.blizzard.level == 4) { levelMultiplier = 1.6 }
		if (player.blizzard.level == 5) { levelMultiplier = 1.8 }
		if (player.blizzard.level == 6) { levelMultiplier = 2.0 }
		if (player.blizzard.level == 7) { levelMultiplier = 2.2 }
		if (player.blizzard.level == 8) { levelMultiplier = 2.4 }
		if (player.blizzard.level == 9) { levelMultiplier = 2.6 }
		if (player.blizzard.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Frostbite',
		refName: 'frostbite',
		stacks: 0,
		maxStacks: function() {
			return 2
		},
		// damage: function() {
		// 	let damage = player.blizzard.damage() * 2
		// 	return damage
		// }
	},
	botMod: 1.5,
	topMod: 2.5,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.blizzard)
	},
	cast: function(undefined, spell) {
		let mainAllEnemies = getAllEnemiesInRoom()
		let numberOfTargets = spell.numberOfTargets > mainAllEnemies.length ? mainAllEnemies.length : spell.numberOfTargets
		let allEnemies = mainAllEnemies.slice(0, numberOfTargets);
		if (checkAvailableEnemy(allEnemies[0])) {return}
		for (let i = 0; i < numberOfTargets; i++) {
			let enemyIceResist = allEnemies[i]?.iceResist ? allEnemies[i]?.iceResist : 0
			let damageObject = calculateMagicDamage(allEnemies[i], spell)
			console.log(damageObject, ' DAMAGE OBJECT')
			let { damageAfterMagicResist, damageResisted } = damageObject
			spell.flavorTextCast(allEnemies[i], damageAfterMagicResist, damageResisted)
			applyDamageToEnemy(allEnemies[i], damageAfterMagicResist)
			if (spell.debuff) {applyDebuff(allEnemies[i], spell.debuff)}
		}
		let spellIndex = player.spellsConjured.indexOf(spell)
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You raise your arms to the sky, conjuring a storm of ice that crashes down onto the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, `cryo-mage-spell-text-color`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.blizzard = { ...blizzard }

const cryoclast = {
	level: 1,
	name: 'Cryoclast',
	refName: 'cryoclast',
	color: 'ice',
	conjureBarColor: 'ice-conjure',
	type: 'ice',
	element: 'ice',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.cryoclast.level == 1) {return 25 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 2) {return 50 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 3) {return 75 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 4) {return 100 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 5) {return 125 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 6) {return 150 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 7) {return 175 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 8) {return 200 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 9) {return 225 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level >= 10) {return 250 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.cryoclast.level <= 1) {spellLevelReduction = 0}
		if (player.cryoclast.level == 2) {spellLevelReduction = 0}
		if (player.cryoclast.level == 3) {spellLevelReduction = 0}
		if (player.cryoclast.level == 4) {spellLevelReduction = 0}
		if (player.cryoclast.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.cryoclast.level <= 1) {spellLevelReduction = 0}
		if (player.cryoclast.level == 2) {spellLevelReduction = 0}
		if (player.cryoclast.level == 3) {spellLevelReduction = 0}
		if (player.cryoclast.level == 4) {spellLevelReduction = 0}
		if (player.cryoclast.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		iceSpellConjure.play()
	},
	castAudio: function() {
		cryoclastArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.cryoclast.level == 1) { levelMultiplier = 1.0 }
		if (player.cryoclast.level == 2) { levelMultiplier = 1.2 }
		if (player.cryoclast.level == 3) { levelMultiplier = 1.4 }
		if (player.cryoclast.level == 4) { levelMultiplier = 1.6 }
		if (player.cryoclast.level == 5) { levelMultiplier = 1.8 }
		if (player.cryoclast.level == 6) { levelMultiplier = 2.0 }
		if (player.cryoclast.level == 7) { levelMultiplier = 2.2 }
		if (player.cryoclast.level == 8) { levelMultiplier = 2.4 }
		if (player.cryoclast.level == 9) { levelMultiplier = 2.6 }
		if (player.cryoclast.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Frostbite',
		refName: 'frostbite',
		stacks: 0,
		maxStacks: function() {
			return 2
		},
		// damage: function() {
		// 	let damage = player.fire.damage() * 2
		// 	return damage
		// }
	},
	botMod: 2.0,
	topMod: 3.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.cryoclast)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		// if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		let enemyIceResist = enemy?.iceResist ? enemy?.iceResist : 0
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		calculateFrostbiteEffect(enemy, spell, damageObject, enemyIceResist)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You conjure an enormous boulder of ice above your head, launching it at blinding speed into the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, `ice`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect2: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The impact causes the ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`to explode in an icy blast!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, `ice`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.cryoclast = { ...cryoclast }
const flashbolt = {
	level: 1,
	name: 'Flashbolt',
	refName: 'flashbolt',
	color: 'lightning',
	conjureBarColor: 'lightning-conjure',
	type: 'lightning',
	element: 'lightning',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.flashbolt.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.flashbolt.level <= 1) {spellLevelReduction = 0}
		if (player.flashbolt.level == 2) {spellLevelReduction = 0}
		if (player.flashbolt.level == 3) {spellLevelReduction = 0}
		if (player.flashbolt.level == 4) {spellLevelReduction = 0}
		if (player.flashbolt.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.flashbolt.level <= 1) {spellLevelReduction = 0}
		if (player.flashbolt.level == 2) {spellLevelReduction = 0}
		if (player.flashbolt.level == 3) {spellLevelReduction = 0}
		if (player.flashbolt.level == 4) {spellLevelReduction = 0}
		if (player.flashbolt.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		lightningSpellConjure.play()
	},
	castAudio: function() {
		flashboltArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.flashbolt.level == 1) { levelMultiplier = 1.0 }
		if (player.flashbolt.level == 2) { levelMultiplier = 1.2 }
		if (player.flashbolt.level == 3) { levelMultiplier = 1.4 }
		if (player.flashbolt.level == 4) { levelMultiplier = 1.6 }
		if (player.flashbolt.level == 5) { levelMultiplier = 1.8 }
		if (player.flashbolt.level == 6) { levelMultiplier = 2.0 }
		if (player.flashbolt.level == 7) { levelMultiplier = 2.2 }
		if (player.flashbolt.level == 8) { levelMultiplier = 2.4 }
		if (player.flashbolt.level == 9) { levelMultiplier = 2.6 }
		if (player.flashbolt.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Shock',
		refName: 'shock',
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		// damage: function() {
		// 	let damage = player.fire.damage() * 2
		// 	return damage
		// }
	},
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.flashbolt)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let mainAllEnemies = getAllEnemiesInRoom()
		let allEnemies = mainAllEnemies.slice(0, mainAllEnemies.length);
		let enemyLightningResist = enemy.lightningResist
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		//if there is more than 1 enemy and it does not have shock debuff
		if (allEnemies.length > 1 && enemy?.debuffs?.shock) {
			let indexOfTarget = allEnemies.indexOf(enemy)
			//Find the next target without a shock debuff as indexes increase - Finds first monster to the right
			for (let i = indexOfTarget; i < allEnemies.length; i++) {
				let enemyToCheck = allEnemies[i + 1]
				if (enemyToCheck && !enemyToCheck?.debuffs?.shock) {
					applyDebuff(enemyToCheck, spell.debuff)
					break
				}
			}
			//Find the next target without a shock debuff as indexes decrease - Finds first monster to the left
			for (let i = indexOfTarget; i < allEnemies.length; i--) {
				let enemyToCheck = allEnemies[i - 1]
				if (enemyToCheck && !enemyToCheck?.debuffs?.shock) {
					applyDebuff(enemyToCheck, spell.debuff)
					break
				}
				if (i == -1) {
					break
				}
			}
		}
		for (let i = 0; i < allEnemies.length; i++) {
			let enemyTarget = allEnemies[i]
			let mainTargetIndex = allEnemies.indexOf(enemy)
			if (enemyTarget?.debuffs?.shock && i != mainTargetIndex) {
				let enemyLightningResist = enemyTarget.lightningResist
				let damageObject = calculateMagicDamage(enemyTarget, spell)
				let { damageAfterMagicResist, damageResisted } = damageObject
				spell.flavorTextCast(enemyTarget, damageAfterMagicResist, damageResisted)
				applyDamageToEnemy(enemyTarget, damageAfterMagicResist)
			}
		}

		if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Holding up your hand, you channel electricity to the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(` in an electric flash!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.flashbolt = { ...flashbolt }
const chainLightning = {
	level: 1,
	name: 'Chain Lightning',
	refName: 'chainLightning',
	color: 'lightning',
	conjureBarColor: 'lightning-conjure',
	type: 'lightning',
	element: 'lightning',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.chainLightning.level == 1) {return 15 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 2) {return 30 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 3) {return 45 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 4) {return 60 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 5) {return 75 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 6) {return 90 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 7) {return 105 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 8) {return 120 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 9) {return 135 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level >= 10) {return 150 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.chainLightning.level <= 1) {spellLevelReduction = 0}
		if (player.chainLightning.level == 2) {spellLevelReduction = 0}
		if (player.chainLightning.level == 3) {spellLevelReduction = 0}
		if (player.chainLightning.level == 4) {spellLevelReduction = 0}
		if (player.chainLightning.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.chainLightning.level <= 1) {spellLevelReduction = 0}
		if (player.chainLightning.level == 2) {spellLevelReduction = 0}
		if (player.chainLightning.level == 3) {spellLevelReduction = 0}
		if (player.chainLightning.level == 4) {spellLevelReduction = 0}
		if (player.chainLightning.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		lightningSpellConjure.play()
	},
	castAudio: function() {
		chainLightningArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.chainLightning.level == 1) { levelMultiplier = 1.0 }
		if (player.chainLightning.level == 2) { levelMultiplier = 1.2 }
		if (player.chainLightning.level == 3) { levelMultiplier = 1.4 }
		if (player.chainLightning.level == 4) { levelMultiplier = 1.6 }
		if (player.chainLightning.level == 5) { levelMultiplier = 1.8 }
		if (player.chainLightning.level == 6) { levelMultiplier = 2.0 }
		if (player.chainLightning.level == 7) { levelMultiplier = 2.2 }
		if (player.chainLightning.level == 8) { levelMultiplier = 2.4 }
		if (player.chainLightning.level == 9) { levelMultiplier = 2.6 }
		if (player.chainLightning.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Shock',
		refName: 'shock',
		stacks: 0,
		maxStacks: function() {
			return 2
		},
		// damage: function() {
		// 	let damage = player.fire.damage() * 2
		// 	return damage
		// }
	},
	botMod: 1.5,
	topMod: 2.5,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.chainLightning)
	},
	cast: function(enemy, spell) {
		let numberOfTargets = this.level + 4
		let mainAllEnemies = getAllEnemiesInRoom()
		let allEnemies = mainAllEnemies.slice(0, numberOfTargets);
		for (let i = 0; i < numberOfTargets; i++) {
			if (checkAvailableEnemy2(allEnemies[i])) {break}
			// let damageObject = {
			// 	damageBeforeMagicResist: 0,
			// 	damageAfterMagicResist: 0,
			// 	damageResisted: 0,
			// 	bonusShockDamage: 0,
			// }
			let enemyLightningResist = allEnemies[i].lightningResist ? allEnemies[i].lightningResist : 0
			let damageObject = calculateMagicDamage(allEnemies[i], spell)
			let { damageAfterMagicResist, damageResisted } = damageObject
			if (allEnemies[i]?.debuffs?.shock) {
				quickMessage(`SHOULD CALC BONUS SHOCK damage.`)
				damageObject.bonusShockDamage = calculateShockEffect(allEnemies[i], spell, damageObject)
			} else {
				damageObject.bonusShockDamage = 0
			}
			damageObject.totalDamage = damageObject.damageAfterMagicResist + damageObject.bonusShockDamage
			spell.flavorTextCast(allEnemies[i], damageObject.totalDamage, damageResisted)
			applyDamageToEnemy(allEnemies[i], damageObject.totalDamage)
			if (allEnemies[i]?.debuffs?.shock?.stacks == 1) {applyDebuff(allEnemies[i], spell.debuff)}
			console.log(damageObject, 'Chain Lightning Damage Object')
		}
		let spellIndex = player.spellsConjured.indexOf(spell)
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You hold your arms back as they accumulate lightning energy. Throwing your arms forward, thick tendrils of lightning surge into the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.chainLightning = { ...chainLightning }

const gigavolt = {
	level: 1,
	name: 'Gigavolt',
	refName: 'gigavolt',
	color: 'lightning',
	conjureBarColor: 'lightning-conjure',
	type: 'lightning',
	element: 'lightning',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.gigavolt.level == 1) {return 25 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 2) {return 50 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 3) {return 75 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 4) {return 100 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 5) {return 125 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 6) {return 150 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 7) {return 175 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 8) {return 200 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 9) {return 225 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level >= 10) {return 250 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.gigavolt.level <= 1) {spellLevelReduction = 0}
		if (player.gigavolt.level == 2) {spellLevelReduction = 0}
		if (player.gigavolt.level == 3) {spellLevelReduction = 0}
		if (player.gigavolt.level == 4) {spellLevelReduction = 0}
		if (player.gigavolt.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.gigavolt.level <= 1) {spellLevelReduction = 0}
		if (player.gigavolt.level == 2) {spellLevelReduction = 0}
		if (player.gigavolt.level == 3) {spellLevelReduction = 0}
		if (player.gigavolt.level == 4) {spellLevelReduction = 0}
		if (player.gigavolt.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		lightningSpellConjure.play()
	},
	castAudio: function() {
		gigavoltArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.gigavolt.level == 1) { levelMultiplier = 1.0 }
		if (player.gigavolt.level == 2) { levelMultiplier = 1.2 }
		if (player.gigavolt.level == 3) { levelMultiplier = 1.4 }
		if (player.gigavolt.level == 4) { levelMultiplier = 1.6 }
		if (player.gigavolt.level == 5) { levelMultiplier = 1.8 }
		if (player.gigavolt.level == 6) { levelMultiplier = 2.0 }
		if (player.gigavolt.level == 7) { levelMultiplier = 2.2 }
		if (player.gigavolt.level == 8) { levelMultiplier = 2.4 }
		if (player.gigavolt.level == 9) { levelMultiplier = 2.6 }
		if (player.gigavolt.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	botMod: 2.0,
	topMod: 3.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.gigavolt)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let enemyLightningResist = enemy.lightningResist
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)

		let allEnemies = getAllEnemiesInRoom()
		let allConduitEnemies = allEnemies.filter(enemy => enemy?.debuffs?.shock?.stacks == 2)
		allConduitEnemies.forEach(enemy => {
			let enemyLightningResist = enemy.lightningResist
			let spellIndex = player.spellsConjured.indexOf(spell)
			let damageObject = calculateMagicDamage(enemy, spell)
			let { damageAfterMagicResist, damageResisted } = damageObject
			spell.chambered = false
			spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterMagicResist)
		})
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The air crackles with electricity as you channel a giant bolt of lightning from the sky that spirals into the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`with a deafening boom!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`FIX GFIX FGIX IFG `, `lightning-magus-spell-text-color`, line1)
		// customizeEachWord(`${enemy.name} `, enemy.color, line1)
		// customizeEachWord(`shatters!`, `lightning-magus-spell-text-color`, line1)
		// customizeEachWord(`You hit for `, 'green', line2)
		// customizeEachWord(`${damage} `, 'light-blue', line2)
		// customizeEachWord(`lightning `, `lightning`, line2)
		// customizeEachWord(`damage. `, `green`, line2)
		// customizeEachWord(`(Enemy resists `, `white`, line2)
		// customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		// customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
}
player.gigavolt = { ...gigavolt }

const heal = {
	name: 'Heal',
	refName: 'heal',
	color: 'heal',
	type: 'restorative',
	level: 1,
	conjureTime: function() {
		let baseConjureTime = 6000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.heal.level <= 1) {spellLevelReduction = 0}
		if (player.heal.level == 2) {spellLevelReduction = 0}
		if (player.heal.level == 3) {spellLevelReduction = 0}
		if (player.heal.level == 4) {spellLevelReduction = 0}
		if (player.heal.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 6000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.heal.level <= 1) {spellLevelReduction = 0}
		if (player.heal.level == 2) {spellLevelReduction = 0}
		if (player.heal.level == 3) {spellLevelReduction = 0}
		if (player.heal.level == 4) {spellLevelReduction = 0}
		if (player.heal.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.heal.level == 1) {return 20 * player.mysticismMastery.reduction()}
		if (player.heal.level == 2) {return 35 * player.mysticismMastery.reduction()}
		if (player.heal.level == 3) {return 52 * player.mysticismMastery.reduction()}
		if (player.heal.level == 4) {return 70 * player.mysticismMastery.reduction()}
		if (player.heal.level == 5) {return 91 * player.mysticismMastery.reduction()}
		if (player.heal.level == 6) {return 113 * player.mysticismMastery.reduction()}
		if (player.heal.level == 7) {return 137 * player.mysticismMastery.reduction()}
		if (player.heal.level == 8) {return 162 * player.mysticismMastery.reduction()}
		if (player.heal.level == 9) {return 189 * player.mysticismMastery.reduction()}
		if (player.heal.level >= 10) {return 215 * player.mysticismMastery.reduction()}
	},
	conjureBarColor: 'restorative-spell',
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1,
	chambered: false,
	color: 'heal',
	heal: function() {
		let botHeal = player.mysticPower * this.botMod
		let topHeal = player.mysticPower * this.topMod
		let healAmount = Math.pow(randomNumberRange(botHeal, topHeal), this.proficiency)
		let levelMultiplier
		if (player.heal.level == 1) { levelMultiplier = 1.0 }
		if (player.heal.level == 2) { levelMultiplier = 1.2 }
		if (player.heal.level == 3) { levelMultiplier = 1.4 }
		if (player.heal.level == 4) { levelMultiplier = 1.6 }
		if (player.heal.level == 5) { levelMultiplier = 1.8 }
		if (player.heal.level == 6) { levelMultiplier = 2.0 }
		if (player.heal.level == 7) { levelMultiplier = 2.2 }
		if (player.heal.level == 8) { levelMultiplier = 2.4 }
		if (player.heal.level == 9) { levelMultiplier = 2.6 }
		if (player.heal.level >= 10) { levelMultiplier = 3.0 }
		let totalHeal = Math.ceil(healAmount * levelMultiplier)
		return totalHeal
	},
	goldToUpgrade: function () {
		spellGoldUpgradeCost(player.heal)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.heal)
	},
	cast: function() {
		let healAmount = player.heal.heal()
		healAmount = player.health + healAmount > player.maxHealth ? player.maxHealth - player.health : healAmount
		this.chambered = false
		this.flavorTextCast(healAmount)
		applyHealToPlayer(healAmount)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (healAmount) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You place your hands on your chest and a green glow sinks into your body as you `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`Yourself.`, 'white', line1)
		customizeEachWord(`You heal for `, 'green', line2)
		customizeEachWord(`${healAmount} `, 'light-blue', line2)
		customizeEachWord(`health.`, 'green', line2)
		blankSpace()

	},
	description: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Heal `, this.color, line1)
		customizeEachWord(`will heal yourself for an amount based on your Mysticpower.`, 'white', line1)
		blankSpace()
	},
}
player.heal = {...heal}

//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////
//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////
//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////
//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////

//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
// const firefist = {
// 	name: 'Fire Fist',
// 	refName: 'fireFist',
// 	color: 'fire-fist-color',
// 	type: 'enchantment',
// 	enchantWeaponOrArmor: 'weapon',
// 	level: 1,
// 	conjureTime: function() {return 2000},
// 	channelTime: 4.0,
// 	damage: 5,
// 	botMod: 1.0,
// 	topMod: 3.5,
// 	proficiency: 1.0,
// 	duration: 1000000,
// 	chambered: false,
// 	color: 'fire',
// 	buff: {
// 		name: 'Fire Fist',
// 		refName: 'fireFist',
// 		duration: 100000,
// 		onHit: true,
// 	},
// 	onHit: function (weapon, damage, enemy) {
// 		let line1 = document.createElement('div')
// 		customizeEachWord(`A burst of flames erupts from your `, 'white', line1)
// 		customizeEachWord(`${weapon.name} `, weapon.color, line1)
// 		customizeEachWord(`blasting the `, 'white', line1)
// 		customizeEachWord(`${enemy.name} `, enemy.color, line1)
// 		customizeEachWord(`for `, 'white', line1)
// 		customizeEachWord(`${damage} `, 'blue', line1)
// 		customizeEachWord(`damage.`, 'white', line1)
// 	},
// 	goldToUpgrade: function () {
// 		return 9 * this.level
// 	},
// 	pointsToUpgrade: function () {
// 		return this.level + 1
// 	},
// 	channel: function () {
// 		let line1 = document.createElement('div')
// 		customizeEachWord(`You `, 'light-blue', line1)
// 		customizeEachWord(`shape your hands in concentration as you channel `, 'white', line1)
// 		customizeEachWord(`Fire Fist `, 'ice-color', line1)
// 		customizeEachWord(`[`, 'white', line1)
// 		customizeEachWord(`${this.channelTime}`, 'yellow', line1)
// 		customizeEachWord(`]`, 'white', line1)
// 	},
// }
// player.firefist = {...firefist}
const lightningFistEnchant = {
	name: 'Lightning Fist',
	refName: 'lightningFist',
	color: 'lightning-fist-color',
	type: 'enchantment',
	enchantWeaponOrArmor: 'weapon',
	level: 1,
	conjureTime: 1.0,
	channelTime: 1.0,
	damage: 5,
	botMod: 2.0,
	topMod: 5.5,
	proficiency: 1.0,
	duration: 10000,
	chambered: false,
	color: 'lightning-spell',
	onHit: function (weapon, damage, enemy) {
		let line1 = document.createElement('div')
		customizeEachWord(`Sparks explode from your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`as it impacts the `, 'white', line1)
		customizeEachWord(`${enemy.name}, `, enemy.color, line1)
		customizeEachWord(`shocking it for `, 'white', line1)
		customizeEachWord(`${damage} `, 'blue', line1)
		customizeEachWord(`damage.`, 'white', line1)
	},
	goldToUpgrade: function () {
		return 9 * this.level
	},
	pointsToUpgrade: function () {
		return this.level + 1
	},
	channel: function () {
		let line1 = document.createElement('div')
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`shape your hands in concentration as you channel `, 'white', line1)
		customizeEachWord(`Fire Fist `, 'ice-color', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
	},
	cast: function (weapon) {
		let line1 = document.createElement('div')
		customizeEachWord(`With a wave of `, 'white', line1)
		customizeEachWord(`your `, 'light-blue', line1)
		customizeEachWord(`arm you send an `, 'white', line1)
		customizeEachWord(`Ice `, 'ice-color', line1)
		customizeEachWord(`hurling towards the `, 'white', line1)
		customizeEachWord(`${enemy.name}!`, `${enemy.color}`, line1)
	},
	description: function (weapon) {
		let line1 = document.createElement('div')
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`freeze the `, 'green', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`for `, 'green', line1)
		customizeEachWord(`${damage} `, 'light-blue', line1)
		customizeEachWord(`ice damage.`, `${this.color}`, line1)
	},
}
player.lightningFistEnchant = {...lightningFistEnchant}
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////


const allItems = []
// player.spells.push(fire)
// player.spells.push(fireFist)
// player.spells.push(ice)
// player.spells.push(lightningFist)
//---------------------------------------------------

function getUnarmedAttackPower(modifiers) {
	if (modifiers) {
		let attackPowerTotal = [...modifiers].reduce((a, b) => a + b) + player.unarmedAttackPower
		return attackPowerTotal
	} else {
		return player.unarmedAttackPower
	}
}
function getUnarmedSkillDamageMultiplier(modifiers) {
	if (modifiers) {
		let unarmedDamage = [...modifiers].reduce((a, b) => a + b) + player.botMultiplier
		return unarmedDamage
	} else {
		return player.unarmed.botMultiplier
	}
}

//-------------------------------------------------

function getOneHandedAttackPower(modifiers) {
	if (modifiers) {
		let attackPowerTotal = [...modifiers].reduce((a, b) => a + b) + player.oneHandedAttackPower
		return attackPowerTotal
	} else {
		return player.oneHandedAttackPower
	}
}

//__________________________________________________________________________________________________________________________________
//__________________________________________________________________________________________________________________________________

//________________________________________________________________________________________________________________________________________
//________________________________________________________________________________________________________________________________________

function displayPlayerHealthFunc() {}

var playerProxy = new Proxy(player, {
	set: function (target, key, value) {
		target[key] = value
		return true
	},
})

function displayPlayerStats() {
const playerLevel = document.querySelector('.level')

const attributeStr = document.querySelector('.str-number')
const attributeStrMod = document.querySelector('.str-mod')
const attributeDex = document.querySelector('.dex-number')
const attributeDexMod = document.querySelector('.dex-mod')
const attributeAgi = document.querySelector('.agi-number')
const attributeAgiMod = document.querySelector('.agi-mod')
const attributeInt = document.querySelector('.int-number')
const attributeIntMod = document.querySelector('.int-mod')
const attributeWis = document.querySelector('.wis-number')
const attributeWisMod = document.querySelector('.wis-mod')
const attributeMys = document.querySelector('.mys-number')
const attributeMysMod = document.querySelector('.mys-mod')
const attributeCon = document.querySelector('.con-number')
const attributeConMod = document.querySelector('.con-mod')

const statAttack = document.querySelector('.attack-number')
const statAccuracy = document.querySelector('.accuracy-number')
const statSpeed = document.querySelector('.speed-number')
const statSpellpower = document.querySelector('.spellpower-number')
const statMysticpower = document.querySelector('.mysticpower-number')

const statArmorSlashing = document.querySelector('.slashing-armor-number')
const statArmorPiercing = document.querySelector('.piercing-armor-number')
const statArmorBlunt = document.querySelector('.blunt-armor-number')
const statDodge = document.querySelector('.dodge-number')

playerLevel.innerHTML = `Level ${player.level}`

attributeStr.innerHTML = `Str ${player.str}`
attributeStrMod.innerHTML = player.mods.str > 0 ? ` +${player.mods.str}` : ``
attributeDex.innerHTML = `Dex ${player.dex}`
attributeDexMod.innerHTML = player.mods.dex > 0 ? ` +${player.mods.dex}` : ``
attributeAgi.innerHTML = `Agi ${player.agi}`
attributeAgiMod.innerHTML = player.mods.agi > 0 ? ` +${player.mods.agi}` : ``
attributeInt.innerHTML = `Int ${player.int}`
attributeIntMod.innerHTML = player.mods.int > 0 ? ` +${player.mods.int}` : ``
attributeWis.innerHTML = `Wis ${player.wis}`
attributeWisMod.innerHTML = player.mods.wis > 0 ? ` +${player.mods.wis}` : ``
attributeMys.innerHTML = `Mys ${player.mys}`
attributeMysMod.innerHTML = player.mods.mys > 0 ? ` +${player.mods.mys}` : ``
attributeCon.innerHTML = `Con ${player.con}`
attributeConMod.innerHTML = player.mods.con > 0 ? ` +${player.mods.con}` : ``

statAttack.innerHTML = `Attack ${player.currentWeaponSkill.attackPower}`
statAccuracy.innerHTML = `Accuracy: ${(player.currentWeaponSkill.accuracy + 75)}%`
statSpeed.innerHTML = `Speed: ${player.currentWeaponSkill.speed}`
statSpellpower.innerHTML = `Spellpower: ${player.spellPower}`
statMysticpower.innerHTML = `Mysticpower: ${player.mysticPower}`

statArmorSlashing.innerHTML = `Slashing: ${player.slashingArmor}`
statArmorPiercing.innerHTML = `Piercing: ${player.piercingArmor}`
statArmorBlunt.innerHTML = `Blunt: ${player.bluntArmor}`
statDodge.innerHTML = `Dodge: ${player.dodge + 25}%`


///////////////////////////////////////////////////////////////////////

}

/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
function playerStance() {
	// if (player.leftHand == empty && player.rightHand == empty && player.stance != 'hand to hand') {
	// 	console.log(' BOTH++++++++++++++')
	// 	weaponOrShieldAddPlayerAttribute(player.rightFist)
	// 	weaponOrShieldAddPlayerAttribute(player.leftFist)
	// 	player.stance = 'hand to hand'
	// } else if (player.rightHand == empty) {
	// 	console.log(' RIGHT HAND++++++++++++++')
	// 	weaponOrShieldRemovePlayerAttribute(player.rightFist)
	// 	player.stance = ''
	// } else if (player.leftHand == empty) {
	// 	console.log(' LEFT HAND++++++++++++++')
	// 	weaponOrShieldRemovePlayerAttribute(player.leftFist)
	// 	player.stance = ''
	// }
}

const warriorTemplate = {
	maxHealth: 30,
}
const healthBar = document.querySelector('.health-bar')
const magicShieldBar = document.querySelector('.magic-shield-bar')
const healthText = document.querySelector('.health-text')
const manaBar = document.querySelector('.mana-bar')
const manaText = document.querySelector('.mana-text')
const resourceBar = document.querySelector('.class-resource-bar')
const resourceText = document.querySelector('.class-resource-text')
const currentAttributes = document.querySelectorAll('.attribute')
const currentWeaponSkillRightDisplay = document.querySelector('.current-weapon-skill-right')
const currentWeaponSkillLeftDisplay = document.querySelector('.current-weapon-skill-left')
const expBar = document.querySelector('.exp-bar')
expBar.textContent = ''


function updateResource() {
	let resource
	let maxResource
	let resourceName
	switch (player.guild) {
		case 'Warrior':
			resource = 'might'
			maxResource = 'maxMight'
			resourceName = 'Might'
			resourceBar.classList.add('warrior-resource-bar')
			break;
		case 'Sinistral':
			resource = 'adrenaline'
			maxResource = 'maxAdrenaline'
			resourceName = 'Adrenaline'
			resourceBar.classList.add('sinistral-resource-bar')

			break;
		case 'Monk':
			resource = 'focus'
			maxResource = 'maxFocus'
			resourceName = 'Focus'
			resourceBar.classList.add('monk-resource-bar')

			break;
		case 'Ranger':
			resource = 'focus'
			maxResource = 'maxFocus'
			resourceName = 'Focus'
			resourceBar.classList.add('ranger-resource-bar')
			break;
		default:
			resource = ''
			maxResource = ''
			resourceName = ''
	}
	player.maxResource = 30
	const percent =  resource ? (player[resource] / player[maxResource]) * 100 : resource
	resourceBar.style.width =  resource ? `${percent}%` : ``
	resourceText.innerHTML = resource ? `${capitalizeFirstLetter(resourceName)}: ${player[resource]}/${player[maxResource]}` : ``
}
function updateHealth() {
	let healthFromConstitution = (player.con + player.mods.con) * 5
	let multipliers = preClass.healthMultiplier + player.vigor.healthMultiplier()
	let flatBonuses = preRace.maxHealth + preClass.maxHealth + player.mods.maxHealth + (preClass.healthPerLevel * player.level)

	player.maxHealth = Math.ceil((healthFromConstitution * multipliers) + flatBonuses)
	const percent = (player.health / player.maxHealth) * 100 > 100 ? 100 : (player.health / player.maxHealth) * 100 
	healthBar.style.width = `${percent}%`
	healthText.innerHTML = `Health: ${player.health}/${player.maxHealth}`
	if (player.magicShield > 0) {
		const percent = (player.magicShield / player.maxShield) * 100 > 100 ? 100 : (player.magicShield / player.maxShield) * 100 
		magicShieldBar.style.width = `${percent}%`
		magicShieldBar.innerHTML = `Shield: ${player.magicShield}`
	} else {
		magicShieldBar.style.width = `0%`
		magicShieldBar.innerHTML = ``
	}
}
function updateEXP() {
	let currentExp = player.experience
	let currentExpBracket = player.experienceNeededToLevel[player.level - 1]
	let nextExpBracket = player.experienceNeededToLevel[player.level]

	let bracketBase = nextExpBracket - currentExpBracket
	let newExpBase = currentExp - currentExpBracket
	let percentOfTheWayThere = parseInt((newExpBase / bracketBase) * 100).toFixed(2)
	expBar.style.width = `${percentOfTheWayThere}%`
}

function updateMana() {
	let manaFromWisdom = (player.wis + player.mods.wis) * 10
	let multipliers = preClass.manaMultiplier + player.devotion.manaMultiplier()
	let flatBonuses = preRace.maxMana + preClass.maxMana + player.mods.maxMana

	player.maxMana = Math.ceil((manaFromWisdom * multipliers) + flatBonuses)
	const percent = (player.mana / player.maxMana) * 100
	manaBar.style.width = `${percent}%`
	manaText.innerHTML = `Mana: ${player.mana}/${player.maxMana}`
}
function updateTwoHanded() {
	let str = player.str + player.mods.str
	let dex = player.dex + player.mods.dex
	let agi = player.agi + player.mods.agi

	let twoHandedAttributes = ((str * 2) + dex + agi) - 4
	player.twoHanded.attackPower = Math.floor(twoHandedAttributes + player.mods.attackPower)
	player.twoHanded.topMultiplier = parseFloat((0.30 + player.twoHanded.level / 20).toFixed(2))
	player.twoHanded.botMultiplier = parseFloat((0.30 + player.twoHanded.level / 20).toFixed(2))
	player.twoHanded.accuracy = Math.floor(10 + ((dex * 3) + player.twoHanded.level + player.mods.accuracy) * 10) / 10
	player.twoHanded.speed = player.twoHanded.speed <= 2 ? 2 : parseFloat((6.2 - Math.floor((player.twoHanded.level / 5) * 100) / 100).toFixed(1))
	player.twoHanded.speed += player.weight * 0.1
}

function updateOneHanded() {
	let str = player.str + player.mods.str
	let dex = player.dex + player.mods.dex
	const rightWeapon = player.currentRightHandWeapon().skillUsed;
	const leftWeapon = player.currentLeftHandWeapon().skillUsed;
	//This is basically saying, if the player is dual wielding daggers or swords, apply the accuracy penalty of -10
	if ((leftWeapon === 'daggers' || leftWeapon === 'oneHanded') &&
    (rightWeapon === 'daggers' || rightWeapon === 'oneHanded')) {
		player.oneHanded.accuracy = Math.floor(((dex + player.oneHanded.level + player.mods.accuracy) * 10) / 10) - 10
	} else {
		player.oneHanded.accuracy = Math.floor(10 + (dex + player.oneHanded.level + player.mods.accuracy) * 10) / 10
	}
	let oneHandedAttributes = str + dex
	player.oneHanded.attackPower = Math.floor(oneHandedAttributes + player.mods.attackPower)
	player.oneHanded.topMultiplier = parseFloat((0.30 + player.oneHanded.level / 20).toFixed(2)) //parseFloat((0.40 + 1 / 20).toFixed(2));
	player.oneHanded.botMultiplier = parseFloat((0.30 + player.oneHanded.level / 20).toFixed(2))
	player.oneHanded.speed = player.oneHanded.speed <= 2 ? 2 : parseFloat((5.1 - Math.floor((player.oneHanded.level / 5) * 100) / 100).toFixed(1))
	player.oneHanded.speed += player.weight * 0.1
}

function updateDaggers() {
	// let str = player.str + player.mods.str
	let dex = player.dex + player.mods.dex
	let agi = player.agi + player.mods.agi
	let dualSwingPenalty = 10
	const rightWeapon = player.currentRightHandWeapon().skillUsed;
	const leftWeapon = player.currentLeftHandWeapon().skillUsed;
	if ((leftWeapon === 'daggers' || leftWeapon === 'oneHanded') &&
    (rightWeapon === 'daggers' || rightWeapon === 'oneHanded')) {
		player.daggers.accuracy = Math.floor(((dex + player.daggers.level + player.mods.accuracy) * 10) / 10) - dualSwingPenalty
	} else {
		player.daggers.accuracy = Math.floor(10 + (dex + player.daggers.level + player.mods.accuracy) * 10) / 10
	}
	let daggersAttributes = dex + agi
//mods
	player.daggers.attackPower = Math.ceil(daggersAttributes  + player.mods.attackPower)
	player.daggers.topMultiplier = parseFloat((0.30 + player.daggers.level / 20).toFixed(2))
	player.daggers.botMultiplier = parseFloat((0.30 + player.daggers.level / 20).toFixed(2))
	//1 point of dex increases accuracy by 1
	player.daggers.speed = player.daggers.speed <= 2 ? 2 : parseFloat((5.1 - Math.floor((player.daggers.level / 5) * 100) / 100).toFixed(1))
	player.daggers.speed += player.weight * 0.1

}

function updateUnarmed() {
	let str = player.str + player.mods.str
	let dex = player.dex + player.mods.dex
	let agi = player.agi + player.mods.agi
	let dualSwingPenalty = 10
	let unarmedAttributes = (str + dex + agi)

	player.unarmed.attackPower = Math.ceil(unarmedAttributes + player.mods.attackPower)
	player.unarmed.topMultiplier = parseFloat((0.30 + player.unarmed.level / 20).toFixed(2))
	player.unarmed.botMultiplier = parseFloat((0.30 + player.unarmed.level / 20).toFixed(2))
	player.unarmed.accuracy = Math.floor(10 + (dex + player.mods.accuracy + player.unarmed.level - dualSwingPenalty) * 10) / 10
	player.unarmed.speed = parseFloat((4.1 - Math.floor((player.unarmed.level / 5) * 100) / 100).toFixed(1) < 2 ? 2 : parseFloat((4.1 - Math.floor((player.unarmed.level / 10) * 100) / 100).toFixed(1)))
	player.unarmed.speed += player.weight * 0.1
}

function updateBows() {
	let dex = player.dex + player.mods.dex
	let agi = player.agi + player.mods.agi
	let bowsAttributes = dex + agi

	player.bows.attackPower = Math.ceil(bowsAttributes + player.mods.attackPower)
	player.bows.topMultiplier = parseFloat((0.30 + player.bows.level / 20).toFixed(2))
	player.bows.botMultiplier = parseFloat((0.30 + player.bows.level / 20).toFixed(2))
	player.bows.accuracy = Math.floor(10 + (dex + player.bows.level + player.mods.accuracy) * 10) / 10
	player.bows.speed = player.bows.speed <= 2 ? 2 : parseFloat((5.1 - Math.floor((player.bows.level / 5) * 100) / 100).toFixed(1))
	player.bows.speed += player.weight * 0.1

}


function updateShields() {
	let str = player.str + player.mods.str
	let dex = player.dex + player.mods.dex
	let agi = player.agi + player.mods.agi
	let con = player.con + player.mods.con
	let armor = player.armor
	let weight = player.weight + player.mods.weight
	let shieldsAttributes = str / 2 + con * 2
	let shieldsArmorAndWeightBonus = armor + weight / 5

	player.shields.attackPower = Math.ceil(shieldsArmorAndWeightBonus + shieldsAttributes)
	player.shields.topMultiplier = parseFloat((0.45 + player.shields.level / 20).toFixed(2))
	player.shields.botMultiplier = parseFloat((0.45 + player.shields.level / 20).toFixed(2))
	player.shields.accuracy = Math.floor(10 + (shieldsAttributes + player.shields.level + player.mods.accuracy) * 10) / 10
	player.shields.speed = player.shields.speed <= 0 ? 2 : (6.1 - Math.floor((player.shields.level / 10) * 100) / 100).toFixed(1)
}

function updateDodge() {
	//SHOULD MAKE AGILITY FACTOR INTO DODGE
	//every point of agility gives 3 to dodge
	let calculatedDodge = (player.level + player.dodging.rating() + ((player.mods.agi + player.agi) * 3) + player.mods.dodge) - player.weight
	player.dodge = calculatedDodge
}


function updateArmor() {
	player.armor = player.mods.armor
	player.slashingArmor = player.mods.slashingArmor + player.toughness.rating()
	player.piercingArmor = player.mods.piercingArmor + player.toughness.rating()
	player.bluntArmor = player.mods.bluntArmor + player.toughness.rating()
}
function updateMagicResist() {
	//no skills to raise this yet. Need to have magic resist skill and then individual element resists
	player.magicResist.fire = player.mods.fire
}


function updateExpertise() {
	player.slashingPen = player.mods.slashingPen + player.slashingExpertise.amount()
	player.piercingPen = player.mods.piercingPen + player.piercingExpertise.amount()
	player.bluntPen = player.mods.bluntPen + player.bluntExpertise.amount()
}



function updateCurrentWeaponSkill() {
	let playerWeaponSkill = pushItem.find(item => item.roomId == 'right hand' && item.type.weapon)
	let playerWeaponSkillAlt = pushItem.find(item => item.roomId == 'left hand' && item.type.weapon)
	if (player.leftHand == 'empty' && player.rightHand == 'empty') {
		player.currentWeaponSkill = player.unarmed
	} else if (playerWeaponSkill && playerWeaponSkillAlt) {
		player.currentWeaponSkill = player[playerWeaponSkill.skillUsed]
	} else if (playerWeaponSkill != undefined) {

		player.currentWeaponSkill = player[playerWeaponSkill.skillUsed]
	} else if (playerWeaponSkillAlt != undefined) {
		player.currentWeaponSkill = player[playerWeaponSkillAlt.skillUsed]
	}
	currentWeaponSkillRightDisplay.innerHTML = `${player.currentWeaponSkill.name}`
	currentWeaponSkillLeftDisplay.innerHTML = `${player.currentWeaponSkill.name}`
}

function initializePlayerStats() {}

// function updateWeaponAndArmorMods() {
// 	let allItemsEquipped = pushItem.filter(
// 		item =>
// 			item.roomId == 'right hand' ||
// 			item.roomId == 'left hand' ||
// 			item.roomId == 'right ring' ||
// 			item.roomId == 'left ring' ||
// 			item.roomId == 'head' ||
// 			item.roomId == 'necklace' ||
// 			item.roomId == 'shoulders' ||
// 			item.roomId == 'chest' ||
// 			item.roomId == 'back' ||
// 			item.roomId == 'hands' ||
// 			item.roomId == 'waist' ||
// 			item.roomId == 'legs' ||
// 			item.roomId == 'feet'	
// 		)
// 		allItemsEquipped.forEach(equippedItem => {
// 			if (equippedItem.mods) {
// 				for (let itemMod in equippedItem.mods) {
// 					if (player.hasOwnProperty(itemMod)) {

// 						player[itemMod] = player.mods[itemMod]
// 					}
// 					player.mods[itemMod]
// 				}
// 			}
// 		})
// }

function updateWeight() {
	player.weight = player.mods.weight - (player.str * 5) <= 0 ? 0 : player.mods.weight - (player.str * 5)
}
function updateSpeed() {
	player.currentWeaponSkill.speed = player.currentWeaponSkill.speed + (player.weight * 0.1)
}
function updateSpellPower() {
	let int = player.int + player.mods.int
	let wis = player.wis + player.mods.wis
	let spellWeaponBonus = player.currentWeaponRight().mods.spellPower ? player.currentWeaponRight().mods.spellPower * player.spellWeapons.bonus() : 0
	player.spellPower = Math.ceil((int * 2) + wis + player.mods.spellPower + spellWeaponBonus)
}
function updateMysticPower() {
	let mys = player.mys + player.mods.mys
	let int = player.int + player.mods.int
	player.mysticPower = Math.ceil((mys * 2) + int + player.mods.mysticPower)

}
function updateAdvanceSpeed() {
	player.advanceTimer = player.advanceTimer - player.initiation.reduction() < 1 ? 1 : player.advanceTimer - player.initiation.reduction()
}
function updateRetreatSpeed() {
	player.retreatTimer = player.retreatTimer - player.fleetFooted.reduction() < 1.5 ? 1.5 : player.retreatTimer - player.fleetFooted.reduction()
}

function updatePlayerStats() {
	playerStance()
	updateWeight()
	updateSpeed()
	updateHealth()
	updateMana()
	updateResource()

	updateOneHanded()
	updateTwoHanded()
	updateUnarmed()
	updateDaggers()
	updateBows()
	updateShields()
	updateSpellPower()
	updateMysticPower()

	updateExpertise()
	updateDodge()
	updateArmor()
	updateAdvanceSpeed()
	updateRetreatSpeed()
	updateCurrentWeaponSkill()
	updateEXP()
	//HTML DISPLAY NODES SHOULD BE RUN LAST (BELOW)
	displayPlayerStats()
}
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////

//MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------

function moveDirection(command) {
	let direction = abvDirectionToFullDirection(command)
	let directionMoved
	if (player.restStasis) {
		let line1 = document.createElement('div')
		player.stasis = false
		player.restStasis = false
		customizeEachWord(`You are no longer `, 'white', line1)
		customizeEachWord(`resting`, 'light-blue', line1)
		blankSpace()
	}
	switch (direction) {
		case 'up':
			directionMoved = `You move above`
			break
		case 'down':
			directionMoved = `You move below`
			break
		case 'northwest':
			directionMoved = `You move to the northwest`
			break
		case 'north':
			directionMoved = `You move to the north`
			break
		case 'northeast':
			directionMoved = `You move to the northeast`
			break
		case 'east':
			directionMoved = `You move to the east`
			break
		case 'southeast':
			directionMoved = `You move to the southeast`
			break
		case 'south':
			directionMoved = `You move to the south`
			break
		case 'southwest':
			directionMoved = `You move to the southwest`
			break
		case 'west':
			directionMoved = `You move to the west`
			break
	}
	if (currentArea.descriptions.zoneChange != undefined && currentArea.descriptions.zoneChange[direction] && currentArea.descriptions.zoneExitsBool[direction] == true) {
		currentArea.descriptions.zoneChange[direction]()
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
		blankSpace()
	} else if (currentArea.descriptions.zoneExitsBool[direction] == true) {
		blankSpace()
		switch (direction) {
			case 'up':
				player.z++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'down':
				player.z--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northwest':
				player.x--
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'north':
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northeast':
				player.x++
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'east':
				player.x++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southeast':
				player.x++
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'south':
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southwest':
				player.x--
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'west':
				player.x--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
		}
		blankSpace()
		updateScroll()
	} else if (currentArea.descriptions.zoneExitsBool[direction] == undefined) {
		let line1 = document.createElement('div')
		customizeEachWord(`You cannot move in that direction`, 'white', line1)
	} else if (currentArea.descriptions.zoneExitsBool[direction] == 'locked' || currentArea.descriptions.zoneExitsBool[direction] == 'blocked') {
		console.log(currentArea.descriptions)
		if (currentArea.descriptions?.zoneExitsLocked) {
			currentArea.descriptions.zoneExitsLocked[direction]()
		} else {
			quickMessage(`You cannot pass through here`)
		}
	}
}
function retreatDirection(command) {
	let direction = abvDirectionToFullDirection(command)
	let moveOrRetreat = player.combat == false ? ' move ' : ' retreat '
	let directionMoved

	if (currentArea.descriptions.zoneExitsBool[direction] == true) {
		blankSpace()
		switch (direction) {
			case 'up':
				directionMoved = `You ${moveOrRetreat} above`
				player.z++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'down':
				directionMoved = `You ${moveOrRetreat} below`
				player.z--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northwest':
				directionMoved = `You ${moveOrRetreat} to the northwest`
				player.x--
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'north':
				directionMoved = `You ${moveOrRetreat} to the north`
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northeast':
				directionMoved = `You ${moveOrRetreat} to the northeast`
				player.x++
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'east':
				directionMoved = `You ${moveOrRetreat} to the east`
				player.x++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southeast':
				directionMoved = `You ${moveOrRetreat} to the southeast`
				player.x++
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'south':
				directionMoved = `You ${moveOrRetreat} to the south`
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southwest':
				directionMoved = `You ${moveOrRetreat} to the southwest`
				player.x--
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'west':
				directionMoved = `You ${moveOrRetreat} to the west`
				player.x--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
		}
		blankSpace()
	} else if (currentArea.descriptions.zoneExitsBool[direction] == undefined) {
		quickMessage(`You cannot ${moveOrRetreat} in that direction`)
	} else if (currentArea.descriptions.zoneExitsBool[direction] == 'locked') {
		currentArea.descriptions[direction]()
	}
}

const moveUp = () => {
	if (currentArea.descriptions.zoneExitsBool.up === true) {
		directionMoved = 'You move above'
		player.z++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		quickMessage(`That direction is blocked`)
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveDown = () => {
	if (currentArea.descriptions.zoneExitsBool.down === true) {
		directionMoved = 'You move below'
		player.z--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveNorth = () => {
	if (currentArea.descriptions.zoneExitsBool.north === true) {
		directionMoved = 'You move to the north'
		player.y++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveNortheast = () => {
	if (currentArea.descriptions.zoneExitsBool.northeast === true) {
		directionMoved = 'You move to the northeast'
		player.y++
		player.x++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveEast = () => {
	if (currentArea.descriptions.zoneExitsBool.east === true) {
		directionMoved = 'You move to the east'
		player.x++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveSoutheast = () => {
	if (currentArea.descriptions.zoneExitsBool.southeast === true) {
		directionMoved = 'You move to the southeast'
		player.x++
		player.y--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveSouth = () => {
	if (currentArea.descriptions.zoneExitsBool.south === true) {
		directionMoved = 'You move to the south'
		player.y--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveSouthwest = () => {
	if (currentArea.descriptions.zoneExitsBool.southwest === true) {
		directionMoved = 'You move to the southwest'
		player.y--
		player.x--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveWest = () => {
	if (currentArea.descriptions.zoneExitsBool.west === true) {
		directionMoved = 'You move to the west'
		player.x--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveNorthwest = () => {
	if (currentArea.descriptions.zoneExitsBool.northwest === true) {
		directionMoved = 'You move to the northwest'
		player.x--
		player.y++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}

let egbert = {
	npc: true,
	id: 0,
	x: 0,
	y: 5,
	z: -2,
	name: 'Egbert',
	refName: 'egbert',
	picture: "images/npcs/male/civilians/egbert/egbert.png",
	nameColor: 'egbert-name',
	prefix: 'Old Scribe, ',
	prefixColor: 'egbert-title',
	keywords: ['egbert', 'scribe', 'old scribe', 'old scribe, egbert'],
	race: `Human`,
	occupation: `Scribe`,
	description: `Egbert is an old man with a wiry frame and long white hair. He has the look of not being presently aware, perhaps caught up in too many thoughts.`,
	get location() {
		
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questItem: 'pair of glasses',
	questSequence: {
		first: false,
		second: false,
		third: false,
		fourth: false,
		fifth: false,
		sixth: false,
		seventh: false,
		eighth: false,
		ninth: false,
		tenth: false,
		eleventh: false,
		twelth: false,
		thirteenth: false,
		fourteenth: false,
		fifteenth: false,
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)

		// if (!this.questSequence.eleventh) {
		// 	let line1 = lineFunc()
		// 	customizeEachWord(`${this.name}: `, this.nameColor, line1)
		// 	customizeEachWord(`You're not ready for this yet.`, this.prefixColor, line1)
		// } else {
		// }
	},
	skillsOffered: [oneHanded, twoHanded, unarmed, daggers, bows, shields],
	skillsMaxLevel: {
		oneHanded: 3,
		twoHanded: 3,
		unarmed: 3,
		daggers: 3,
		bows: 3,
		shields: 3,
	},
	desc: function () {
		blankSpace()
		npcDescription(this)
		blankSpace()
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Greetings, ${player.name}! I am Egbert, the castle scribe. I will walk you through the rest of your beginner training. In addition to speaking to people, you can also check to see if they have a quest available by typing SHOW QUEST. Go ahead and try this to see what quest I have to offer."`, `white`, line1)
			blankSpace()
			return
		}
		if (this.questSequence.second == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Reading signs can be very useful when trying to find your way around. Keep an eye out for signs, bulletins, posters, or books. You can use the READ command to read any of these. Go ahead and try reading the sign in this room by typing "read sign"."`, `white`, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Speak to me when you are ready to move on."`, `white`, line2)
			blankSpace()
			this.questSequence.second = true
			return 
		} 
		if (this.questSequence.third == false) {

			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Excellent! Now follow me to the north"`, `white`, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert `, this.nameColor, line2)
			customizeEachWord(`strides to the north`, `white`, line2)
			blankSpace()
			egbert.y++
			this.questSequence.third = true
			currentArea.npc.splice(0, 1)
			galvadiaWelcomeArea14.npc.push(egbert)
			galvadiaWelcomeArea8.descriptions.zoneExitsBool.north = true
			updateNpcPicture()
			return 
		}
		if (this.questSequence.fourth == false) {

			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Before you get into actual combat, you'll want to learn the basics. The rooms to the east and west have training dummies for you to practice on that won't hit back. The room to the east will teach you about spell combat, and the room to the west will teach you about melee and ranged combat. To the north is a real monster -- a Goblin Scout we captured that was wandering too close to the castle. It's in a weakened state, so it's nearly harmless, but it will attack you back. If you practiced, I'm confident that you'll have no problem dispatching it."`, `white`, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Speak to me again when you are ready, and I will open the door to the north."`, `white`, line2)
			blankSpace()
			this.questSequence.fourth = true
			return 
		}
		if (this.questSequence.fifth == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Very well! The door is unlocked. I'll meet you once you've slain the Goblin."`, `white`, line1)
			blankSpace()
			currentArea.descriptions.zoneExitsBool.north = true
			this.questSequence.fifth = true
			return
		}
		if (this.questSequence.sixth == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Proceed to the north when you are ready to take on an enemy. Feel free to return to these rooms at any time to practice."`, `white`, line1)
			blankSpace()
			currentArea.descriptions.zoneExitsBool.north = true
			return
		}

		if (this.questSequence.seventh == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`Good work! It looks like you've leveled up. Upon leveling up, you'll automatically increase your maximum health and mana. You will also receive skill and attribute points that you can use to train skills and increase the stats of your choosing. You can check how many points you have by using the EXP command. To increase an attribute, use the INCREASE command followed by the attribute you want to increase, such as "increase strength". Once you have increased a stat, you cannot reallocate the points! So choose your stat carefully. As for skill points, you can spend those only at a class trainer which we will get you to in a moment.`, white, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Before we go, don't forget to pick up anything the Goblin might have dropped by using the GET command. You can pick up gold in the room with 'GET gold' or 'GET all'."`, `white`, line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"When you are finished and are ready to move on, speak to me again."`, white, line3)
			blankSpace()
			this.questSequence.seventh = true
			return
		}
		if (this.questSequence.eighth == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Oh, I almost forgot! You can regenerate your health and mana with the REST command. Resting can be used anywhere at any time except while in combat. The amount of health you recover depends on your Constitution, Wisdom, and Rest skill. There are also food items that you can eat that will increase the rate at which you regain health and mana."`, `white`, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"When you are rested up, meet me in the room to the north."`, white, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert `, this.nameColor, line3)
			customizeEachWord(`strides to the north`, `white`, line3)
			blankSpace()
			egbert.y++
			this.questSequence.eighth = true
			currentArea.npc.splice(0, 1)
			th_b_center_1.npc.push(egbert)
			currentArea.descriptions.zoneExitsBool.north = true
			updateNpcPicture()
			return
		}
		if (this.questSequence.ninth == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Your next task is to figure out how to open this door. You'll need to check the rooms to the east and west to do this."`, `white`, line2)
			blankSpace()
			this.questSequence.ninth = true
			return
		}
		if (this.questSequence.tenth == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert `, this.nameColor, line1)
			customizeEachWord(`looks at the door`, `white`, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"It looks like there's still something you need to do to open the door."`, `white`, line2)
			blankSpace()
			return
		}
		if (this.questSequence.eleventh == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Excellent! Follow me up the stairs to the main Training Hall."`, white, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert `, this.nameColor, line3)
			customizeEachWord(`strides to the north`, 'white', line3)
			blankSpace()
			egbert.x = -7
			egbert.y = 4
			egbert.z = 0
			currentArea.npc.splice(0, 1)
			trainingHallsCommonRoom.npc.push(egbert)
			this.questSequence.eleventh = true
			updateNpcPicture()
			return
		}
		if (this.questSequence.twelth == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Next, I will have you meet with a class trainer who will teach you class specific combat tactics. But before you go, you might want to check out the rooms to the north. They contain useful combat tips that you can refer back to at any time."`, white, line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Now, go east a few times until you see your class trainer at the Fields Crossroads, and speak with them there. Goodluck!"`, white, line2)
			blankSpace()
			this.questSequence.twelth = true
			return
		}
		if (!this.questSequence.fourteenth) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"For the last part of your training, you'll need to go to the Training Fields to the east. ${fieldsTrainer.name} will be there waiting for you where they will instruct you further."`, white, line1)
			blankSpace()
			return
		}
		if (!this.questSequence.fifteenth) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"${fieldsTrainer.name} informed me of your accomplishements! You've done very well, and will make a fine ${player.guild}. Remember that you can return here at any time to train in the basement or reference the training rooms."`, white, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Before you go, I want to tell you how to get to the Town Square and the Guild Plaza where the ${player.guild}'s Guild is. Go west from here, then southwest, then straight south until you come to the Castle Crossroads. Follow the bend in the road, continuing south, and you'll be there in no time. Read any signs you come across. They're very useful for getting directions to various places around Galvadia."`, white, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"If you ever find yourself completely lost and unable to find your way, I have placed a blessing on you that will last until level 10 that will allow you to use the RECALL command. This command will instantly teleport you back to this room. After level 10, you will no longer be able to use this command. It's a safety measure we have to take as I'm sure you can imagine the security risk of having anyone trained in combat and above level 10 teleporting inside the castle walls would impose."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line4)
			customizeEachWord(`"Alright, I'll let you on your way."`, 'white', line4)
			blankSpace()
			customizeEachWord(`Egbert `, this.nameColor, line5)
			customizeEachWord(`strides to the south`, 'white', line5)
			currentArea.npc.pop()
			this.questSequence.fifteenth = true
			updateNpcPicture()
			return
		}
		quickMessage(`Next quest sequence not yet programmed`)
	},
	quest: async function () {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"I seem to have missplaced my glasses. I won't be able to show you around if I can't see! I think I left them somewhere in my office to the west."`, `white`, line1)
		blankSpace()
	},
	offer: async function() {
		let qItem = pushItem.find(x => x.name.toLowerCase() == this.questItem)
		let qItemIndex = pushItem.indexOf(qItem)
		if (this.questSequence.first == false && qItem != undefined && player.backpack.find(item => item == qItem.name)) {
			pushItem.splice(qItemIndex, 1)
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand the `, 'white', line1)
			customizeEachWord(`${qItem.name} `, qItem.color, line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			blankSpace()
			await dialogueWait(200)
			playerGainQuestExperience(10)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Wonderful! Now I can see well enough to show you around. I'm sure you noticed you gained some experience from completing the quest I gave you. Some quests will also grant additional rewards. You can check your experience progress by typing "exp"."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"I'll be in the room to the east when you are ready to move on."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name} `, this.nameColor, line4)
			customizeEachWord(`strides to the east`, 'white', line4)
			blankSpace()
			egbert.x++
			currentArea.descriptions.zoneExitsBool.east = true
			currentArea.npc.splice(0, 1)
			galvadiaWelcomeArea8.npc.push(egbert)
			this.questSequence.first = true
			updateNpcPicture()
		} else if (this.questSequence.first == false) {
			let line1 = lineFunc()
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"If you can find my glasses, I'll be able to show you around. They should be somewhere in my office, in the room to the west."`, 'white', line1)
			blankSpace()
		} else {return}
	},
	displayShop: async function (ssiq) {
		this.questSequence.thirteenth = true
		displayShopSkillsOrSpells(this, ssiq)		

		// if (!this.questSequence.eleventh) {
		// 	let line1 = lineFunc()
		// 	customizeEachWord(`${this.name}: `, this.nameColor, line1)
		// 	customizeEachWord(`You're not ready for this yet.`, this.prefixColor, line1)
		// } else {
		// }
	},
}


function npcMovesEastToWest(chosenNpc) {
	let eastCount = 0
	let westCount = 0
	let direction
	setInterval(() => {
		console.log('interval running')
		let npcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
		let thisIndexToRemove = npcArea.npc.indexOf(npcArea.npc.find(npc => npc.name == chosenNpc.name))
		let chosenDirection = () => {
			if (eastCount == chosenNpc.eastCount && westCount == chosenNpc.westCount) {
				eastCount = 0
				westCount = 0
			}
			if (eastCount < chosenNpc.eastCount) {
				eastCount++
				return 'east'
			} else if (eastCount == chosenNpc.westCount) {
				if (westCount < chosenNpc.westCount) {
					westCount++
					return 'west'
				}
			}
		}
		direction = chosenDirection()
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == false) {
			quickMessage(`In the same room, not moving`)
			return
		}
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == true) {
			let newNpcArea
			switch (direction) {
				case 'east':
					chosenNpc.x += 1
					break
				case 'west':
					chosenNpc.x -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			let line1 = document.createElement('div')
			customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
			removeNpcFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			newNpcArea.npc.push(chosenNpc)
		} else if (coordinatesMatch(chosenNpc, player) == false) {
			let newNpcArea
			let entersFromDirection
			console.log(direction, 'DIRECTION')
			switch (direction) {
				case 'east':
					entersFromDirection = 'west'
					chosenNpc.x += 1
					break
				case 'west':
					entersFromDirection = 'east'
					chosenNpc.x -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			if (coordinatesMatch(chosenNpc, player) == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
				customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
			}
			removeNpcFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			console.log(newNpcArea, ' NEW NPC AREA')
			newNpcArea.npc.push(chosenNpc)
		}
	}, chosenNpc.intervalTick)
}

function npcMovesNorthToSouth(chosenNpc) {
	let northCount = 0
	let southCount = 0
	let direction
	setInterval(() => {
		console.log('interval running')
		let npcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
		let thisIndexToRemove = npcArea.npc.indexOf(npcArea.npc.find(npc => npc.name == chosenNpc.name))
		let chosenDirection = () => {
			if (northCount == chosenNpc.northCount && southCount == chosenNpc.southCount) {
				northCount = 0
				southCount = 0
			}
			if (northCount < chosenNpc.northCount) {
				northCount++
				return 'north'
			} else if (northCount == chosenNpc.southCount) {
				if (southCount < chosenNpc.southCount) {
					southCount++
					return 'south'
				}
			}
		}
		direction = chosenDirection()
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == false) {
			quickMessage(`In the same room, not moving`)
			return
		}
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == true) {
			let newNpcArea
			switch (direction) {
				case 'north':
					chosenNpc.y += 1
					break
				case 'south':
					chosenNpc.y -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			let line1 = document.createElement('div')
			customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
			removeNpcFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			newNpcArea.npc.push(chosenNpc)
		} else if (coordinatesMatch(chosenNpc, player) == false) {
			let newNpcArea
			let entersFromDirection
			console.log(direction, 'DIRECTION')
			switch (direction) {
				case 'north':
					entersFromDirection = 'south'
					chosenNpc.y += 1
					break
				case 'south':
					entersFromDirection = 'north'
					chosenNpc.y -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			if (coordinatesMatch(chosenNpc, player) == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
				customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
			}
			removeNpcFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			console.log(newNpcArea, ' NEW NPC AREA')
			newNpcArea.npc.push(chosenNpc)
		}
	}, chosenNpc.intervalTick)
}

//USE THIS FUNCTION TO GIVE NPCS EXACT DIRECTIONS TO MOVE
async function specificNpcMovement(npc) {
	//eastcount
	let currentNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	//For xAxis, 1 = EAST, -1 = WEST, 0 = DOESN'T MOVE ON THIS AXIS
	let xAxisA = npc.xa
	let yAxisA = npc.ya
	let xAxisB = npc.xb
	let yAxisB = npc.yb
	let xCounterA = 0
	let yCounterA = 0
	let xCounterB = 0
	let yCounterB = 0
	let direction
	let entersFromDirection
	//intervaltick
	let behaviorA = true
	let behaviorB = false
	const movesToDirectionMap = {
			'1,0': 'east',
			'-1,0': 'west',
			'0,1': 'north',
			'0,-1': 'south',
			'1,1': 'northeast',
			'1,-1': 'southeast',
			'-1,-1': 'southwest',
			'-1,1': 'northwest',
		}
	const entersFromDirectionMap = {
			'1,0': 'west',
			'-1,0': 'east',
			'0,1': 'south',
			'0,-1': 'north',
			'1,1': 'southwest',
			'1,-1': 'northwest',
			'-1,-1': 'northeast',
			'-1,1': 'southeast',
		}
		//inverse
	while(true) {
	updateNpcPicture()
	if (!npc.isInConversation) {
		await waitForNextAction(npc.waitInterval)
	}
	if (npc.isInConversation) {
		await waitForNextAction(100)
	} else if (behaviorA) {
		let directionKey = `${xAxisA[xCounterA]},${yAxisA[yCounterA]}`
		direction = movesToDirectionMap[directionKey]
		entersFromDirection = entersFromDirectionMap[directionKey]
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${capitalizeFirstLetter(npc.prefix)} `, npc.prefixColor, line1)
			customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
		}
		currentNpcArea.npc.splice(currentNpcArea.npc.indexOf(npc), 1)
		npc.x = npc.x + xAxisA[xCounterA]
		npc.y = npc.y + yAxisA[yCounterA]
		currentNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		currentNpcArea.npc.push(npc)
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${npc.prefix} `, npc.prefixColor, line1)
			customizeEachWord(`${npc.name} `, npc.nameColor, line1)
			customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
		}
		xCounterA++
		yCounterA++
		if (xCounterA == xAxisA.length) {
			xCounterB = 0
			yCounterB = 0
			behaviorA = false
			behaviorB = true
		}
	}   else if (behaviorB == true) {
		// console.log('before NPC moves')
		let directionKey = `${xAxisB[xCounterB]},${yAxisB[yCounterB]}`
		direction = movesToDirectionMap[directionKey]
		entersFromDirection = entersFromDirectionMap[directionKey]
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${capitalizeFirstLetter(npc.prefix)} `, npc.prefixColor, line1)
			customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
		}
		currentNpcArea.npc.splice(currentNpcArea.npc.indexOf(npc), 1)
		npc.x = npc.x + xAxisB[xCounterB]
		npc.y = npc.y + yAxisB[yCounterB]
		currentNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		currentNpcArea.npc.push(npc)
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${capitalizeFirstLetter(npc.prefix)} `, npc.prefixColor, line1)
			customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
			customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
		}
		xCounterB++
		yCounterB++
		if (xCounterB == xAxisB.length) {
			xCounterA = 0
			yCounterA = 0
			behaviorA = true
			behaviorB = false
			}
		}
	}
}

function applySkillBuff(buff) {
	player[buff.skillEnhanced.name].level += buff.skillEnhanced.level
	setTimeout(() => {
		player[buff.skillEnhanced.name].level -= buff.skillEnhanced.level
	}, buff.duration)
}

function removeNpcFromRoom(area, selectNpc) {
	let allNpcsInRoom = area.npc
	let npcIndex = allNpcsInRoom.indexOf(selectNpc)
	area.npc.splice(npcIndex, 1)
}
function addNpcToRoom(npc) {
	let roomToAddNpc = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	roomToAddNpc.npc.push(npc)
}
function removeItemFromBackpackAndPushItemArray(questItem) {
	let questItemIndex = pushItem.indexOf(questItem)
	pushItem.splice(questItemIndex, 1)
	player.backpack.splice(questItemIndex, 1)
}


function compareCoordinates(comparedObject) {
	if (comparedObject.s == undefined) {
		if (comparedObject.x == player.x && comparedObject.y == player.y && comparedObject.z == player.z) {
			return true
		} else {
			return false
		}
	} else if (comparedObject.s != undefined) {
		if (comparedObject.x == player.x && comparedObject.y == player.y && comparedObject.z == player.z && comparedObject.s == player.s) {
			return true
		} else {
			return false
		}
	}
}

function npcMovesRandomly(npc) {
	let npcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	console.log(npc, ' NPC')
	let newNpcArea
	let canNpcMove = npcArea.descriptions.zoneExits.split(' ')
	let randomDirectionIndex = randomNumberRange(0, canNpcMove.length - 1)
	let thisIndexToRemove = npcArea.npc.indexOf(npcArea.npc.find(npc => npc.name == npc.name))
	let direction = canNpcMove[randomDirectionIndex]
	while (npcArea.descriptions.zoneExitsBool[direction] != true) {
		randomDirectionIndex = randomNumberRange(0, canNpcMove.length - 1)
		direction = canNpcMove[randomDirectionIndex]
	}
	if (coordinatesMatch(npc, player) == true && npc.movesWhenPlayerIsHere == false) {
		quickMessage(`In the same room, not moving`)
		return
	}
	if (coordinatesMatch(npc, player) == true && npc.movesWhenPlayerIsHere == true) {
		if (direction != 'up' || direction != 'down') {
			let line1 = document.createElement('div')
			customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
		} else if (direction == 'up') {
			let line1 = document.createElement('div')
			customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
			customizeEachWord(`moves above`, 'white', line1)
		} else if (direction == 'down') {
			let line1 = document.createElement('div')
			customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
			customizeEachWord(`moves below`, 'white', line1)
		}
		switch (direction) {
			case 'west':
				npc.x = npc.x - 1
				break
			case 'northwest':
				npc.x = npc.x - 1
				npc.y = npc.y + 1
				break
			case 'north':
				npc.y = npc.y + 1
				break
			case 'northeast':
				npc.x = npc.x + 1
				npc.y = npc.y + 1
				break
			case 'east':
				npc.x = npc.x + 1
				break
			case 'southeast':
				npc.x = npc.x + 1
				npc.y = npc.y - 1
				break
			case 'south':
				npc.y = npc.y - 1
				break
			case 'southwest':
				npc.x = npc.x - 1
				npc.y = npc.y - 1
				break
			case 'up':
				npc.z = npc.z + 1
				break
			case 'down':
				npc.z = npc.z - 1
				break
			default:
				quickMessage(`This is the default. Figure out what went wrong. This should probably never run`)
		}
		removeNpcFromRoom(npcArea, thisIndexToRemove)
		newNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		newNpcArea.npc.push(npc)
	} else if (coordinatesMatch(npc, player) == false) {
		switch (direction) {
			case 'west':
				npc.x = npc.x - 1
				entersFromDirection = 'east'
				break
			case 'northwest':
				npc.x = npc.x - 1
				npc.y = npc.y + 1
				entersFromDirection = 'southeast'
				break
			case 'north':
				npc.y = npc.y + 1
				entersFromDirection = 'south'
				break
			case 'northeast':
				npc.x = npc.x + 1
				npc.y = npc.y + 1
				entersFromDirection = 'southwest'
				break
			case 'east':
				npc.x = npc.x + 1
				entersFromDirection = 'west'
				break
			case 'southeast':
				npc.x = npc.x + 1
				npc.y = npc.y - 1
				entersFromDirection = 'northwest'
				break
			case 'south':
				npc.y = npc.y - 1
				entersFromDirection = 'north'
				break
			case 'southwest':
				npc.x = npc.x - 1
				npc.y = npc.y - 1
				entersFromDirection = 'northeast'
				break
			case 'up':
				npc.z = npc.z + 1
				entersFromDirection = 'below'
				break
			case 'down':
				npc.z = npc.z - 1
				entersFromDirection = 'above'
				break
			default:
				quickMessage(`This is the default. Figure out what went wrong. This should probably never run`)
		}

		if (coordinatesMatch(npc, player) == true) {
			if (entersFromDirection != 'below' || entersFromDirection != 'above') {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
				customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
			} else if (entersFromDirection == 'below') {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
				customizeEachWord(`enters from below`, 'white', line1)
			} else {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
				customizeEachWord(`enters from above`, 'white', line1)
			}
		}
		removeNpcFromRoom(npcArea, thisIndexToRemove)
		newNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		newNpcArea.npc.push(npc)
	}
}

class NPCCreator {
	constructor(options) {
		this.x = options.x || null
		this.y = options.y || null
		this.z = options.z || null
		this.name = options.name || null
		this.nameColor = options.nameColor || null
		this.keywords = options.keywords || null
		this.displayName = options.displayName || null
		this.prefix = options.prefix || null
		this.prefixColor = options.prefixColor || null
		this.suffix = options.suffix || null
		this.suffixColor = options.suffixColor || null
		this.skillsOffered = options.skillsOffered || null
		this.skillsMaxLevel = options.skillsMaxLevel || null
		this.spellsOffered = options.spellsOffered || null
		this.spellsMaxLevel = options.spellsMaxLevel || null
		this.itemsOffered = options.itemsOffered || null
		this.buy = options.buy || null
		this.train = options.train || null
		this.learn = options.learn || null
		this.description = options.description || null
		this.desc = options.desc || null
		this.speak = options.speak || null
		this.displayShop = options.displayShop || null
	}
}


const benjamin = {
	x: -3,
	y: 2,
	z: 0,
	name: 'Benjamin',
	name2: 'Naker',
	refName: 'benjamin',
	nameColor: 'food',
	suffix: ', Castle Baker',
	suffixColor: 'light-brown',
	keywords: ['ben', 'benjamin', 'baker'],
	occupation: `Shopkeeper`,
	race: `Human`,
	description: `A jolly looking baker`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [apple, applePie],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello! I am Benjamin Naker, the Castle Baker. I make a wonderful Mudpie, but I'm all out of Mudballs to make them, and the Mudlings in the Fields are too strong for me to handle, sadly."`, this.suffixColor, line1)
			blankSpace()
		} else {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I'm back to making my spectacular Mudpies, thanks to you!"`, this.suffixColor, line1)
			blankSpace()
		}
	},
	questSequence: {
		first: false,
	},
	questItem: 'mudball',
	quest: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Drats! I'm all out of Mudballs. I can't cook any more Mudpies without Mudballs. All I need is one Mudball to get me through the day.`, this.suffixColor, line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace()
		}
	},
	offer: async function() {
		let questItem = pushItem.find(item => (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand') && item.keywords.some(keyword => keyword == this.questItem))
		let questItemIndex = pushItem.indexOf(questItem)
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first && questItem) {
			pushItem.splice(questItemIndex, 1)
			player.backpack.splice(questItemIndex, 1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand the `, 'white', line1)
			customizeEachWord(`${questItem.name} `, questItem.color, line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			blankSpace()
			await dialogueWait(200)
			playerGainQuestExperience(20)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Benjamin: `, this.nameColor, line2)
			customizeEachWord(`"You've saved the day! Now I can continue making Mudpies!"`, this.suffixColor, line2)
			blankSpace()
			this.questSequence.first = true
			return
		} else if (this.questSequence.first == true) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You do not have the correct quest item.`, 'white', line1)
			blankSpace()
			return
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const threx = {
	x: -10,
	y: -10,
	z: 0,
	name: 'Threx',
	refName: 'threx',
	nameColor: 'dark-orange',
	prefix: 'Warrior Recruitment Officer, ',
	prefixColor: 'warrior-color',
	keywords: ['threx'],
	occupation: `Warrior's Guild Officer`,
	race: `Human`,
	description: `Warrior`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (!this.questSequence.second) {
			let line1 = lineFunc()
			customizeEachWord(`You must be a member of the `, 'white', line1)
			customizeEachWord(`Warrior's Guild `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [oneHanded, twoHanded, toughness, shields, ripslash, charge],
	skillsMaxLevel: {
		oneHanded: 5,
		twoHanded: 5,
		toughness: 5,
		shields: 5,
		ripslash: 2,
		charge: 1,
	},
	questSequence: {},
	speakSequence: {},
	speak: async function () {
		if (!this.questSequence.first) {
			threxSpeakDialogue.dialogue1()
			return
		}
		if (!this.questSequence.second) {
			threxSpeakDialogue.dialogue2()
		}
	},
	questItem: 'cult texts',
	quest: async function () {
		if (!this.questSequence.first) {
			threxQuestDialogue.dialogue1()
			return
		}
		if (!this.questSequence.second) {
			threxQuestDialogue.dialogue2()
			return
		}
		if (!this.questSequence.third) {
			threxQuestDialogue.dialogue3()
		}
	},
	offer: async function() {
		if (!this.questSequence.first) {
			threxOfferDialogue.dialogue1()
		} 
	},
	displayShop: async function(ssiq) {
		if (!this.questSequence.second) {
			let line1 = lineFunc()
			customizeEachWord(`You must be a member of the `, 'white', line1)
			customizeEachWord(`Warrior's Guild `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		displayShopSkillsOrSpells(this, ssiq)
	}
}
let threxSpeakDialogue = {
	dialogue1: async function() {
		let line1 = lineFunc()
		let randomNumber = randomNumberRange(1, 3)
		await dialogueWait(200)
		blankSpace()
		if (randomNumber == 1) {	
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"Greetings, traveller."`, 'white', line1)
		}
		if (randomNumber == 2) {
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"This is the Warrior's Guild. Only guild members are allowed in."`, 'white', line1)
		}
		if (randomNumber == 3) {
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"There's been a disturbance in the magics lately. Even the other guilds are talking about it."`, 'white', line1)
		}
		blankSpace()
	},
	dialogue2: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line1)
		customizeEachWord(`"Go ahead and take a look around the guild. There are several restricted Guild Shops and trainers that require certain levels to be able to use. As you level up, you will be able to access these shops and trainers."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line2)
		customizeEachWord(`"I have no more quests for you at this time, but many of the guild members here have quests to offer. As you level and complete quests, can check back in with them because they might have some new quests waiting for you."`, 'white', line2)
		blankSpace()
	},
	dialogue3: async function() {},
}
let threxQuestDialogue = {
	dialogue1: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line1)
		customizeEachWord(`"Hello, ${player.name}. I've been expecting you. Since you've proven yourself in combat, I'd like to see if you can help the guild obtain some information. There's been a disturbance in the magics around here, and we'd like to find out what's going on. I've heard rumors that there have been cultists sneaking into the graveyard to meet. Your objective is to visit the graveyard and report back with any findings. We suspect that the Cultists have something on them that will have information on their practices which we believe to be connected to the disturbance."`, this.prefixColor, line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line2)
		customizeEachWord(`"If you can complete this task, you will be accepted into the Warrior's Guild. Goodluck."`, this.prefixColor, line2)
		blankSpace()
		return
	},
	dialogue2: async function() {

	},
	dialogue3: async function() {

	},
}
let threxOfferDialogue = {
	dialogue1: async function() {
		let questItem = pushItem.find(item => (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand') && item.keywords.some(keyword => keyword == threx.questItem))
		if (questItem) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand the `, 'white', line1)
			customizeEachWord(`${questItem.name} `, questItem.color, line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${threx.name}`, threx.color, line1)
			blankSpace()
			await dialogueWait(200)
			playerGainQuestExperience(100)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, threx.nameColor, line2)
			customizeEachWord(`"It would appear as though the Cultists know about the disturbances in the magics, and are actively working to further the disruption. I will need to discuss this with the guild leaders to figure out our next course of action."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, threx.nameColor, line3)
			customizeEachWord(`"There's nothing we can do in the immediate, so for now, we'll focus on getting you trained up! Come with me to the Guild Halls."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx `, threx.nameColor, line4)
			customizeEachWord(`moves to the south`, 'white', line4)
			blankSpace()
			threx.questSequence.first = true
			threx.x = -12
			threx.y = -13
			threx.z = -2
			galvadiaWarriorsGuildEntrance.descriptions.zoneExitsBool.south = true
			removeItemFromBackpackAndPushItemArray(questItem)
			removeNpcFromRoom(galvadiaWarriorsGuildEntrance, threx)
			addNpcToRoom(threx)
			return
		} else {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"Return when you've found out some information."`, 'white', line1)
			blankSpace()
		}
	},
	dialogue2: async function() {},
	dialogue3: async function() {},
}

let velthash = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Velthash',
	refName: 'velthash',
	nameColor: 'dark-purple',
	color: 'warrior-color',
	prefix: 'Berserker Warmaster, ',
	prefixColor: 'warrior-color',
	keywords: ['velthash', 'vel'],
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand, npc) {
	if (player.guild != 'Warrior') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Warrior `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, npc)
	},
	questSequence: {
	},
	skillsOffered: [oneHanded, twoHanded, shields],
	skillsMaxLevel: {
		oneHanded: 5,
		twoHanded: 5,
		shields: 5
	},
	itemsOffered: [shortsword],
	questItem: [cultTexts],
	quest: async function() {
		// let line1 = lineFunc()
		// if (!this.questSequence.seventh) {
		// 	await dialogueWait(200)
		// 	blankSpace()
		// 	customizeEachWord(`${this.name}: `, this.nameColor, line1)
		// 	customizeEachWord(`"The Graveyard is east of the Town Square. The Bulletin in the square will give you the exact directions. Return back when you've found something worth investigating."`, 'white', line1)
		// 	blankSpace()
		// 	return
		// } 
	},
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the Guild Halls. The class trainers here have more skills to offer you. As for training, the Graveyard should suffice for a while. Once you've outgrown it, you should explore east and west of the Castle Crossroads. To the east is the Glade -- a very peaceful and relaxing place, typically teeming with townspeople. A little farther in and to the northeast, you'll find the entrance to The Shallows. To the west of the Castle Crossroads is the Kobold Caves. It's a little more dangerous than The Shallows, so make sure you're well equipped."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office inside the guild once I'm finished meeting with the guild leaders. Check in after you've reached level 10. That should give me enough time. I might have a new task for you after we discuss our next move."`, 'white', line3)
		blankSpace()
		customizeEachWord(`${this.name} `, this.color, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		currentArea.npc.pop()
		currentArea.descriptions.zoneExitsBool.south = true
		pushItem.splice(qItemIndex, 1)
		this.questSequence.seventh = true
	},
	speak: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let line5 = lineFunc()
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Welcome back, ${player.name}. We were able to dissect the Cult Texts, and what we found is very disturbing. The cult itself is rooted in an ancient following that sought to disrupt the balance of magic in the world. Their belief was that the world we live in is a flat plane of existence that extends as far as magic can reach. They also believed that because this plane is flat, there must be another side to it. They believed that their ancestors once lived on that side of the plane, and that their affinity for magic would be ten fold of what it is here. The shape and origins of the world has been a topic of study for ages, but no conclusive evidence has ever been substantiated."`, 'white', line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Regardless of whether or not this is all true, the cult is actively trying to undermine what we protect. The other disturbing part of all of this is we believe there is someone from Galvadia working with them on the inside -- someone who would have deep knowledge of ancient studies. While I work with the guilds to take appropriate protective measures, I'd like you to investigate the castle grounds to see if you find anything suspicious. I imagine this person must have access to ancient knowledge and history. Let me know your findings."`, 'white', line2)
			blankSpace()
			this.questSequence.first = true
			return
		}
		if (!this.questSequence.second) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Have you found anything yet?"`, 'white', line1)
			blankSpace()
			return
		}
	},
	learn: (secondCommand, npc) => {
		learnInteraction(secondCommand, npc)
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

const ragnar = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Ragnar',
	refName: 'ragnar',
	picture: 'images/npcs/male/warriors/fighters/ragnar/ragnar.png',
	nameColor: 'ragnar-name',
	prefix: 'Lord of War, ',
	prefixColor: 'warrior-color',
	keywords: ['ragnar'],
	occupation: `Fighter Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Fighter') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Fighter in order to train with Ragnar`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [dualStrike, charge, oneHanded, initiation, tactics, vigor]
		} else if (player.level < 20) {
			return [dualStrike, shred, bladeBlitz, charge, oneHanded, initiation, tactics, vigor, warcraft, precision, 
				slashingExpertise, piercingExpertise, bluntExpertise, bleed]
		} else if (player.level < 30) {
			return [dualStrike, shred, bladeBlitz, charge, oneHanded, thrillOfTheKill, battleRage, counterAttack, brutalBlows, 
				multipleStrikes, stunningBlows, resilience, initiation, tactics, vigor, warcraft, precision, slashingExpertise, 
				piercingExpertise, bluntExpertise, bleed]
		} else {
			return 	[dualStrike, shred, bladeBlitz, charge, oneHanded, thrillOfTheKill, slashingExpertise, piercingExpertise, 
				bluntExpertise, battleRage, weaponTempering, armorTempering, counterAttack, tactics, initiation, brutalBlows, 
				multipleStrikes, stunningBlows, vigor, warcraft, resilience, bleed]
		}
	},
	skillsMaxLevel: {
		get dualStrike() {return skillMaxLevel2(player.dualStrike)},
		get shred() {return skillMaxLevel2(player.shred)},
		get bladeBlitz() {return skillMaxLevel2(player.bladeBlitz)},
		get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
		get charge() {return skillMaxLevel5(player.charge)},
		get thrillOfTheKill() {return skillMaxLevel2(player.thrillOfTheKill)},
		get slashingExpertise() {return skillMaxLevel5(player.slashingExpertise)},
		get piercingExpertise() {return skillMaxLevel5(player.piercingExpertise)},
		get bluntExpertise() {return skillMaxLevel5(player.bluntExpertise)},
		get battleRage() {return skillMaxLevel5(player.battleRage)},
		weaponTempering: 10,
		armorTempering: 10,
		get counterAttack() {return skillMaxLevel2(player.counterAttack)},
		get tactics() {return skillMaxLevel5(player.tactics)},
		get initiation() {return skillMaxLevel5(player.initiation)},
		get brutalBlows() {return skillMaxLevel2(player.brutalBlows)},
		get multipleStrikes() {return skillMaxLevel2(player.multipleStrikes)},
		get stunningBlows() {return skillMaxLevel2(player.stunningBlows)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get resilience() {return skillMaxLevel3(player.resilience)},
		get bleed() {return skillMaxLevel3(player.bleed)},
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Ragnar. I'm here to train Warrior's Guild Prospects who are interested in joining the Warrior's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const magvello = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Magvello',
	refName: 'magvello',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'red',
	prefix: 'Howling Blade, ',
	prefixColor: 'warrior-color-dark',
	keywords: ['magvello'],
	occupation: `Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with Magvello`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [ripslash, charge, twoHanded, initiation, tactics, vigor]
		} else if (player.level < 20) {
			return [ripslash, cyclone, cataclysm, charge, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, 
				slashingExpertise, piercingExpertise, bluntExpertise, bleed]
		} else if (player.level < 30) {
			return [ripslash, cyclone, cataclysm, charge, twoHanded, thrillOfTheKill, battleRage, counterAttack, brutalBlows, 
				multipleStrikes, stunningBlows, resilience, initiation, tactics, vigor, warcraft, precision, cleave, slashingExpertise, 
				piercingExpertise, bluntExpertise, bleed]
		} else {
			return 	[ripslash, cyclone, cataclysm, charge, twoHanded, thrillOfTheKill, cleave, slashingExpertise, piercingExpertise, 
				bluntExpertise, battleRage, weaponTempering, armorTempering, counterAttack, tactics, initiation, brutalBlows, 
				multipleStrikes, stunningBlows, vigor, warcraft, resilience, bleed]
		}
	},
	skillsMaxLevel: {
		get ripslash() {return skillMaxLevel2(player.ripslash)},
		get cyclone() {return skillMaxLevel2(player.cyclone)},
		get cataclysm() {return skillMaxLevel2(player.cataclysm)},
		get twoHanded() {return weaponSkillMaxLevel(player.twoHanded)},
		get charge() {return skillMaxLevel5(player.charge)},
		get thrillOfTheKill() {return skillMaxLevel2(player.thrillOfTheKill)},
		get cleave() {return skillCleaveMaxLevel(player.cleave)},
		get slashingExpertise() {return skillMaxLevel5(player.slashingExpertise)},
		get piercingExpertise() {return skillMaxLevel5(player.piercingExpertise)},
		get bluntExpertise() {return skillMaxLevel5(player.bluntExpertise)},
		get battleRage() {return skillMaxLevel5(player.battleRage)},
		weaponTempering: 10,
		armorTempering: 10,
		get counterAttack() {return skillMaxLevel2(player.counterAttack)},
		get tactics() {return skillMaxLevel5(player.tactics)},
		get initiation() {return skillMaxLevel5(player.initiation)},
		get brutalBlows() {return skillMaxLevel2(player.brutalBlows)},
		get multipleStrikes() {return skillMaxLevel1(player.multipleStrikes)},
		get stunningBlows() {return skillMaxLevel2(player.stunningBlows)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get resilience() {return skillMaxLevel3(player.resilience)},
		get bleed() {return skillMaxLevel3(player.bleed)},
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const allSkillsMan = {
	x: -7,
	y: 4,
	z: 0,
	name: 'All Skills Man',
	refName: 'allSkillsMan',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'red',
	prefix: 'Super Skilled Man, ',
	prefixColor: 'warrior-color-dark',
	keywords: ['skills', 'skill', 'man'],
	occupation: `Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)
		
	},
	//shadowmark
	//shadowvenom
	//poison
	//bleed
	skillsOffered: [twoHanded, oneHanded, unarmed, daggers, bows, shields, perception, rest, slashingExpertise, piercingExpertise, 
		bluntExpertise, firePenetration, icePenetration, lightningPenetration, weakSpot, vigor, devotion, cleave, multipleStrikes, 
		doubleDraw, extraStrike, stunningBlows, precision, warcraft, stealth, block, dodging, supremeDodging, toughness, sideStep, 
		quickshot, dodgeStrike, preemptiveStrike, lockpicking, smokeBomb, mindsEye, arcaneKnowledge, mysticismMastery, sorceryMastery, 
		magicDexterity, battleRage, resilience, hardenedSkin, knightsResolve, weaponTempering, armorTempering, evasiveRoll, 
		athletics, ridingSkill, tauntingShout, berserking, headshot, backstabbing, brutalBlows, thrillOfTheKill, counterAttack, 
		fleetFooted, initiation, vigilance, tactics, fistsOfFury, fistsOfPrecision, wayOfTheFist, bleed, burn, charge, stealth, 
		poison, shadowMark, shadowVenom],
	skillsMaxLevel: {
		twoHanded: 10,
		oneHanded: 10,
		unarmed: 10,
		daggers: 10,
		bows: 10,
		shields: 10,
		perception: 10,
		rest: 10,
		slashingExpertise: 10,
		piercingExpertise: 10,
		bluntExpertise: 10,
		firePenetration: 10,
		icePenetration: 10,
		lightningPenetration: 10,
		weakSpot: 10,
		vigor: 10,
		devotion: 10,
		cleave: 10,
		multipleStrikes: 10,
		doubleDraw: 10,
		extraStrike: 10,
		stunningBlows: 10,
		precision: 10,
		warcraft: 10,
		stealth: 10,
		precision: 10,
		block: 10,
		dodging: 10,
		supremeDodging: 10,
		sideStep: 10,
		dodgeStrike: 10,
		preemptiveStrike: 10,
		lockpicking: 10,
		smokeBomb: 10,
		mindsEye: 10,
		arcaneKnowledge: 10,
		mysticismMastery: 10,
		sorceryMastery: 10,
		magicDexterity: 10,
		battleRage: 10,
		resilience: 10,
		hardenedSkin: 10,
		knightsResolve: 10,
		weaponTempering: 10,
		armorTempering: 10,
		evasiveRoll: 10,
		athletics: 10,
		ridingSkill: 10,
		tauntingShout: 10,
		berserking: 10,
		headshot: 10,
		backstabbing: 10,
		brutalBlows: 10,
		thrillOfTheKill: 10,
		counterAttack: 10,
		fleetFooted: 10,
		initiation: 10,
		vigilance: 10,
		brutalBlows: 10,
		tactics: 10,
		fistsOfFury: 10,
		fistsOfPrecision: 10,
		wayOfTheFist: 10,
		bleed: 10,
		burn: 10,
		charge: 10,
		stealth: 10,
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const allAbilitiesMan = {
	x: -7,
	y: 4,
	z: 0,
	name: 'All Abilities Man',
	refName: 'allSkillsMan',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'red',
	prefix: 'Super Ability Man, ',
	prefixColor: 'warrior-color-dark',
	keywords: ['ability', 'man'],
	occupation: `Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with Magvello`)
		}
	},
	skillsOffered: [ripslash, cyclone, cataclysm, dualStrike, shred, bladeBlitz, valorStrike, shieldSlam, boomingMight, 
	ambush, backstab, guillotine, venomBlade, contagion, bane, shadowDaggers, shadowsurge, shadowNova, catalyst, tempest, 
	callOfWind, knuckleBlitz, fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, blazingFist, tidalFist, 
	lightningFist, elementalTempest, transcendence, piercingArrow, rapidFireShot, hydraArrow],
	skillsMaxLevel: {
		ripslash: 10,
		cyclone: 10,
		cataclysm: 10,
		dualStrike: 10,
		shred: 10,
		bladeBlitz: 10,
		valorStrike: 10,
		shieldSlam: 10,
		boomingMight: 10,
		ambush: 10,
		backstab: 10,
		guillotine: 10,
		venomBlade: 10,
		contagion: 10,
		bane: 10,
		shadowDaggers: 10,
		shadowsurge: 10,
		shadowNova: 10,
		catalyst: 10,
		tempest: 10,
		callOfWing: 10,
		knuckleBlitz: 10,
		fireSeal: 10,
		waterSeal: 10,
		earthSeal: 10,
		mysticFist: 10,
		unleashedPower: 10,
		blazingFist: 10,
		tidalFist: 10,
		lightningFist: 10,
		elementalTempest: 10,
		transcendence: 10,
		piercingArrow: 10,
		rapidFireShot: 10,
		hydraArrow: 10,
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}

let fieldsTrainer
let fieldsTrainerQuestSequence = {
		first: false,
		second: false,
		third: false,
}

let fieldsTrainerDialogue = {
	// quest: async function() {
	// 	if (!this.questSequence.first) {
	// 		quickMessage(`Try SPEAKing to Velthash`)
	// 		return
	// 	}
	// },
	speak: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let line5 = lineFunc()
		let line6 = lineFunc()
		//All non-mage class dialogue
		if (!this.questSequence.first) {
			let weaponSkill = player.guild == 'Warrior' ? ' one handed if you are a Fighter or a Knight, and two handed if you are a Berserker' : player.guild == 'Sinistral' ? 'daggers' : player.guild == 'Ranger' ? 'bows' : player.guild == 'Monk' ? 'unarmed combat' : undefined
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Greetings, you must be ${player.name}! I am ${this.name}. I will teach you the essentials of combat."`, 'white', line1)
			blankSpace()
			if (player.guild != 'Mage') {
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"First things first. In order to grow stronger, you'll need to level up, train your skills, and increase your attributes. Leveling up requires gaining experience, which can be done by slaying enemies or completing quests. Most people you come across will have a quest to offer, so be sure to speak to them! To train your skills, you need to find a class trainer who can teach you, which I just happen to be. To see what skills a class trainer has to offer, use the SHOW SKILLS command. To train a specific skill, use the TRAIN command followed by the skill number. One of your most essential skills is your weapon skill, ${weaponSkill}. Your weapon skill is the only skill that affects how fast you can swing your weapon. It also increases your damage and accuracy, so I would recommend training it as high as possible whenever you can."`, 'white', line2)
			blankSpace()
			} else {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line2)
				customizeEachWord(`"First things first. In order to grow stronger, you'll need to level up, train your spells and skills, and increase your attributes. Leveling up requires gaining experience, which can be done by slaying enemies or completing quests. Most people you come across will have a quest to offer, so be sure to speak to them! To learn spells and train skills, you need to find a class trainer who can teach you, which I just happen to be. To see what spells a class trainer has to offer, use the SHOW SPELLS command. To see what skills a class trainer has to offer, use the SHOW SKILLS command. To train a specific spell, use the LEARN command followed by the spell number, and to train a specific skill, use the TRAIN command followed by the skill number. Studying your spells to make them more powerful is always a safe way to spend your points. If you don't know which skills you should be training alongside your spells, you can use the HELP command followed by the skill or spell name to learn more about it."`, 'white', line2)
				blankSpace()
			}
			if (player.guild == 'Sinistral') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"As a Sinistral, you have the unique ability to stealth by using the HIDE command. If you use a regular attack while hidden, you will leap out at your foe with a Sneak Attack, instantly striking them without the need to engage combat first. You will also deal bonus damage when performing a Sneak Attack."`, 'white', line3)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line4)
				customizeEachWord(`"While stealthed, enemies will not be able to see you thus allowing you to roam around without being engaged upon. However, depending on the enemy's level, they can grow suspicious and search for you, so if you're planning to attack, make sure to do it quick before you are spotted. High level enemies will have a very easy time spotting a low level Sinistral. Gaining levels and training your Stealth skill higher will help you remain hidden among enemies. Training your Stealth skill also increases the damage of your Sneak Attack."`, 'white', line4)
				blankSpace()
			}
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line5)
			customizeEachWord(`"Let me know once you're ready to move on."`, 'white', line5)
			blankSpace()
			this.questSequence.first = true
			return
		}
		if (!this.questSequence.second || player.level < 3) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"When you enter into a hostile area like the Training Fields, each time you move to a new room, there is a chance for an enemy to emerge. Moving around quickly is a good way to stir up multiple enemies. Be careful not to stir up too many as you might find yourself overwhelmed. The best way to deal with multiple enemies is by using hit-and-retreat tactics. You can learn all about advanced combat tactics in the Training Halls."`, 'white', line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Enemies cannot follow you out of hostile areas. If your health gets low or you get overwhelmed, you can always run to a safe area, like here. There are no hostile or safe area indicators. Generally, enemies cannot follow you to cities, towns, or on roads within or near towns."`, 'white', line2)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Enemies often drop useful items, so be sure to make use of whatever you find. You can also sell me anything that you don't need. To do this, use the SELL command followed by any word in the item's name or the backpack slot number. Be careful not to sell something you want to keep. The best way to do this is by using the item slot number in your backpack or by using the full name of the item. Your backpack will reorganize itself each time an item leaves it, so the slot numbers can change each time you sell something, so be sure to use the right slot number whenever you sell something."`, 'white', line3)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line4)
			customizeEachWord(`"Once you've done some combat training in the fields and reached level 3, return to me for your next task. Feel free to come back as you level up to train your skills."`, 'white', line4)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (player.level >= 3 && !this.questSequence.third) {
			if (player.guild == 'Warrior') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"Excellent work! It looks like you've learned your first ability. To use an ability, just say its name (or use the / key on the numpad). Warrior abilities are unique in that they require a wind up time before they execute, but they can be used out of combat before engaging an enemy. You can time an ability so that it hits your target as soon as you engage it to maximize the damage you deal at the start of combat. If you are not engaged with an enemy when your ability wind up finishes, there will be a penalty and all your abilities will be on cooldown for a duration. Abilities can be used alongside regular attacks meaning that you can use an ability even while affected by exhaustion from your regular attacks. Warriors have an ability resource called Might that they use to use abilities. Like other class resources, you regenerate your resource each time you land successful, regular attacks."`, 'white', line1)
				blankSpace()
			}
			if (player.guild == 'Sinistral') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"Excellent work! It looks like you've learned your first ability. To use an ability, just say its name (or use the / key on the numpad). Abilities can be used alongside regular attacks meaning that you can use an ability even while affected by exhaustion from your regular attacks. However, you cannot use one ability while another is on cooldown. Sinistral abilities require the resource Adrenaline to use. You accumulate Adrenaline with each successful regular attack."`, 'white', line1)
				blankSpace()
			}
			if (player.guild == 'Monk') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"Excellent work! It looks like you've learned your first ability. To use an ability, just say its name (or use the / key on the numpad). Abilities can be used alongside regular attacks meaning that you can use an ability even while affected by exhaustion from your regular attacks. However, you cannot use one ability while another is on cooldown. Like Rangers, Monk abilities require the resource Focus to use. You accumulate Focus with each successful regular attack."`, 'white', line1)
				blankSpace()
			}
			if (player.guild == 'Ranger') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"Excellent work! It looks like you've learned your first ability. To use an ability, just say its name (or use the / key on the numpad). Abilities can be used alongside regular attacks meaning that you can use an ability even while affected by exhaustion from your regular attacks. However, you cannot use one ability while another is on cooldown. Like Monks, Ranger abilities require the resource Focus to use. You accumulate Focus with each successful regular attack."`, 'white', line1)
				blankSpace()
			}
			if (player.guild != 'Mage') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line2)
				customizeEachWord(`"Like skills, abilities can be trained to increase their strength and grant additional effects. Because of their strength, they cost a great deal more to train than skills do. I would recommend only training them once you've learned most other skills that your current class trainer has to offer."`, 'white', line2)
				blankSpace()
			}
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Now that you're stronger, you can train in the East Training Fields. The monsters will be a little tougher, and some will attack you from range so you might have to adjust your tactics. Once you think you're strong enough, I want you to defeat the elemental boss to the south. Boss enemies different than regular enemies in several ways: They are stronger and have more health while providing more experience and drops, there's usually one boss enemy in an area, they are guaranteed to spawn when you enter the room, when killed they will respawn after a long duration, and they are typically accompanied by minions."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line4)
			customizeEachWord(`"Be sure to use the HELP command followed by the name of the ability or spell to learn more about it."`, 'white', line4)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line5)
			customizeEachWord(`"Speak to me when you're ready, and I'll open the way to the south."`, 'white', line5)
			blankSpace()
			this.questSequence.third = true
			crossroads_shops_and_fields.descriptions.zoneExitsBool.east = true
			return
		}
		if (!this.questSequence.fourth) {
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Very well, the way to the south is open."`, 'white', line1)
			blankSpace()
			this.questSequence.fourth = true
			crossroads_shops_and_fields.descriptions.zoneExitsBool.south = true
			return
		}
		if (!player.killList.lesserMudElemental || !player.killList.lesserGrassElemental || !player.killList.lesserWaterElemental) {
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"The way is open to the south. Return to me when you have slain the boss elemental."`, 'white', line1)
			blankSpace()
			return
		}
		if (player.killList.lesserMudElemental && player.killList.lesserGrassElemental && player.killList.lesserWaterElemental) {
			this.questSequence.fifth = true
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Congratulations, you've completed your combat training! You're ready to join the ${player.guild}'s Guild. For now, go back to Egbert so he can complete your admissions, and then meet me outside the ${player.guild}'s Guild when you're ready."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"I'll see you soon, ${player.name}!"`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name} `, this.nameColor, line3)
			customizeEachWord(`walks to the west`, 'white', line3)
			blankSpace()
			this.questSequence.fifth = true
			crossroads_shops_and_fields.npc.pop()
			switch(player.guild) {
				case 'Warrior':
				warriorsGuildEntrance.npc.push(this)
				break;
				case 'Mage':
				mageGuildEntrance.npc.push(this)
				break;
				case 'Sinistral':
				sinistralsGuildEntrance.npc.push(this)
				break;
				case 'Monk':
				monksGuildEntrance.npc.push(this)
				break;
				case 'Ranger':
				rangersGuildEntrance.npc.push(this)
				break;
				default:
				quickMessage(`none of these`)
			}
			egbert.questSequence.fourteenth = true
			return
		}
		if (!this.questSequence.sixth) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Good to see you again! It didn't take you long to find your way here I see. Before I can officially induct you into the guild, I need you to do a little work for me first. Lately, there's been a disturbance in the magics. As you could probably tell from the Training Fields, there's been an influx of elementals taking shape around here. Having you prospects kill them off for training helps keep their numbers low enough to not be a problem, but I'm afraid more powerful elementals might be taking shape in places we haven't discovered yet."`, 'white', line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Your task is to investigate some rumors we've been hearing about. We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details. Just a little bit of information will help us figure out what might be influencing this behavior."`, 'white', line2)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"The Graveyard is east of the Town Square. The Bulletin in the square will give you the exact directions. Return back when you've found something worth investigating."`, 'white', line3)
			blankSpace()
			this.questSequence.sixth = true
			return
		}
		if (!this.questSequence.seventh) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"The Graveyard is east of the Town Square. The Bulletin in the square will give you the exact directions. Return back when you've found something worth investigating."`, 'white', line1)
			blankSpace()
			return
		}
	},


}

let questObject = {
	weaponsmith: {
		copperQuest: {
			count: 0,
			oreMax: 6,
			questItem: copperOre,
			questSequence1: {
			}
		},
		ironQuest: {
			count: 0,
			oreMax: 0,
			questItem: ironOre,
			questSequence1: {
				complete: false,
			}
		},
		lightHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: lightHide,
			questSequence1: {
				complete: false,
			}
		},
		thickHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: thickHide,
			questSequence1: {
				complete: false,
			}
		},
		thinFiberQuest: {
			count: 0,
			questItem: thinFiber,
			questSequence1: {
				complete: false,
			}
		},
		refinedFiberQuest: {
			count: 0,
			questItem: refinedFiber,
			questSequence1: {
				complete: false,
			}
		},
	},
	armorsmith: {
		copperQuest: {
			count: 0,
			oreMax: 0,
			questItem: copperOre,
			questSequence1: {
				complete: false,
			}
		},
		ironQuest: {
			count: 0,
			oreMax: 0,
			questItem: ironOre,
			questSequence1: {
				complete: false,
			}
		},
		lightHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: lightHide,
			questSequence1: {
				complete: false,
			}
		},
		thickHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: thickHide,
			questSequence1: {
				complete: false,
			}
		},
		thinFiberQuest: {
			count: 0,
			questItem: thinFiber,
			questSequence1: {
				complete: false,
			}
		},
		refinedFiberQuest: {
			count: 0,
			questItem: refinedFiber,
			questSequence1: {
				complete: false,
			}
		},
	},
}
async function craftQuestTurnIn1(npc, rewardAmount) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`hands you `, 'white', line1)
	customizeEachWord(`${rewardAmount} `, 'yellow', line1)
	customizeEachWord(`gold`, 'white', line1)
	playerGainGold(rewardAmount)
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name}: `, npc.nameColor, line2)
	customizeEachWord(`"For every 3 ores, I can craft a new set of weapons. So fa, you have turned in a total of ${questObject.weaponsmith.copperQuest.count}"`, 'white', line2)
	blankSpace()
}
async function craftQuestTurnIn2(npc, rewardAmount) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`hands you `, 'white', line1)
	customizeEachWord(`${rewardAmount} `, 'yellow', line1)
	customizeEachWord(`gold`, 'white', line1)
	await dialogueWait(200)
	blankSpace()
	playerGainGold(rewardAmount)
	customizeEachWord(`${npc.name}: `, npc.nameColor, line2)
	customizeEachWord(`"I can craft a new set of weapons! Check out the shop to see what's in stock."`, 'white', line2)
	blankSpace()
}
async function craftQuestTurnIn3(npc, rewardAmount) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`hands you `, 'white', line1)
	customizeEachWord(`${rewardAmount} `, 'yellow', line1)
	customizeEachWord(`gold`, 'white', line1)
	playerGainGold(rewardAmount)
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name}: `, npc.nameColor, line2)
	customizeEachWord(`"I can now craft all weapons that are made using copper ore."`, 'white', line2)
	blankSpace()
}
async function craftQuestComplete(npc) {
	let line1 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name}: `, npc.nameColor, line1)
	customizeEachWord(`"I don't need any copper ore. I can make everything that utilizes copper."`, 'white', line1)
	blankSpace()
}


let questDialogueObject = {

}

let greaves = {
	x: -10,
	y: -13,
	z: -1,
	name: 'Greaves',
	refName: 'greaves',
	picture: 'images/npcs/male/warriors/knights/greaves/greaves.png',
	nameColor: 'blue',
	prefix: 'Hand of Justice, ',
	prefixColor: 'warrior-color-light',
	keywords: ['greaves'],
	occupation: `Knight's Guild Master`,
	race: `Human`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Knight') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Knight in order to train with Greaves.`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [valorStrike, tauntingShout, oneHanded, shields, initiation, tactics, vigor]
		} else if (player.level < 20) {
			return [valorStrike, shieldSlam, boomingMight, tauntingShout, oneHanded, shields, block, knightsResolve, initiation, tactics, vigor, warcraft, precision, 
				slashingExpertise, piercingExpertise, bluntExpertise]
		} else if (player.level < 30) {
			return [valorStrike, shieldSlam, boomingMight, tauntingShout, oneHanded, shields, block, knightsResolve, battleRage, counterAttack, brutalBlows, 
				multipleStrikes, stunningBlows, resilience, initiation, tactics, vigor, warcraft, precision, slashingExpertise, 
				piercingExpertise, bluntExpertise]
		} else {
			return 	[valorStrike, shieldSlam, boomingMight, tauntingShout, oneHanded, shields, block, knightsResolve, slashingExpertise, piercingExpertise, 
				bluntExpertise, battleRage, weaponTempering, armorTempering, counterAttack, tactics, initiation, brutalBlows, 
				multipleStrikes, stunningBlows, vigor, warcraft, precision, resilience]
		}
	},
	skillsMaxLevel: {
		get valorStrike() {return skillMaxLevel2(player.valorStrike)},
		get shieldSlam() {return skillMaxLevel2(player.shieldSlam)},
		get boomingMight() {return skillMaxLevel2(player.boomingMight)},
		get tauntingShout() {return skillMaxLevel5(player.tauningShout)},
		get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
		get shields() {return weaponSkillMaxLevel(player.shields)},
		get block() {return skillMaxLevel3(player.block)},
		get knightsResolve() {return skillMaxLevel5(player.knightsResolve)},
		get slashingExpertise() {return skillMaxLevel5(player.slashingExpertise)},
		get piercingExpertise() {return skillMaxLevel5(player.piercingExpertise)},
		get bluntExpertise() {return skillMaxLevel5(player.bluntExpertise)},
		get battleRage() {return skillMaxLevel5(player.battleRage)},
		weaponTempering: 10,
		armorTempering: 10,
		get counterAttack() {return skillMaxLevel2(player.counterAttack)},
		get tactics() {return skillMaxLevel5(player.tactics)},
		get initiation() {return skillMaxLevel5(player.initiation)},
		get brutalBlows() {return skillMaxLevel2(player.brutalBlows)},
		get multipleStrikes() {return skillMaxLevel2(player.multipleStrikes)},
		get stunningBlows() {return skillMaxLevel2(player.stunningBlows)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get resilience() {return skillMaxLevel3(player.resilience)},
	},
	questSequence: {
	},
	itemsOffered: [shortsword, longsword],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {

	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}


const daggslain = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Daggslain',
	refName: 'daggslain',
	nameColor: 'yellow',
	prefix: 'Silent Carnage, ',
	prefixColor: 'sinistral-color',
	keywords: ['daggslain'],
	occupation: `trainer`,
	race: `Human`,
	description: `Assassin's Guild Master`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Assassin') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Sinistral's Guild Prospect `, 'sinistral-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [ambush, stealth, daggers, dodging, fleetFooted, vigilance]
		} else if (player.level < 20) {
			return [ambush, backstab, guillotine, smokeBomb, stealth, daggers, dodging, fleetFooted, vigilance, vigor, precision, multipleStrikes, sinisterMark]
		} else if (player.level < 30) {
			return [ambush, backstab, guillotine, smokeBomb, stealth, daggers, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, sinisterMark]
		} else {
			return [ambush, backstab, guillotine, smokeBomb, stealth, daggers, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, sinisterMark]
		}
	},
	skillsMaxLevel: {
		get ambush() {return skillMaxLevel2(player.ambush)},
		get backstab() {return skillMaxLevel2(player.backstab)},
		get guillotine() {return skillMaxLevel2(player.guillotine)},
		get smokeBomb() {return skillMaxLevel5(player.smokeBomb)},
		get daggers() {return weaponSkillMaxLevel(player.daggers)},
		get stealth() {return skillMaxLevel5(player.stealth)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get dodgeStrike() {return skillMaxLevel3(player.dodgeStrike)},
		get supremeDodging() {return skillMaxLevel5(player.supremeDodging)},
		get backstabbing() {return skillMaxLevel5(player.backstabbing)},
		get fleetFooted() {return skillMaxLevel5(player.fleetFooted)},
		get vigilance() {return skillMaxLevel5(player.vigilance)},
		get vigor() {return skillMaxLevel3(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get multipleStrikes() {return skillMaxLevel3(player.multipleStrikes)},
		get sinisterMark() {return skillMaxLevel5(player.sinisterMark)},
	},
		questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const zel = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Zel',
	refName: 'zel',
	nameColor: 'yellow',
	prefix: 'Silent Carnage, ',
	prefixColor: 'sinistral-color',
	keywords: ['zel'],
	occupation: `trainer`,
	race: `Human`,
	description: `Assassin's Guild Master`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.guild != 'Sinistral') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Sinistral `, 'sinistral-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [daggers, oneHanded, stealth],
	skillsMaxLevel: {
		daggers: 5,
		stealth: 2,
	},
		questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		// if (this.questSequence.second) {
		// 	this.questSequence.first = true
		// 	this.speak()
		// }
	},
}
const shallox = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Shallox',
	refName: 'shallox',
	nameColor: 'yellow',
	// prefix: 'Shadow Tamer, ',
	prefix: 'Master of Shadows, ',
	prefixColor: 'dark-purple',
	keywords: ['Shallox'],
	occupation: `Shadowblade Guild Master`,
	race: `Human`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Shadowblade') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Sinistral's Guild Prospect `, 'sinistral-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [shadowsurge, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance]
		} else if (player.level < 20) {
			return [shadowsurge, shadowDaggers, shadowNova, smokeBomb, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance, vigor, precision, multipleStrikes, shadowMark]
		} else if (player.level < 30) {
			return [shadowsurge, shadowDaggers, shadowNova, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, shadowMark]
		} else {
			return [shadowsurge, shadowDaggers, shadowNova, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, shadowMark]
		}
	},
	skillsMaxLevel: {
		get shadowsurge() {return skillMaxLevel2(player.shadowsurge)},
		get shadowDaggers() {return skillMaxLevel2(player.shadowDaggers)},
		get shadowNova() {return skillMaxLevel2(player.shadowNova)},
		get smokeBomb() {return skillMaxLevel5(player.smokeBomb)},
		get daggers() {return weaponSkillMaxLevel(player.daggers)},
		get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
		get stealth() {return skillMaxLevel5(player.stealth)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get dodgeStrike() {return skillMaxLevel3(player.dodgeStrike)},
		get supremeDodging() {return skillMaxLevel5(player.supremeDodging)},
		get backstabbing() {return skillMaxLevel5(player.backstabbing)},
		get fleetFooted() {return skillMaxLevel5(player.fleetFooted)},
		get vigilance() {return skillMaxLevel5(player.vigilance)},
		get vigor() {return skillMaxLevel3(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get multipleStrikes() {return skillMaxLevel3(player.multipleStrikes)},
		get shadowMark() {return skillMaxLevel5(player.shadowMark)},
	},
		questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [crudeShiv, leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Shallox. I'm here to train Sinistral's Guild Prospects who are interested in joining the Sinistral's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}

	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const kaijin = {
	x: -8,
	y: 6,
	z: 0,
	name: 'Kaijin',
	refName: 'kaijin',
	nameColor: 'monk-color',
	prefix: 'Wisened Fool, ',
	prefixColor: 'purple',
	keywords: ['kaijin'],
	occupation: `trainer`,
	race: `Dragonkin`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Monk') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Monk's Guild Prospect `, 'monk-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.catpitalName}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [unarmed, toughness, dodging],
	skillsMaxLevel: {
		unarmed: 5,
		toughness: 5,
		dodging: 5,
		// empoweringStrike: 1,
		// catalyst: 5,
		// tempest: 5,
		// fireSeal: 5,
		// flameStrike: 5,
		// waterSeal: 5,
		// waveFist: 5,
		// blazingFist: 5,
		// riptideFist: 5,
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Kaijin. I'm here to train Monk's Guild Prospects who are interested in joining the Monk's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const delverick = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Delverick',
	refName: 'delverick',
	nameColor: 'monk-color',
	prefix: 'Martial Monk, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color-light',
	keywords: ['delverick'],
	occupation: `trainer`,
	race: `Human`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Martial Monk') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Martial Monk in order to train with Delverick`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [catalyst, tempest, unarmed, dodging, toughness, vigor, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 20) {
			return [catalyst, tempest, callOfWind, knuckleBlitz, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 30) {
			return [catalyst, tempest, callOfWind, knuckleBlitz, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		} else {
			return [catalyst, tempest, callOfWind, knuckleBlitz, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		}
	},
	skillsMaxLevel: {
		get catalyst() {return skillMaxLevel2(player.catalyst)},
		get tempest() {return skillMaxLevel2(player.tempest)},
		get callOfWind() {return skillMaxLevel2(player.callOfWind)},
		get knuckleBlitz() {return skillMaxLevel2(player.knuckleBlitz)},
		get unarmed() {return weaponSkillMaxLevel(player.unarmed)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get toughness() {return skillMaxLevel5(player.toughness)},
		get hardenedSkin() {return skillMaxLevel5(player.hardenedSkin)},
		get resilience() {return skillMaxLevel5(player.resilience)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel4(player.warcraft)},
		get precision() {return skillMaxLevel4(player.precision)},
		get wayOfTheFist() {return skillMaxLevel4(player.wayOfTheFist)},
		get stunningBlows() {return skillMaxLevel3(player.stunningBlows)},
		get preemptiveStrike() {return skillMaxLevel3(player.preemptiveStrike)},
		get fistsOfFury() {return skillMaxLevel3(player.fistsOfFury)},
		get fistsOfPrecision() {return skillMaxLevel3(player.fistsOfPrecision)},
		get extraStrike() {return skillExtraStrikeMaxLevel(player.extraStrike)},
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Delverick. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const maelius = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Maelius',
	refName: 'maelius',
	nameColor: 'monk-color',
	prefix: 'Mystic Monk, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color',
	keywords: ['maelius'],
	occupation: `trainer`,
	race: `Elf`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Mystic Monk') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Mystic Monk in order to train with Maelius`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [fireSeal, waterSeal, earthSeal, unarmed, dodging, toughness, vigor, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 20) {
			return [fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 30) {
			return [fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		} else {
			return [fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		}
	},
	skillsMaxLevel: {
		get fireSeal() {return skillMaxLevel2(player.fireSeal)},
		get waterSeal() {return skillMaxLevel2(player.waterSeal)},
		get earthSeal() {return skillMaxLevel2(player.earthSeal)},
		get mysticFist() {return skillMaxLevel2(player.mysticFist)},
		get unleashedPower() {return skillMaxLevel2(player.unleashedPower)},
		get unarmed() {return weaponSkillMaxLevel(player.unarmed)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get toughness() {return skillMaxLevel5(player.toughness)},
		get hardenedSkin() {return skillMaxLevel5(player.hardenedSkin)},
		get resilience() {return skillMaxLevel5(player.resilience)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel4(player.warcraft)},
		get precision() {return skillMaxLevel4(player.precision)},
		get wayOfTheFist() {return skillMaxLevel4(player.wayOfTheFist)},
		get stunningBlows() {return skillMaxLevel3(player.stunningBlows)},
		get preemptiveStrike() {return skillMaxLevel3(player.preemptiveStrike)},
		get fistsOfFury() {return skillMaxLevel3(player.fistsOfFury)},
		get fistsOfPrecision() {return skillMaxLevel3(player.fistsOfPrecision)},
		get extraStrike() {return skillExtraStrikeMaxLevel(player.extraStrike)},
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Maelius. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const fearecia = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Fearecia',
	refName: 'fearecia',
	nameColor: 'monk-color',
	prefix: 'Elemental Monk, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color-dark',
	keywords: ['fearecia'],
	occupation: `trainer`,
	race: `Dragon Kin`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Elemental Monk') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be an Elemental Monk in order to train with Fearecia`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [blazingFist, tidalFist, lightningFist, unarmed, dodging, toughness, vigor, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 20) {
			return [blazingFist, tidalFist, lightningFist, elementalTempest, transcendence, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 30) {
			return [blazingFist, tidalFist, lightningFist, elementalTempest, transcendence, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		} else {
			return [blazingFist, tidalFist, lightningFist, elementalTempest, transcendence, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		}
	},
	skillsMaxLevel: {
		get blazingFist() {return skillMaxLevel2(player.blazingFist)},
		get tidalFist() {return skillMaxLevel2(player.tidalFist)},
		get lightningFist() {return skillMaxLevel2(player.lightningFist)},
		get elementalTempest() {return skillMaxLevel2(player.elementalTempest)},
		get transcendence() {return skillMaxLevel2(player.transcendence)},
		get unarmed() {return weaponSkillMaxLevel(player.unarmed)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get toughness() {return skillMaxLevel5(player.toughness)},
		get hardenedSkin() {return skillMaxLevel5(player.hardenedSkin)},
		get resilience() {return skillMaxLevel5(player.resilience)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel4(player.warcraft)},
		get precision() {return skillMaxLevel4(player.precision)},
		get wayOfTheFist() {return skillMaxLevel4(player.wayOfTheFist)},
		get stunningBlows() {return skillMaxLevel3(player.stunningBlows)},
		get preemptiveStrike() {return skillMaxLevel3(player.preemptiveStrike)},
		get fistsOfFury() {return skillMaxLevel3(player.fistsOfFury)},
		get fistsOfPrecision() {return skillMaxLevel3(player.fistsOfPrecision)},
		get extraStrike() {return skillExtraStrikeMaxLevel(player.extraStrike)},
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Fearecia. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}
const sitoria = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Sitoria',
	refName: 'sitoria',
	nameColor: 'light-blue',
	prefix: 'Fatal Fist, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color-dark',
	keywords: ['sitoria'],
	occupation: `trainer`,
	race: `Human`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.guild != 'Monk') {
			quickMessage(`You must be a Monk to train with Sitoria`)
		} else {
			trainInteraction(secondCommand, this)
		}
	},
	skillsOffered: [unarmed],
	skillsMaxLevel: {
		unarmed: 5,
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Sitoria. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		if (this.questSequence.second) {
			this.questSequence.first = true
			this.speak()
		}
	},
}

const talon = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Talon',
	refName: 'talon',
	nameColor: 'ranger-color',
	prefix: `Nature's Guardian, `,
	prefixColor: 'light-brown',
	keywords: ['talon'],
	occupation: `trainer`,
	race: `Half-Elf`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Ranger') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Ranger's Guild Prospect `, 'ranger-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [piercingArrow, evasiveRoll, bows, sideStep, warcraft, precision, dodging]
		} else if (player.level < 20) {
			return [piercingArrow, rapidFireShot, hydraArrow, evasiveRoll, bows, headshot, markOfTheBeast, quickshot, sideStep, warcraft, precision, dodging, vigor]
		} else if (player.level < 30) {
			return [piercingArrow, rapidFireShot, hydraArrow, evasiveRoll, bows, doubleDraw, headshot, markOfTheBeast, quickshot, sideStep, weakSpot, warcraft, precision, dodging, vigor]
		} else {
			return [piercingArrow, rapidFireShot, hydraArrow, evasiveRoll, bows, doubleDraw, headshot, markOfTheBeast, quickshot, sideStep, weakSpot, warcraft, precision, dodging, vigor]
		}
	},
	skillsMaxLevel: {
		get piercingArrow() {return skillMaxLevel2(player.piercingArrow)},
		get rapidFireShot() {return skillMaxLevel2(player.rapidFireShot)},
		get hydraArrow() {return skillMaxLevel2(player.hydraArrow)},
		get evasiveRoll() {return skillMaxLevel5(player.evasiveRoll)},
		get bows() {return weaponSkillMaxLevel(player.bows)},
		get doubleDraw() {return skillMaxLevel2(player.doubleDraw)},
		get headshot() {return skillMaxLevel2(player.headshot)},
		get markOfTheBeast() {return skillMaxLevel5(player.markOfTheBeast)},
		get quickshot() {return skillMaxLevel3(player.quickshot)},
		get sideStep() {return skillMaxLevel3(player.sideStep)},
		get weakSpot() {return skillMaxLevel3(player.weakSpot)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get vigor() {return skillMaxLevel3(player.vigor)},
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortbow, leatherTunic, leatherGloves, leatherBoots],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Talon. I'm here to train Ranger's Guild Prospects who are interested in joining the Ranger's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const tilwin = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Tilwin',
	refName: 'tilwin',
	nameColor: 'ranger-color',
	prefix: `Lord of Arrows, `,
	prefixColor: 'light-blue',
	keywords: ['tilwin'],
	occupation: `trainer`,
	race: `Half-Elf`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.guild != 'Ranger') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Ranger's Guild Prospect `, 'ranger-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [bows],
	skillsMaxLevel: {
		bows: 5,
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortbow, leatherTunic, leatherGloves, leatherBoots],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const joch = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Joch',
	refName: 'joch',
	picture: "images/npcs/male/civilians/joch/joch.png",
	nameColor: 'joch-name',
	prefix: 'Weaponsmith ',
	prefixColor: 'joch-prefix',
	keywords: ['joch'],
	occupation: `Shopkeeper`,
	race: `Human`,
	description: `Joch looks happy to be selling his wares`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [shortsword, phi, phi, handAxe, phi, phi, mace, phi, phi, longsword, phi, phi, poleAxe, phi, phi, sledgehammer, phi, phi, squiresShield, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I could make use of any copper ores you might find. If I got my hands on some, I could make a new set of weapons. I know there's copper ore in the Kobold Caves, but it's quite dangerous to venture there."`, 'white', line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Ahhh, I live for the smell of smoldering metal."`, 'white', line1)
			blankSpace()
			return
		}
		//iron
	},
	offer: async function() {
		let qItem
		if (questObject.weaponsmith.copperQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.weaponsmith.copperQuest.questItem().refName)
		}
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		if (qItemName == 'Copper Ore') {
			if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.weaponsmith.copperQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.weaponsmith.copperQuest.count
				if (count == 6) {
					craftQuestTurnIn3(this, rewardAmount)
				} else if (count == 3) {
					craftQuestTurnIn2(this, rewardAmount)
				} else  {
					craftQuestTurnIn1(this, rewardAmount)
				} 
				if (!questObject.weaponsmith.copperQuest.questSequence1.first && count <= 1) {
					questObject.weaponsmith.copperQuest.questSequence1.first = true
					this.itemsOffered = [shortsword, phi, phi, handAxe, phi, phi, mace, phi, phi, longsword, phi, phi, poleAxe, phi, phi, sledgehammer, phi, phi, squiresShield, phi, phi]
				} else if (!questObject.weaponsmith.copperQuest.questSequence1.second && count == 5) {
					questObject.weaponsmith.copperQuest.questSequence1.second = true
					this.itemsOffered = [shortsword, broadSword, phi, handAxe, beardedAxe, phi, mace, stoutedMace, phi, longsword, claymore, phi, poleAxe, beardedPoleAxe, phi, sledgehammer, maul, phi, squiresShield, bronzeShield, phi]
				} else if (!questObject.weaponsmith.copperQuest.questSequence1.third && count == 10) {
					questObject.weaponsmith.copperQuest.questSequence1.third = true
					questObject.weaponsmith.copperQuest.questSequence1.complete = true
					this.itemsOffered = [shortsword, broadSword, gladius, handAxe, beardedAxe, serratedAxe, mace, stoutedMace, flangedMace, longsword, claymore, bastardSword, poleAxe, beardedPoleAxe, serratedPoleaxe, sledgehammer, maul, flangedMaul, squiresShield, bronzeShield, galvadianKiteShield]
				}
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, welcome to my shop! Well, our shop. Me and my twin brother Clyde work the smith here. I make the weapons, and he makes the armor!"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"We're running a bit short on metals, so we can only make items that don't use a lot of copper. If you find any copper ores, bring 'em back here to increase our stock. We'll also tip you a little for your troubles. Can't pay ya full price for em, but what we can make will make up for it."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"The Kobold Caves have some copper veins to mine. You'll need a pickaxe to mine, but lucky you, I have some in stock. I wouldn't mess around with Kobolds until at least level 8. But who knows, maybe you're more skilled than ya look!"`, 'white', line3)
			blankSpace()
		} else {
			let randomNumber = randomNumberRange(1, 2)
			if (randomNumber == 1) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I live for the smell of smoldering ore!`, 'white', line1)
				blankSpace()
			} else if (randomNumber == 2) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I'd love to be able to go up north to the mountains. I've heard there's some good ores up there, but the goblins have set up camp at the base of the mountain.`, 'white', line1)
				blankSpace()
			}
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let clyde = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Clyde',
	refName: 'clyde',
	picture: "images/npcs/male/civilians/clyde/clyde.png",
	nameColor: 'clyde-name',
	prefix: 'Armorsmith ',
	prefixColor: 'clyde-prefix',
	keywords: ['clyde'],
	occupation: 'Armorer',
	race: 'Human',
	description: 'Clyde looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, phi, phi, phi, phi, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.armorsmith.copperQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any copper ingots? My store could always use more ore!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.armorsmith.copperQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.armorsmith.copperQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.armorsmith.copperQuest.questItem().refName)
		}
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		if (qItemName == 'Copper Ore') {
			if (!questObject.armorsmith.copperQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.armorsmith.copperQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.armorsmith.copperQuest.count
				if (count == 6) {
					craftQuestTurnIn3(this, rewardAmount)
				} else {
					craftQuestTurnIn2(this, rewardAmount)
				} 
				if (!questObject.armorsmith.copperQuest.questSequence1.first && count == 0) {
					questObject.armorsmith.copperQuest.questSequence1.first = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, phi, phi, phi, phi, phi, phi]
				} else if (!questObject.armorsmith.copperQuest.questSequence1.second && count == 1) {
					questObject.armorsmith.copperQuest.questSequence1.second = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, phi, phi, phi, phi, phi]
				} else if (!questObject.armorsmith.copperQuest.questSequence1.third && count == 2) {
					questObject.armorsmith.copperQuest.questSequence1.third = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, ringmailLeggings, phi, phi, phi, phi]
				}else if (!questObject.armorsmith.copperQuest.questSequence1.fourth && count == 3) {
					questObject.armorsmith.copperQuest.questSequence1.fourth = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, ringmailLeggings, ringmailShoulders, phi, phi, phi]
				} else if (!questObject.armorsmith.copperQuest.questSequence1.fifth && count == 4) {
					questObject.armorsmith.copperQuest.questSequence1.fifth = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, ringmailLeggings, ringmailShoulders, ringmailHelm, phi, phi]
				} else if (!questObject.armorsmith.copperQuest.questSequence1.sixth && count == 5) {
					questObject.armorsmith.copperQuest.questSequence1.sixth = true
					questObject.armorsmith.copperQuest.questSequence1.complete = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, ringmailLeggings, ringmailShoulders, ringmailHelm, ringmailGloves, phi]
				}  else if (!questObject.armorsmith.copperQuest.questSequence1.sixth && count == 6) {
					questObject.armorsmith.copperQuest.questSequence1.sixth = true
					questObject.armorsmith.copperQuest.questSequence1.complete = true
					this.itemsOffered = [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, ringmailLeggings, ringmailShoulders, ringmailHelm, ringmailGloves, ringmailStompers]
				} 
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, welcome to my shop! Well, our shop. Me and my twin brother Joch work the smith here. I make the armor, and he makes the weapons!"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"We're running a bit short on metals, so we can only make items that don't use a lot of copper. If you find any copper ores, bring 'em back here to increase our stock. We'll also tip you a little for your troubles. Can't pay ya full price for em, but what we can make will make up for it."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"The Kobold Caves have some copper veins to mine. You'll need a pickaxe to mine, but lucky you, my brother has some in stock. I wouldn't mess around with Kobolds until at least level 8. But who knows, maybe you're more skilled than ya look!"`, 'white', line3)
			blankSpace()
		} else {
			let randomNumber = randomNumberRange(1, 2)
			if (randomNumber == 1) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I live for the smell of smoldering ore!`, 'white', line1)
				blankSpace()
			} else if (randomNumber == 2) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I'd love to be able to go up north to the mountains. I've heard there's some good ores up there, but the goblins have set up camp at the base of the mountain.`, 'white', line1)
				blankSpace()
			}
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let dolf = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Dolf',
	refName: 'dolf',
	picture: 'images/npcs/male/civilians/dolf/dolf.png',
	nameColor: 'dolf-name',
	prefix: 'Leatherworker ',
	prefixColor: 'dolf-prefix',
	keywords: ['dolf'],
	occupation: 'Leatherworker',
	race: 'Human',
	description: 'Dolf looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [leatherCap, phi, leatherTunic, phi, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.armorsmith.lightHideQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any light hide? My store could always use more light hide!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.armorsmith.lightHideQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.armorsmith.lightHideQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.armorsmith.lightHideQuest.questItem().refName)
		} else {

		}
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		//iron ore
		if (qItemName == 'Light Hide') {
			if (!questObject.armorsmith.lightHideQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.armorsmith.lightHideQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.armorsmith.lightHideQuest.count
				if (count == 6) {
					craftQuestTurnIn3(this, rewardAmount)
				} else {
					craftQuestTurnIn2(this, rewardAmount)
				}
				if (!questObject.armorsmith.lightHideQuest.questSequence1.first && count == 0) {
					questObject.armorsmith.lightHideQuest.questSequence1.first = true
					this.itemsOffered = [leatherCap, phi, leatherTunic, phi, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.second && count == 1) {
					questObject.armorsmith.lightHideQuest.questSequence1.second = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, phi, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.third && count == 2) {
					questObject.armorsmith.lightHideQuest.questSequence1.third = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.fourth && count == 3) {
					questObject.armorsmith.lightHideQuest.questSequence1.fourth = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.fifth && count == 4) {
					questObject.armorsmith.lightHideQuest.questSequence1.fifth = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.sixth && count == 5) {
					questObject.armorsmith.lightHideQuest.questSequence1.sixth = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, studdedLeatherGloves, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.seventh && count == 6) {
					questObject.armorsmith.lightHideQuest.questSequence1.seventh = true
					questObject.armorsmith.lightHideQuest.questSequence1.complete = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, studdedLeatherGloves, leatherBoots, studdedLeatherBoots]
				} 
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Dolf the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let todlin = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Todlin',
	refName: 'todlin',
	picture: 'images/npcs/male/civilians/todlin/todlin.png',
	nameColor: 'todlin-name',
	prefix: 'Woodcrafter ',
	prefixColor: 'todlin-prefix',
	keywords: ['todlin'],
	occupation: 'Woodcrafter',
	race: 'Half-Elf',
	description: 'Todlin looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [shortbow, phi, phi, dirk, phi, phi, hardenedLeatherFists, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.weaponsmith.lightHideQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any light hide? My store could always use more light hide!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.weaponsmith.lightHideQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.weaponsmith.lightHideQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.weaponsmith.lightHideQuest.questItem().refName)
		} 
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		//iron ore
		if (qItemName == 'Light Hide') {
			if (!questObject.weaponsmith.lightHideQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.weaponsmith.lightHideQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.weaponsmith.lightHideQuest.count
				if (count == 1 || count == 3) {
					craftQuestTurnIn1(this, rewardAmount)
				} else if (count == 2 || count == 4) {
					if (count == 4) {
						craftQuestTurnIn3(this, rewardAmount)
					} else {
						craftQuestTurnIn2(this, rewardAmount)
					}
				} 
				if (!questObject.weaponsmith.lightHideQuest.questSequence1.first && count <= 1) {
					questObject.weaponsmith.lightHideQuest.questSequence1.first = true
					this.itemsOffered = [shortbow, phi, phi, dirk, phi, phi, hardenedLeatherFists, phi, phi]
				} else if (!questObject.weaponsmith.lightHideQuest.questSequence1.second && count == 2) {
					questObject.weaponsmith.lightHideQuest.questSequence1.second = true
					this.itemsOffered = [shortbow, longbow, phi, dirk, stiletto, phi, hardenedLeatherFists, studdedLeatherFists, phi]
				} else if (!questObject.weaponsmith.lightHideQuest.questSequence1.third && count == 4) {
					questObject.weaponsmith.lightHideQuest.questSequence1.third = true
					questObject.weaponsmith.lightHideQuest.questSequence1.complete = true
					this.itemsOffered = [shortbow, longbow, battleBow, dirk, stiletto, crescentDagger, hardenedLeatherFists, studdedLeatherFists, fighterFists]
				}
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Todlin the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let lyra = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Lyra',
	refName: 'lyra',
	picture: 'images/npcs/female/civilians/lyra/lyra.png',
	nameColor: 'lyra-name',
	prefix: 'Tailor ',
	prefixColor: 'lyra-prefix',
	keywords: ['lyra'],
	occupation: 'Tailor',
	race: 'Human',
	description: 'Lyra looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [clothCap, phi, apprenticeRobes, phi, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.armorsmith.thinFiberQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any thin fiber? My store could always use more thin fiber!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.armorsmith.thinFiberQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.armorsmith.thinFiberQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.armorsmith.thinFiberQuest.questItem().refName)
		}
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		if (qItemName == 'Thin Fiber') {
			if (!questObject.armorsmith.thinFiberQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.armorsmith.thinFiberQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.armorsmith.thinFiberQuest.count
				if (count == 6) {
					craftQuestTurnIn3(this, rewardAmount)
				} else {
					craftQuestTurnIn2(this, rewardAmount)
				} 
				if (!questObject.armorsmith.thinFiberQuest.questSequence1.first && count == 0) {
					questObject.armorsmith.thinFiberQuest.questSequence1.first = true
					this.itemsOffered = [clothCap, phi, apprenticeRobes, phi, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.thinFiberQuest.questSequence1.second && count == 1) {
					questObject.armorsmith.thinFiberQuest.questSequence1.second = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, phi, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.thinFiberQuest.questSequence1.third && count == 2) {
					questObject.armorsmith.thinFiberQuest.questSequence1.third = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.thinFiberQuest.questSequence1.fourth && count == 3) {
					questObject.armorsmith.thinFiberQuest.questSequence1.fourth = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.thinFiberQuest.questSequence1.fifth && count == 4) {
					questObject.armorsmith.thinFiberQuest.questSequence1.fifth = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.thinFiberQuest.questSequence1.sixth && count == 5) {
					questObject.armorsmith.thinFiberQuest.questSequence1.sixth = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, silkGloves, sandals, phi]
				} else if (!questObject.armorsmith.thinFiberQuest.questSequence1.seventh && count == 6) {
					questObject.armorsmith.thinFiberQuest.questSequence1.seventh = true
					questObject.armorsmith.thinFiberQuest.questSequence1.complete = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, silkGloves, sandals, silkFootwraps]
				} 
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Lyra the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

let faffa = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Faffa',
	refName: 'faffa',
	picture: 'images/npcs/male/civilians/faffa/faffa.png',
	nameColor: 'faffa-name',
	prefix: 'Staff Crafter ',
	prefixColor: 'faffa-prefix',
	keywords: ['faffa'],
	occupation: 'Staff Crafter',
	race: 'Gnome',
	description: 'Faffa looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [woodenStaff, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.weaponsmith.thinFiberQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any thin fiber? My store could always use more thin fiber!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.weaponsmith.thinFiberQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.weaponsmith.thinFiberQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.weaponsmith.thinFiberQuest.questItem().refName)
		} 
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		//iron ore
		if (qItemName == 'Thin Fiber') {
			if (!questObject.weaponsmith.thinFiberQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.weaponsmith.thinFiberQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.weaponsmith.thinFiberQuest.count
				if (count == 1 || count == 3) {
					craftQuestTurnIn1(this, rewardAmount)
				} else if (count == 2 || count == 4) {
					if (count == 4) {
						craftQuestTurnIn3(this, rewardAmount)
					} else {
						craftQuestTurnIn2(this, rewardAmount)
					}
				} 
				if (!questObject.weaponsmith.thinFiberQuest.questSequence1.first && count <= 1) {
					questObject.weaponsmith.thinFiberQuest.questSequence1.first = true
					this.itemsOffered = [woodenStaff, phi, phi]
				} else if (!questObject.weaponsmith.thinFiberQuest.questSequence1.second && count == 2) {
					questObject.weaponsmith.thinFiberQuest.questSequence1.second = true
					this.itemsOffered = [woodenStaff, powerStaff, phi]
				} else if (!questObject.weaponsmith.thinFiberQuest.questSequence1.third && count == 4) {
					questObject.weaponsmith.thinFiberQuest.questSequence1.third = true
					questObject.weaponsmith.thinFiberQuest.questSequence1.complete = true
					this.itemsOffered = [woodenStaff, powerStaff, runeStaff]
				}
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Faffa the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}


let deylani = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Deylani',
	refName: 'deylani',
	picture: 'images/npcs/female/civilians/deylani/deylani.png',
	nameColor: 'deylani-name',
	// prefix: 'Villager ',
	// prefixColor: '',
	keywords: ['deylani'],
	occupation: '',
	race: 'Human',
	description: 'Deylani',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 3)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Good day, sir."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"It's a beautiful day outside today, don't you think?"`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 3) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I might go visit the Glade later. I could use a nice walk around there."`, 'white', line1)
			blankSpace()
			return
		}
	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	xa: [0, 0, 0, 1, 1, 1, 1],
	ya: [1, 1, 1, 0, 0, 0, 0],
	xb: [-1, -1, -1, -1, 0, 0, 0],
	yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}
let arnoldo = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Arnoldo',
	refName: 'arnoldo',
	// picture: 'images/npcs/female/civilians/deylani/deylani.png',
	nameColor: 'deylani-name',
	// prefix: 'Villager ',
	// prefixColor: '',
	keywords: ['arnoldo'],
	occupation: '',
	race: 'Human',
	description: 'arnoldo',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 3)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Those damned Kobolds. I'd do anything to have them all slaughtered."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I had a son that went missing a few years ago. I'm pretty sure it was the Kobolds."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 3) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"If I wasn't so old, I would go after them all myself."`, 'white', line1)
			blankSpace()
			return
		}
	},
	quest: async function () {
		if (!this.questSequence.first) {
		let line1 = lineFunc()
		await dialogueWait(250)
		blankSpace()
		customizeEachWord(`Arnoldo wants you to kill one of each Kobold type in the Kobold's Lair`, 'white', line1)
		blankSpace()
		return
		}
		if (this.questSequence.first) {
		quickMessage(`${this.name} doesn't have a quest to offer you`)
		}
	},
	offer: async function() {
		let line1 = lineFunc()
		let isQuestObjectiveComplete
		if (player.killList.koboldArcher == 1 &&
			player.killList.koboldChild == 1 &&
			player.killList.koboldDigger == 1 &&
			player.killList.koboldScoundrel == 1 &&
			player.killList.koboldSpearthrower == 1 &&
			player.killList.koboldChief == 1) {
				isQuestObjectiveComplete = true
			}
		if (!isQuestObjectiveComplete) {
			quickMessage(`You have not completed the quest objective`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Thank you so much.. Nothing will ever bring back my son, but I feel better knowing that those wretched things were slaughtered."`, 'white', line1)
		blankSpace()
		this.questSequence.first = true
		await dialogueWait(200)
		playerGainQuestExperience(250)

	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	xa: [0, 0, 0, 1, 1, 1, 1],
	ya: [1, 1, 1, 0, 0, 0, 0],
	xb: [-1, -1, -1, -1, 0, 0, 0],
	yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}
let timtim = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Tim-Tim',
	refName: 'timTim',
	picture: 'images/npcs/male/civilians/timtim/timtim.png',
	nameColor: 'timtim',
	// prefix: 'Tim-',
	// prefixColor: 'timtim',
	keywords: ['tim', 'tim tim', 'tim-tim'],
	occupation: '',
	race: 'Human',
	description: 'Lil Tim Tim',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 2)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I'm looking for my sister. She's scared of the bugs I catch, and I just caught a big one!"`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I save all the gross stuff I find to freak out my sister, haha!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	questSequence: {
	},
	questItem: [wormGuts],
	quest: async function() {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Do you have anything gross? I like to freak my sister out with things that I find."`, 'white', line1)
		blankSpace()
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Oooooooo I'm gonna really get her with this!"`, 'white', line1)
		blankSpace()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
		await dialogueWait(200)
		playerGainQuestExperience(100)

	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}

let sally = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Sally',
	refName: 'sally',
	picture: 'images/npcs/female/civilians/sally/sally.png',
	nameColor: 'sally',
	// prefix: 'Villager ',
	// prefixColor: '',
	keywords: ['sally'],
	occupation: '',
	race: 'Human',
	description: 'Sally',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 2)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"My brother is so gross! My mommy had to get the beetle out of my hair that he put in it yesterday."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"If he puts a beetle on me again I'm going to get him back!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	questSequence: {
	},
	questItem: [mudBall],
	quest: async function() {
		if (!timtim.questSequence.first) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"It's ok, my brother hasn't picked on me today. But if he does, I'll be looking to get him back."`, 'white', line1)
			blankSpace()
			return
		}
		if (timtim.questSequence.first) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"My brother put worm guts on me!! I hate him so much I wanna smear mud all over his face!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!timtim.questSequence.first) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"It's ok, my brother hasn't picked on me today. But if he does, I'll be looking to get him back."`, 'white', line1)
			blankSpace()
			return
		} 
		if (timtim.questSequence.first && !qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Thanks Mister! I'm gonna throw this right in his face!"`, 'white', line1)
		blankSpace()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
		await dialogueWait(200)
		playerGainQuestExperience(200)
	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}
let travellingWagon = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Wagon',
	refName: 'wagon',
	picture: 'images/npcs/male/civilians/wagon/wagon.png',
	nameColor: 'dark-brown',
	prefix: 'Travelling ',
	prefixColor: 'dark-brown',
	keywords: ['travelling', 'wagon', 'travelling wagon', 'coachman'],
	occupation: '',
	race: 'Human',
	description: 'A Travelling Wagon',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 2)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`Coachman: `, this.nameColor, line1)
			customizeEachWord(`"Hello there. I travel these roads bringing food and supplies to the castle. "`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`Coachman: `, this.nameColor, line1)
			customizeEachWord(`"I lose some things off the cart from time to time."`, 'white', line1)
			blankSpace()
			return
		}
	},
	questSequence: {
	},
	questItem: [sackOfGrain],
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Coachman: `, this.nameColor, line1)
		customizeEachWord(`If you happen to find anything that looks like it might have falled off my wagon, I'd appreciate it if you brought it to me.`, 'white', line1)
		blankSpace()
	},
	offer: async function() {
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You do not have the proper item for this quest`)
			return
		} 
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Coachman: `, this.nameColor, line1)
		customizeEachWord(`Oho! I thought my wagon felt a little lighter. I appreciate you bringing this back to me. I'd be out some gold if I didn't have that sack. I think cuttin' you half the price would be fair.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`The coachman grins at you as he hands you a sack of gold`, ['white', 'italic'], line2)
		blankSpace()
		await dialogueWait(200)
		playerGainGold(100)
		await dialogueWait(200)
		playerGainQuestExperience(200)
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}

const strayCat = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Kitty',
	refName: 'kitty',
	picture: 'images/npcs/female/civilians/stray cat/stray cat.png',
	nameColor: 'grey',
	prefix: 'Stray ',
	prefixColor: 'dark-grey',
	keywords: ['stray', 'kitty', 'stray kitty', 'cat', 'stray cat'],
	occupation: '',
	race: 'Cat',
	description: 'A stray cat',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 1)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`The stray cat runs away from you and keeps an eye on you from a distance...`, ['white', 'italic'], line1)
			blankSpace()
			return
		}
	},
	questSequence: {
	},
	questItem: [halfEatenFish],
	quest: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`The kitty looks hungry`, ['white', 'italic'], line1)
		blankSpace() 
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == strayCat.questItem[0]().refName)
		console.log(qItem)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`You place the Half-Eaten Fish on the ground and step away. After several moments, the cat slowly approaches the fish. After a few quick sniffs, the cat bites into it and runs off`, ['white', 'italic'], line1)
		blankSpace()
		await dialogueWait(200)
		playerGainQuestExperience(250)
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true

	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}

let kasia = {
	npc: true,
	id: 0,
	x: 3,
	y: 0,
	name: 'Kasia',
	refName: 'kasia',
	picture: 'images/npcs/female/civilians/kasia/kasia.png',
	nameColor: 'kasia-name',
	prefix: 'Young Lass ',
	prefixColor: 'kasia-title',
	keywords: ['kasia', 'lass', 'young lass', 'lass kasia', 'young lass kasia'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)

	},
	desc: () => inspectBlip('A young woman wearing a lovely silk dress stands here smiling.', 'descriptions'),
	speak: async function () {
		let randomNumber = randomNumberRange(1, 1)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"A fine day it is, today!"`, 'white', line1)
			blankSpace()
			return
		}	
	},
	questSequence: {
		first: false,
	},
	questItem: [brightYellowFlower],
	quest: async function () {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`"${this.name}: "`, this.nameColor, line1)
		customizeEachWord(`"I like to collect flowers. Today, I'd like to find one that represents my mood: bright like the sun!"`, 'white', line1)
		blankSpace() 
	},
	offer: async function () {
		let qItem = this.questItem
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Kasia takes a deep smell of the flower`, ['white', 'italic'], line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This flower is just what I was looking to find today!"`, 'white', line2)
		blankSpace()
		pushItem.splice(qItemIndex, 1)
		player.backpack.splice(qItemIndex, 1)
		await dialogueWait(200)
		playerGainQuestExperience(200)
	},
}

let crutches = {
	name: 'Crutches',
	refName: 'crutches',
	nameColor: 'crutches-name',
	titleColor: 'crutches-title',
	speakComplete1: false,
	speakComplete2: false,
	keywords: ['crutches', 'jailor'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const titleSpan = document.createElement('span')

		const titleNode = document.createTextNode(`Jailor, `)
		const firstNameNode = document.createTextNode(`Crutches`)

		firstNameSpan.appendChild(firstNameNode)
		titleSpan.appendChild(titleNode)
		firstNameSpan.classList.add('crutches-name')
		titleSpan.classList.add('crutches-title')

		npcDiv.appendChild(titleSpan)
		npcDiv.appendChild(firstNameSpan)
		peopleDiv.appendChild(npcDiv)
	},
	desc: () => quickMessage(`A very old, hunch-backed old man`),
	speak: async () => {
		if (crutches.speakComplete1 == false) {
			player.dialogueStasis = true
			await dialogueWait(200)
			let line1 = paragraphFunc()
			customizeEachWord(`Crutches: `, ['greaves-name', 'indent'], line1)
			customizeEachWord(
				`"Ahhh, you must be another initiate! By the smell of you, you must be a prospective ${player.playerClass.name}. Before I let you go further, go north and bring me 3 fingers! "`,
				'white',
				line1
			)
			await dialogueWait(200)
			let line2 = gameLine()
			customizeGameDialogue(`You'll need one of these.`, 'white', line2)
			blankSpace()
			weaponGen(trainingShortsword())
			pushItem[pushItem.length - 1].roomId = 'backpack'
			await dialogueWait(200)
			let line3 = lineFunc()
			customizeEachWord(`You receive a `, 'indent', line3)
			customizeEachWord(`${pushItem[pushItem.length - 1].name}`, `${pushItem[pushItem.length - 1].color}`, line3)
			customizeEachWord(`!`, 'white', line3)
			await dialogueWait(200)
			let line4 = paragraphFunc()
			customizeEachWord(`When you have slain the Goblin Scout, return here and "offer crutches".`, 'white', line4)
			blankSpace()
			player.dialogueStasis = false
			crutches.speakComplete1 = true
		} else if (greaves.speakComplete1 == true && player.killList.goblin_scout == undefined) {
			setTimeout(() => {
				let line1 = paragraphFunc()
				customizeNPCDialogue(`Have you completed your task?`, 'greaves-name', line1)
				setTimeout(() => {
					let line2 = gameLine()
					customizeGameDialogue(`He looks you over to see that there is no blood on you. He turns back to his business without saying anything.`, 'white', line2)
				}, 1000)
			}, 1000)
		}
		if (player.killList.goblin_scout != undefined && greaves.speakComplete1 == true) {
			setTimeout(() => {
				let line1 = paragraphFunc()
				customizeNPCDialogue(`Great work, ${player.name}! You have proven yourself in combat. I will let the ${player.playerClass.name}'s guild admissions officer aware of your graduation status immediately.`, 'greaves-name', line1)
				customizeNPCDialogue(
					`From here, your next step is to gain admission to the ${player.playerClass.name}'s guild. You can find it south of here on the south side of the city. You can also explore as much as you'd like. The marketplace is now open, and the grassfields are no longer guarded. If you wish to travel to the city, you will find it to the south after exiting the training halls to the west.`,
					'greaves-name',
					line1
				)
			}, 1000)

			greaves.speakComplete2 = true
		} else if (greaves.speakComplete2 == true) {
			npcDialogue(`Placeholder`, 'greaves-name')
		}
	},
}

const lessa = {
	x: -2,
	y: 2,
	z: 0,
	name: 'Lessa',
	refName: 'lessa',
	nameColor: 'light-purple',
	prefix: 'Mud-covered Mage Prospect, ',
	prefixColor: 'purple',
	keywords: ['lessa'],
	occupation: `Mage prospect`,
	race: `Human`,
	description: ``,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Oh, this is just awful! Those damned Mudlings got their mud goo all over me! I can absorb their normal attacks with my magic shield, but their Mudslap ability is too strong."`, [this.prefixColor], line1)
			blankSpace()
		} 
	},
}

const sylas = {
	x: 1,
	y: 4,
	z: 0,
	name: 'Sylas',
	refName: 'sylas',
	nameColor: 'light-yellow',
	prefix: 'Shadowy Prospect, ',
	prefixColor: 'yellow',
	keywords: ['sylas', 'thief'],
	occupation: `Thief Prospect`,
	race: `Human`,
	description: `A shadowy thief`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Those Waterlings don't hit very hard, but you have to engage them quick or else they'll keep spraying you with water at range."`, this.prefixColor, line1)
			blankSpace()
		} 
	},
}

const levins = {
	npc: true,
	id: 0,
	x: -7,
	y: 8,
	z: 0,
	name: `Levins`,
	refName: 'levins',
	nameColor: 'light-blue',
	prefix: 'Commander ',
	prefixColor: 'blue',
	keywords: ['levins', 'commander', 'commander levins'],
	questComplete1: false,
	questComplete2: false,
	speakComplete1: false,
	speakComplete2: false,
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},
	desc: () => quickMessage('Commander Levins'),
	speak: () => {
		if (levins.speakComplete1 == false) {
			levins.speakComplete1 = true
			let weapon
			if (player.playerClass.name == 'Warrior') {
				weapon = 'Longsword'
				pushItem.push(longsword(10, false))
			} else if (player.playerClass.name == 'Rogue') {
				weapon = 'Shiv'
				pushItem.push(shiv(10, false))
			}
			pushItem.slice(-1)[0].roomId = 'backpack'
			npcDialogue(`For this last room, there's a Scout that we captured. He's a little tougher than the other creatures you've fought. To keep things on an even playing field, take this ${weapon}. Once you have defeated the scout, come back and'offer' me your completed task.`, 'levins-name')
			setTimeout(() => {
				let line1 = document.createElement('div')
				customizeEachWord(`You receive a `, 'game-dialogue', line1)
				customizeEachWord(`${weapon}`, 'green', line1)
				customizeEachWord(`!`, 'white', line1)
				blankSpace()
				setTimeout(() => {
					npcDialogue(
						`WEAPONS: To equip a weapon, you simply need to hold it. You can do this by using the 'UNPACK' command. Try 'unpack ${weapon}. Now you can check your inventory to see that your weapon is wielded. Two handed weapons are wielded by both hands, so they will take up two slots. You can dual wield one handed weapons, but only once you have trained the dual weapon skill.`
					)
				}, 1000)
			}, 1000)
		} else {
			let line1 = document.createElement('div')
			npcDialogue(`Return to me when you have completed your task`, 'levins-name')
			customizeEachWord(`(Try 'offer levins')`, 'game-dialogue', line1)
		}
	},
	quest: () => npcDialogue(`There are goblins in each of these rooms. Once you have slain them all, come back here and I will reward you.`),
	offer: function () {
		if (levins.questComplete1 == false && player.killList.goblin_scout) {
			levins.questComplete1 = true
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			npcDialogue(
				`Very nice! As you can see, upon gaining a level and completing your combat training quest, you have received 'stat points' and 'build points'. You will be able to use these to increase your attributes and learn new skills. You will learn all about how to do this once you join a guild.`,
				'levins-name'
			)
			npcDialogue(`If you're ever at the castle, feel free to drop by. I might have some tasks for you.`)
			setTimeout(() => {
				customizeEachWord(`You have been awarded `, 'white', line1)
				customizeEachWord(`100 `, 'yellow', line1)
				customizeEachWord(`gold!`, 'white', line1)
				customizeEachWord(`You have been awarded `, 'white', line2)
				customizeEachWord(`2 `, 'green', line2)
				customizeEachWord(`build `, 'light-blue', line2)
				customizeEachWord(`points!`, 'white', line2)
				player.gold = player.gold + 100
				player.skillPoints = player.skillPoints + 2
				setTimeout(() => {
					gameDialogue(`Commander Levins returns to the castle`)
					currentArea.npc = []
				}, 1000)
			}, 500)
		} else {
			let line1 = document.createElement('div')
			customizeEachWord(`You have not met the requirements to complete this quest`, 'white', line1)
		}
	},
}

const belric = {
	npc: true,
	id: 0,
	x: -7,
	y: 6,
	z: 0,
	name: `Belric`,
	refName: 'belric',
	nameColor: 'blue',
	suffix: ', Lord Commander of The Galvadian Guard',
	suffixColor: 'gold',
	keywords: ['belric'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},

	skills: [unarmedCombatSkill, oneHandedWeaponSkill, twoHandedWeaponSkill],
	skillsOffered: ['unarmed combat', 'one handed weapon skill', 'two handed weapon skill'],
	skillsMaxLevel: {
		unarmed: 10,
		oneHanded: 10,
		twoHanded: 10,
	},
	desc: () => quickMessage('A large, heavily armored knight stands before you.', 'descriptions'),
	quest: () => gameDialogue(`Belric holds out an open hand, expecting goblin heads.`),
	offer: function () {
		let questItems = pushItem.filter(item => item.name == 'goblin head')
		let questItemsIndexOfFirst = pushItem.indexOf(questItems[0])
		if (questItems[0] != undefined && questItems[1] == undefined) {
			quickMessage(`You hand a ${questItems[0].name} over to Belric`)
			player.experience += questItems[0].experience
			quickMessage(`You gain ${questItems[0].experience} points!`)
			pushItem.splice(questItemsIndexOfFirst, 1)
			player.backpack.splice(questItemsIndexOfFirst, 1)
			npcDialogue(`Ahhhh yes! The justice I feel from seeing their heads is palpable! Bring me more, and you will continue to be rewarded.`)
		} else if (questItems[0] != undefined && questItems[1] != undefined) {
			npcDialogue(`You hand over all your ${questItems[0].name}s to Belric`)
			npcDialogue(`Ahhhh yes! The justice I feel from seeing their heads is palpable! Bring me more, and you will continue to be rewarded.`)

			questExperienceMultipleItems(questItems)
		} else {
			gameDialogue(`You must have the proper item(s) to turn in this quest`)
		}
	},
}

const till = {
	x: -3,
	y: 9,
	z: 0,
	name: 'Till',
	refName: 'till',
	nameColor: 'light-brown',
	prefix: 'Annoyed Warrior Prospect, ',
	prefixColor: 'brown',
	occupation: 'Warrior Prospect',
	race: 'Human',
	description: 'A very annoyed looking warrior prospect',
	keywords: ['till', 'annoyed', 'warrior', 'prospect', 'annoyed warrior', 'annoyed warrior prospect', 'warrior prospect'],
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Damn it all! I've lost my lucky coin. I must've dropped it somewhere in the fields when I was fighting one of those Grasslings. You'll get cut up pretty bad if you don't retreat to another room when fighting them. I probably lost my coin when I was doing that."`, this.prefixColor, line1)
			blankSpace()
		} else {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I won't be so complacent again. Thanks for finding my coin."`, this.prefixColor, line1)
			blankSpace()
		}
	},
	quest: async function () {
		if (!this.questSequence.first) {
		let line1 = lineFunc()
		await dialogueWait(250)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"I'm looking for my lucky coin. I dropped it around here somewhere."`, 'white', line1)
		blankSpace()
		return
		}
		if (this.questSequence.first) {
		quickMessage(`${this.name} doesn't have a quest to offer you`)
		}
	},
	offer: function () {
		let qItem = pushItem.find(({ keywords }) => keywords.some(keyword => keyword == 'lucky coin'))
		let qItemIndex = pushItem.indexOf(qItem)
		let line1 = line()
		if (qItem.roomId == 'backpack' || qItem.roomId == 'right hand' || qItem.roomId == 'left hand') {
			customizeEachWord(`You hand a `, 'italic', line1)
			customizeEachWord(`Lucky Coin `, 'green', line1)
			customizeEachWord(`to the squire`, 'italic', line1)
			blankSpace()
			pushItem.splice(qItemIndex, 1)
			player.backpack.splice(qItemIndex, 1)
			let line2 = line()
			customizeEachWord(`Squire: `, this.nameColor, line2)
			customizeEachWord(`"Oh my! You found my coin! Holy hells, I've been looking all day. Here, take this."`, 'white', line2)
			blankSpace()
			let line3 = line()
			let line4 = line()
			customizeEachWord(`You receive `, 'white', line3)
			customizeEachWord(`50 `, 'yellow', line3)
			customizeEachWord(`gold!`, 'white', line3)
			customizeEachWord(`You gain `, 'white', line4)
			customizeEachWord(`20 `, 'light-blue', line4)
			customizeEachWord(`experience points!`, 'white', line4)
			player.gold = player.gold + 50
			player.experience = player.experience + 20
			playerLevelFunc()
			blankSpace()
		} else {
			quickMessage(`You must have the proper item to turn in this quest`)
		}
	},
	movesWhenPlayerIsHere: false,
	eastCount: 2,
	westCount: 2,
	intervalTick: 3000,
	npcBehavior: function () {
		npcMovesEastToWest(this)
	},
}


const villagerMalchus = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Malchus',
	refName: 'malchus',
	nameColor: randomClassColor(),
	suffix: ', Villager',
	suffixColor: 'brown',
	keywords: ['villager', 'malchus'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},
	desc: function () {
		let message1 = 'Male villager (Malchus)'
		let message1Color = `${this.nameColor}`
		inspectBlip(message1, message1Color)
	},
	speak: function () {
		let line1 = lineFunc()
		customizeEachWord(`${this.name}`, [this.nameColor, 'indent'], line1)
		customizeEachWord(` Greetings! My name is Malchus. I have lived in Galvadia all my life. Never have I seen a more beautiful place. It has everything to offer from lakes and rivers to hills and forests.`, 'white', line1)
	},
	movesWhenPlayerIsHere: false,
	eastCount: 2,
	westCount: 2,
	intervalTick: 5000,
	npcBehavior: function () {
		setInterval(() => {
			npcMovesRandomly(this)
		}, this.intervalTick)
	},
}

const villagerLinus = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Linus',
	refName: 'linus',
	nameColor: randomClassColor(),
	suffix: ', Villager',
	suffixColor: 'brown',
	keywords: ['villager', 'linus'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	desc: function () {
		npcDescription(this)
	},
	movesWhenPlayerIsHere: false,
	eastCount: 3,
	westCount: 3,
	intervalTick: 5000,
	npcBehavior: function () {
		setInterval(() => {
			npcMovesRandomly(this)
		}, this.intervalTick)
	},
}
const villagerRissah = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Rissah',
	refName: 'rissah',
	nameColor: randomClassColor(),
	picture: 'images/npcs/female/civilians/rissah/rissah.png',
	prefix: 'Villager ',
	prefixColor: 'light-brown',
	keywords: ['villager', 'rissah'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		this.isInConversation = true
		if (this.questSequence.first == false) {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"All this browsing around the marketplace has gotten me thirsty. I could use something really refreshing."`, this.prefixColor, line1)
			blankSpace()
		}
		if (this.questSequence.first) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"The market here on the castle grounds is a great place to socialize. The shops here don't have as much to sell as the shops in town, but that's ok with me."`, this.prefixColor, line1)
			blankSpace()
		}
		clearTimeout(NPCConversationIntervals.rissah)		
		NPCConversationIntervals.rissah = setTimeout(() => {
			this.isInConversation = false
		}, this.conversationInterval)
	},
	quest: async function () {
		if (!this.questSequence.first) {
		let line1 = lineFunc()
		await dialogueWait(250)
		blankSpace()
		customizeEachWord(`She appears to be thirsty.`, 'white', line1)
		blankSpace()
		return
		}
		if (this.questSequence.first) {
		quickMessage(`${this.name} doesn't have a quest to offer you`)
		}
	},
	offer: async function () {
		let qItem = pushItem.find(({ keywords }) => keywords.some(keyword => keyword == 'water berry'))
		let qItemIndex = pushItem.indexOf(qItem)
		let line1 = line()
		let line2 = line()
		let line4 = line()
		if (this.questSequence.first) {
			customizeEachWord(`You have already completed this quest`, 'white', line1)
		} else if (!qItem) {
			quickMessage(`You must have the proper item to complete this quest`)
		} else if (!this.questSequence.first && qItem.roomId == 'backpack' || qItem.roomId == 'right hand' || qItem.roomId == 'left hand') {
			this.questSequence.first = true
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`You hand a `, 'white', line1)
			customizeEachWord(`${qItem.name} `, 'green', line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${this.name} `, this.nameColor, line1)
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Oh my, a `, this.prefixColor, line2)
			customizeEachWord(`${qItem.name}`, 'green', line2)
			customizeEachWord(`! `, this.prefixColor, line2)
			customizeEachWord(`You must have worked really hard to get this. Benjamin only sells apples and mudpies. I should tell him to get you to collect some for him to sell. I bet he'd pay you for them.`, this.prefixColor, line2)
			await dialogueWait(250)
			playerGainQuestExperience(20)
			pushItem.splice(qItemIndex, 1)
			player.backpack.splice(qItemIndex, 1)
			return
		}  
	},
	desc: function () {
		npcDescription(this)
	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 1, -1, -1, 1, 0],
	// ya: [1, 0, -1, 1, 0, -1],
	// xb: [0, 1, -1, -1, 1, 0],
	// yb: [1, 0, -1, 1, 0, -1],
	xa: [0],
	xb: [0],
	ya: [1],
	yb: [-1],
	originalWaitInterval: 10000,
	conversationInterval: 10000,
	waitInterval: 10000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}
const villager1 = {
	npc: true,
	id: 0,
	x: -4,
	y: 2,
	z: 0,
	name: 'Villager1',
	refName: 'villager1',
	nameColor: randomClassColor(),
	suffix: ', Villager',
	suffixColor: 'brown',
	keywords: ['villager', 'rissah'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},
	desc: function () {
		let message1 = 'Female villager (Rissah)'
		let message1Color = `${this.nameColor}`
		inspectBlip(message1, message1Color)
	},
	movesWhenPlayerIsHere: true,
	eastCount: 4,
	westCount: 4,
	intervalTick: 5000,
	npcBehavior: function () {
		setInterval(() => {
			npcMovesEastToWest(this)
		}, this.intervalTick)
	},
}

// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 
// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 




// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 
// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 

function restFunction() {
	if (!player.restStasis) {
		quickMessage(`You are now resting...`)
		player.restStasis = true
		// let healthRecoveredPerTick = player.rest.healthPerTick()
		// let manaRecoveredPerTick = player.rest.manaPerTick()
		let restTimer = player.rest.restTimer
		let restInterval = setInterval(() => {
			if (player.restStasis) {
				let healthRecoveredPerTick = player.rest.healthPerTick()
				let manaRecoveredPerTick = player.rest.manaPerTick()
				if (player.health + healthRecoveredPerTick > player.maxHealth) {
					healthRecoveredPerTick = player.maxHealth - player.health
					player.health = player.maxHealth
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${healthRecoveredPerTick} `, 'green', line1)
					customizeEachWord(`hit points from resting`, 'white', line1)
					updatePlayerStats()
				} else {
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${healthRecoveredPerTick} `, 'green', line1)
					customizeEachWord(`hit points from resting`, 'white', line1)
					player.health = player.health + healthRecoveredPerTick
					updatePlayerStats()
				}
				if (player.mana + manaRecoveredPerTick > player.maxMana) {
					manaRecoveredPerTick = player.maxMana - player.mana
					player.mana = player.maxMana
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${manaRecoveredPerTick} `, 'blue', line1)
					customizeEachWord(`mana from resting`, 'white', line1)
					updatePlayerStats()
				} else {
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${manaRecoveredPerTick} `, 'blue', line1)
					customizeEachWord(`mana from resting`, 'white', line1)
					player.mana = player.mana + manaRecoveredPerTick
					updatePlayerStats()
				}
			}
			if (!player.restStasis) {
				clearInterval(restInterval)
			}
		}, restTimer)
	} else {
		quickMessage(`You are already resting`)
	}
}

//function trainSkill(secondCommand, thirdCommand) {
//	console.log(thirdCommand)
//	var regExp = /[a-zA-Z]/g //used to test if string contains letters. returns true or false
//	let npcName = thirdCommand == undefined ? undefined : thirdCommand.replace(/\s/g, '') //if thirdCommand contains any spaces, this removes them
//	npcName = npcName == undefined ? undefined : npcName.toLowerCase()
//	let targetNpc = currentArea.npc.find(npc => npc.name == npcName && npc.skills[0] != undefined)
//	const skillNumber = secondCommand - 1
//	if (!currentArea.npc[0]) {
//		quickMessage(`There is nobody here teaching anything.`)
//	} else if (secondCommand == undefined) {
//		quickMessage(`You must specify what skill or spell you wish to train and who to train it from`)
//	} else if (thirdCommand != npcName) {
//		quickMessage(`You do not see anyone named ${thirdCommand}`)
//	} else if (targetNpc.skills[skillNumber] == undefined) {
//		quickMessage(`This person cannot teach you that skill or spell`)
//	} else if (targetNpc.skills[skillNumber]) {
//		quickMessage(`You successfully train ${targetNpc.skills[skillNumber]}!`)
//	}
//}

function buyCommand(secondCommand, thirdCommand) {
	const validItemsNpc = currentArea.npc.filter(npc => npc.itemsOffered).length > 0 ? currentArea.npc.filter(npc => npc.itemsOffered) : currentArea.npc.find(npc => npc.itemsOffered)
	const specifiedNpc = currentArea.npc.find(npc => npc.refName == thirdCommand)
	const thirdCommandIsNpcName = validItemsNpc.some(npc => npc.refName == thirdCommand)
	if (validItemsNpc && validItemsNpc[1] && !thirdCommandIsNpcName) {
		quickMessage(`You must specify who you wish to buy from`)
	} else if (validItemsNpc != undefined && validItemsNpc[1] != undefined && thirdCommandIsNpcName == true) {
		specifiedNpc.buy(secondCommand)
	} else if (specifiedNpc != undefined && specifiedNpc.itemsOffered != null) {
		specifiedNpc.buy(secondCommand)
	} else if (validItemsNpc != undefined) {
		validItemsNpc[0].buy(secondCommand)
	} else {
		quickMessage(`Nobody here is teaching skills`)
	}
}

function buyInteraction(secondCommand, npc) { //interaction response from npc object
	let npcItemIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	let masterItem = npc.itemsOffered[npcItemIndex] != undefined ? npc.itemsOffered[npcItemIndex] : undefined
	masterItem = masterItem != undefined ? masterItem() : undefined
	let playerGold = player.gold
	let goldCost = masterItem != undefined ? masterItem.price : undefined
	let line1 = document.createElement('div')
	if (masterItem == undefined || masterItem.name == '???') {
		customizeEachWord(`There is no item by that number being sold`, 'white', line1)
	} else if (playerGold < goldCost) {
		customizeEachWord(`You do not have enough gold to buy that item`, 'white', line1)
	} else if (masterItem != undefined) {
		let vowels = ['a', 'e', 'i', 'o', 'u']
		let aOrAn = vowels.includes(masterItem.name[0].toLowerCase()) ? 'an' : 'a'

		customizeEachWord(`You purchased ${aOrAn} `, 'white', line1)
		customizeEachWord(`${masterItem.name} `, masterItem.color, line1)
		customizeEachWord(`for `, 'white', line1)
		customizeEachWord(`${masterItem.price} `, 'yellow', line1)
		customizeEachWord(`gold`, 'white', line1)
		player.gold -= goldCost
		if (masterItem.type.weapon) {
			weaponGen(masterItem)
		} else if (masterItem.type.armor) {
			armorGen(masterItem)
		} else if (masterItem.type.food) {
			foodGen(masterItem)
		}
		let purchasedItem = pushItem[pushItem.length - 1]
		purchasedItem.roomId = 'backpack'
	} else {
		customizeEachWord(`Fix this line`, 'white', line1)
	}
}

function trainInteraction(secondCommand, npc) {
	console.log(npc)
	let npcSkillIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	let masterSkill = npc.skillsOffered[npcSkillIndex]
	if (!masterSkill) {
		quickMessage(`That is not a skill that you can learn`)
		return
	}
	let npcSkillMaxLevel = masterSkill != undefined ? npc.skillsMaxLevel[masterSkill.refName] : undefined
	let playerSkill = player[masterSkill.refName]
	let playerGold = player.gold
	let playerPoints = player.skillPoints
	let goldCost = playerSkill != undefined ? playerSkill.goldToUpgrade() : masterSkill.goldToUpgrade()
	let pointsCost = playerSkill != undefined ? playerSkill.pointsToUpgrade() : masterSkill.pointsToUpgrade()
	let line1 = document.createElement('div')
 	if (masterSkill == undefined) {
		customizeEachWord(`That skill is not one of the choices`, 'white', line1)
	} 
	// else if (masterSkill.requiredPlayerLevel && player.level < masterSkill.requiredPlayerLevel()) {
	// 	quickMessage(`You must be level ${masterSkill.requiredPlayerLevel()} in order to train this ability`)
	// } 
	else if (playerGold < goldCost) {
		quickMessage(`You do not have enough gold to learn this skill!`)
	} else if (playerPoints < pointsCost) {
		quickMessage(`You do not have enough ability points to learn this skill!`)
	} else if (playerSkill == undefined && masterSkill != undefined) {
		playerSkill = { ...masterSkill }
		customizeEachWord(`You have learned the `, 'white', line1)
		customizeEachWord(`${masterSkill.refName} `, masterSkill.color, line1)
		customizeEachWord(`skill!`, 'white', line1)
		console.log(playerSkill)
		console.log(playerSkill.update)
		if (playerSkill.update) {
			player[playerSkill.refName].update()
		}
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else if (playerSkill.level < npcSkillMaxLevel) {
		playerSkill.level++
		customizeEachWord(`You have furthered your knowledge of the `, 'white', line1)
		customizeEachWord(`${playerSkill.name} `, playerSkill.color, line1)
		customizeEachWord(`skill! You have increased its level to `, 'white', line1)
		customizeEachWord(`${playerSkill.level}`, `light-blue`, line1)
		console.log(playerSkill)
		console.log(playerSkill.update)
		if (playerSkill.update) {
			player[playerSkill.refName].update()
		}
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else {
		customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
		customizeEachWord(`cannot teach you any more of the `, 'white', line1)
		customizeEachWord(`${playerSkill.name} `, playerSkill.color, line1)
		customizeEachWord(`skill`, 'white', line1)
	}
}
function learnInteraction(secondCommand, npc) {
	let npcSpellIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	console.log(npc)
	let masterSpell = npc.spellsOffered[npcSpellIndex]
	if (!masterSpell) {
		quickMessage(`Can't learn that`)
		return
	}
	let npcSkillMaxLevel = masterSpell != undefined ? npc.spellsMaxLevel[masterSpell.refName] : undefined
	let playerSpell = player[masterSpell.refName]
	let playerGold = player.gold
	let playerPoints = player.skillPoints
	let goldCost = playerSpell != undefined ? playerSpell.goldToUpgrade() : masterSpell.goldToUpgrade()
	let pointsCost = playerSpell != undefined ? playerSpell.pointsToUpgrade() : masterSpell.pointsToUpgrade()
	let line1 = document.createElement('div')
 	if (masterSpell == undefined) {
		customizeEachWord(`That spell is not one of the choices`, 'white', line1)
	} 
	// else if (masterSpell.requiredPlayerLevel && player.level < masterSpell.requiredPlayerLevel()) {
	// 	quickMessage(`You must be level ${masterSpell.requiredPlayerLevel()} in order to train this ability`)
	// } 
	else if (playerGold < goldCost) {
		quickMessage(`You do not have enough gold to learn this spell!`)
	} else if (playerPoints < pointsCost) {
		quickMessage(`You do not have enough ability points to learn this spell!`)
	} else if (playerSpell == undefined && masterSpell != undefined) {
		playerSpell = { ...masterSpell }
		customizeEachWord(`You have learned the `, 'white', line1)
		customizeEachWord(`${masterSpell.refName} `, masterSpell.color, line1)
		customizeEachWord(`spell!`, 'white', line1)
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else if (playerSpell.level < npcSkillMaxLevel) {
		playerSpell.level++
		customizeEachWord(`You have furthered your knowledge of the `, 'white', line1)
		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
		customizeEachWord(`skill! You have increased its level to `, 'white', line1)
		customizeEachWord(`${playerSpell.level}`, `light-blue`, line1)
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else {
		customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
		customizeEachWord(`cannot teach you any more of the `, 'white', line1)
		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
		customizeEachWord(`skill`, 'white', line1)
	}
}

// function applyExpertiseUponLeveling(skill) {
// 	// switch (skill.refName) {
// 	// 	case 'slashingExpertise':
// 	// 		skill.expertiseAmount()
// 	// 		break;
// 	// 	case 'piercingExpertise':
// 	// 		skill.expertiseAmount()
// 	// 		break;
// 	// 	case 'bluntExpertise':
// 	// 		skill.expertiseAmount()
// 	// 		break;
// 	// 	case 'firePenetration':
// 	// 		skill.penetrationAmount()
// 	// 		break;
// 	// }
// }

function sell(secondCommand, itemNumberPre) {
	//sell sword
	//sell 1
	//sell right/left
	if (currentArea.npc) {
		if (currentArea.npc[0] == undefined) {
			quickMessage(`There is nobody here to sell anything to`)
		} else if (currentArea.npc[0] && secondCommand == undefined) {
			quickMessage(`You must specify what you want to sell`)
		} else if (currentArea.npc[0]) {
			const itemNumber = itemNumberPre != undefined ? itemNumberPre - 1 : undefined
			const backpackArray = pushItem.filter(item => item.roomId == 'backpack')
			const itemSoldArray = backpackArray.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
			if (itemNumber) {
				let itemSold = itemSoldArray[itemNumber]
				if (!itemSold) {
					quickMessage(`You do not have that item to sell`)
				} else {
					if (itemSold.sellValue == 0) {
						quickMessage(`This item cannot be sold`)
						return
					}
					let removeThisItem = pushItem.find(item => item.id == itemSold.id)
					let removedItemIndex = pushItem.indexOf(removeThisItem)
					player.gold = player.gold + itemSold.sellValue
					pushItem.splice(removedItemIndex, 1)
					//quickMessage(`You sold your ${itemSold.name} for ${itemSold.sellValue} gold`)
					sellItemDialog(itemSold.name, itemSold.sellValue)
				}
			} else {
				let itemSold = itemSoldArray[0]
				if (itemSold == undefined) {
					quickMessage(`You do not have that item to sell`)
				} else {
					if (itemSold.sellValue == 0) {
						quickMessage(`This item cannot be sold`)
						return
					}
					console.log('2 THIS IS WHERE SOLD')
					sellItemDialog(itemSold.name, itemSold.sellValue)
					let removeThisItem = pushItem.find(item => item.id == itemSold.id)
					let removedItemIndex = pushItem.indexOf(removeThisItem)
					player.gold = player.gold + itemSold.sellValue
					pushItem.splice(removedItemIndex, 1)
					//quickMessage(`You sold your ${itemSold.name} for ${itemSold.sellValue} gold`)
				}
			}
		} else {
			console.log('nobody selling anything here')
		}
	}
}
function showSkills(thirdCommand) {
	console.log('new function')
	const allNpcsInRoom = currentArea.npc
	const validSkillsNpc = currentArea.npc.filter(npc => npc.skillsOffered != undefined)
	let npcByName = allNpcsInRoom.find(({ keywords }) => keywords.some(keyword => keyword == thirdCommand))
	//NO NPCS IN THE ROOM TEACH SKILLS
	if (validSkillsNpc[0] == undefined) {
		quickMessage(`There is nobody here teaching skills`)
		return
	}
		if (validSkillsNpc[0] != undefined && validSkillsNpc [1] != undefined) {
		if (thirdCommand == undefined) {
			quickMessage(`You must specify whose skills you wish to see`)
			return
		} else {
			if (npcByName == undefined) {
				quickMessage(`There is nobody here named ${thirdCommand} teaching skills`)
				return
			} else {
				npcByName.displayShop('skills')
				return
			}
		}
	}
	//THERE IS AN NPC IN THE ROOM SPECIFIED BY THE PLAYER
		if (npcByName != undefined) {
	//THE SPECIFIED NPC DOES TEACH SKILLS
		if (npcByName.skillsOffered != undefined) {
			npcByName.displayShop('skills')		
			return
		} else {
	//NPC DOES NOT TEACH SKILLS
			quickMessage(`${npcByName.name} is not teaching any skills`)
			return
		}
	}
	//COULD BE MULTIPLE NPCS IN THE ROOM, BUT ONLY 1 OF THEM TEACHES SKILLS
	if (validSkillsNpc[0] != undefined && validSkillsNpc[1] == undefined) {
	//IF THERE IS NO THIRDCOMMAND FROM THE PLAYER I.E. COMMAND IS "SHOW SKILLS" WITHOUT A SPECIFIED NAME
		if (thirdCommand == undefined) {
			validSkillsNpc[0].displayShop('skills')
			return
		} else {
			quickMessage(`There is nobody named ${thirdCommand} teaching skills`)
			return
		}
	}
}
function showSpells(thirdCommand) {
	console.log('new function')
	const allNpcsInRoom = currentArea.npc
	const validSpellsNpc = currentArea.npc.filter(npc => npc.spellsOffered != undefined)
	let npcByName = allNpcsInRoom.find(npc => npc.refName == thirdCommand)
	//NO NPCS IN THE ROOM TEACH SPELLS
	if (validSpellsNpc[0] == undefined) {
		quickMessage(`There is nobody here teaching spells`)
		return
	}
		if (validSpellsNpc[0] != undefined && validSpellsNpc [1] != undefined) {
		if (thirdCommand == undefined) {
			quickMessage(`You must specify whose spells you wish to see`)
			return
		} else {
			if (npcByName == undefined) {
				quickMessage(`There is nobody here named ${thirdCommand} teaching spells`)
				return
			} else {
				npcByName.displayShop('spells')
				return
			}
		}
	}
	//THERE IS AN NPC IN THE ROOM SPECIFIED BY THE PLAYER
		if (npcByName != undefined) {
	//THE SPECIFIED NPC DOES TEACH SPELLS
		if (npcByName.spellsOffered != undefined) {
			npcByName.displayShop('spells')		
			return
		} else {
	//NPC DOES NOT TEACH SPELLS
			quickMessage(`${npcByName.name} is not teaching any spells`)
			return
		}
	}
	//COULD BE MULTIPLE NPCS IN THE ROOM, BUT ONLY 1 OF THEM TEACHES SPELLS
	if (validSpellsNpc[0] != undefined && validSpellsNpc[1] == undefined) {
	//IF THERE IS NO THIRDCOMMAND FROM THE PLAYER I.E. COMMAND IS "SHOW SPELLS" WITHOUT A SPECIFIED NAME
		if (thirdCommand == undefined) {
			validSpellsNpc[0].displayShop('spells')
			return
		} else {
			quickMessage(`There is nobody named ${thirdCommand} teaching spells`)
			return
		}
	}
}

function showItems(thirdCommand) {
	console.log('new function')
	const allNpcsInRoom = currentArea.npc
	const validItemsNpc = currentArea.npc.filter(npc => npc.itemsOffered != undefined)
	let npcByName = allNpcsInRoom.find(npc => npc.name.toLowerCase() == thirdCommand)
	//NO NPCS IN THE ROOM TEACH SPELLS
	if (!validItemsNpc[0]) {
		quickMessage(`There is nobody here selling items`)
		return
	}
	if (validItemsNpc[0]&& validItemsNpc[1]) {
		if (!thirdCommand) {
			quickMessage(`You must specify whose items you wish to see`)
			return
		} else {
			if (npcByName == undefined) {
				quickMessage(`There is nobody here named ${thirdCommand} selling items`)
				return
			} else {
				npcByName.displayShop('items')
				return
			}
		}
	}
	//THERE IS AN NPC IN THE ROOM SPECIFIED BY THE PLAYER
		if (npcByName != undefined) {
	//THE SPECIFIED NPC DOES TEACH SPELLS
		if (npcByName.itemsOffered != undefined) {
			npcByName.displayShop('items')		
			return
		} else {
	//NPC DOES NOT TEACH SPELLS
			quickMessage(`${npcByName.name} is not selling items`)
			return
		}
	}
	//COULD BE MULTIPLE NPCS IN THE ROOM, BUT ONLY 1 OF THEM TEACHES SPELLS
	if (validItemsNpc[0] != undefined && validItemsNpc[1] == undefined) {
	//IF THERE IS NO THIRDCOMMAND FROM THE PLAYER I.E. COMMAND IS "SHOW SPELLS" WITHOUT A SPECIFIED NAME
		if (thirdCommand == undefined) {
			validItemsNpc[0].displayShop('items')
			return
		} else {
			quickMessage(`There is nobody named ${thirdCommand} selling items here`)
			return
		}
	}
	quickMessage(`no conditions met???`)
}
function showQuest(thirdCommand) {
	//item
	console.log('new function')
	const validQuestNpc = currentArea.npc.filter(npc => npc.quest != undefined)
	// let npcByName = validQuestNpc.find(npc => npc.name.toLowerCase() == thirdCommand)
	let npcByName = validQuestNpc.find(({ keywords }) => keywords.some(keyword => keyword == thirdCommand))
	console.log(npcByName)
	//NO NPCS IN THE ROOM TEACH SPELLS
	if (validQuestNpc[0] == undefined) {
		quickMessage(`There is nobody here offering quests`)
		return
	}
	if (validQuestNpc[0] != undefined && validQuestNpc [1] != undefined) {
		if (thirdCommand == undefined) {
			quickMessage(`You must specify whose quest you wish to see`)
			return
		} else {
			if (npcByName == undefined) {
				quickMessage(`There is nobody here named ${thirdCommand} offering any quests`)
				return
			} else {
				npcByName.quest()
				return
			}
		}
	}
	//THERE IS AN NPC IN THE ROOM SPECIFIED BY THE PLAYER
		if (npcByName != undefined) {
	//THE SPECIFIED NPC DOES TEACH SPELLS
		if (npcByName.quest != undefined) {
			npcByName.quest()	
			return
		} else {
	//NPC DOES NOT TEACH SPELLS
			quickMessage(`${npcByName.name} does not have any quests to offer you`)
			return
		}
	}
	//COULD BE MULTIPLE NPCS IN THE ROOM, BUT ONLY 1 OF THEM TEACHES SPELLS
	if (validQuestNpc[0] != undefined && validQuestNpc[1] == undefined) {
	//IF THERE IS NO THIRDCOMMAND FROM THE PLAYER I.E. COMMAND IS "SHOW SPELLS" WITHOUT A SPECIFIED NAME
		if (thirdCommand == undefined) {
			validQuestNpc[0].quest()
			return
		} else {
			quickMessage(`There is nobody named ${thirdCommand} offering quests`)
			return
		}
	}
	quickMessage(`no conditions met???`)
}

function show(secondCommand, thirdCommand) {
	let showWhat = secondCommand == 'skills' ? showSkills : secondCommand == 'items' ? showItems : secondCommand == 'spells' ? showSpells : secondCommand == 'quest' ? showQuest : undefined
	if (showWhat == undefined) {
		console.log(1)
		quickMessage(`You must specify either skills, items, spells or quest after the SHOW command`)
		return
	} else {
		showWhat(thirdCommand)
	}
}

function trainSkill(secondCommand, thirdCommand) {
	if (isNaN(secondCommand)) {
		quickMessage(`You must specify the number of skill to train before the teacher's name.`)
		return
	}
	const validSkillsNpc = currentArea.npc.filter(npc => npc.skillsOffered).length > 0 ? currentArea.npc.filter(npc => npc.skillsOffered) : currentArea.npc.find(npc => npc.skillsOffered)
	if (!validSkillsNpc) {
		quickMessage(`There is nobody here teaching skills`)
		return
	}
	if (!secondCommand) {
		quickMessage(`You must specify what skill you want to train`)
		return
	}
	if (validSkillsNpc.length > 1 && !thirdCommand) {
		quickMessage(`There are more than one trainers here. You must specify who you wish to train skills from.`)
		return
	}
	let npc
	if (!thirdCommand) {
		npc = validSkillsNpc[0]
	} else {
		npc = npcByName(thirdCommand)
	}
	console.log(npc)
	npc.train(secondCommand, npc)
}

function increaseStat(secondCommand) {
	let stat
	switch (secondCommand) {
		case 'strength':
		case 'str':
			stat = 'str'
			break
		case 'dexterity':
		case 'dex':
			stat = 'dex'
			break
		case 'agility':
		case 'agi':
			stat = 'agi'
			break
		case 'intelligence':
		case 'int':
			stat = 'int'
			break
		case 'wisdom':
		case 'wis':
			stat = 'wis'
			break
		case 'constitution':
		case 'con':
			stat = 'con'
			break
	}
	if (player[stat] == undefined) {
		quickMessage(`You do not have the stat ${secondCommand} to increase.`)
	} else if (player.attributePoints > 0) {
		let line1 = document.createElement('div')
		customizeEachWord(`You have increased your `, 'white', line1)
		customizeEachWord(`${secondCommand.toUpperCase()} `, 'green', line1)
		customizeEachWord(`by`, 'white', line1)
		customizeEachWord(`1`, 'light-blue', line1)
		customizeEachWord(`!`, 'white', line1)
		player.attributePoints = player.attributePoints - 1
		player[stat]++
		updatePlayerStats()
	} else {
		quickMessage(`You do not have enough stat points.`)
	}
}

function learnSpell(secondCommand, thirdCommand) {
	if (isNaN(secondCommand)) {
		quickMessage(`You must specify the number of spell to learn before the teacher's name.`)
		return
	}
	const validSpellsNpc = currentArea.npc.filter(npc => npc.spellsOffered).length > 0 ? currentArea.npc.filter(npc => npc.spellsOffered) : currentArea.npc.find(npc => npc.spellsOffered)
	if (!validSpellsNpc) {
		quickMessage(`There is nobody here teaching spells`)
		return
	}
	if (!secondCommand) {
		quickMessage(`You must specify what spell you want to train`)
		return
	}
	if (validSpellsNpc.length > 1 && !thirdCommand) {
		quickMessage(`There are more than one teachers here. You must specify who you wish to learn spells from.`)
		return
	}
	let npc
	if (!thirdCommand) {
		npc = validSpellsNpc[0]
	} else {
		npc = npcByName(thirdCommand)
	}
	console.log(npc)
	npc.learn(secondCommand, npc)
}

function specialShop() {
	
}

function displayShopSkillsOrSpells(targetNpc, ssoi) {
	// const targetNpc = currentArea.npc ? currentArea.npc.find(x => x.name == headerName.toLowerCase()) : undefined
	let skillNumber = 1
	let spellNumber = 1
	let itemNumber = 1
	if (ssoi == 'skills') {
		if (targetNpc.skillsOffered[0]) {
			const mainWindowDiv = document.createElement('div')
			const headingContainer = document.createElement('div')
			const headingDiv = document.createElement('div')
			const headingNode = document.createElement('div')
			headingNode.classList.add('orange')
			headingNode.textContent = `Skills`
			const skillsContainerContainer = document.createElement('div')
			const skillsContainer = document.createElement(`div`)
			const priceContainer = document.createElement('div')
			const informationContainer = document.createElement('div')
			const informationSkillsContainer = document.createElement('div')
			const informationSpellsContainer = document.createElement('div')
			const informationAbilitiesContainer = document.createElement('div')
			const informationSkillsNode = document.createTextNode(`Skills: Train #`)
			const informationAbilitiesNode = document.createTextNode(`Abilities: Train #`)
			const informationSpellsNode = document.createTextNode(`Spells: Learn #`)
			informationSkillsContainer.appendChild(informationSkillsNode)
			informationAbilitiesContainer.appendChild(informationAbilitiesNode)
			informationSpellsContainer.appendChild(informationSpellsNode)
			informationContainer.appendChild(informationSkillsContainer)
			informationContainer.appendChild(informationAbilitiesContainer)
			informationContainer.appendChild(informationSpellsContainer)

			headingDiv.appendChild(headingNode)
			headingContainer.appendChild(headingDiv)
			mainWindowDiv.appendChild(headingContainer)
			skillsContainerContainer.appendChild(skillsContainer)
			skillsContainerContainer.appendChild(priceContainer)
			skillsContainerContainer.appendChild(informationContainer)
			mainWindowDiv.appendChild(skillsContainerContainer)
			skillsContainerContainer.classList.add('shop-skills-container-container')
			mainWindowDiv.classList.add(`shop-main`)
			headingDiv.classList.add(`shop-heading`)
			skillsContainer.classList.add(`shop-skills-container`)
			priceContainer.classList.add('shop-price-container')
			informationContainer.classList.add('shop-information-container') //change this
			headingContainer.classList.add(`shop-heading-container`)
			let skills = targetNpc.skillsOffered
			skills.forEach(skill => {
				if (player[skill.refName] != undefined) {
					skill = player[skill.refName]
				}
				const itemContainer = document.createElement(`div`)

				const priceAndBuildPointsContainer = document.createElement('div')
				priceAndBuildPointsContainer.classList.add('price-build-points-container')

				const itemNode = document.createElement('div')
				itemNode.textContent = skill.name
				const priceDiv = document.createElement('div')
				const priceNode = document.createElement('div')
				const g = document.createElement('div')

				const skillPointsDiv = document.createElement('div')
				const skillPointsNumber = document.createElement('div')
				const skillPointsString = document.createElement('div')



				skillPointsString.classList.add('build-points-string')
				skillPointsNumber.classList.add('light-blue')
				itemContainer.classList.add(`shop-skills-number-container`)
				skillPointsDiv.classList.add('price-g')
				skillPointsDiv.classList.add('shop-column-2')
				priceDiv.classList.add('price-g')
				priceDiv.classList.add('shop-column-1')
				itemNode.classList.add(skill.color)
				itemNode.classList.add('item-node')
				priceNode.classList.add('shop-price-amount')
				console.log(skill)
				skillPointsNumber.textContent = skill.pointsToUpgrade ? skill.pointsToUpgrade() : 'fix this skill'
				skillPointsString.textContent = 'skill point(s)'
				g.textContent = 'g'
				priceNode.textContent = `${skill.goldToUpgrade ? skill.goldToUpgrade() : 'fix this skill'}`
				let numberNode = document.createElement(`div`) //Ex. skill 1: skill 2: skill 3:
				numberNode.textContent = `${skillNumber}) `
				skillNumber++
				priceAndBuildPointsContainer.appendChild(priceDiv)
				priceAndBuildPointsContainer.appendChild(skillPointsDiv)
				itemContainer.appendChild(numberNode)
				itemContainer.appendChild(itemNode)
				priceDiv.appendChild(priceNode)
				priceDiv.appendChild(g)
				if (skill.level == targetNpc.skillsMaxLevel[skill.refName]) {
					const maxTrainedDiv = document.createElement('div')
					const maxTrainedString = document.createElement('div')
					maxTrainedString.textContent = 'You have learned all they can teach!'
					maxTrainedDiv.classList.add('price-g')
					maxTrainedString.classList.add('build-points-string')
					maxTrainedDiv.appendChild(maxTrainedString)
					priceAndBuildPointsContainer.appendChild(maxTrainedDiv)
				} else 	if (skill.requiredPlayerLevel) {
					const requiredLevelDiv = document.createElement('div')
					const requiredLevelString = document.createElement('div')
					const requiredLevelNumber = document.createElement('div')
					requiredLevelString.classList.add('build-points-string')
					requiredLevelNumber.classList.add('red')
					requiredLevelDiv.classList.add('price-g')
					// requiredLevelNumber.textContent = skill.requiredPlayerLevel()
					requiredLevelString.textContent = 'Required level'
					requiredLevelDiv.appendChild(requiredLevelString)
					requiredLevelDiv.appendChild(requiredLevelNumber)
					priceAndBuildPointsContainer.appendChild(requiredLevelDiv)
					}
				skillPointsDiv.appendChild(skillPointsNumber)
				skillPointsDiv.appendChild(skillPointsString)
				priceContainer.appendChild(priceAndBuildPointsContainer)
				skillsContainer.appendChild(itemContainer)

			})
			masterArea.appendChild(mainWindowDiv)
			updateScroll()
		}
	}
	if (ssoi == 'spells') {
		if (targetNpc.spellsOffered[0]) {
			const mainWindowDiv = document.createElement('div')
			const headingContainer = document.createElement('div')
			const headingDiv = document.createElement('div')
			const headingNode = document.createElement('div')
			headingNode.classList.add('purple')
			headingNode.textContent = `Spells`
			const spellsContainerContainer = document.createElement('div')
			
			const spellsContainer = document.createElement(`div`)
			const priceContainer = document.createElement('div')

			const informationContainer = document.createElement('div')
			const informationSkillsContainer = document.createElement('div')
			const informationSpellsContainer = document.createElement('div')
			const informationAbilitiesContainer = document.createElement('div')
			const informationSkillsNode = document.createTextNode(`Skills: Train #`)
			const informationAbilitiesNode = document.createTextNode(`Abilities: Train #`)
			const informationSpellsNode = document.createTextNode(`Spells: Learn #`)
			informationSkillsContainer.appendChild(informationSkillsNode)
			informationAbilitiesContainer.appendChild(informationAbilitiesNode)
			informationSpellsContainer.appendChild(informationSpellsNode)
			informationContainer.appendChild(informationSkillsContainer)
			informationContainer.appendChild(informationAbilitiesContainer)
			informationContainer.appendChild(informationSpellsContainer)


			headingDiv.appendChild(headingNode)
			headingContainer.appendChild(headingDiv)
			mainWindowDiv.appendChild(headingContainer)
			spellsContainerContainer.appendChild(spellsContainer)
			spellsContainerContainer.appendChild(priceContainer)
			mainWindowDiv.appendChild(spellsContainerContainer)
			spellsContainerContainer.classList.add('shop-skills-container-container')
			spellsContainerContainer.appendChild(informationContainer)
			informationContainer.classList.add('shop-information-container') //change this
			spellsContainerContainer.appendChild(spellsContainer)
			spellsContainerContainer.appendChild(priceContainer)
			spellsContainerContainer.appendChild(informationContainer)
			mainWindowDiv.appendChild(spellsContainerContainer)
			mainWindowDiv.classList.add(`shop-main`)
			headingDiv.classList.add(`shop-heading`)
			spellsContainer.classList.add(`shop-spells-container`)
			priceContainer.classList.add('shop-price-container')
			headingContainer.classList.add(`shop-heading-container`)
			let spells = targetNpc.spellsOffered
			spells.forEach(spell => {
				console.log(spell)
				if (player[spell.refName] != undefined) {
					spell = player[spell.refName]
				}
				const itemContainer = document.createElement(`div`)

				const priceAndBuildPointsContainer = document.createElement('div')
				priceAndBuildPointsContainer.classList.add('price-build-points-container')

				const itemNode = document.createElement('div')
				itemNode.textContent = spell.name
				const priceDiv = document.createElement('div')
				const priceNode = document.createElement('div')
				const g = document.createElement('div')

				const skillPointsDiv = document.createElement('div')
				const skillPointsNumber = document.createElement('div')
				const skillPointsString = document.createElement('div')

				skillPointsString.classList.add('build-points-string')
				skillPointsNumber.classList.add('light-blue')
				itemContainer.classList.add(`shop-skills-number-container`)
				skillPointsDiv.classList.add('price-g', 'shop-column-2')
				priceDiv.classList.add('price-g', 'shop-column-1')
				itemNode.classList.add(spell.color)
				itemNode.classList.add('item-node')
				priceNode.classList.add('shop-price-amount')

				skillPointsNumber.textContent = spell.pointsToUpgrade()
				skillPointsString.textContent = 'build points'
				g.textContent = 'g'
				priceNode.textContent = `${spell.goldToUpgrade()}`
				itemContainer.classList.add(`shop-skills-number-container`)
				let numberNode = document.createElement('div') //Ex. skill 1: skill 2: skill 3:
				numberNode.textContent = `${spellNumber}) `
				spellNumber++

				priceAndBuildPointsContainer.appendChild(priceDiv)
				priceAndBuildPointsContainer.appendChild(skillPointsDiv)
				itemContainer.appendChild(numberNode)
				itemContainer.appendChild(itemNode)
				priceDiv.appendChild(priceNode)
				priceDiv.appendChild(g)
				skillPointsDiv.appendChild(skillPointsNumber)
				skillPointsDiv.appendChild(skillPointsString)
				priceContainer.appendChild(priceAndBuildPointsContainer)
				spellsContainer.appendChild(itemContainer)
			})

			masterArea.appendChild(mainWindowDiv)
			updateScroll()
		}
	} else if (ssoi == 'items') {
		if (targetNpc.itemsOffered[0]) {
			const mainWindowDiv = document.createElement('div')
			const headingContainer = document.createElement('div')
			const headingDiv = document.createElement('div')
			const headingNode = document.createElement('div')
			headingNode.classList.add('green')
			headingNode.textContent = `Items`
			const itemsContainerContainer = document.createElement('div')
			const itemsContainer = document.createElement(`div`)
			const priceContainer = document.createElement('div')
			const miscContainer = document.createElement('div')
			headingDiv.appendChild(headingNode)
			headingContainer.appendChild(headingDiv)
			mainWindowDiv.appendChild(headingContainer)
			itemsContainerContainer.appendChild(itemsContainer)
			itemsContainerContainer.appendChild(priceContainer)
			itemsContainerContainer.appendChild(miscContainer)
			mainWindowDiv.appendChild(itemsContainerContainer)
			itemsContainerContainer.classList.add('shop-skills-container-container')
			mainWindowDiv.classList.add(`shop-main`)
			headingDiv.classList.add(`shop-heading`)
			itemsContainer.classList.add(`shop-spells-container`)
			priceContainer.classList.add('shop-price-container')
			miscContainer.classList.add('shop-price-container')
			headingContainer.classList.add(`shop-heading-container`)
			let items = targetNpc.itemsOffered
			items.forEach(item => {
				item = item()
				const itemContainer = document.createElement(`div`)
				const priceDiv = document.createElement('div')
				const miscDiv = document.createElement('div')
				priceDiv.classList.add('price-g')
				const itemNode = document.createElement('div')
				itemNode.classList.add(item.color)
				itemNode.classList.add('item-node')
				itemNode.textContent = item.name
				const priceNode = document.createElement('div')
				const g = document.createElement('div')
				g.textContent = item.name == '???' ? '\u00A0\u00A0' : 'g';
				priceNode.classList.add('shop-price-amount')
				priceNode.textContent = item.price
				itemContainer.classList.add(`shop-skills-number-container`)
				miscDiv.classList.add(`shop-skills-number-container`)
				let numberNode = document.createElement('div') //Ex. skill 1: skill 2: skill 3:
				numberNode.classList.add('number-node')
				numberNode.textContent = `${itemNumber}) `
				itemNumber++
				itemContainer.appendChild(numberNode)
				itemContainer.appendChild(itemNode)
				priceDiv.appendChild(priceNode)
				priceDiv.appendChild(g)
				priceContainer.appendChild(priceDiv)
				itemsContainer.appendChild(itemContainer)
				miscContainer.appendChild(miscDiv)
			})
			masterArea.appendChild(mainWindowDiv)
			updateScroll()
		}
	}
	blankSpace()
}

function trade(secondCommand) {
	if (currentArea.npc) {
		const allNpcs = currentArea.npc.map(allNpc => allNpc)
		const findNpc = allNpcs.find(x => x.name == secondCommand)
		if (findNpc && findNpc.trade != undefined) {
			findNpc.trade(secondCommand)
		} else if (findNpc == undefined && secondCommand != undefined) {
			quickMessage(`You do not see anyone named ${secondCommand} to trade with`, 'descriptions')
		} else if (findNpc.trade == undefined) {
			quickMessage(`this person does not have anything to trade`)
		} else {
			quickMessage(`You must specify who you wish to trade with`, 'descriptions')
		}
	}
}

function tradeDialog(headerName) {
	const targetNpc = currentArea.npc ? currentArea.npc.find(x => x.name == headerName.toLowerCase()) : undefined
	let itemNumber = 1
	if (targetNpc != undefined) {
		if (targetNpc.items[0]) {
			const targetNpcItems = targetNpc.items
			const topDiv = document.createElement('div')
			const topNode = document.createTextNode(`_____________________________________${targetNpc.displayName}________________________________________`)

			const itemsListDiv = document.createElement('div') //main div for items

			const itemName = targetNpcItems.map(item => npcItemsToNode(item)) //array of all the items the npc has
			itemName.forEach(itemsListNode => {
				const itemByNumberDiv = document.createTextNode(`item ${itemNumber}: `) //Ex. item 1: item 2: item 3:
				itemNumber = itemNumber + 1
				itemsListDiv.appendChild(itemByNumberDiv)
				itemsListDiv.appendChild(itemsListNode)
			})
			itemsListDiv.classList.add('descriptions')
			//itemsListDiv.appendChild(itemsListNode)
			topDiv.appendChild(topNode)

			masterArea.appendChild(topDiv)
			masterArea.appendChild(itemsListDiv)
			updateScroll()
		} // else {
		//	quickMessage(`${targetNpc.name} has nothing to trade`)
		//}
	} // else {
	//quickMessage(`You do not see ${headerName} to trade with`)
	//}
}



function playerGainKillExperience(gainedExperience) {
	player.experience += gainedExperience
	playerLevelFunc()
}
function playerGainQuestExperience(gainedExperience) {
	let line1 = lineFunc()
	player.experience += gainedExperience
	blankSpace()
	customizeEachWord(`You gain `, 'white', line1)
	customizeEachWord(`${gainedExperience} `, 'light-blue', line1)
	customizeEachWord(`experience points!`, 'white', line1)
	blankSpace()
	playerLevelFunc()
}
function playerGainGold(goldGained) {
	player.gold += goldGained
}

function questExperienceMultipleItems(questItems) {
	let count = 0
	questItems.forEach(item => {
		let questItemIndex = pushItem.indexOf(item)
		count += item.experience
		pushItem.splice(questItemIndex, 1)
		player.backpack.splice(questItemIndex, 1)
	})
	setTimeout(() => {
		playerGainQuestExperience(count)
	}, 200)
}

function questItemOffer() {
	if (player.backpack.map(x => x.toLowerCase()).find(y => y == this.questItem)) {
		let qItem = pushItem.find(x => x.name.toLowerCase() == this.questItem)
		let qItemIndex = pushItem.indexOf(qItem)
		quickMessage(`You hand a ${qItem.name} over to ${this.name}`, 'descriptions')
		pushItem.splice(qItemIndex, 1)
		player.backpack.splice(qItemIndex, 1)
	}
}
//SKILLS++SKILLS++SKILLS++SKILLS++SKILLS++SKILLS++SKILLS++SKILLS
function oneHandedWeaponSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'one handed weapon skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function twoHandedWeaponSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'two handed weapon skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function unarmedCombatSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'unarmed combat skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel
	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function daggerSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'dagger skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function chargeSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'charge skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}

function ripslashSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'ripslash'
	skillLevel = skillLevel == 0 ? 1 : skillLevel
	if (player.ripslash.level == 0) {
	}
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
//SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  //

//SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS //
// function fire(spellLevel, npcMaxLearnLevel) {
// 	trainedSpellName = 'fire'
// 	spellLevel = spellLevel == 0 ? 1 : spellLevel

// 	let spellModifier = 1.3 * spellLevel
// 	let spellCost = spellLevel * spellModifier
// 	if (spellLevel == npcMaxLearnLevel) {
// 		return false
// 	} else {
// 		return spellCost
// 	}
// }
// function ice(spellLevel, npcMaxLearnLevel) {
// 	trainedSpellName = 'ice'
// 	spellLevel = spellLevel == 0 ? 1 : spellLevel

// 	let spellModifier = 1.3 * spellLevel
// 	let spellCost = spellLevel * spellModifier
// 	if (spellLevel == npcMaxLearnLevel) {
// 		return false
// 	} else {
// 		return spellCost
// 	}
// }

// function fireFist() {spellLevel}

//////////////////////// AREAS AREAS AREAS AREAS AREAS AREAS AREAS AREAS AREAS

let areaIdGenerator = function () {
	//Not using currently. This creates a unique ID based on coordinates. It's not very good for keeping IDs organized though
	allAreas[0] = allAreas[0] + 1
	return allAreas[0]
}

let allAreas = [0]
function directionRefresher() {
	let directionsArray = Object.values(currentArea.descriptions.zoneExitsBool)
	let compiledDirections = []
	for (let i = 0; i < Object.keys(currentArea.descriptions.zoneExitsBool).length; i++) {
		if (directionsArray[i] == true || directionsArray[i] == 'locked') {
			compiledDirections = `${compiledDirections} ${Object.keys(currentArea.descriptions.zoneExitsBool)[i]}`
		}
	}
	compiledDirections = compiledDirections.slice(1, compiledDirections.length)
	currentArea.descriptions.zoneExits = compiledDirections
}

function repeat(targetNpc) {
	let foundNpc = currentArea.npc.find(npc => npc.name == targetNpc)
	if (foundNpc != undefined && foundNpc.name == targetNpc) {
		foundNpc.speak()
	} else if (currentArea.quests != undefined && currentArea.quests.onEntry != undefined && currentArea.quests.roomDialogue != undefined) {
		currentArea.quests.roomDialogue()
	}
}

function pull(secondCommand) {
	let objectBeingPulled = currentArea.interactables != undefined && currentArea.interactables[secondCommand] != undefined ? currentArea.interactables[secondCommand] : undefined
	if (objectBeingPulled != undefined && objectBeingPulled.activate != undefined) {
		objectBeingPulled.activate()
		return
	} else if (objectBeingPulled != undefined && objectBeingPulled.activate != undefined) {
		quickMessage(`You must specify what you want to pull`)
	} else if (objectBeingPulled != undefined) {
		quickMessage(`You cannot pull the ${objectBeingPulled.names[0]}`)
	} else {
		quickMessage(`You do not see a ${secondCommand} to pull.`)
	}
}

function actionWordFunction(secondCommand) {
	let action = secondCommand
	let interactable = currentArea.interactables[action]
	if (interactable.requirement) {
		for (let requirement in interactable.requirement) {
			if (player[requirement] < interactable.requirement[requirement]) {
				quickMessage(`requirement not met`)
			}
		}
	}
}

let currentRoom
let futureRoom

let olivandra = {
	name: 'Olivandra',
	refName: 'olivandra',
	nameColor: 'purple',
	color: 'mage-color',
	prefix: 'Grand Warlock, ',
	prefixColor: 'mage-color',
	keywords: ['olivandra'],
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand, npc) {
			trainInteraction(secondCommand, npc)
		},
	learn: function (secondCommand) {
		if (player.guild != 'Mage') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Mage `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	questSequence: {
	},
	itemsOffered: [],
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the Guild Halls. The class trainers here have more skills to offer you. As for training, the Graveyard is a great place to level up. Once you feel you've outgrown it, you can explore The Shallows inside the Glade or the Kobold Caves near the lake west of the castle."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office inside the guild once I'm finished meeting with the guild leaders. Check in after you've reached level 10. That should give me enough time. I might have a new task for you after we discuss our next move."`, 'white', line3)
		blankSpace()
		customizeEachWord(`${this.name} `, this.color, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		currentArea.npc.pop()
		currentArea.descriptions.zoneExitsBool.southwest = true
		pushItem.splice(qItemIndex, 1)
		this.questSequence.seventh = true
	},
	speak: async function() {
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
	skillsOffered: [devotion, firePenetration, icePenetration, lightningPenetration, arcaneKnowledge, mysticismMastery, sorceryMastery, spellWeapons, magicDexterity, clearMind],
	skillsMaxLevel: {
		devotion: 10,
		firePenetration: 10,
		icePenetration: 10,
		lightningPenetration: 10,
		arcaneKnowledge: 10,
		mysticismMastery: 10,
		sorceryMastery: 10,
		spellWeapons: 10,
		magicDexterity: 10,
		clearMind: 10,
	},
	spellsOffered: [fireflames, inferno, meteor, frostfreeze, blizzard, cryoclast, flashbolt, chainLightning, gigavolt],
	spellsMaxLevel: {
		fireflames: 2,
		inferno: 2,
		meteor: 2,
		frostfreeze: 2,
		blizzard: 2,
		cryoclast: 2,
		flashbolt: 2,
		chainLightning: 2,
		gigavolt: 2,
	},
	learn: (secondCommand, npc) => {
		learnInteraction(secondCommand, npc)
	},
}
let scylla = {
	name: 'Scylla',
	prefix: 'Archmage of Ice, ',
	refName: 'scylla',
	nameColor: 'dark-blue',
	prefixColor: 'light-blue',
	keywords: ['scylla'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, spellWeapons, magicDexterity, clearMind]
		} else if (player.level < 20) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, icePenetration]

		} else if (player.level < 30) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, icePenetration, mindsEye]

		} else {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, icePenetration, mindsEye]
		}
	},	
	skillsMaxLevel: {
		get mindsEye() {return skillMaxLevel1(player.mindsEye)},
		get devotion() {return skillMaxLevel5(player.devotion)},
		get arcaneKnowledge() {return skillMaxLevel5(player.arcaneKnowledge)},
		get mysticismMastery() {return skillMaxLevel5(player.mysticismMastery)},
		get sorceryMastery() {return skillMaxLevel5(player.sorceryMastery)},
		get icePenetration() {return skillMaxLevel5(player.icePenetration)},
		get magicDexterity() {return skillMaxLevel5(player.magicDexterity)},
		get clearMind() {return skillMaxLevel5(player.clearMind)},
		get spellWeapons() {return skillMaxLevel5(player.spellWeapons)},
	},
	spellsOffered: [frostfreeze, blizzard, cryoclast, barrier, heal],
	spellsMaxLevel: {
		get frostfreeze() {return skillMaxLevel3(player.frostfreeze)},
		get blizzard() {return skillMaxLevel3(player.blizzard)},
		get cryoclast() {return skillMaxLevel3(player.cryoclast)},
		get barrier() {return skillMaxLevel3(player.barrier)},
		get heal() {return skillMaxLevel3(player.heal)},
	},
	itemsOffered: [trainingStaff, apprenticeRobes],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Cryo Mage') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Cryo Mage `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	learn: function (secondCommand) {
		if (player.playerClass.name != 'Cryo Mage') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Cryo Mage `, 'warrior-color', line1)
			customizeEachWord(`in order to study with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	desc: () => quickMessage(`A Warlock with chin length black hair`),
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let gelvander = {
	name: 'Gelvander',
	prefix: 'Archmage of Fire, ',
	refName: 'gelvander',
	nameColor: 'red',
	prefixColor: 'red-orange',
	keywords: ['gelvander'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, spellWeapons, magicDexterity, clearMind]
		} else if (player.level < 20) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, firePenetration]

		} else if (player.level < 30) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, firePenetration, mindsEye]

		} else {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, firePenetration, mindsEye]
		}
	},	
	skillsMaxLevel: {
		get mindsEye() {return skillMaxLevel1(player.mindsEye)},
		get devotion() {return skillMaxLevel5(player.devotion)},
		get arcaneKnowledge() {return skillMaxLevel5(player.arcaneKnowledge)},
		get mysticismMastery() {return skillMaxLevel5(player.mysticismMastery)},
		get sorceryMastery() {return skillMaxLevel5(player.sorceryMastery)},
		get firePenetration() {return skillMaxLevel5(player.firePenetration)},
		get magicDexterity() {return skillMaxLevel5(player.magicDexterity)},
		get clearMind() {return skillMaxLevel5(player.clearMind)},
		get spellWeapons() {return skillMaxLevel5(player.spellWeapons)},
	},
	spellsOffered: [fireflames, inferno, meteor, barrier, heal],
	spellsMaxLevel: {
		get fireflames() {return skillMaxLevel3(player.fireflames)},
		get inferno() {return skillMaxLevel3(player.inferno)},
		get meteor() {return skillMaxLevel3(player.meteor)},
		get barrier() {return skillMaxLevel3(player.barrier)},
		get heal() {return skillMaxLevel3(player.heal)},
	},
	itemsOffered: [trainingStaff, apprenticeRobes],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Pyromancer') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Pyromancer `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	learn: function (secondCommand) {
		if (player.playerClass.name != 'Pyromancer') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Pyromancer `, 'warrior-color', line1)
			customizeEachWord(`in order to study with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	desc: () => quickMessage(`A Warlock with chin length black hair`),
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let blasphemy = {
	name: 'Blasphemy',
	prefix: 'Archmage of Lightning, ',
	refName: 'blasphemy',
	nameColor: 'light-yellow',
	prefixColor: 'yellow',
	keywords: ['blasphemy'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, spellWeapons, magicDexterity, clearMind]
		} else if (player.level < 20) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, lightningPenetration]

		} else if (player.level < 30) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, lightningPenetration, mindsEye]

		} else {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, lightningPenetration, mindsEye]
		}
	},	
	skillsMaxLevel: {
		get mindsEye() {return skillMaxLevel1(player.mindsEye)},
		get devotion() {return skillMaxLevel5(player.devotion)},
		get arcaneKnowledge() {return skillMaxLevel5(player.arcaneKnowledge)},
		get mysticismMastery() {return skillMaxLevel5(player.mysticismMastery)},
		get sorceryMastery() {return skillMaxLevel5(player.sorceryMastery)},
		get lightningPenetration() {return skillMaxLevel5(player.lightningPenetration)},
		get magicDexterity() {return skillMaxLevel5(player.magicDexterity)},
		get clearMind() {return skillMaxLevel5(player.clearMind)},
		get spellWeapons() {return skillMaxLevel5(player.spellWeapons)},
	},
	spellsOffered: [flashbolt, chainLightning, gigavolt, barrier, heal],
	spellsMaxLevel: {
		get flashbolt() {return skillMaxLevel3(player.flashbolt)},
		get chainLightning() {return skillMaxLevel3(player.chainLightning)},
		get gigavolt() {return skillMaxLevel3(player.gigavolt)},
		get barrier() {return skillMaxLevel3(player.barrier)},
		get heal() {return skillMaxLevel3(player.heal)},
	},
	itemsOffered: [trainingStaff, apprenticeRobes],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	learn: function (secondCommand) {
		if (player.playerClass.name != 'Lightning Magus') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Lightning Magus `, 'warrior-color', line1)
			customizeEachWord(`in order to study with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Lightning Magus') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Lightning Magus `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	desc: () => quickMessage(`A Warlock with chin length black hair`),
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}


class AreaMaker {
	constructor(enemySpawnChance, isPlayerHere, npc, hostile, id, x, y, z, gold, descriptions, interactables) {
		this.enemySpawnChance = enemySpawnChance
		this.isPlayerHere = isPlayerHere
		this.npc = npc
		this.hostile = hostile
		this.id = id
		this.x = x
		this.y = y
		this.z = z // z being 0 is normal elevation. -1 would be going down and 1 would be going up
		this.gold = gold
		this.descriptions = descriptions
		this.interactables = interactables
		this.descriptions.zoneExitsFunc()
		allAreas.push(this)
	}
}
// AreaMaker.prototype.onEntry = function() {
// 	quickMessage('enter')
// if (currentArea.enemySpawnChance == 0) {return}
// let spawnChance = currentArea.enemySpawnChance
// let spawnRoll = randomNumberRange(1, 100)
// if (spawnRoll <= spawnChance) {
// 	let monster = currentArea.enemies
// 	if (monster == undefined) {return}
// 	let index = randomNumberRange(0, monster.length - 1)
// 	monsterGen(monster[index])
// }
// }

let galvadiaWelcomeArea = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	0, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area`,
		zoneType: 'galvadia_basement',
		desc: `Welcome to the lands of Galvadia. Here, you will learn the basics of the game. The most basic feature is how to move around. In order to move, just type the direction you want to go such as NORTH or shorthand you can just type N. You can see which directions you can move by check the "Obvious Exits" underneath the room description. For quicker and more advanced movement, you can also use the numpad by using the number corresponding to a direction, e.g., north is 8, northeast is 9, east is 6, etc. When you are ready to move on, head north.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaWelcomeArea2 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	1, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 2`,
		zoneType: 'galvadia_basement',
		desc: `Areas will sometimes have keywords highlighted in them which indicates that there is something of interest to investigate. By EXAMINE-ing a keyword, you can find out more information about it. Investigating keywords can be very useful as they may lead to something important like finding a hidden room or a clue to a quest. Try EXAMINE-ing the wall here by typing EXAMINE wall or EX wall.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['wall'],
	}),
	{
		wall: {
			names: ['wall'],
			color: function () {
				return 'blue'
			},
			desc: async function () {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You take a closer look at the wall and see that there is something written on it.`, 'white', line1)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`The wall reads: `, 'gray', line2)
					customizeEachWord(`"Good job! Now proceed to the north for your next lesson."`, 'white', line2)
					blankSpace()
			},
		},
	}
)
function calculateSupremeDodging() {
	applyBuff(player.supremeDodging.buff)
}
function calculateResilience() {
	applyBuff(player.resilience.buff)
}
function applyOnHitSkillBuffs(weaponObject) {
	if (weaponObject.doesSwingHit) {
		if (player.supremeDodging.level > 0) {calculateSupremeDodging()}
		if (player.resilience.level > 0) {calculateResilience()}
	}
}

function inspectHTML(message, classChange, div, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(classChange)
	line.appendChild(span)
	div.appendChild(line)
	masterArea.appendChild(div)
	updateScroll()
}

function inspectBlip(message, classChange, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(classChange, 'inspect-blip')
	line.appendChild(span)
	masterArea.appendChild(line)
	blankSpace()
	updateScroll()
}

let galvadiaWelcomeArea3 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	2, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 3`,
		zoneType: 'galvadia_basement',
		desc: `To pick up an item, use the GET command. Try GET key or just G key. Once you pick up and item, you can see it in your inventory by using the INVENTORY or I command. Your inventory will show you everything that you own on your person including your equipped gear, gold, and items in your backpack. Once you have picked up the key, head to the north.`,
		// It is essential that you gear yourself properly if you want to survive and slay enemys. Pick up the equipment on the ground by typing 'get sword' or 'g sword' and 'get armor' or 'g armor'. You can also pick up all the items on the ground by typing 'get all' or 'g all'. Once you pick up an item, you can see it in your inventory by typing 'inventory' or 'i'. To equip a piece of armor, you must be wielding it in either hand. To do this, type 'unpack tunic' and then 'wear tunic' ('equip tunic' or 'don tunic' also works). To equip a weapon, you simply need to be wielding it in either hand first. By unpacking your weapon into either hand, you can now swing it at your enemies! However, make sure that you are only wielding one weapon at a time unless you know the dual wielding skill. To put items from your hands into your backpack, type 'pack' or 'p' followed by the item name. You can also type 'p left' or 'p right' to put items away. If you want to remove armor to don something else, type 'remove tunic', unpack the other piece of armor, then equip it. If an item has a similar name as another item, you can type 'unpack' followed by the exact name to unpack that specific item. Once you're comfortable with equipping and unequipping gear, proceed to the north.
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
function capitalizeFirstLetter(string) {
	return string.charAt(0).toUpperCase() + string.slice(1)
}
let galvadiaWelcomeArea4 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	3, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 4`,
		zoneType: 'galvadia_basement',
		desc: `Some rooms will appear to have no obvious exits other than the way you came in. Often, there will be clues that will lead you to discovering a way forward. Here, you see that there is a lever next to the door. Try EXAMINE-ing it to see what you can do with it.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['lever'],
	}),
	{
		lever: {
			names: ['lever'],
			color: function () {
				return 'red'
			},
			desc: async function () {
				let line1 = document.createElement('div')
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You see a conspicuous lever on the wall. Maybe you should try to PULL it.`, 'gray', line1)
				blankSpace()
			},
			activate: async function () {
				if (!currentArea.descriptions.zoneExitsBool.north) {
					let line1 = document.createElement('div')
					let line2 = document.createElement('div')
					let line3 = document.createElement('div')
					player.stasis = true
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You hear a deep rumbling sound as the wall in front of you begins to move.`, 'gray', line1)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord('A way has opened to the north!', 'white', line2)
					blankSpace()
					player.stasis = false
					currentArea.descriptions.zoneExitsBool.north = true
					currentArea.descriptions.zoneExitsFunc()
				} else if (currentArea.descriptions.zoneExitsBool.north == true) {
					let line1 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You pull the lever again. Nothing happens.`, 'white', line1)
				}
			},
		},

	}
)

let galvadiaWelcomeArea5 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	4, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 5`,
		zoneType: 'galvadia_basement',
		desc: `Locked doors are indicated by yellow text which can be unlocked by using the appropriate key. You can use the key you found in the previous room to unlock this door. To do so, type UNLOCK followed by the direction you want to unlock. If you are successful, the door will unlock, and the key will disappear. When you have done this, proceed to the next room.`,
		zoneExitsBool: {
			north: 'locked',
			south: true,
		},
		zoneExitsLocked: {
			north: function () {
				if (galvadiaWelcomeArea5.descriptions.zoneExitsBool.north == 'locked') {
					let line1 = document.createElement('div')
					customizeEachWord(`The way to the north is locked. The lock looks to be pretty simple.`, 'white', line1)
				}
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaWelcomeArea6 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[egbert], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 6`,
		zoneType: 'galvadia_basement',
		desc: `You can speak to people you come across most of whom will have something useful to say or hint at a quest. To do this, type SPEAK followed by the name of the person you wish to talk to.`,
		zoneExitsBool: {
			east: 'blocked',
			south: true,
			west: true,
		},
		east: function () {
			quickMessage(`This way is LOCKED`)
		},
		south: function () {
			quickMessage(`This way is BLOCKED`)
		},
		zoneExitsLocked: {
			east: () => {
				quickMessage(`The door is locked`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

galvadiaWelcomeArea6.quests = {
	quests: {
		complete: false,
	},
}

let galvadiaWelcomeArea7 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 7`,
		zoneType: 'galvadia_basement',
		desc: `You enter into what looks like a scribes office. There are scrolls and papers littered about the room. On the far wall is a desk illuminated by candle light. You see something sticking out from underneath the parchment that's strewn about the desk. Try examining it.`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['parchment'],
	}),
	{
		parchment: {
			names: ['parchment'],
			color: function () {
				return 'dark-gray'
			},
			desc: async function () {
				let line1 = lineFunc()
				await dialogueWait(200)
				blankSpace()
				if (galvadiaWelcomeArea7.quests.glassesComplete == false) {
					customizeEachWord(`Lifting up the parchment, you accidentally knock to the ground what was lying underneath. You look down to see a pair of glasses on the floor.`, 'grey', line1)
					questItemGen(pairOfGlasses())
					galvadiaWelcomeArea7.quests.glassesComplete = true
				} else {
					customizeEachWord(`You look at the scattered parchment and wonder how anyone could function with such a mess.`, 'grey', line1)
				}
				blankSpace()
			},
		},
	}
)

galvadiaWelcomeArea7.quests = {
	glassesComplete: false,
}

let galvadiaWelcomeArea8 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 8`,
		zoneType: 'galvadia_basement',
		desc: `You see a SIGN hanging from the wall.`,
		onEntry: async function() {
			if (egbert.questSequence.second == false) {
				egbert.speak()
			}
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`Egbert's studies to the west`, 'bold', line2)
			customizeEachWord(`Training Dummy Halls to the north`, 'bold', line3)
			blankSpace()
			egbert.questSequence.second = true
		},
		zoneExitsBool: {
			north: 'blocked',
			east: true,
			southeast: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaWelcomeArea9 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	4, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 9`,
		zoneType: 'galvadia_basement',
		desc: `In addition to inspecting people and keywords, you can also inspect items you see on the ground to see if you want to pick it up. Once you've picked it up, you must use the 'examine' command to see its qualities. You can see the item in your inventory with the inventory command, and then examine it by typing "ex" followed by the name of the item. You can also type "ex" followed by any word within the name. For example, you can examine the training jerkin by typing "ex training", "ex jerkin", or "ex training jerkin". If you have items that contain the same word, like training, you might want to use the full name of the item to make sure you're examining the item you want. You can also type "ex" followed by an inventory slot number to examine the item that's in that slot to examine an item in that slot. Typing "ex" followed by "right" or "left" will examine the items that you are holding in either hand. When examining an item by name, the item in your right or left hand will always be chosen over an item by the same name in your backpack.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaWelcomeArea10 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	2, // X
	4, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Equipping Armor`,
		zoneType: 'galvadia_basement',
		desc: `When you pick up a piece of armor that you want to use, you must "equip" it. To do this, you must wield it in either hand by first "unpacking" it, then equip it by typing "equip" followed by the name of the item. Try "unpack jerkin" followed by "equip jerkin". To remove a piece of armor, use the "remove" command followed by the name of the armor you wish to remove. You will need to remove a piece of armor before equipping another piece of armor of the same type.`,
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaWelcomeArea11 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	2, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Wielding Weapons`,
		desc: `To use a weapon, all you need to do is wield it in either hand by "unpacking" it. Once you are holding a weapon in either hand, it is consider wielded. You can only wield one weapon at a time. However, some classes are able to learn the Dual Wield skill at higher levels which allows the use of two weapons simulataneously. Warrior classes are capable of wielding one-handed weapons with a shield or two-handed weapons. Two-handed weapons are wielded in both hands, so they cannot be used alongside a shield, nor can they be dual wielded. Weapons can only be used in combat against hostile enemies. You will learn more about fighting in the combat rooms.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

// let galvadiaWelcomeArea13 = new AreaMaker(
// 	0, //SPAWN RATE
// 	true, //IS PLAYER HERE
// 	[crutches], // NPC
// 	false, // IS HOSTILE
// 	areaIdGenerator(), //ROOM ID
// 	1, // X
// 	6, // Y
// 	-2, // Z
// 	0, //GOLD
// 	(descriptions = {
// 		areaNameClass: yellow,
// 		areaName: `Training Halls Basement Entrance`,
// 		desc: `Above are the combat training rooms. Once you are ready, proceed above. You can come back to these rooms any time.`,
// 		zoneExitsBool: {
// 			north: true,
// 			south: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let galvadiaWelcomeArea14 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	6, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Combat Training Halls: Physical Fighting and Magic Fighting`, //change area name
		zoneType: 'galvadia_basement',
		desc: `You find yourself in the well worn halls of the Combat Training Halls. Countless adventurer's have made their way through these halls. The stone floors are worn smooth from use. The walls are decorated with nicks and scratches. 
		EAST: Magic Combat
		WEST: Physical Combat`,
		zoneExitsBool: {
			north: 'blocked',
			east: true,
			south: true,
			west: true,
		},
		onEntry: function() {
			if (egbert.questSequence.fourth == false) {
				egbert.speak()
			}
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
// let galvadiaWelcomeArea15 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	1, //change x coord
// 	8, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Training Dummy Training Halls`, //change area name
// 		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
// 		zoneExitsBool: {
// 			north: true,
// 			east: true,
// 			south: true,
// 			west: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let galvadiaWelcomeArea16 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	7, //change y coord
	-2,
	0,
	(descriptions = {
		questSequence: {
			first: false
		},
		onEntry: function() {
			if (this.questSequence.first == false) {
				this.questSequence.first = true
				monsterGen(woundedGoblinScout(currentArea))
			}
		},
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
		zoneExitsBool: {
			north: 'blocked',
			south: true,
		},
		zoneChange: {
			up: function () {
				player.x = -7
				player.y = 3
				player.z = 0
			},
		},
		zoneExitsLocked: {
			up: () => {
				quickMessage(`You must first slay the Goblin Scout!`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let th_b_center_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	8, //change y coord
	-2,
	0,
	(descriptions = {
		onEntry: function() {
			player.dialogueStasis = true
			if (egbert.questSequence.ninth == false) {
				egbert.speak()
				return
			}
			if (egbert.questSequence.tenth == true && egbert.questSequence.eleventh == false) {
				egbert.speak()
				return
			}
			player.dialogueStasis = false
		},
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
		zoneExitsBool: {
			north: 'locked',
			east: true,
			south: true,
			west: true,
		},
		zoneExitsLocked: {
			north: () => {
				quickMessage(`The door won't budge.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let th_b_center_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	9, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
		zoneExitsBool: {
			south: true,
			up: true,
		},
		zoneChange: {
			up: function () {
				player.x = -7
				player.y = 3
				player.z = 0
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let th_b_w_wing_1 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	0, //change x coord
	8, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let th_b_w_wing_2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-1, //change x coord
	9, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. There is a lever here.`,
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
			actionWord: ['lever'],
	}),
	{
	lever: {
		names: ['lever'],
		pulled: false,
		color: function () {
			return 'red'
		},
		desc: function () {
			let line1 = document.createElement('div')
			customizeEachWord(`You see a large lever sticking out of the wall.`, 'white', line1)
		},
		activate: async function () {
			if (th_b_w_wing_2.interactables.lever.pulled == false) {
				th_b_w_wing_2.interactables.lever.pulled = true
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You hear the distant sound of a latch flipping open.`, 'grey', line1)
				blankSpace()
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You hear the light clinking of gold coins bouncing to the ground.`, 'grey', line2)
				currentArea.gold = randomNumberRange(5, 8)
				blankSpace()
				if (th_b_w_wing_2.interactables.lever.pulled == true && th_b_e_wing_2.interactables.lever.pulled == true) {
					th_b_center_1.descriptions.zoneExitsBool.north = true
					egbert.questSequence.tenth = true
				}
			} else if (th_b_w_wing_2.interactables.lever.pulled == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`You pull the lever again. Nothing happens.`, 'gray', line1)
			}
		},
	},
}
)

let th_b_e_wing_1 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	2, //change x coord
	8, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let th_b_e_wing_2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	3, //change x coord
	9, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Dummy Training Halls`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. There is a lever here. `,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
			actionWord: ['lever'],
	}),
	{
		lever: {
			names: ['lever'],
			pulled: false,
			color: function () {
				return 'red'
			},
			desc: function () {
				let line1 = document.createElement('div')
				customizeEachWord(`You see a large lever sticking out of the wall.`, 'white', line1)
			},
			activate: async function () {
				if (th_b_e_wing_2.interactables.lever.pulled == false) {
					th_b_e_wing_2.interactables.lever.pulled = true
					let line1 = document.createElement('div')
					let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You hear the distant sound of a latch flipping open`, ['italic', 'grey'], line1)
					blankSpace()
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You hear the light clinking of gold coins bouncing to the ground.`, 'grey', line2)
					currentArea.gold = randomNumberRange(5, 8)
					blankSpace()
					if (th_b_e_wing_2.interactables.lever.pulled == true && th_b_w_wing_2.interactables.lever.pulled == true) {
						th_b_center_1.descriptions.zoneExitsBool.north = true
						egbert.questSequence.tenth = true
					}
				} else if (th_b_e_wing_2.interactables.lever.pulled == true) {
					let line1 = document.createElement('div')
					customizeEachWord(`You pull the lever again. Nothing happens.`, 'white', line1)
				}
			},
		},
	}
)


let galvadiaWelcomeArea17 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	10, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Tutorial End Room`, //change area name
		zoneType: 'galvadia_basement',
		desc: ``,
		zoneExitsBool: {
			up: 'blocked',
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaWelcomeArea17_combatRoom1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	0, //change x coord
	6, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Combat Training Room`, //change area name
		zoneType: 'galvadia_basement',
		desc: `ATTACKING - To initiate melee combat with a enemy, use the 'ADVANCE' or 'AD' command. Once engaged, you cannot move directions until you retreat or slay the enemy. However, if you are using a ranged weapon, you can attack the enemy from afar without engaging it. To perform an attack, use the 'ATTACK' or 'A' command. After an attack is performed, you will not be able to move, retreat, or perform another attack for a short time, so be careful when attacking an enemy as it might be able to strike you during this time. 
		 RETREATING - To disengage from your enemy, use the 'RETREAT' or 'RE' command. Like combat actions, you cannot perform another action after retreating for a short time. Even so, retreating is a very useful tactic when fightning enemies as you will be able to mitigate a lot of damage by retreating before the enemy hits you. However, this will not be viable against ranged or magic foes as they can hit you without being engaged. Higher level enemies also have quicker attack speeds, so you won't be able to dodge as many attacks this way at higher levels.`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['ATTACKING', 'RETREATING', 'melee'],
	}),
	{
		attacking: {
			names: ['ATTACKING'],
			color: function () {
				return 'yellow'
			},
		},
		melee: {
			names: ['melee'],
			desc: function() {
				quickMessage(`You just inspected melee`)
			},
			color: function () {
				return 'yellow'
			},
		},
		retreating: {
			names: ['RETREATING'],
			color: function () {
				return 'yellow'
			},
		},
	}
)

let galvadiaWelcomeArea18_combatRoom2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	2, //change x coord
	6, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Enemy Behavior`, //change area name
		zoneType: 'galvadia_basement',
		desc: `Enemies only have a chance to spawn when you enter a new area in hostile zones. There are no indicators of a hostile zone, so you have to be careful when exploring unchartered areas. Enemies will also follow you, but most only follow you within a couple areas, though, certain enemies can track you from very far away, but can only move one area at a time. Hostile areas are also the only areas that enemies can move in, so you can always escape to safety by running out of the hostile area. Each enemy type has its own set movement speed and attack/casting speed, so learning these patterns will help you gain a better understanding of how to fight them.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
// let galvadiaWelcomeArea19_combatRoom3 = new AreaMaker(
// 	5,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	0, //change x coord
// 	8, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Combat Room 3`,
// 		desc: `Combat Room 3`,
// 		zoneExitsBool: {
// 			east: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )

// let galvadiaWelcomeArea20_combatRoom4 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	2, //change x coord
// 	8, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Combat Room 4`, //change area name
// 		desc: `Combat Room 4`,
// 		zoneExitsBool: {
// 			west: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )

let centralBeginnersRoom = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-7, // X
	2, // Y
	-1, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Hall`,
		desc: `This is the central training room for warrior prospects.`,
		zoneExitsBool: {
			north: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

centralBeginnersRoom.quests = {
	startComplete: false,
	seComplete: false,
	sComplete: false,
	swComplete: false,
	wComplete: false,
	nwComplete: false,
	nComplete: false,
	neComplete: false,
	eComplete: false,
	onEntry: function () {
		if (previousArea.x == -7 && previousArea.y == 2 && previousArea.z == 0 && this.startComplete == false) {
			gameDialogue(`Welcome to the training halls. Here, you will train how to perform basic actions. Once you have completed each task, you will be prompted onward.`)
			gameDialogue(`Directions that are red indicate a locked door, or in other circumstances, may require a special item to unlock.`)
			gameDialogue(`For your first task, pick up the key from the ground and unlock the door to the north.`)
			gameDialogue(`To pick up something from the ground, use the GET command. Try "get key" or "g key", and then "unlock north" or "unlock n".`)
			startComplete = true
		}
		if (previousArea.x == -8 && previousArea.y == 3 && previousArea.z == -1 && this.seComplete == false) {
			this.seComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.north = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head north for your next task.`)
		}
		if (previousArea.id == 3 && this.sComplete == false) {
			this.sComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.northeast = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head northeast for your next task.`)
		}
		if (previousArea.id == 4 && this.swComplete == false) {
			this.swComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.east = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head east for your next task.`)
		}
		if (previousArea.id == 5 && this.wComplete == false) {
			this.wComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.southeast = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head southeast for your next task.`)
		}
		if (previousArea.id == 6 && this.nwComplete == false) {
			this.nwComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.south = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head south for your next task.`)
		}
		if (previousArea.id == 7 && this.nComplete == false) {
			this.nComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.southwest = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head southwest for your next task.`)
		}
		if (previousArea.id == 8 && this.neComplete == false) {
			this.neComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.west = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head west for your next task.`)
		}
		if (previousArea.id == 9 && this.eComplete == false) {
			this.eComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.up = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head UP the stairs for your next task.`)
		}
	},
}

centralBeginnersRoom.roomDialogue = `To move, type the direction you wish to go. You can check the available directions you can move by looking at the room's "Obvious Exits". If your view gets too cluttered, you can refresh your view of the room by using the LOOK command (or just 'L'). Once you are ready, travel to the NORTHWEST for your next task.`

let grassfields_entrance = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance To The Festival Grounds`,
		desc: `As you stand in front of your home, you find yourself on a well-traveled road that winds its way to the north and south. The road is made of smooth, worn down cobblestone from the countless passage of castlefolk. Rows of houses line the streets, smoke curling from their chimneys. To the west, the main road leads directly to the castle gates. Before the castle, you see the colorful jumble of stalls and tents of the marketplace. A large grassy field sprawls for acres across from the busy market.`,
		zoneExitsBool: {
			west: true,
			east: true,
		},
		north: () => gameDialogue(`This will take you farther into the residential district. For now, you need to keep heading west to the Castle Training Halls.`),
		south: () => gameDialogue(`This will take you farther into the residential district. For now, you need to keep heading west to the Castle Training Halls.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let crossroads_shops_and_fields = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Training Fields Central`,
		zoneType: 'galvadia_training_fields',
		desc: `You stand in a large, open area surrounded by yellow fields. Numerous trainers are here instructing and keeping close eye on those in the fields. Some prospects sit here, resting before going back in; others look nervous.`,
		zoneExitsBool: {
			north: true,
			east: 'blocked',
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mud_elemental_field = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	3, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance to the Market`,
		zoneType: 'galvadia_training_fields',
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
mud_elemental_field.onEntry = function() {
	let doAnyExist = pushMonster.some(monster => monster.refName == 'lesserMudElemental' || monster.refName == 'lesserWaterElemental' || monster.refName == 'lesserGrassElemental')
	if (!bossTimeouts.lesserMudElemental && !doAnyExist) {
		monsterGen(lesserMudElemental(currentArea))
		monsterGen(lesserWaterElemental(currentArea))
		monsterGen(lesserGrassElemental(currentArea))
		bossTimeouts.lesserMudElemental = setTimeout(() => {
			delete bossTimeouts.lesserMudElemental
		}, 600000)
	}
}
let marketplace_bazaar = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	2, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance to the Market`,
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			east: true,
		},
		north: () => gameDialogue(`You'll want to explore the fields later, but for now you need to get to the castle`),
		south: () => gameDialogue(`The marketplace is currently closed. Check back later.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let marketplace_bazaar3 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	2, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance to the Market`,
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		north: () => gameDialogue(`You'll want to explore the fields later, but for now you need to get to the castle`),
		south: () => gameDialogue(`The marketplace is currently closed. Check back later.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let marketplace_bazaar_south_exit = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	1, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Market South Exit`,
		desc: `Market South Exit`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let marketplace_bazaar_4 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	2, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `East Market`,
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			west: true,
		},
		north: () => gameDialogue(`You'll want to explore the fields later, but for now you need to get to the castle`),
		south: () => gameDialogue(`The marketplace is currently closed. Check back later.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let fieldsEntrance = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	5, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Entrance To The Training Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `The wide path into the fields is blotted with water and mud. A few people can be seen hiding just around the corner that leads farther into the fields.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields1 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	6, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `By The Castle Moat In The Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `By The Castle Moat In The Fields`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

function spawnMonsterOnEntry(enemyArray) {
	// Define an array of possible monsters with their spawn probabilities
	const enemies = enemyArray
  
	// Generate a random number between 1 and 100
	let randomNumber = randomNumberRange(1, 100);
  
	// Initialize a variable to keep track of the cumulative probability
	let cumulativeProbability = 0;
  
	// Iterate through the monsters and check their spawn probabilities
	for (const entry of enemies) {
		console.log(entry, ' ENTRY')
	  cumulativeProbability += entry.probability;
	  if (randomNumber <= cumulativeProbability) {
		let enemyExtracted = entry.enemy
		monsterGen(enemyExtracted(currentArea));
		return; // Exit the loop and function after spawning a monster
	  }
	}
  
	// If no monster has been spawned, you can add an action here
	// For example, a message indicating no monsters spawned.
  }


let fields2 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	6, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Entering Into the Large Expanse Of The Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `The fields stretch out before you in all directions. To the west, the field borders the castle moat as it extends to the north. To the east, the fields are ushered northward by the shallow cliffside.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields3 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	6, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `In The Fields By The Cliffside`,
		zoneType: 'galvadia_training_fields',
		desc: `The forest that extends to the edge of the cliff casts shadows on the field along the eastern edge.`,
		zoneExitsBool: {
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let fields4 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	7, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Along The Castle Moat`,
		zoneType: 'galvadia_training_fields',
		desc: `As you continue through the field, the sun shows no signs of letting up.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let fields5 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	7, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Amidst A Small Glade In The Middle Of The Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `As you step farther into the field, you cross into a small glade of sorts. A tree in the middle provides shade for anyone in need of a rest. Flowers cover the ground here, as it's the only area around that's not too overgrown to blossom. You see something shiny next to the tree among the roots.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['shiny'],
	}),
	{
		shiny: {
			names: ['shiny'],
			color: function() {
				return 'green'
			},
			desc: async function() {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You take a closer look at the object and see that it's a coin wedged into the roots. You reach down and pry the coin from the roots.`, 'grey', line1)
					questItemGen(luckyCoin())
					blankSpace()
			},
		}
	}
)
let fields6 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	7, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Exploring the Hills and Slops of the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `The field gives way to a gentle slope, leading to a breathtaking view of the distant mountains. Their majestic peaks pierce the sky, cloaked in a shroud of mist. The crisp mountain air carries with it a sense of adventure and possibility.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields7 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	8, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Nestled Grove`,
		zoneType: 'galvadia_training_fields',
		desc: `As you explore the field, you come across a hidden grove nestled among the tall grass. The trees here are lush and verdant, their branches intertwined to form a natural canopy. Sunlight filters through the foliage, casting dappled shadows on the ground below.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields8 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[lessa], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	8, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Roaming Through a Patch of Mushrooms`,
		zoneType: 'galvadia_training_fields',
		desc: `In the heart of the field, you stumble upon a patch of wild mushrooms of various shapes and colors. Some glow softly, emitting an otherworldly luminescence. The air is thick with an earthy scent, hinting at the mystical properties these mushrooms possess.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields9 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[till], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	8, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields1 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	5, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields2 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	5, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields3 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields4 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[sylas], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields5 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	3, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields6 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	3, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let underFields1 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	9, // Y
	-1, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Fields Room 11`,
		desc: `Fields Room 11`,
		zoneExitsBool: {
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

fields1.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 33}, {enemy: waterling, probability: 33}, {enemy: grassling, probability: 34}])}
fields2.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields3.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields4.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields5.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields6.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields7.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields8.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields9.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}

lette_fields1.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields2.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields3.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields4.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields5.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields6.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}






function enemyGoldDrops(goldObject) {
	const keys = Object.keys(goldObject);
	const randomKey = keys[randomNumberRange(0, keys.length - 1)]
	const randomValue = goldObject[randomKey];
	console.log(keys)
	console.log(randomKey)
	console.log(randomValue)
	return randomValue
}

function enemyItemDrops(itemDrops, probability, enemy) {
	for (let i = 0; i < itemDrops.length; i++) {
		if (probability[i] >= randomNumberRange(1, 100)) {
			enemy.itemDrops.push(itemDrops[i]())
		}
	}
}

let just_outside_the_castle_east = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Just Outside The East Castle Gates`,
		zoneType: 'galvadia_training_fields',
		desc: `This road leads directly to the Training Fields.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

function lineFunc(addClass) {
	const classOrClassArray = addClass
	let line = document.createElement('div')
	if (Array.isArray(classOrClassArray)) {
		classOrClassArray.forEach(classToAdd => line.classList.add(classToAdd))
	} else {
		line.classList.add(classOrClassArray)
	}
	return line
}
function gameLine(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent', 'game-dialogue', optionalClass)
	return line
}
function paragraphFunc(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent', optionalClass)
	return line
}
function inspectLine(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent', optionalClass)
	return line
}
function indentLine(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent')
	return line
}

function line() {
	let line1 = document.createElement('div')
	return line1
}

// async function delayedDialogue(arr) {

// 	let delayTime = 1000;

// 	customizeEachWord(`${arr[0]}`);
// 	await wait(delayTime);

// 	console.log("Velthash says, 'Good morning! It's a fine day today, isn't it?'");
// 	await wait(delayTime);

// 	console.log("Without another word, Velthash goes over to the castle gate to unlock the door.");
// 	await wait(delayTime);

// 	console.log("Velthash says, 'Have a good rest of your day!'");
//   }

//   function wait(ms) {
// 	return new Promise(resolve => setTimeout(resolve, ms));
//   }

let zalbane = {
	x: -10,
	y: -10,
	z: 0,
	name: 'Zalbane',
	refName: 'zalbane',
	nameColor: 'zalbane-name',
	prefix: 'Lord of War, ',
	prefixColor: 'zalbane-title',
	keywords: ['zalbane'],
	occupation: `Guild Master of the Warrior's Guild`,
	race: `Human`,
	description: `Guild Master Warrior`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`Threx `, this.nameColor, line1)
			customizeEachWord(`looks you over`, 'white', line1)
			blankSpace()
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`Threx: `, this.nameColor, line1)
			customizeEachWord(`Do you think you have what it takes to be a Warrior?`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(250)
			blankSpace()
			customizeEachWord(`Threx: `, this.nameColor, line1)
			customizeEachWord(`Come back with proof that you've slain a kobold, then I'll know that you're serious`, this.prefixColor, line1)
			blankSpace()
		} else {
			await dialogueWait(250)
			blankSpace()
			blankSpace()
		}
	},
	questSequence: {
		first: false,
	},
	questItem: 'kobold skull',
	quest: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Drats! I'm all out of Mudballs. I can't cook any more Mudpies without Mudballs. All I need is one Mudball to get me through the day.`, this.suffixColor, line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace()
		}
	},
	offer: async function() {
		let questItem = pushItem.find(item => (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand') && item.keywords.some(keyword => keyword == this.questItem))
		let questItemIndex = pushItem.indexOf(questItem)
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first && questItem) {
		} 
	},
}
let vezzlethrax = {
	name: 'Vezzlethrax',
	refName: 'vezzlethrax',
	prefix: "Night's Venom, ",
	nameColor: 'vezzlethrax-name',
	prefixColor: 'dark-green',
	keywords: ['vezzlethrax'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)

	},
	train: function (secondCommand, npc) {
		if (player.className.name != 'Thief') {
				let line1 = lineFunc()
				customizeEachWord(`You must be a member of the `, 'white', line1)
				customizeEachWord(`Sinistral's Guild`, 'sinistral-color', line1)
				customizeEachWord(`in order to train with `, 'white', line1)
				customizeEachWord(`${this.name}`, this.nameColor, line1)
				return
			}
			trainInteraction(secondCommand, npc)
		},
		get skillsOffered() {
			if (player.level < 10) {
				return [venomBlade, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance]
			} else if (player.level < 20) {
				return [venomBlade, contagion, bane, smokeBomb, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance, vigor, precision, multipleStrikes, poison]
			} else if (player.level < 30) {
				return [venomBlade, contagion, bane, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, poison]
			} else {
				return [venomBlade, contagion, bane, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, poison]
			}
		},
		skillsMaxLevel: {
			get venomBlade() {return skillMaxLevel2(player.venomBlade)},
			get contagion() {return skillMaxLevel2(player.contagion)},
			get bane() {return skillMaxLevel2(player.bane)},
			get smokeBomb() {return skillMaxLevel5(player.smokeBomb)},
			get daggers() {return weaponSkillMaxLevel(player.daggers)},
			get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
			get stealth() {return skillMaxLevel5(player.stealth)},
			get dodging() {return skillMaxLevel5(player.dodging)},
			get dodgeStrike() {return skillMaxLevel3(player.dodgeStrike)},
			get supremeDodging() {return skillMaxLevel5(player.supremeDodging)},
			get backstabbing() {return skillMaxLevel5(player.backstabbing)},
			get fleetFooted() {return skillMaxLevel5(player.fleetFooted)},
			get vigilance() {return skillMaxLevel5(player.vigilance)},
			get vigor() {return skillMaxLevel3(player.vigor)},
			get warcraft() {return skillMaxLevel3(player.warcraft)},
			get precision() {return skillMaxLevel3(player.precision)},
			get multipleStrikes() {return skillMaxLevel3(player.multipleStrikes)},
			get poison() {return skillMaxLevel5(player.poison)},
		},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
	desc: () => quickMessage(`Velthash towers over you, but his kind demeanor is calming yet intimidating. He's clad in full plate armor except for his helmet which he holds at his hip.`),
	speak: async function() {
	},
}

let castle_gates_east = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-4, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `East Castle Gates`,
		zoneType: 'galvadia_training_fields',
		desc: `The Eastern Gates are less guarded because of the frequent flow of class trainers and teachers taking their pupils to the Training Fields. The guards here are much more relaxed here.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		west: () => gameDialogue(`There is a large guard blocking your way to the west. Perhaps you should speak to him.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_gates_e_inside = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-5, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Just Inside The East Castle Gates`,
		zoneType: 'galvadia_training_fields',
		desc: `You stand in a small courtyard just inside the gates.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let back_training_halls_entrance = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-6, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Halls Back Foyer`,
		zoneType: 'galvadia_training_halls_common_room',
		desc: `The door of the back foyer is propped open due to the frequent flow of prospects to and from the Training Fields. Through the doorway past the castle gates, you see groups of them of all different classes entering and exiting the fields.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsCommonRoom = new AreaMaker( //change name
	0,
	true,
	[allSkillsMan, allAbilitiesMan],
	false,
	areaIdGenerator(),
	-7, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		onEntry: function() {
			if (egbert.questSequence.twelth == false) {
				egbert.speak()
			}
		},
		areaNameClass: 'training-halls',
		areaName: `Training Hall Common Room`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `You find yourself in the large, crowded common area of the Training Halls. The room is full of students preparing for tests and others taking a break from their training. You hear sounds of clashing metal and magic casting beyond the door to the north. Standing near the door is the Training Commander in charge of directing the students. `, //`CENTRAL TRAINING ROOM - new recruits practicing their stances and strikes. A burly guard stands at the western door`, //change area desc
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExitsLocked: {
			west: () => gameDialogue(`You can't go here until you finish your preliminary training`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsBasementEntrance = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Hall Basement Entrance`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `The design of this room is perfect for relaxation. On the left and right of the room are sauna stalls while the rest of the room has cusioned benches and day beds for those in need of a quick rest.`,
		zoneExitsBool: {
			north: true,
			down: true,
		},
		zoneChange: {
			down: function () {
				player.x = 1
				player.y = 9
				player.z = -2
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsOutside = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Training Halls Outside`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls. There is a sign here.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`Granery to the east`, 'bold', line2)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
// let castle_courtyard_granery_path_2 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	-10, //change x coord
// 	1, //change y coord
// 	0,
// 	0,
// 	(descriptions = {
// 		areaNameClass: 'courtyardGreen',
// 		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
// 		desc: `Approaching the Training Halls.`,
// 		zoneExitsBool: {
// 			east: true,
// 			west: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let castle_courtyard_granery_path_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_courtyard_granery_path_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-6, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			northeast: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-5, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_building = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-5, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_mill = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-5, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			west: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyardNearMonksGuild = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing the Monk's Guild`, //change area name
		desc: `Nearing the Monk's Guild. There is a large SIGN here`,
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`Galvadia Castle - Northwest`, 'bold', line2)
			customizeEachWord(`Training Halls - Northeast`, 'bold', line3)
			customizeEachWord(`Galvadia Square - South`, 'bold', line4)
			blankSpace()
		},
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castleGateway = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Castle Gateway`, //change area name
		desc: `Standing between the castle walls just past the moat bridge.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleMoat = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'bridge',
		areaName: `North Castle Crossroads In Front Of The Castle Moat Bridge`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `Two guards stand at the entrance to the moat bridge, inspecting people as they pass.
		There is a sign here.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
			southwest: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`North: Castle`, 'white', line2)
			customizeEachWord(`Southeast: Glade of Galvadia`, 'white', line3)
			customizeEachWord(`Southwest: Galvadian Fields`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let junction_castle_town_fields = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'bridge',
		areaName: `West Castle Crossroads`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `This is the start of the path that leads away fraom both the castle and town. It follows the castle moat to the west, and extends beyond it far into the distance well into the Galvadian Fields.
		There is a sign here.`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
			west: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`Northeast: Castle`, 'white', line2)
			customizeEachWord(`Southeast: Town Square`, 'white', line3)
			customizeEachWord(`West: Galvadian Fields`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let toGalvadiaFields1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Start Of The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `The sounds of town are faint. You can just see the tips of buildings and blacksmith smoke above the trees in the distance to the east. The west continues along the castle moat bank.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Passing The Southwest Bend Of The Moat`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `Rounding the southwest bend of the moat, you pass by a few travelling carts and patrol guards. A few children playing by the moat are being scolded by guards for being to close to the water.`,
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing On The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `On the south side of the path, the trees are getting denser as they extend to the west. Far to the north, you can make out the outer castle bailey. `,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing On The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `As there is not much on the path, you focus your eyes on the distance. Garrisons and guard towers line the road after it splits north. Carts bringing supplies to the castle are inspected before they pass through.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing On The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `You can barely make out the Castle Crossroads to the east. The forest south of the path gets denser as you travel west. The rough terrain makes it impossible to enter the woods. The entrance must be far on the other side.`,
		zoneExitsBool: {
			east: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-17, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Approaching The Western Road Junction`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: ``,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Western Road South Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `The guard presence at the junction is a little stronger than on other parts of the road.`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		sign: function () {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			customizeEachWord(`North - West Castle Gates`, ['white', 'bold'], line1)
			customizeEachWord(`West - Galvadia Fields, town`, ['white', 'bold'], line2)
			customizeEachWord(`East - South Castle Gates, town`, ['white', 'bold'], line3)
		},
	})
)
let toGalvadiaFields8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields10 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-21, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			west: true,
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-22, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-24, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-26, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			west: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-28, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-29, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-30, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_10 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-29, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_11 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-29, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_12 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-28, // x coord
	2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_13 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	3, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	4, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	5, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	6, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-26, // x coord
	7, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-24, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-22, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-21, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_14 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-26, // x coord
	3, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_15 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	3, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_16 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_17 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_18 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-24, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			west: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_19 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_20 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-22, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCaveEntrance = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Entrance to the Kobold Caves`, //change area name
		desc: `You stand in front of a large cave mouth. Animal skulls litter the ground with some decoratively strung up across the entrance and other still fresh heads stuck on pikes. The area is quiet with no animals in sight - you can only imagine why. You hear the occasional, crazed yelping coming from within the caves.`,
		zoneType: "galvadia_fields_main",
		zoneExitsBool: {
			east: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom1 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Dark Damp Cave`, //change area name
		desc: `A steep slope extends upward toward the mouth of the cave. Tunnels wind in several directions. Through dimly lit torch light, you can see that the northern and southern tunnels curve around. To the west, you hear much more loudly the yips and yelps of kobolds. To the east is quiet, and seemingly less active.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Through A Narrow Passage`, //change area name
		desc: `You can see a spotlight of sunshine to the south that illuminates the ground. The north tunnel extends farther into the caves.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom3 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn in the Caves`, //change area name
		desc: `Crumbled stone litters the area. It's hard to gain footing with all the rubble under your feet. Torches are dotted around the walls at least making it easier to see. Large chunks of colored stone jut out from the walls in what looks like a copper vein.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		actionWord: ['copper', 'vein'],
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		copper: {
			names: ['copper'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					quickMessage(`vein reset`)
					this.empty = false
				}, 10000) //10 second respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!koboldCavesRoom3.interactables.copper.empty) {
					customizeEachWord(`A copper vein that looks like it could be mined with a pickaxe`, 'white', line1)
				} else {
					customizeEachWord(`This copper vein is empty`, 'white', line1)
				}
			},
			color: function() {
				if (koboldCavesRoom3.interactables.copper.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
		vein: {
			names: ['vein'],
			desc: function() {
				let line1 = lineFunc()
				if (!koboldCavesRoom3.interactables.copper.empty) {
					customizeEachWord(`A copper vein that looks like it could be mined with a pickaxe`, 'white', line1)
				} else {
					customizeEachWord(`This copper vein is empty`, 'white', line1)
				}
			},
			color: function() {
				if (koboldCavesRoom3.interactables.copper.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		}
	}
)
let koboldCavesRoom4 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn In The Caves`, //change area name
		desc: `Winding through the turn, you see light coming from the southeast. More crumbled stone starts to crunch under your feet.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom5 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Through The Cave Tunnels`, //change area name
		desc: `You see dim light to the east and west, but you can barely see anything in front of you.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom6 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn In The Caves`, //change area name
		desc: `Little Kobold torches line the walls here and to the southwest. They must have a reason for wanting to see better here at this part of the tunnels.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom7 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Winding Through The Tunnels`, //change area name
		desc: `Boulders, rocks, and dirt have been pushed and piled in such a way as to make way for traffic. Footprints show in the thick dust on the floor`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom8 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Heading Down The Narrow Tunnels`, //change area name
		desc: `The tunnel has been cleared of rocks and dirt. Slender planks have been braced against the walls and ceiling to keep the roof from creating a cave-in.  A glowing moss that emits enough light to see grows along the
		walls.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom9 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Branch In The Tunnels`, //change area name
		desc: `There is extra light coming from the east. You can also hear clatterings and excited yips coming from that direction. To the south, the dark tunnels continue.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom10 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Travelling Through The Narrow Tunnels`, //change area name
		desc: `Faint light can be seen illuminating the turn to the south. With what light there is in this room, you can see little footsteps making their way to the north and curving around to the east.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom11 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	-3, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn In The Tunnels`, //change area name
		desc: `The walls have been recently reinforced with old wood and other stolen materials from nearby buildings above ground. You can smell the mildew emitting from the materials.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom12 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	-4, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Winding Through The Tunnels`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom13 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	-4, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom14 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-4, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom15 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-3, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom16 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom17 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Heading Down A Well Worn Tunnel`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom18 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'blue',
		areaName: `At A Pond In The Middle Of A Large Room`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom19 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On A Lit Path Through The Tunnels`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom20 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom21 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Living Area`, //change area name
		desc: `The walls come closer together only allowing a couple to pass through at a time. The walls have been scraped and scratched by equipment being dragged through the hallway. Small bits of fabric, fur, arrowheads, and other items can be seen scattered along the passageway.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom22 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Dwelling`, //change area name
		desc: `Carved into the wall is a large enclave for a Kobold Family. Scraggled animal pelts have been stacked up for what look to be beds. Skinned rat carcassed hang from the ceiling. Makeshift weapons and armor are stacked to one side.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['pelts'],
	}),
	{
		pelts: {
			names: ['pelts'],
			questSequence: {
				first: false
			},
			color: function() {
				let obstacle = 6
				if (player.perception.check(obstacle) && !koboldCavesRoom22.interactables.pelts.questSequence.first) {
					return 'green'
				} else {
					return 'white'
				}
			},
			desc: async function() {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let obstacle = 6
				if (player.perception.check(obstacle) && !this.questSequence.first) {
					this.questSequence.first = true
					let item
					if (player.playerClass.name == 'Berserker') {item = boneTippedSpear}
					if (player.playerClass.name == 'Fighter') {item = rustySword}
					if (player.playerClass.name == 'Knight') {item = rustySword}
					if (player.guild == 'Sinistral') {item = boneDagger}
					if (player.guild == 'Monk') {item = leatherGrips}
					if (player.guild == 'Ranger') {item = crudelyCarvedBow}
					if (player.guild == 'Mage') {item = woodenStaff}
					weaponGen(item(currentArea))
					console.log(item)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You see something sticking out from beneath the pelts. Upon closer inspection, it looks to be some type of weapon. Despite not wanting to touch the smelly kobold pelts, you lift them up to pull out what was underneath.`, 'white', line1)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You find a `, 'white', line2)
					customizeEachWord(`${item().name} `, item().color, line2)
					customizeEachWord(`beneath the pelts`, 'white', line2)
					blankSpace()
				} else {
					blankSpace()
					customizeEachWord(`You see a messy stack of Kobold Pelts stacked up`, 'white', line1)
					blankSpace()
				}
			}
		}
	}
)
let koboldCavesRoom23 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Dwelling`, //change area name
		desc: `A lit fire is at the center of this enclave. Critter bones lay strewn about near the fire.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['bones'],
	}),
	{
		bones: {
			names: ['bones'],
			questSequence: {
				first: false
			},
			color: function() {
				let obstacle = 6
				if (player.perception.check(obstacle) && !koboldCavesRoom23.interactables.bones.questSequence.first) {
					return 'green'
				} else {
					return 'white'
				}
			},
			desc: async function() {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let obstacle = 6
				if (player.perception.check(obstacle) && !this.questSequence.first) {
					this.questSequence.first = true
					questItemGen(ratHide())
					questItemGen(ratTail())
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`Among the litter of bones you spot something that you could make use of`, 'white', line1)
					blankSpace()
					await dialogueWait(200)
					customizeEachWord(`You find a `, 'white', line2)
					customizeEachWord(`${ratHide().name} `, ratHide().color, line2)
					customizeEachWord(`laying on the ground`, 'white', line2)
					blankSpace()
				} else {
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You see critter bones all over the place`, 'white', line1)
					blankSpace()
				}
			}
		}
	}
)
let koboldCavesRoom24 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Living Area`, //change area name
		desc: `Well worn stone has been smoothed out from the many years of use.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom25 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Dwelling`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom26 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom27 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-21, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom28 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-20, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northwest: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room1 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-20, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At The Bottom Of Uneven Stone Stairs`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-21, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At The Bottom Of Uneven Stone Stairs`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room3 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At The Bottom Of Uneven Stone Stairs`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room4 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, // x coord
	-1, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Overlooking A Steep Dropoff`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room5 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At The Bottom Of Uneven Stone Stairs`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room6 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-1, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At The Bottom Of Uneven Stone Stairs`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room7 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	0, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Chief Chambers`, //change area name
		desc: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
		zoneType: "kobold_cave_chief_room",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
//tunnels
koboldCavesRoom1.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom2.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom3.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom4.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom5.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom6.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom7.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom8.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom9.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom10.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom11.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom12.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom13.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom14.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom15.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom16.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom17.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom27.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom28.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
//main
koboldCavesRoom18.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom20.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom21.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom22.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom23.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom24.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom25.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom26.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
//floor 2
koboldCavesFloor2Room1.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room2.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room3.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room4.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room5.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room6.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room7.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
//CHIEF ROOM
koboldCavesFloor2Room7.onEntry = function() {
	let doAnyExist = pushMonster.some(monster => monster.refName == 'koboldChief')
	if (!bossTimeouts.koboldChief && !doAnyExist) {
		monsterGen(koboldChief(currentArea))
		bossTimeouts.koboldChief = setTimeout(() => {
			delete bossTimeouts.koboldChief
		}, 600000)
	}
}

let trainingHallsCombatHalls1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Advanced Combat Study Halls`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `You see more higher level guild prospects and even recently inducted guild members studying here. There are statues stanced in specific combat poses, demonstrating proper technique of various abilities.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`ADVANCED COMBAT TRAINING HALLS`, 'white', line2)
			blankSpace()
		},
		actionWord: ['sign']
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
			desc: function() {
				let line1 = lineFunc()
				blankSpace()
				customizeEachWord(`A large decorated sign hangs from the ceiling. On one side is a heavily geared Warrior surrounded by monsters. On the other side is the Warrior standing amongst bodies of dead monsters.`, 'white', line1)
				blankSpace()
			}
		}
	}
)

let trainingHallsCombatHalls2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Advanced Combat Study Halls`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `You see more higher level guild prospects and even recently inducted guild members studying here. There are statues stanced in specific combat poses, demonstrating proper technique of various abilities.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
)

let training_halls3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Live Monsters Training Halls 2`, //change area name
		desc: `The goblins to the east and west are a little stronger than before. Speak to Commander Levins before fighting them. He has some useful items for you.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let training_halls3_room3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'blue',
		areaName: `Mage Initiate Room`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: ``,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallEntryMessHall = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Hall entry to the Mess Hall`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `Entry way to the Mess Hall`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let trainingHallEntry34525234 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Hall entry to the Mess Hall`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `Entry way to the Mess Hall`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_courtyard_south_junction = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway. There is a large SIGN here`,
		zoneExitsBool: {
			north: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction231 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction232 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction233 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction23 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_bath_house_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_bath_house_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_bath_house_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castleCourtyardCrossInThePath1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			north: true,
			southeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyardNearingWestGateJunction = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing the West Gate Junction`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_court_fountain_SE = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Southeast`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			northwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_E = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain East`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_NE = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Northeast`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_N = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain North`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_castle_entrance = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing the West Gate Junction`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: 'locked',
			south: true,
		},
		zoneExitsLocked: {
			north: function () {
				if (castle_court_castle_entrance.descriptions.zoneExitsBool.north == 'locked') {
					let line1 = document.createElement('div')
					customizeEachWord(`The way to the north is locked. The lock looks to be pretty simple.`, 'white', line1)
				}
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'blue',
		areaName: `Castle Courtyard Fountain`, //change area name
		desc: `The Castle Courtyard Fountain stands as the centerpiece of the bustling castle grounds. Crystal-clear water cascades from a sculpted marble structure, its soothing melody harmonizing with the lively atmosphere. Castle residents and visitors alike gather here, sharing stories and enjoying the enchanting ambiance.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},

		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_w = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain West`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_nw = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Northwest`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_court_fountain_s = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain South`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			south: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n12_sw = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Southwest`, //change area name
		desc: `West Gate Junction. South is the Monk's guild, west is the West Exit, east is the Castle Pond, north is the Castle`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n13_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing The Castle Court Fountain`, //change area name
		desc: `You can smell the mixture of food and animals in the air coming from the nearby kitchen and stables. To the east, the gentle sound of water invites you to the captivating Castle Courtyard Fountain.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n14_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `West Gate Junction`, //change area name
		desc: `West Gate Junction. South is the Monk's guild, west is the West Exit, east is the Castle Pond, north is the Castle`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_split_to_tower_and_kitchen = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `A Split To The Tower And Castle Kitchen`, //change area name
		desc: ``,
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_northwest_tower = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `At The Footsteps Of The Northwest Guard Tower`, //change area name
		desc: ``,
		zoneExitsBool: {
			southeast: true,
			northwest: 'locked',
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_kitchen = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Just Outside The Castle Kitchen`, //change area name
		desc: ``,
		zoneExitsBool: {
			north: 'locked',
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_passing_stables_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Passing By The Stables`, //change area name
		desc: `As you pass by the Castle Stables, you catch glimpses of the majestic horses within their stalls. The rhythmic sounds of hooves against the stable floor echo through the air, reminding you of the strength and grace that resides within these gentle creatures.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n16_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Just Inside The Western Gate Near The Stables`, //change area name
		desc: `Stepping inside the West Castle Gates, you find yourself surrounded by a bustling atmosphere. Soldiers march with purpose, while merchants set up their wares. The air carries the scent of freshly baked bread and the sound of cheerful greetings.`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_w_gatehouse = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-17, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `West Castle Gatehouse`, //change area name
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExitsLocked: {
			west: () => quickMessage(`can't go here yet`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_moat_west = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'brown',
		areaName: `Standing on the West Gate Drawbridge`, //change area name
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	12, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-17, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: 'locked',
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Standing on the West Gate Drawbridge`, //change area name
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_stables_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'stables-orange',
		areaName: `Castle Stables`, //change area name
		desc: `North of the castle gates, you discover the Castle Stables. Neat rows of sturdy wooden stalls house majestic horses, their manes brushed and hooves cared for. The gentle nickering of the horses creates a soothing melody within the stables.`,
		zoneExitsBool: {
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_stables_stall_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'stables-orange',
		areaName: `Stable Stalls`, //change area name
		desc: `Within the Castle Stables, you find yourself amidst a symphony of equine energy. Each stall shelters a magnificent steed, their glossy coats gleaming under the warm sunlight. Hay fills the air with its earthy scent, inviting you to explore further.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyardPath1Area4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Castle Courtyard Path 1 Area 4`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let holy_light_chapel_path1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 1`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_path2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 2`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_path3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 3`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_path4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 4`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_interior1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Interior 1`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_interior3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Interior 3`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_interior2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Interior 2`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsCombatRoom3 = new AreaMaker(
	5,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Attributes: Secondary Benefits`,
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `Strength: Strength`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let trainingHallsCombatRoom4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-6, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Defensive Attributes`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `Attack, armor, and penetration types: 
		There are three attack types that are possible for both you and enemies: slashing, piercing, and blunt swings. Your attack type is determined by your weapon. You can check what type a weapon is by examining or inspecting it. If you swing with a weapon that has only one swing type, you will always swing that type, and your weapon's damage will be matched against the enemy's armor of that type. This works the same for an enemy attacking you. If an enemy swings at you with a slashing attack, its damage will be matched against your slashing armor: piercing attack against piercing armor, and blunt attack against blunt armor. The way in which your attack type is determined if your weapon has multiple swing types, say it's a slashing and piercing type, is random. If it's a slashing and piercing type, there is a 50/50 chance of swinging either type. If your weapon happens to have three swing types (very rare circumstances), then there would be an even split chance amongst all three types.

		Armor value: Armor value is very effective in that it prevents 1 damage per point of armor. An attack with 10 damage against an armor value of 10 would be completely negated. There is also a damage percent negation for every point of damage beyond that, making armor very effective for both you and enemies. You will eventually come across weapons, skills, and abilities that increase your armor penetration that will allow you to deal more damage to heavily armored enemies. Each point of penetration will negate the value of the coresponding type by 1. If an enemy has 10 slashing armor, and you have 5 slashing penetration, its slashing armor will be reduced to 5. The swing type is always matched against the enemy's armor type. That is to say, if an enemy has 10 slashing armor, and you have 10 slashing penetration, but your weapon swing is a blunt attack, the damage will be matched against the enemy's blunt armor, so your slashing penetration will have no effect for that swing.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let trainingHallsCombatRoom1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Enemy Behavior`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `Attacking: Enemies can have up to four ways of attacking you: Melee attack, ranged attack, melee ability, ranged ability. Most of the time they will only use one or two of those. Enemy attacks are easy to predict as they occur at the same interval every time. Enemy abilities can vary in their charge up or cast time, making them unpredictable until you familiarize yourself with that enemy.
		Movement: Enemies can only move one room at a time, and they will follow you if you are within one room of them. The speed at which they move (and attack) is typically dependent on their level. Higher level enemies will move much faster and attack much more frequently than lower level enemies.`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
)

let trainingHallsCombatRoom2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-6, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Combat Stats`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `Attack: This is the primary stat that influences your damage. Each weapon skill utilizes different stats in order to calculate attack:
		Unarmed: Each point of either Str, Dex, or Agi will raise your attack by 1
		One Handed Weapons: Each point of Str or Dex will raise your attack by 1
		Two Handed Weapons: Each point of Str will increase your attack by 2
		Daggers: Each point of Dex or Agi will increase your attack by 1
		Bows: Each point of Dex or Agi will increase your attack by 1

		Speed: This is the speed at which you can swing your weapon for regular attacks. It can only be lowered by training your weapon skill, and the fastest swing you can acquire is two seconds.
		Accuracy: Your accuracy represents your percent chance of hitting an enemy with 0 dodge and the same level as you. Accuracy is increased primarily through the Dexterity attribute, but is also increased by training your weapon skill. Some guilds offer additional skills that will increase your accuracy as well.
		Dodge: Dodge is similar to accuracy in that in that it represents your percent chance of dodging an enemy's regular attack that has 0 accuracy and the same level as you. Dodge is increased primarily through the Agility attribute, and various skills typically taught by trainers of the Rogue's Guild.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

////////////////////////////////////////////////////////OLD STARTING AREA BELOW////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////OLD STARTING AREA BELOW////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////OLD STARTING AREA////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////OLD STARTING AREA////////////////////////////////////////////////////////////////////////////////////////
let theShallowsEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	2,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	3,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	5,
	4,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows3 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows24 = new AreaMaker(
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	5,
	6,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			south: true,
			northwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows25 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	4,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows26 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows4 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows5 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows6 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	8,
	6,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows7 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	8,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade.',
		desc: 'NORTHEAST PART. There is a clover here.',
		zoneExitsBool: {
			west: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['clover']
	}),
	{
		clover: {
			names: ['clover'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					this.empty = false
				}, 900000) //15 minute respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!theShallows7.interactables.clover.empty) {
					customizeEachWord(`A blossom of clover that looks ripe for the pickins`, 'white', line1)
				} else {
					customizeEachWord(`There is no blossom to pick`, 'white', line1)
				}
			},
			color: function() {
				if (theShallows7.interactables.clover.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
	}
)
let theShallows8 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows9 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows10 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	8,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows11 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	9,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows12 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	10,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade.',
		desc: 'NORTHEAST PART. There is a clover here.',
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['clover']
	}),
	{
		clover: {
			names: ['clover'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					this.empty = false
				}, 900000) //15 minute respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!theShallows12.interactables.clover.empty) {
					customizeEachWord(`A blossom of clover that looks ripe for the pickins`, 'white', line1)
				} else {
					customizeEachWord(`There is no clover to pick`, 'white', line1)
				}
			},
			color: function() {
				if (theShallows12.interactables.clover.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
	}
)
let theShallows13 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	10,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows14 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	9,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows15 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	8,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows16 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	4,
	10,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade.',
		desc: 'NORTHEAST PART. There is a clover here.',
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['clover']
	}),
	{
		clover: {
			names: ['clover'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					this.empty = false
				}, 900000) //15 minute respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!theShallows16.interactables.clover.empty) {
					customizeEachWord(`A blossom of clover that looks ripe for the pickins`, 'white', line1)
				} else {
					customizeEachWord(`There is no clover to pick`, 'white', line1)
				}
			},
			color: function() {
				if (theShallows16.interactables.clover.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
	}
)
let theShallows17 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	9,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows18 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	8,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows19 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows20 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	2,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows21 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	2,
	6,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows22 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows23 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	4,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			west: true,
			east: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
theShallows1.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows2.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows3.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows4.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows5.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows6.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows7.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows8.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows9.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows10.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows11.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows12.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows13.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows14.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows15.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows16.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows17.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows18.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows19.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows20.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows21.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows22.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows23.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows24.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows25.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}
theShallows26.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 10}, {enemy: stag, probability: 10}, {enemy: impling, probability: 10}])}


let centralGlade = new AreaMaker(
	0,
	false,
	[kasia],
	true,
	areaIdGenerator(),
	2, //x
	0, //y
	0, //z
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `The Central Glade of Galvadia`,
		desc: `Between the town and castle walls, deep within the Galvadian forest, you find yourself standing in a massive glade. The surrounding trees tower high above you, and in the very middle stands the biggest tree youve ever seen. Roots extend from the base of the tree like giant tendrils. A massive trunk extends through the top of the forest canopy, the crown blossoms beyond the glade itself. The bits of light that make its way through cast soft spotlights around the glade. Despite the lack of direct light, the forest itself glows a comforting amber.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let westGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Traveling to the west of the Glade',
		desc: 'Two giant trees standing opposite each other mark the end of the path leading to the glade. Heading away from the glade is a tunnel of trees extending out of sight. The branches intertwine to form an arc high above the forest path. To the west is the path back to town. To the east is the Glade of Galvadia - a massive glade the size of a small town resting inside the bowl of a very shallow crater. Though the Central Glade is a safe haven, the outskirts are known to have bandits and hostile creatures skittering about.',
		zoneExitsBool: {
			north: true,
			northeast: false,
			east: true,
			southeast: false,
			south: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let northwestGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northwestern edge of the Glade',
		desc: 'Just ahead of you, a few deer are bounding around playfully. They stop briefly to look up and take note of your presence before going back to playing. Approaching them is tempting, but you think better of disrupting their play.',
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let northGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Traveling to the north side of the Glade',
		desc: 'Heading north, you start to notice that there are fewer people around. You again become aware of the natural sounds happening around you.',
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let northeastGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let eastGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Eastern side of the Glade',
		desc: 'In the vast openness of the glade, on this side lies an oasis of trees.',
		zoneExitsBool: {
			northwest: true,
			north: true,
			east: 'locked',
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let southeastGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Southeastern edge of the Glade',
		desc: 'In the vast openness of the glade, on this side lies an oasis of trees.',
		zoneExitsBool: {
			northwest: true,
			north: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let southGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'South Part of the Glade',
		desc: 'In the vast openness of the glade, on this side lies an oasis of trees.',
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let southwestGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Southwestern Part of the Glade',
		desc: 'In the vast openness of the glade, on this side lies an oasis of trees.',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			south: 'locked',
		},
		zoneExitsLocked: {
			south: () => {
				gameDialogue(`This is the entrance to the Ranger's Guild`)
			},
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let entranceToGladeOfGalvadia3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	0,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Entrance to the Galvadian Forest',
		desc: 'Two giant trees standing opposite each other mark the end of the path leading to the glade. Heading away from the glade is a tunnel of trees extending out of sight. The branches intertwine to form an arc high above the forest path. To the west is the path back to town. To the east is the Glade of Galvadia - a massive glade the size of a small town resting inside the bowl of a very shallow crater. Though the Central Glade is a safe haven, the outskirts are known to have bandits and hostile creatures skittering about.',
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneType: 'galvadian_glade_entrance',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let entranceToGladeOfGalvadia2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-1,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Entrance to the Galvadian Forest',
		desc: 'Two giant trees standing opposite each other mark the end of the path leading to the glade. Heading away from the glade is a tunnel of trees extending out of sight. The branches intertwine to form an arc high above the forest path. To the west is the path back to town. To the east is the Glade of Galvadia - a massive glade the size of a small town resting inside the bowl of a very shallow crater. Though the Central Glade is a safe haven, the outskirts are known to have bandits and hostile creatures skittering about.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneType: 'galvadian_glade_entrance',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let entranceToGladeOfGalvadia1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-2,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Entrance to the Galvadian Forest',
		desc: 'Two giant trees standing opposite each other mark the end of the path leading to the glade. Heading away from the glade is a tunnel of trees extending out of sight. The branches intertwine to form an arc high above the forest path. To the west is the path back to town. To the east is the Glade of Galvadia - a massive glade the size of a small town resting inside the bowl of a very shallow crater. Though the Central Glade is a safe haven, the outskirts are known to have bandits and hostile creatures skittering about.',
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
		},
		zoneType: 'galvadian_glade_entrance',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let outsideEntranceToGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'Approaching the Entrance to The Glade of Galvadia',
		zoneType: "galvadia_exterior_north",
		desc: 'As you near the glade entrance, you notice how much larger the trees are here. With each step you take, You feel as though the forest can feel your presence. ',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let pathNearingEntranceToGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-4,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'Nearing the Entrance to the Glade of Galvadia',
		zoneType: "galvadia_exterior_north",
		desc: 'Nearing the entrance to the Glade',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let onPathToGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'On the path to the Glade of Galvadia',
		zoneType: "galvadia_exterior_north",
		desc: 'On the path to the Glade',
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let wellWornPathToTheGlade = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'On the well worn path between Galvadia and the glade',
		zoneType: "galvadia_exterior_north",
		desc: `On the well worn path`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let bridgeOverTheRiver = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'On the bridge overlooking the river',
		zoneType: "galvadia_exterior_north",
		desc: `Going over the bridge crossing the river`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castlePathNearRiver = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'By the edge of the river banks near the bridge',
		zoneType: "galvadia_exterior_north",
		desc: `Steep banks near the river bridge`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let offTheCastlePath = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'East Castle Crossroads',
		zoneType: "galvadia_exterior_north",
		desc: `The business of the town square can be heard as you stand at the East Castle Crossroads. The eastern path is a long, dirt road that borders the castle moat. It extends past the moat up a long, steady incline toward the forest. Townspeople travel this road often to visit the glade.
		There is a sign here.`,
		zoneExitsBool: {
			northwest: true,
			east: true,
			southwest: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`North: Castle`, 'white', line2)
			customizeEachWord(`East: Glade of Galvadia`, 'white', line3)
			customizeEachWord(`South: Town Square`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)

let startingAreaEastSecretDown = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	0,
	-1,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `In a hole beneath a fallen tree`,
		desc: `Secret rooms like this will often disappear soon after you leave. You can always rediscover the entrance, so be sure to remember where and how you discovered it.`,
		zoneExitsBool: {
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaSoutheast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Southeast of the Starting Area`,
		desc: `Here you will train about stats, spells, skills, and abilities. Stats influence your skills and your skills influence your spells and abilities. Depending on your race and class, you will gain a small number of stats each time you gain a level. You will also be awarded a few stat points to allocate yourself along with some build points. Build Points are used to train your skills and abilities at a guild trainer. Guild trianers are only availble to guild members, and you can only be part of one guild. You will train more about skills and abilities once you get to a guild trainer. `,
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let startingAreaSouth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `South of the Starting Area`,
		desc: `Oh no, a blob! Don't worry, this enemy is harmless and is only here to teach you combat! Firstly, you cannot attack a enemy unless you are ENGAGED with it. Engaging is simple, and in most cases, hostile enemys will engage you automatically. If you wish to engage an enemy, you must ADVANCE, or 'ad', followed by the enemy name. Once engaged, both you and the enemy can deal damage to one another. But be careful, ranged enemies can attack you without being engaged! However, if you have the ranged skill you can do this too. Once you are engaged with an enemy, you need to ATTACK, or 'a' the enemy. Simply typing 'a' will attack the first enemy you are engaged with. If there are multiple enemies you are engaged with, you can type 'a' followed by a number to indicate which enemy in the room you wish to attack. Typing 'a' followed by the enemy name will single out that enemy and you will only attack the enemy with that name. When you are engaged, you will not be able to move until you are no longer engaged. For that to happen, you need to either kill all the enemys you are engaged with, or an easier way is to simply RETREAT As far as defense goes, you will train more about that when training your defensive skills. For now, and mostly throughout your journey, you will be using the RETREAT, or 're', command. Retreating will disengage you from all enemys in the room allowing you to perform non-combat actions again. If you retreat, the enemy will engage you again as soon as it can. If you're trying to run away, you'll probably want to use the RETREAT command followed by a direction. This will disengage you from the enemy while also moving you into another room creating more distance! This is very useful, but be careful because moving into another room might spawn another enemy for you to deal with. Go ahead and test out the commands you trained on this blob before heading to the southwest of the Starting Area.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaSouthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Southwest of the Starting Area`,
		desc: `Here you will train about some general game information. Monsters are encountered in hostile areas and will only have a chance of spawning when you enter that particular area, so moving from room to room will eventually cause a enemy to spawn. Monsters will also have a chance to drop a variety of items from weapons and armor to quest items. Another way to obtain items is from a shop. These will typically be found in towns and cities. You will be able to buy and sell once you find one. `,
		zoneExitsBool: {
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaWest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `West of the Starting Area`,
		desc: `A little tunnel of trees connecting the starting area glade to the main glade`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let startingAreaUp = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator,
	3,
	0,
	1,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Above the Starting Area`,
		desc: `Here you will train about how shops work.`,
		zoneExitsBool: {
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaBelow = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	0,
	-1,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Underneath the starting area`,
		desc: `You find yourself in an underground, dirt cave. The sounds of a lightly crackling fire accompany the smell of roasting meat. an old man sits behind the fire, working something in his hands.`,
		zoneExitsBool: {
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let northTownGate = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-3,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Passing through the town gates',
		desc: `Many people travelling through the gates, to and from the castle. Citizens passing through on their way to the forest.
		There is a sign here.`,
		zoneType: "galvadia_town",
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			south: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`Northwest: Galvadian Fields`, 'white', line2)
			customizeEachWord(`Northeast: Glade of Galvadia`, 'white', line3)
			customizeEachWord(`South: Town Square`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let northMostGalvadianTown = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `North Side Of The Square`,
		desc: `The northern part of the square sits between the bakery shops and the blacksmith making it one of the busiest areas. Everyone heading to and from the Glade pass through here, as well as anyone making any last purchases before leaving town.`,
		zoneType: "galvadia_town",
		zoneExits: [],
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaShop1 = new AreaMaker(
	0,
	false,
	[benjamin],
	false,
	areaIdGenerator(),
	-11,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Town Square Bakery`,
		desc: `The bakery draws a large crowd as the only food shop in the square, though it is quite large, seating the same as a castle mess hall. The sound of conversation, laughs, and clatter fills the air. `,
		zoneType: "galvadia_town",
		fire: true,
		zoneExits: [],
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaShop2 = new AreaMaker(
	0,
	false,
	[joch, clyde],
	false,
	areaIdGenerator(),
	-9,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `The Blacksmith Shop`,
		desc: `An assortment of blades and armor are on display behind the vendor stalls of the blacksmith. The heat of the furnace blows through, bringing a sweat to your brow. The smiths here are known for their crafts. You recognize the craftsmanship to be the same as much of the weapons and armor you've seen worn by castle guards.`,
		zoneType: "galvadia_town",
		zoneExits: [],
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaTownSquare = new AreaMaker(
	0,
	false,
	[villagerRissah, deylani, timtim, sally, travellingWagon, strayCat, kasia, allSkillsMan],
	false,
	areaIdGenerator(),
	-10,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Galvadia Town Square',
		zoneType: "galvadia_town",
		desc: `The town square is full of hustle and bustle. The mix of chatter, laughter, tinks and clangs of metal, smells of food and brewing potions, 
		There is a sign here.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			let line6 = document.createElement('div')
			let line7 = document.createElement('div')
			let line8 = document.createElement('div')
			let line9 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`Northwest: Bakery`, 'white', line2)
			customizeEachWord(`North: Castle Crossroads`, 'white', line3)
			customizeEachWord(`Northeast: Blacksmith and Armorsmith`, 'white', line4)
			customizeEachWord(`East: East Residential`, 'white', line5)
			customizeEachWord(`Southeast: Magic Shop`, 'white', line6)
			customizeEachWord(`South: Guild Plaza`, 'white', line7)
			customizeEachWord(`Southwest: Bows, Daggers, and Leathers`, 'white', line8)
			customizeEachWord(`West: West Residential`, 'white', line9)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign']
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			}
		}
	}
)
let galvadiaCity_East = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Of The Town Square',
		desc: 'This is the only road to and from the East Residential District -- the main housing for Galvadian citizens. Across the bridge to the east, the road winds and weaves from house to house. Lanes disappear into neighborhoods far out of sight.',
		zoneType: "galvadia_town",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCity_East2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'By The East Residential Bridge',
		desc: 'By The East Residential Bridge',
		zoneType: "galvadia_town",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCity_East3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'On a Bridge Overlooking The River',
		desc: 'On a Bridge Overlooking The River',
		zoneType: "galvadia_town",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCity_East4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Just Outside The Residential District',
		desc: 'Just Outside The Residential District',
		zoneType: "galvadia_town",
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down Lavish Lane',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down Lavish Lane',
		zoneExitsBool: {
			northwest: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-4,
	-7,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down Lavish Lane 2',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down Lavish Lane 2',
		zoneExitsBool: {
			northwest: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadia_residential_east_entrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-2,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North Entrance',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North Entrance',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-1,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	0,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_5 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_6 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_7 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	5,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_8 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	6,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadia_city_east_residential_path3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Entrance To The East Residential Neighborhood',
		zoneType: "galvadia_residential_east",
		desc: `Entrance To The East Residential Neighborhood.
		There is a sign here`,
		zoneExitsBool: {
			northwest: true,
			east: true,
			south: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`East: Eastern Residential District - North`, 'white', line2)
			customizeEachWord(`South: Graveyard and Eastern Residential District - South`, 'white', line3)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path5 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 2',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 2',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path6 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 3',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 3',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path7 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 4',
		zoneType: "galvadia_residential_east",
		desc: `Heading Down The South Side Of Lavish Lane 4. 
		There is a SIGN here.`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		sign: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`East: Eastern Residential District - South`, 'white', line2)
			customizeEachWord(`Southwest: Graveyard`, 'white', line3)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path8 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-4,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 5',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 5',
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path9 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 6',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 6',
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path10 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'On The South Side Of Lavish Lane Nearing The Graveyard',
		zoneType: "galvadia_residential_east",
		desc: 'On The South Side Of Lavish Lane Nearing The Graveyard',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path11 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Just Outside The Graveyard',
		desc: 'Just Outside The Graveyard',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard1 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-8,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Graveyard Entrance',
		zoneType: "galvadia_graveyard",
		desc: 'Tall trees and fog surround the graveyard. Through the fog and tree branches, you can barely make out the top of the Guild Hall that towers high above the cemetery wall.  A straight cobblestone path goes straight ahead. Two dirt paths branch offone goes north along the graveyard wall, the other south along the river bank.',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard2 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'On a Straight Path Through the Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'The graveyard is connected by cobbled pathways that extend throughout the area. To the east, you see the graveyard entrance. To the west are hundreds of grave sites.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard3 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'In The Graveyard By A Marked Grave',
		zoneType: "galvadia_graveyard",
		desc: 'To the north, you see an ivy-covered stone archway. A small, dirt path leads straight to a headstone. There are Vilolets growing on both sides of the path.',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone1 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'At A Gravestone Surrounded By Violets',
		zoneType: "galvadia_graveyard",
		desc: 'A single violet has been placed upon the gravestone.',
		zoneExitsBool: {
			south: true,
		},
		actionWord: ['headstone'],
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		headstone: {
			names: ['headstone'],
			requirement: {
				level: 4,
			},
			color: function() {
				if (gravestone1.interactables.headstone.requirement) {
					for (let requirement in gravestone1.interactables.headstone.requirement) {
						if (player[requirement] < gravestone1.interactables.headstone.requirement[requirement]) {
							return 'red'
						} else {
							return 'blue'
						}
					}
				}
			}
		}
	}
)
let graveyard4 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Northside Graveyard Junction',
		zoneType: "galvadia_graveyard",
		desc: 'You stand at a junction in the graveyard. More graves lie to the west and south. The western path extends passed several more graves before nearing the river. The path to the south leads to a gloomier side of the cemetery with larger, more entricately engraved tombs.',
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard5 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'By A Marked Grave',
		zoneType: "galvadia_graveyard",
		desc: 'To the north, you see a simple gravestone embedded into the ground. A stone pedestal stands behind it. Several objects that look like offerings have been placed upon it.',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone2 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'At A Gravestone Surrounded By Roses',
		zoneType: "galvadia_graveyard",
		desc: 'A single Rose has been placed on the tombstone.',
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard6 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Nearing The West End Of The Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'You can see the path in front of you split to the north and south. The south path rounds several dead trees before disappearing into the gloom of the south graveyard. The path to the north curves around to the east, passing by several more graves.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard7 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-14,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Far End Of The Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'Peering into the distance, across the river, you can see the western residential area of Galvadia. You spot a few wagons travelling up and down the road, smoke piping out of the house chimneys.',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard8 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-14,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'On A Path To The North Side Of The Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'You round the graveyard path to the north, heading toward the northern row of graves.',
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard9 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Nearing A Large Dead Tree',
		zoneType: "galvadia_graveyard",
		desc: 'In the northwest corner of the graveyard stands a large, leafless tree.',
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone3 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Beneath A Large Tree',
		zoneType: "galvadia_graveyard",
		desc: `You stand just beneath a massive tree. It is completely leafless. Other than that, it appears to be very healthy. There is an archway in the roots that look like a door leading into it.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard10 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'North Graveyard Path',
		zoneType: "galvadia_graveyard",
		desc: 'You pass by a gated portion of the graveyard to the south. To the west, the end of the path is marked by a large tree. A decorated gravestone lies just to the east.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard11 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone4 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		tombstone: {
			names: ['tombstone'],
			color: function() {
				return 'sinistral-color'
			},
			desc: function() {
				let doesPlayerHaveJewel = pushItem.some(item => item.refName == 'secretText')
				let line1 = lineFunc()
				if (player.guild == 'Monk' && !doesPlayerHaveJewel){
					customizeEachWord(`Inspecting the tombstone, you spot something shiny just under a leaf. You clear away the leaves to see an engraved jewel in the soil.`, 'white', line1)
					questItemGen(secretText(currentArea))
				} else {
					customizeEachWord(`You see that the tombstone is fresh. The engraving reads, "Here lies Gulard"`, 'white', line1)
				}
			},
			activate: function() {
				quickMessage(`test`)
			}
		}
	}
)
let graveyard12 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard13 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone5 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard14 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-8,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			south: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard15 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-8,
	-16,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard16 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard17 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard18 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard19 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-16,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard20 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard21 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard26 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-14,
	-16,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard22 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard23 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-19,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone7 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-20,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard24 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone6 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard25 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone8 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Tombstone',
		zoneType: "galvadia_graveyard",
		desc: "Just Outside The Residential District - tombstone with markings of the Sinistral's Guild",
		zoneExitsBool: {
			west: true,
		},
		actionWord: ['tombstone'],
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		tombstone: {
			names: ['tombstone'],
			requirement: {
				playerClass: 'Sinistral',
				playerGuidl: 'Sinistral',
			},
			color: function() {
				return 'sinistral-color'
			},
			desc: function() {
				let doesPlayerHaveJewel = pushItem.some(item => item.refName == 'thievesJewel')
				let line1 = lineFunc()
				if (player.guild == 'Sinistral' && !doesPlayerHaveJewel){
					customizeEachWord(`Inspecting the tombstone, you spot something shiny just under a leaf. You clear away the leaves to see an engraved jewel in the soil.`, 'white', line1)
					questItemGen(thievesJewel(currentArea))
				} else {
					customizeEachWord(`You see that the tombstone is fresh. The engraving reads, "Here lies Gulard"`, 'white', line1)
				}
			},
			activate: function() {
				quickMessage(`test`)
			}
		}
	}
)
graveyard1.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard2.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard3.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard4.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard5.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard6.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard7.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard8.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard9.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard10.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard11.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard12.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard13.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard14.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard15.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard16.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard17.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard18.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard19.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard20.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard21.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard22.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard23.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard24.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard25.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard26.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}



let galvadiaCitySoutheast = new AreaMaker(
	0,
	false,
	[lyra, faffa],
	false,
	areaIdGenerator(),
	-9,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'The Magic Shop',
		zoneType: "galvadia_town",
		desc: 'The smell of brewing potions drifts through the air outside the Magic Shop. Mage apprentices can be seen through the windows sitting at tables studying. The outdoor stalls are hosted by a young mage weaving strange fabrics, and an unorganized yet happy looking gnome holding a staff twice his size.',
		zoneExitsBool: {
			north: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCityWest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Galvadia Town West',
		zoneType: "galvadia_town",
		desc: 'The town square is easily one of the more crowded areas within the walls. A large fountain is in the center of the square, allowing people to sit or take a drink. There are shopkeepers on every corner selling their wares, from food and potions to swords and armor. In front of the fountain is a large SIGN',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: 'blocked',
		},
		zoneExitsLocked: {
			west: () => quickMessage(`This direction is locked`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCitySouthwest = new AreaMaker(
	0,
	false,
	[dolf, todlin],
	false,
	areaIdGenerator(),
	-11,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Bows, Daggers, and Leathers Shop',
		zoneType: "galvadia_town",
		desc: 'Tanned leater is strung up all around on racks, and wood shavings litter the ground. A shopkeep looks up and gives you a nod as he continues stringing a bow without missing a beat.',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaSouthSquare = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'South Of The Square Nearing The Guild Plaza Bridge',
		zoneType: "galvadia_town",
		desc: 'Just a little farther to the south is the main bridge connecting the Guild Plaza to the Town Square, with a steady stream of people to and from. Across the bridge is the Guild Plaza. The view beyond the bridge is taken up entirely by the massive buildings of the Guild Halls. ',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaSouthBridge = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-7,
	0,
	0,
	(descriptions = {
		areaNameClass: 'bridge',
		areaName: 'Crossing The Guild Plaza Bridge',
		zoneType: "galvadia_town",
		desc: `The bridge connecting the town square and guild plaza stretches across the canals. The bridge is almost as wide as it is long to accommodate the influx of people at high traffic times. A variety of wizardly clothed students to fully clad, plate armored knights occupy the bridge.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaGuildPlaza = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'North Side Of The Guild Plaza',
		zoneType: "galvadia_guild_square",
		desc: 'Entering the guild district, buildings tower on all sides. During classes, the plaza is nearly empty, but the sounds of metal clanging and distant blasts can be heard.',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaGuildSquare = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Guild Square',
		zoneType: "galvadia_guild_square",
		desc: 'Surrounded by the 3 guild buildings',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let rangersGuildOutside = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Outside the Ranger's Guild`,
		zoneType: "galvadia_guild_square",
		desc: `Outside the Ranger's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Entrance`,
		zoneType: "galvadia_guild_square",
		desc: `Ranger's Guild Entrance`,
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildStaircase = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			east: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildStaircase2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildCommonRoom = new AreaMaker(
	0,
	false,
	[talon],
	false,
	areaIdGenerator(),
	-7,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Level 10 Room`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	4,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Level 10 Room`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	5,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Level 30 Room`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let sinistralsGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Entrance`,
		desc: `Sinistral's Guild Entrance`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
			southeast: true,
			// southeast: 'blocked',

		},
		zoneExitsLocked: {
			southeast: function() {
				quickMessage(`Only members of the Sinistral's Guild are allowed through here.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildEntranceRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Darkened Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildEntranceStaircase = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Staircase`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildCommonRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-11,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeCommonRoom = new AreaMaker(
	0,
	false,
	[shallox],
	false,
	areaIdGenerator(),
	-7,
	-12,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			southeast: true,
			south: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-13,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Level 10 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-13,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Level 20 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-13,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Level 30 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let sinistralsGuildThiefCommonRoom = new AreaMaker(
	0,
	false,
	[vezzlethrax],
	false,
	areaIdGenerator(),
	-6,
	-11,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northeast: true,
			east: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildThiefLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-10,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief Level 10 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildThiefLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-11,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief Level 20 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildThiefLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-12,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief Level 30 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsCommonRoom = new AreaMaker(
	0,
	false,
	[daggslain],
	false,
	areaIdGenerator(),
	-7,
	-10,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-9,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Level 10 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Level 20 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-9,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Level 30 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaWarriorsGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside The Warrior's Guild`,
		desc: `Outside The Warrior's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let newmageentrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Outside The Mage's Guild`,
		desc: `Outside The Mage's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralnewentrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Outside The Sinistral's Guild`,
		desc: `Outside The Sinistral's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildEntrance = new AreaMaker( //possible new entrance
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Entrance Hall`,
		desc: `You stand at the top of a large staircase that extends down below into a larger common room. The walkways to the east and west cut south along the walls creating a balcony that overlooks the common room below.`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			south: true,
			// south: 'blocked',

		},
		zoneExitsLocked: {
			south: () => {
				quickMessage(`Only members of the Warrior's Guild are allowed through.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkerEntrance = new AreaMaker( //possible new entrance
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Entrance Hall`,
		desc: `Large common room of the Warrior's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: 'blocked',
			west: 'blocked',
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildDownstairsInterior2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Main Room`,
		desc: `Large common room of the Warrior's Guild. There is a SIGN here.`,
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			east: true,
			south: true,
			west: true,
			up: true,
		},
		sign: async function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			let line5 = lineFunc()
			await dialogueWait(200)
			customizeEachWord(`The sign reads:`, 'white', line1)
			customizeEachWord(`Northwest/Northeast: Guild Leader Offices`, 'white', line2)
			customizeEachWord(`East: Knight's Wing`, 'white', line3)
			customizeEachWord(`South: Berserker's Wing`, 'white', line4)
			customizeEachWord(`West: Fighter's Wing`, 'white', line5)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersWingEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-13,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Wing Entrance`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersCommonRoom = new AreaMaker(
	0,
	false,
	[magvello],
	false,
	areaIdGenerator(),
	-10,
	-14,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Common Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-14,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Level 10 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-15,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Level 20 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-14,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Level 30 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let warriorsGuildFightersWingEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Wing Entrance`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersCommonRoom = new AreaMaker(
	0,
	false,
	[ragnar],
	false,
	areaIdGenerator(),
	-12,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Common Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-13,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Level 10 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Level 20 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Level 30 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildKnightsWingEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Wing Entrance`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsCommonRoom = new AreaMaker(
	0,
	false,
	[greaves],
	false,
	areaIdGenerator(),
	-8,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Common Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Level 10 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Level 20 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-13,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Level 30 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildOfficerHallNorthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Officer Hall`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildOfficerHallRagnar = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside Ragnar's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildRagnarsOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-9,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Ragnar's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildOfficerHallMagvello = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside Magvello's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildMagvellosOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-9,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Magvello's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildOfficeHallGreaves = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside Greave's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildGreavesOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-9,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Main Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildDownstairsInterior23 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Main Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let monksGuildOutside = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Outside The Monk's Guild`,
		desc: `Outside The Monk's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Entrance To The Monk's Guild`,
		desc: `Entrance To The Monk's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			west: true,
			// west: 'blocked',
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildCommonRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Monk's Guild Room 1`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkCommonRoom = new AreaMaker(
	0,
	false,
	[delverick],
	false,
	areaIdGenerator(),
	-13,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk's Common Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-8,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk Level 10 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk Level 20 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk Level 30 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkCommonRoom = new AreaMaker(
	0,
	false,
	[maelius],
	false,
	areaIdGenerator(),
	-13,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk Common Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-8,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk's Level 10 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk's Level 20 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk's Level 30 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkCommonRoom = new AreaMaker(
	0,
	false,
	[fearecia],
	false,
	areaIdGenerator(),
	-13,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk Common Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-8,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk's Level 10 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk's Level 20 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk's Level 30 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let guild_plaza_northwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Northwest Section Of The Guild Plaza Along The Canals`,
		desc: 'The water in the canals flow westward.',
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let guild_plaza_northeast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Northeast Section Of The Guild Plaza`,
		desc: 'A few small groups of students are hanging out here away from the business of the Plaza.',
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Mage Guild Entrance Corridor`,
		desc: 'Mage Guild Entrance Corridor',
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			southwest: true,
			// southwest: 'blocked',
		},
		zoneExitsLocked: {
			southwest: function() {
				quickMessage(`Only members of the Mage's Guild are allowed through here.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCommonRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Mage's Guild Common Room`,
		desc: 'Mage Guild Common Room',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Quarters Entrance`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			south: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerCommonRoom = new AreaMaker(
	0,
	false,
	[gelvander],
	false,
	areaIdGenerator(),
	-13,
	-10,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Tower Common Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Level 10 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Level 20 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Level 30 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Quarters Entrance`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			east: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerCommonRoom = new AreaMaker(
	0,
	false,
	[scylla],
	false,
	areaIdGenerator(),
	-14,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Tower Common Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			northwest: true,
			southwest: true,
			west: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-12,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Level 10 Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Level 20 Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-10,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Level 30 Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let mageGuildLightningMagusEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Quarters Entrance`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerCommonRoom = new AreaMaker(
	0,
	false,
	[blasphemy],
	false,
	areaIdGenerator(),
	-12,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Common Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			northeast: true,
			east: true,
			southeast: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-10,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Level 10 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Level 20 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-12,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Level 30 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let arenaCenter = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	100,
	100,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaNorthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	99,
	101,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaNorth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	100,
	101,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaNortheast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	101,
	101,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaEast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	101,
	100,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaSoutheast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	101,
	99,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			northwest: true,
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaSouth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	100,
	99,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaSouthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	99,
	99,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaWest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	99,
	100,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
//KEEP THIS BELOW ALL AreaMaker rooms!!!
//KEEP THIS BELOW ALL AreaMaker rooms!!!
let areaHandler = {
	get: (target, key) => {
		if (typeof target[key] === 'object' && target[key] !== null) {
			return new Proxy(target[key], handler)
		}
		return target[key]
	},
	set: (target, prop, value) => {
		target[prop] = value
	},
}
let proxy = new Proxy(currentArea, areaHandler)
//KEEP THIS BELOW ALL AreaMaker rooms!!!
//KEEP THIS BELOW ALL AreaMaker rooms!!!
////////////////////////////////ABILITIES////////////////////////////////



function help(secondCommand) {
	for (let skill in player) {
		if (skill.toLowerCase() == secondCommand) {
			player[skill].description()
			return
		}
	}
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`I'm sorry, but ${secondCommand} is not a valid skill to search for`, 'white', line1)
	blankSpace()
	return
}

// function abilityWeaponsCheck(weaponTypes, weapon1, weapon2) {
// 	if (weapon1 != undefined) {return false}
// 	if (weapon2 != undefined) {return false}
// 	if (weapon1 == undefined && getWeapon1().skillUsed == 'twoHanded') {
// 		let line1 = lineFunc()
// 		customizeEachWord(`You cannot perform this ability with these weapons`, 'white', line1)
// 		return true	
// 	}
// 	if (weapon2 != undefined) {
// 		if (weaponTypes.some(types => weapon2.skillUsed.includes(types))) {return false}
// 	}
// 	else {
// 		let line1 = lineFunc()
// 		customizeEachWord(`You cannot perform this ability with these weapons`, 'white', line1)
// 		return true
// 	}
// }

function dualWieldAbilityTemplate(secondCommand) {
	let rightWeapon = pushItem.find(weapon => weapon.roomId == 'right hand')
	let leftWeapon = pushItem.find(weapon => weapon.roomId == 'left hand')
}

function initiateSpellConjure(spell) {
	if (spell.chambered == false) {
		spell.queued = true
		spell.flavorTextChannel()
	}
}

// function initiateAbilityWindup(ability) {
// 	if (ability.onCooldown != true) {
// 		ability.queued = true
// 		let count = ability.windUp
// 		const abilityInterval = setInterval(() => {
// 			if (count <= 0) {
// 				ability.queued = false
// 				clearInterval(abilityInterval)
// 			}
// 			count--
// 			if (count <= 0 && ability.onCooldown != true) {
// 				ability.queued = false
// 			}
// 		}, 1000)
// 	}
// }
function initiateAbilityWindup(ability) {
	const conjureBar = document.querySelector('.bar-1')
	conjureBar.classList.add('warrior-resource-bar')
	let windUpTime = Math.floor(ability.windUp * 1000)
	let remainingTime = windUpTime
	let width = 0
	if (ability.onCooldown != true) {
		player.warriorAbilityQueue = true
		ability.queued = true
		const intervalId = setInterval(() => {
			if (remainingTime <= -1) {
				player.warriorAbilityQueue = false
				ability.queued = false
				conjureBar.style.width = 0
				clearInterval(intervalId)
				return
			}
			width = ((windUpTime - remainingTime) / windUpTime) * 100
			conjureBar.style.width = `${width}%`
			remainingTime -= 10
		}, 10)
	}
}
function initiateTimedAbility(ability) {
	const conjureBar = document.querySelector('.bar-1')
	conjureBar.classList.add('ranger-resource-bar')
	let windUpTime = Math.floor(ability.windUp * 1000)
	let remainingTime = windUpTime
	let width = 0
	if (ability.onCooldown == false && ability.queued == false) {
		ability.queued = true
		const intervalId = setInterval(() => {
			if (remainingTime <= -1) {
				player.warriorAbilityQueue = false
				ability.queued = false
				conjureBar.style.width = 0
				clearInterval(intervalId)
				return
			}
			width = ((windUpTime - remainingTime) / windUpTime) * 100
			conjureBar.style.width = `${width}%`
			remainingTime -= 10
		}, 10)
	}
}
function releaseTimedAbility(ability) {
	const conjureBar = document.querySelector('.bar-1')
	let windUpTime = Math.floor(ability.windUp * 1000)
	let remainingTime = windUpTime
	let width = 0
	if (ability.onCooldown == false && ability.queued == false) {
		ability.queued = true
		const intervalId = setInterval(() => {
			if (remainingTime <= -1) {
				player.warriorAbilityQueue = false
				ability.queued = false
				conjureBar.style.width = 0
				clearInterval(intervalId)
				return
			}
			width = ((windUpTime - remainingTime) / windUpTime) * 100
			conjureBar.style.width = `${width}%`
			remainingTime -= 10
		}, 10)
	}
}

function initiateAbilityCooldown(ability) {
	if (ability.hasOwnProperty('windUp')) {
		let line1 = lineFunc()
		customizeEachWord(`You burn the energy that you gathered for `, 'white', line1)
		customizeEachWord(`${ability.name} `, ability.color, line1)
		customizeEachWord(`and must wait `, 'white', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${ability.cooldownSet / 1000}`, 'yellow', line1)
		customizeEachWord(`] seconds`, 'white', line1)
		player.isAbilityQueued = false
		ability.queued = false
		blankSpace()
	}
	const cooldownBar = document.querySelector('.bar-1')
	cooldownBar.style.width = '100%'
	let castTime = ability.cooldown
	let remainingTime = castTime
	ability.onCooldown = true
	ability.queued = false
	const abilityInterval = setInterval(() => {
		if (remainingTime <= 0) {
			ability.onCooldown = false
			ability.cooldown = ability.cooldownSet
			cooldownBar.style.width = 0
			clearInterval(abilityInterval)
		} else {
		let width = (remainingTime / ability.cooldownSet) * 100
		cooldownBar.style.width = `${width}%`
		ability.cooldown -= 10
		remainingTime -= 10
		}
	}, 10)
}

function sinistralAbilities(ability, weaponUsed, targetEnemy) {
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (!targetEnemy) {
		quickMessage(`There is no enemy for you to attack`)
		return
	}
	stealthBreak()
	player.combat = true
	targetEnemy.combat = true
	let hitChance = playerAbilityHitChance(targetEnemy)
	player.isAbilityQueued = false
	ability.queued = false
	resourceConsumed(ability)
	if (hitChance == false) {
		ability.flavorTextMiss(targetEnemy, weaponUsed)
	} else if (hitChance == true) {
		console.log(ability, ' ABILITY')
		let baseDamage = player[ability.refName].damage(targetEnemy)
		let penetrationType = calculatePenetrationRoll()
		let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
		let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
		let damageBlocked = baseDamage - damageAfterArmor
		ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
		applyDamageToEnemy(targetEnemy, damageAfterArmor)
		if (ability.debuff) {applyDebuff(targetEnemy, ability.debuff)}
		if (ability.refName == 'bane') {
			if (targetEnemy.debuffs?.poison) {
				let weapon1 = getWeapon1()
				let weapon2 = getWeapon2()
				// let weaponArray = [weapon1, weapon2]
				applyEnchantmentToWeapon(weapon1, weapon2, targetEnemy.debuffs.poison)
				removeDebuff(targetEnemy, targetEnemy.debuffs.poison)
			}
		}

		if (ability.refName == 'guillotine') {
			if (targetEnemy.health <= 0) {
				if (targetEnemy?.debuffs?.sinisterMark) {
					let adrenalineGained = targetEnemy.debuffs.sinisterMark.stacks * player.sinisterMark.adrenalineBonus()
					ability.flavorTextAdrenalineGain()
					resourceGained(ability, adrenalineGained, 'maxAdrenaline')
				}
			}
		}
		if (ability.refName == 'ambush') {
			if (targetEnemy.health <= 0) {
				ability.flavorTextSpecial()
				player.isStealthed = true
			}
		}

	}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}

function stealthBreak() {
	if (player.isStealthed) {
		player.isStealthed = false
		player.stealth.flavorTextStealthBreak()
		applyBuff(player.stealth.buff)
	}
}

function chargeEffect() {
	if (player.charge.level == player.charge.maxLevel) {return}
	applyBuff(player.charge.buff)
}
function chargeFunction(secondCommand) {
	let targetMonster = pushMonster.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
	chargeEffect()
	if (player.charge.level == 0) {
		quickMessage(`You have not learned the charge skill`)
	} else if (player.combat == true) {
		attack(secondCommand)
	} else if (targetMonster != undefined && player.combat == false) {
		let line1 = document.createElement('div')
		player.combat = true
		targetMonster.combat = true
		player.charge.cooldown = player.charge.cooldownSet
		customizeEachWord(`Letting out a thundering battlecry, you charge the ${targetMonster.name}!`, 'white', line1)
		attack(secondCommand)
	} else {
		quickMessage(`Charge function not working properly`)
	}
}


function buildUpThenRelease(targetByFirst, targetByNumber, targetByName, targetsName) {
	let target
	if (targetByFirst != undefined) {
		target = targetByFirst
	} else if (targetByNumber != undefined) {
		target = targetByNumber
	} else if (targetByName != undefined) {
		target = targetByName
	} else if (targetsName != undefined) {
		target = targetsName
	}
	console.log(target)
	if (player.buildUpThenRelease && target != undefined) {
		if (target.buildUpCount == undefined) {
			target.buildUpCount = 1
		} else {
			target.buildUpCount++
		}
		if (target.buildUpCount % 5 == 0) {
			quickMessage(`Every 4th attack is double attacking`)
			setTimeout(() => {
				if (target.health > 0) {
					attack()
				}
			}, 100)
		}
	}
}
function stealthAbility() {
	if (player.stealth.level == 0) {
		quickMessage(`You must be trained in stealth in order to hide`)
		return
	}
	const areThereMonsters = pushMonster.some(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
	let stealth = player.stealth
	if ((!areThereMonsters || player.stealth.level >= 5) && player.isStealthed == false) {
		player.isStealthed = true
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		combatCount(stealth.cooldown())
		customizeEachWord(`You are now hidden. `, 'gray', line1)
		customizeEachWord(`Seconds until you can act [`, 'white', line1)
		customizeEachWord(`${stealth.cooldown()}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	} else if (player.isStealthed == true) {
		quickMessage(`You are already hidden!`)
	} else {
		quickMessage(`You cannot hide with enemies in the room!`)
	}
}

// function block() {
// 	let line1 = document.createElement('div')
// 	let playerShield = pushItem.find(shield => shield.roomId == 'right hand' || shield.roomId == 'left hand')
// 	if (player.block.level == 0) {
// 		customizeEachWord(`You do not know the `, 'white', line1)
// 		customizeEachWord(`Block `, 'green', line1)
// 		customizeEachWord(`skill`, 'white', line1)
// 	} else if (playerShield != undefined) {
// 		quickMessage(`You throw up your shield to block the next attack`)
// 		player.blocking = true
// 		let blockTimeout = setTimeout(() => {
// 			if (player.blocking == true) {
// 				player.blocking = false
// 				quickMessage(`You lower your shield`)
// 			} else {
// 				clearTimeout(blockTimeout)
// 			}
// 		}, 5000)
// 	} else {
// 		quickMessage(`You must be wielding a shield to use this ability!`)
// 	}
// }

// function enemyBlockCheck() {
// 	if (player.blocking == true) {
// 		let playerShield = pushItem.find(shield => shield.roomId == 'right hand' || shield.roomId == 'left hand')
// 	}
// }

function unhide() {
	if (player.isStealthed == true) {
		player.isStealthed = false
		quickMessage(`You are no longer hidden`)
	} else {
		quickMessage(`You are already not hidden`)
	}
}

function eat(secondCommand) {
	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack')
	let foodItem
	if (isNaN(secondCommand)) {
		foodItem = allItemsInBackpack.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	}else if (!isNaN(secondCommand)) {
		foodItem = allItemsInBackpack.filter(item => item.roomId == 'backpack')[secondCommand - 1]
	}
	if (!foodItem) {
	quickMessage(`You do not have that in your backpack to eat`)
	return
	} else if (!foodItem.type.food) {
		quickMessage(`You cannot eat that!`)
		return
	}
	let line1 = lineFunc()
	if (foodItem.type.food) {
		customizeEachWord(`You ate a `, 'white', line1)
		customizeEachWord(`${foodItem.name}`, foodItem.color, line1)
		applyBuff(foodItem.buff)
		player.rest.healthBonus = foodItem.buff.healthBonus
		player.rest.manaBonus = foodItem.buff.manaBonus
		setTimeout(() => {
			player.rest.healthBonus = 0
			player.rest.manaBonus = 0
			quickMessage(`You are no longer full`)
		}, foodItem.buff.duration)
		let foodIndex = pushItem.indexOf(foodItem)
		pushItem.splice(foodIndex, 1)
		player.backpack.splice(foodIndex, 1)
	} else if (foodItem.type.food) {
		customizeEachWord(`You ate a `, 'white', line1)
		customizeEachWord(`${foodItem.name}`, foodItem.color, line1)
		applyBuff(foodItem.buff)
		player.rest.healthBonus = foodItem.buff.healthBonus
		player.rest.manaBonus = foodItem.buff.manaBonus
		setTimeout(() => {
			player.rest.healthBonus = 0
			player.rest.manaBonus = 0
			quickMessage(`You are no longer full`)
		}, foodItem.buff.duration)
		let foodIndex = pushItem.indexOf(foodItem)
		pushItem.splice(foodIndex, 1)
		player.backpack.splice(foodIndex, 1)
	}
}

function playerAbilityHitChance(monster) {
	let playerLevel = player.level
	let playerAccuracy = player.currentWeaponSkill.accuracy
	let monsterLevel = monster.level
	let monsterDodge = monster.dodge
	let hitChance = playerLevel + playerAccuracy - (monsterDodge + monsterLevel) + 75 <= 0 ? 0 : playerLevel + playerAccuracy - (monsterDodge + monsterLevel) + 75 >= 100 ? 100 : playerLevel + playerAccuracy - (monsterDodge + monsterLevel) + 75
	console.log(hitChance, ' PLAYER HIT CHANCE')
	if (hitChance >= randomNumberRange(1, 100)) {
		return true
	} else {
		return false
	}
}

function smokeBombFunction() {
	let allEnemies = getAllEnemiesInRoom()
	let ability = player.smokeBomb
	player.combat = false
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	for (let i = 0; i < allEnemies.length; i++) {
		allEnemies[i].combat = false
	}
	quickMessage(`POOF`)
	resourceConsumed(ability)
}

function ambushFunction(secondCommand, thirdCommand) {
	if (!player.isStealthed) {
		quickMessage(`You must be stealthed in order to use this ability!`)
		return
	}
	let ability = player.ambush
	let weapon1 = player.currentWeaponRight()
	let weapon2 = player.currentWeaponLeft()
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (weaponUsed[0]) {
		if (weaponUsed[0].skillUsed != 'daggers' || weaponUsed[1].skillUsed != 'daggers') {
			quickMessage(`This ability requires two daggers!`)
			return
		}
	}
	if (!player.combat && ability.cooldown == ability.cooldownSet) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} 
}

function backstabFunction(secondCommand, thirdCommand) {
	let ability = player.backstab
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? weapon1 : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (player.isStealthed || player.combat) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat or stealthed in order to use this ability`, 'white', line1)
	}
}


function guillotineFunction(secondCommand, thirdCommand) {
	let ability = player.guillotine
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (player.isStealthed || player.combat) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat or stealthed in order to use this ability`, 'white', line1)
	}
}
function venomBladeFunction(secondCommand, thirdCommand) {
	let ability = player.venomBlade
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (player.isStealthed || player.combat) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat or stealthed in order to use this ability`, 'white', line1)
	}
}
function contagionFunction(secondCommand, thirdCommand) {
	let ability = player.contagion
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	// let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon2 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let weaponUsed = weapon2
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityCombatCheck()) {return}
	resourceConsumed(ability)
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	const hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else {
			baseDamage = player[ability.refName].damage(targetEnemy)
			penetrationType = calculatePenetrationRoll()
			penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, player.poison)
			applyDebuff(targetEnemy, player.poison)
		}
	resourceConsumed(ability)
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function baneFunction(secondCommand, thirdCommand) {
	let ability = player.bane
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (abilityCombatCheck()) {return}
	sinistralAbilities(ability, weaponUsed, targetEnemy)
}

function shadowVenomFunction(secondCommand, thirdCommand) {
	let ability = player.shadowVenom
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? [weapon1, weapon2] : weapon1 != undefined && weapon2 == undefined ? [weapon1] : weapon1 == undefined && weapon2 != undefined ? [weapon2] : undefined
	if (actionWait()) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	console.log(weaponUsed)
	resourceConsumed(ability)
	applyEnchantmentToWeapon(weaponUsed[0], weaponUsed[1], ability.buff)
}
// function poisonFunction(secondCommand, thirdCommand) {
// 	let ability = player.poison
// 	let abilityName = ability.refName
// 	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
// 	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
// 	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
// 	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? [weapon1, weapon2] : weapon1 != undefined && weapon2 == undefined ? [weapon1] : weapon1 == undefined && weapon2 != undefined ? [weapon2] : undefined
// 	if (actionWait()) {return}
// 	if (doesPlayerHaveAbility(ability)) {return}
// 	if (abilityResourceCheck(ability)) {return}
// 	console.log(weaponUsed)
// 	resourceConsumed(ability)
// 	applyEnchantmentToWeapon(weaponUsed[0], weaponUsed[1], ability.buff)
// }

function shadowDaggersFunction(secondCommand, thirdCommand) {
	let ability = player.shadowDaggers
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let doesApplyShadowMark = false
	let allEnemies = getAllEnemiesInRoom()
	if (checkAvailableEnemy(allEnemies[0])) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	resourceConsumed(ability)
	if (player.isStealthed) {
		player.isStealthed = false
		doesApplyShadowMark = true
	}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	for (let i = 0; i < ability.numberOfHits(); i++) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			baseDamage = player[ability.refName].damage(targetEnemy)
			penetrationType = calculatePenetrationRoll()
			penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			damageBlocked = baseDamage - damageAfterArmor
			if (doesApplyShadowMark) {
				applyDebuff(targetEnemy, player.shadowMark.debuff)
			}
			applyDebuff(targetEnemy, ability.debuff[0])
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, 0)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)				
			// combatCount(weaponSkillSpeed)
			}
	}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()

}

function shadowsurgeFunction(secondCommand, thirdCommand) {
	let ability = player.shadowsurge
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = getAllEnemiesInRoom()[0]
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	resourceConsumed(ability)
	let doesPlayerShadowStep = false
	if (player.combat == false && targetEnemy) {
		player.combat = true
		targetEnemy.combat = true
		doesPlayerShadowStep = true
	}
	if (doesPlayerShadowStep) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed, doesPlayerShadowStep)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			let baseDamage = player[ability.refName].damage(targetEnemy, doesPlayerShadowStep)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, doesPlayerShadowStep)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, player.shadowMark.debuff)
			// combatCount(weaponSkillSpeed)
		}
	}
	if (!doesPlayerShadowStep) {
		let enemiesInRoom = getAllEnemiesInCombat()
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed, doesPlayerShadowStep)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			let baseRegularDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseRegularDamage, penetrationType)
			let damageBlocked = baseRegularDamage - damageAfterArmor
			ability.flavorTextRegularHit(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, doesPlayerShadowStep)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			// ability.flavorTextRegularHit(targetEnemy, weaponUsed, regularDamage, doesPlayerShadowStep)
			// applyDamageToEnemy(targetEnemy, regularDamage)
			let shadowMarkedEnemies = enemiesInRoom.filter(enemy => enemy.debuffs?.shadowMark)
			for (let i = 0; i < shadowMarkedEnemies.length; i++) {
				//THIS CALCULATES THE SHADOW MAGIC DAMAGE FROM THE CONSUMED STACKS
				let baseDamage = player[ability.refName].damage(targetEnemy, doesPlayerShadowStep)
				let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy.shadowResist, player.shadowPen)
				let damageResisted = baseDamage - damageAfterResist
				ability.flavorText(targetEnemy, weaponUsed, damageAfterResist, penetrationFlavorText, damageResisted, doesPlayerShadowStep)
				applyDamageToEnemy(targetEnemy, damageAfterResist)

				// let damageObject = calculateMagicDamage(enemy, spell)
				// let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
				// spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
				// applyDamageToEnemy(enemy, damageAfterMagicResist)

				let enemyStacks = shadowMarkedEnemies[i].debuffs.shadowMark.stacks
				removeDebuff(shadowMarkedEnemies[i], shadowMarkedEnemies[i].debuffs.shadowMark)
				applyBuff(player.shadowsurge.buff)
				player.buffs.shadowbane.stacks = (enemyStacks - 1)  + player.buffs.shadowbane.stacks > player.buffs.shadowbane.maxStacks() ? player.buffs.shadowbane.maxStacks() : (enemyStacks - 1) + player.buffs.shadowbane.stacks
			}
		}

	}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}

function shadowNovaFunction(secondCommand, thirdCommand) {
	let ability = player.shadowNova
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let doesApplyShadowMark = false
	let allEnemies = getAllEnemiesInRoom()
	if (checkAvailableEnemy(allEnemies[0])) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	resourceConsumed(ability)
	if (player.isStealthed) {
		player.isStealthed = false
		doesApplyShadowMark = true
	}
		let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			let allEnemiesInCombat = getAllEnemiesInCombat()
			let targetEnemyIndex = allEnemiesInCombat.indexOf(targetEnemy)
			allEnemiesInCombat.splice(targetEnemyIndex, 1)
			baseDamage = player[ability.refName].damage(targetEnemy)
			penetrationType = calculatePenetrationRoll()
			penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			damageBlocked = baseDamage - damageAfterArmor

			if (player?.buffs?.shadowbane) {
				let shadowbaneStacks = player?.buffs?.shadowbane?.stacks ? player?.buffs?.shadowbane?.stacks : 0
				let splitStacks = Math.floor(shadowbaneStacks / allEnemiesInCombat.length)
				if (splitStacks > 0) {
					for (let i = 0; i < allEnemiesInCombat.length; i++) {
						let newMarkedEnemy = allEnemiesInCombat[i]
						applyDebuff(newMarkedEnemy, player.shadowMark.debuff)
						newMarkedEnemy.debuffs.shadowMark.stacks + (splitStacks - 1) > newMarkedEnemy.debuffs.shadowMark.maxStacks() ? newMarkedEnemy.debuffs.shadowMark.stacks = newMarkedEnemy.debuffs.shadowMark.maxStacks() : newMarkedEnemy.debuffs.shadowMark.stacks += splitStacks - 1
					}
				} else {
					for (let i = 0; i < shadowbaneStacks; i++) {
						let newMarkedEnemy = allEnemiesInCombat[i]
						applyDebuff(newMarkedEnemy, player.shadowMark.debuff)
					}
				}
			}
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, 0)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)				
			// combatCount(weaponSkillSpeed)
			}
	
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()

}


function applyEnchantmentToWeapon(weapon1, weapon2, enchantBuff) {
	if (weapon1 && !weapon1.enchantment[0]) {
		let newBuff = {...enchantBuff}
		let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
		console.log(duration, ' DURATION')
		weapon1.enchantment.push(newBuff)
		newBuff.flavorTextApplyBuff()
		newBuff.timer = setTimeout(() => {
			weapon1.enchantment.splice(0, 1)
			newBuff.flavorTextWearsOff()
		}, duration)
	} else if (weapon1 && weapon1.enchantment[0]) {
		for (let i = 0; i < weapon1.enchantment.length; i++) {
			if (weapon1.enchantment[i].refName == enchantBuff.refName) {
				let updatedStacks = weapon1.enchantment[i].stacks > enchantBuff.stacks ? weapon1.enchantment[i].stacks : enchantBuff.stacks
				let newBuff = {...enchantBuff}
				let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
				console.log(duration, ' DURATION')

				clearTimeout(weapon1.enchantment[i].timer)
				weapon1.enchantment.splice(i, 1)
				weapon1.enchantment.push(newBuff)
				newBuff.stacks = updatedStacks
				newBuff.flavorTextApplyBuff()
				newBuff.timer = setTimeout(() => {
					weapon1.enchantment.splice(i, 1)
					newBuff.flavorTextWearsOff()
				}, duration)
			}
		}
	}
	if (weapon2 && !weapon2.enchantment[0]) {
		let newBuff = {...enchantBuff}
		weapon2.enchantment.push(newBuff)
		newBuff.flavorTextApplyBuff()
		let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
		console.log(duration, ' DURATION')

		newBuff.timer = setTimeout(() => {
			weapon2.enchantment.splice(0, 1)
			newBuff.flavorTextWearsOff()
		}, duration)
	} else if (weapon2 && weapon2.enchantment[0]) {
		for (let i = 0; i < weapon2.enchantment.length; i++) {
			if (weapon2.enchantment[i].refName == enchantBuff.refName) {
				let updatedStacks = weapon2.enchantment[i].stacks > enchantBuff.stacks ? weapon2.enchantment[i].stacks : enchantBuff.stacks
				let newBuff = {...enchantBuff}
				let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
				console.log(duration, ' DURATION')

				clearTimeout(weapon2.enchantment[i].timer)
				weapon2.enchantment.splice(i, 1)
				weapon2.enchantment.push(newBuff)
				newBuff.stacks = updatedStacks
				newBuff.flavorTextApplyBuff()
				newBuff.timer = setTimeout(() => {
					weapon2.enchantment.splice(i, 1)
					newBuff.flavorTextWearsOff()
				}, duration)
			}
		}
	}




	// let weaponArray = [weapon1, weapon2]
	// if (Array.isArray(weaponArray)) {
	// 	weaponArray.forEach(weapon => {
	// 		if (!weapon.enchantment[0]) {
	// 			quickMessage(`first ran`)
	// 			let line1 = lineFunc()
	// 			customizeEachWord(`You enchant your `, 'white', line1)
	// 			customizeEachWord(`${weapon.name} `, weapon.color, line1)
	// 			customizeEachWord(`with `, 'white', line1)
	// 			customizeEachWord(`${enchantBuff.name}`, enchantBuff.color, line1)
	// 			customizeEachWord(`!`, 'white', line1)
	// 			weapon.enchantment.push(enchantBuff)
	// 			let index = weapon.enchantment.indexOf(enchantBuff)
	// 			weapon.enchantment[index].timer = setTimeout(() => {
	// 				let line1 = lineFunc()
	// 				customizeEachWord(`${enchantBuff.name} `, enchantBuff.color, line1)
	// 				customizeEachWord(`wears off first`, `white`, line1)
	// 				weapon.enchantment.splice(index, 1)
	// 			}, enchantBuff.duration)

	// 		} else {
	// 			quickMessage(`second ran`)
	// 			console.log(weapon)
	// 			weapon.enchantment.forEach((enchant, ind) => {
	// 				console.log(enchant, ' enchant')
	// 				console.log(enchantBuff, ' ENCHANT BUFF ENCHANT BUFF')
	// 				quickMessage(`Index foreach: ${ind}`)
	// 				quickMessage(`Enchant name of second application: ${enchant.name}`)
	// 				if (enchant.refName == 'poison') {
	// 					clearTimeout(enchant.timer)
	// 					let previousStacks = enchant.stacks > enchantBuff.stacks? enchant.stacks : enchantBuff.stacks
	// 					quickMessage(`You reapply ${enchantBuff.name} to your ${weapon.name}`)
	// 					let index = weapon.enchantment.indexOf(enchant)
	// 					quickMessage(`Index indexOf custom assign: ${index}`)
	// 					weapon.enchantment.splice(index, 1)
	// 					weapon.enchantment.push(enchantBuff)
	// 					enchantBuff.stacks = previousStacks
	// 					weapon.enchantment[index].timer = setTimeout(() => {
	// 						let index2 = weapon.enchantment.indexOf(enchantBuff)
	// 						let line1 = lineFunc()
	// 						customizeEachWord(`${enchantBuff.name} `, enchantBuff.color, line1)
	// 						customizeEachWord(`wears off second`, `white`, line1)
	// 						weapon.enchantment.splice(index2, 1)
	// 					}, enchantBuff.duration)
	// 				}
	// 				if (enchant.refName == 'shadowVenom') {
	// 					quickMessage(`You reapply ${enchantBuff.name} to your ${weapon.name}`)
	// 					clearTimeout(enchant.timer)
	// 					let index = weapon.enchantment.indexOf(enchant)
	// 					weapon.enchantment.splice(index, 1)
	// 					weapon.enchantment.push(enchantBuff)
	// 					weapon.enchantment[index].timer = setTimeout(() => {
	// 						let line1 = lineFunc()
	// 						customizeEachWord(`${enchantBuff.name} `, enchantBuff.color, line1)
	// 						customizeEachWord(`wears off`, `white`, line1)
	// 						weapon.enchantment.splice(index, 1)
	// 					}, enchantBuff.duration)
	// 				}
	// 			})
	// 		}
	// 	})
	
	// } else {
	// 	quickMessage(`You are not wielding the proper weapons to enchant`)
	// }
}



function abilityQueueCheck() {
		if (player.isAbilityQueued) {
			let line1 = lineFunc()
			customizeEachWord(`You are currently gathering energy for another ability!`, 'white', line1)
			updateScroll()
			return true
		} else {
			return false
		}
}

function abilityCooldownCheck(ability) {
	let isAnyAbilityOnCooldown = false
	let abilityOnCooldown = ability
	for (let property in player) {
		if (player[property].onCooldown) {
			isAnyAbilityOnCooldown = true
			abilityOnCooldown = player[property]
		}
	}
	let cooldown = abilityOnCooldown.cooldown / 1000
	if (isAnyAbilityOnCooldown) {
		let line1 = lineFunc()
		customizeEachWord(`Your abilities are still on cooldown for `, 'white', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${(Math.ceil(cooldown * 10) / 10).toFixed(1)}`, 'yellow', line1)
		customizeEachWord(`] `, 'white', line1)
		customizeEachWord(`seconds!`, 'white', line1)
		return true
	}
}

function abilityCombatCheck() {
	if (player.combat != true) {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat to use this ability`, 'white', line1)
		return true
	}
}
function doesPlayerHaveAbility(ability) {
	if (ability.level == 0) {
		let line1 = lineFunc()
		customizeEachWord(`You do not know this ability`, 'white', line1)
		return true
	}
}
function abilityResourceCheck(ability) {
	let line1 = lineFunc()
	if (typeof(ability.resourceCost) == 'function' && player[ability.resourceName] - ability.resourceCost() < 0) {
		blankSpace()
		customizeEachWord(`You do not have enough ${capitalizeFirstLetter(ability.resourceName)} to perform this ability`, 'white', line1)
		return true
	} else if (player[ability.resourceName] - ability.resourceCost < 0) {
		customizeEachWord(`You do not have enough ${capitalizeFirstLetter(ability.resourceName)} to perform this ability`, 'white', line1)
		blankSpace()
		return true
	}
}



function loseResource(resourceName, resourceCost) {
	player[resourceName] = player[resourceName] - resourceCost
	updateResource()
}

function resourceConsumed(ability) {
	if (typeof(ability.resourceCost) == 'function') {
		player[ability.resourceName] -= ability.resourceCost()
	} else {
		player[ability.resourceName] -= ability.resourceCost
	}
	updateResource()
}
function resourceGained(ability, amountGained, maxResource) {
	if (player[ability.resourceName] + amountGained > player[maxResource]) {
		player[ability.resourceName] = player[maxResource]
	} else {
		player[ability.resourceName] += amountGained
	}
	updateResource()
}


function gainClassResourceOnAttack(doesSwingHit) {
	if (!doesSwingHit) {
		return
	}
	let resource
	let maxResource
	let resourceGain
	if (player.guild == 'Warrior') {
		resource = 'might'
		maxResource = 'maxMight'
		resourceGain = 1
	}
	if (player.guild == 'Monk') {
		resource = 'focus'
		maxResource = 'maxFocus'
		resourceGain = 2
	}
	if (player.guild == 'Ranger') {
		resource = 'focus'
		maxResource = 'maxFocus'
		resourceGain = 3
	}
	if (player.guild == 'Sinistral') {
		resource = 'adrenaline'
		maxResource = 'maxAdrenaline'
		resourceGain = 5
	}
	player[resource] + resourceGain > player[maxResource] ? player[maxResource] : player[resource] += resourceGain
	updateResource()
}

function addSinisterMark(monster) {
	let sinisterMarks = 'sinisterMarks'
	if (player.playerClass.name == 'Thief') {
		if (monster.hasOwnProperty(sinisterMarks)) {
			if (monster.sinisterMarks != player.sinisterMarksMax) {
			monster[sinisterMarks]++
			}
		} else {
			monster[sinisterMarks] = 1
		}
	}
	console.log(`${monster.sinisterMarks} SINISTER MARKS`)
}


function abilityWindUpText(ability) {
	let line1 = lineFunc()
	customizeEachWord(`You begin gathering energy for `, 'white', line1)
	customizeEachWord(`${ability.name}`, ability.color, line1)
}

function abilityWeaponsCheck(ability, weaponUsed) {
	let weaponSkillsUsed = []
	if (Array.isArray(weaponUsed)) {
		for (let i = 0; i < weaponUsed.length; i++) {
			weaponSkillsUsed.push(weaponUsed[i].skillUsed)
		}
	}
	console.log(weaponUsed)
	if (Array.isArray(weaponUsed)) {
		if (!ability.weaponTypesUsed.some(element => weaponSkillsUsed.includes(element))) {
			let line1 = lineFunc()
			customizeEachWord(`You must be wielding the appropriate weapons to perform `, 'white', line1)
			customizeEachWord(`${ability.name}`, ability.color, line1)
			blankSpace()
			return true
		}
	} else if (!weaponUsed || !ability.weaponTypesUsed.some(element => weaponUsed.skillUsed.includes(element))) {
		let line1 = lineFunc()
		customizeEachWord(`You must be wielding the appropriate weapons to perform `, 'white', line1)
		customizeEachWord(`${ability.name}`, ability.color, line1)
		blankSpace()
		return true
	}
}

function tauntingShoutFunction() {
	let ability = player.tauntingShout
	if (ability.level > 0) {
		player.combat = true
		resourceConsumed(ability)
		let allEnemiesInRoom = getAllEnemiesInRoom()
		allEnemiesInRoom.forEach(enemy => {
			enemy.combat = true
		})
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You let out a `, 'white', line1)
		customizeEachWord(`Taunting Shout`, ability.color, line1)
		customizeEachWord(`, taunting every enemy to attack you!`, 'white', line1)
		blankSpace()
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You do not know the ability `, 'white', line1)
		customizeEachWord(`Taunting Shout`, ability.color, line1)
		customizeEachWord(`.`, 'white', line1)
	}
}

function ripslashFunction(secondCommand, thirdCommand) {
	let ability = player.ripslash
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
	//windup
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				resourceConsumed(ability)
				initiateAbilityCooldown(ability)
				return
			}
			if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let numberOfSwings = ability.numberOfSwings()
				let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
				player.isAbilityQueued = false
				player[abilityName].queued = false
				resourceConsumed(ability)
				for (let i = 0; i < numberOfSwings; i++) {
					let hitChance = playerAbilityHitChance(targetEnemy)
					if (hitChance == false) {
						ability.flavorTextMiss(targetEnemy, weaponUsed)
					} else if (hitChance == true && targetEnemy.health > 0) {
					let	baseDamage = player[abilityName].damage(targetEnemy)
					let	penetrationType = calculatePenetrationRoll()
					let	penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					let	damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					let	damageBlocked = baseDamage - damageAfterArmor
					ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
					applyDamageToEnemy(targetEnemy, damageAfterArmor)
						if (targetEnemy?.debuffs?.bleed) {
							applyDebuff(targetEnemy, player.bleed)
						}
					}
				}
			} else {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(ability)
				}
			updateScroll()
		}, ability.windUp * 1000)
}

function cycloneFunction() {
		let ability = player.cyclone
		let abilityName = player.cyclone.refName
		let weaponTypesToCheck = player[abilityName].weaponTypesUsed
		let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
		let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
		let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
		if (doesPlayerHaveAbility(ability)) {return}
		if (abilityWeaponsCheck(ability, weaponUsed)) {return}
		if (abilityResourceCheck(ability)) {return}
		if (abilityCooldownCheck(ability)) {return}
		if (abilityQueueCheck(ability)) {return}
		ability.windUpText()
		player.isAbilityQueued = true
		initiateAbilityWindup(ability)
			setTimeout(() => {
				if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(ability)
					return
				}
				if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
					let meleeCombatMonsters = getAllEnemiesInCombat()
					let numberOfTargets = Math.min(ability.numberOfTargets(), meleeCombatMonsters.length)
					resourceConsumed(ability)
					console.log(numberOfTargets, ' NUMBER OF TARGETS')
					player[abilityName].queued = false
					player.isAbilityQueued = false
					ability.flavorText2(weaponUsed) //This flavor text is for abilities that hit multiple enemies
					for (let i = 0; i < numberOfTargets; i++) {
						let targetEnemy = meleeCombatMonsters[i]
						let hitChance = playerAbilityHitChance(targetEnemy)
						if (hitChance == false) {
							ability.flavorTextMiss(targetEnemy, weaponUsed)
						} else if (hitChance == true) {
							baseDamage = player[abilityName].damage(targetEnemy)
							penetrationType = calculatePenetrationRoll()
							penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
							damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
							damageBlocked = baseDamage - damageAfterArmor
							ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
							applyDamageToEnemy(targetEnemy, damageAfterArmor)
							applyDebuff(targetEnemy, player.bleed)
						}
					}
				} else {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(player[abilityName])
				}
				updateScroll()
			}, ability.windUp * 1000)
	}

function cataclysmFunction(secondCommand, thirdCommand) {
	let ability = player.cataclysm
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			let enemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(enemy)
			resourceConsumed(ability)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			if (hitChance == false) {
				ability.flavorTextMiss(enemy, weaponUsed)
			} else if (hitChance == true) {
				let allEnemiesInRoom = getAllEnemiesInRoom()
				let mainEnemyIndex = allEnemiesInRoom.indexOf(enemy)
				let additionalEnemy1
				let additionalEnemy2
				let baseDamage = ability.damage(enemy)
				let additionalEnemyBaseDamage = Math.ceil(baseDamage * 0.5)
				let penetrationType = calculatePenetrationRoll()
				let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
				let damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(enemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(enemy, damageAfterArmor)
				applyDebuff(enemy, ability.debuff)
				if (allEnemiesInRoom[2]) {
					if (mainEnemyIndex == 0) {
						//Additional enemies are the two after the main target
						additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex + 1]
						additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 2]
					} else if (mainEnemyIndex == allEnemiesInRoom.length - 1) {
						//additional enemies are the two before the main target
						additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
						additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex - 2]
					} else {
						//additional enemies are ones before and one after the main target
						additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
						additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 1]
					}
					let additionalDamage1 = calculateAbilityDamageAgainstEnemyArmor(enemy, additionalEnemyBaseDamage, penetrationType)
					let damageBlocked1 = additionalEnemyBaseDamage - additionalDamage1
					ability.specialEffect(additionalEnemy1, additionalDamage1, penetrationFlavorText, damageBlocked1)
					applyDamageToEnemy(additionalEnemy1, additionalDamage1)
					applyDebuff(additionalEnemy1, ability.debuff)
					let additionalDamage2 = calculateAbilityDamageAgainstEnemyArmor(enemy, additionalEnemyBaseDamage, penetrationType)
					let damageBlocked2 = additionalEnemyBaseDamage - additionalDamage2
					ability.specialEffect(additionalEnemy2, additionalDamage2, penetrationFlavorText, damageBlocked2)
					applyDamageToEnemy(additionalEnemy2, additionalDamage2)
					applyDebuff(additionalEnemy2, ability.debuff)
				} else if (allEnemiesInRoom[1]) {
					if (mainEnemyIndex == 0) {
						additionalEnemy1 = allEnemiesInRoom[1]
					} else if (mainEnemyIndex == 1) {
						additionalEnemy1 = allEnemiesInRoom[0]
					}
					let additionalDamage1 = calculateAbilityDamageAgainstEnemyArmor(enemy, additionalEnemyBaseDamage, penetrationType)
					let damageBlocked1 = additionalEnemyBaseDamage - additionalDamage1
					ability.specialEffect(additionalEnemy1, additionalDamage1, penetrationFlavorText, damageBlocked1)
					applyDamageToEnemy(additionalEnemy1, additionalDamage1)
					applyDebuff(additionalEnemy1, ability.debuff)
				}













			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, ability.windUp * 1000)
	}

function dualStrikeFunction(secondCommand, thirdCommand) {
	const ability = player.dualStrike
	if (player.currentWeaponRight().skillUsed != 'oneHanded' && player.currentWeaponLeft().skillUsed != 'oneHanded') {
		let line1 = lineFunc()
		customizeEachWord(`You must be dual wielding to use `, 'white', line1)
		customizeEachWord(`${ability.name}`, ability.color, line1)
		return
	}
	let timeoutInterval = ability.windUp * 1000
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName]) && (player.currentWeaponRight().skillUsed != 'oneHanded' && player.currentWeaponLeft().skillUsed != 'oneHanded')) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(targetEnemy)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			resourceConsumed(ability)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				baseDamage = player[abilityName].damage()
				penetrationType = calculatePenetrationRoll()
				penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				applyDebuff(targetEnemy, ability.debuff)
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, timeoutInterval)
	}



function bladeBlitzFunction(secondCommand, thirdCommand) {
	let ability = player.bladeBlitz
	let abilityName = ability.refName
	let timeoutInterval = ability.windUp * 1000
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])	
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(ability)) {
			player[abilityName].cooldown = ability.cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && ability.cooldown == player[abilityName].cooldownSet) {
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			for (let i = 0; i < ability.numberOfSwings(); i++) {
				if (targetEnemy.health <= 0) {return}
				let hitChance = playerAbilityHitChance(targetEnemy)
				if (hitChance == false) {
					ability.flavorTextMiss(targetEnemy)
				} else if (hitChance == true) {
					baseDamage = player[abilityName].damage(targetEnemy)
					penetrationType = calculatePenetrationRoll()
					penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					damageBlocked = baseDamage - damageAfterArmor
					ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
					// if (Array.isArray(weaponUsed)) {
					// 		if (weaponUsed[0]?.enchantment) {
					// 			for (let enchant in weaponUsed[0].enchantment) {
					// 				let enchantmentDamage = weaponUsed[0].enchantment[enchant].damage(targetEnemy)
					// 				let resistType = weaponUsed[0].enchantment[enchant].resistType
					// 				let penType = weaponUsed[0].enchantment[enchant].penType
					// 				let element = weaponUsed[0].enchantment[enchant].element
					// 				let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, targetEnemy[resistType], player[penType])
					// 				let damageResisted = enchantmentDamage - damageAfterResist
					// 				weaponUsed[0].enchantment[enchant].flavorText(targetEnemy, damageAfterResist, element, damageResisted)
					// 			}
					// 		}
					// 		if (weaponUsed[1]?.enchantment) {
					// 			for (let enchant in weaponUsed[1].enchantment) {
					// 				let enchantmentDamage = weaponUsed[1].enchantment[enchant].damage(targetEnemy)
					// 				let resistType = weaponUsed[1].enchantment[enchant].resistType
					// 				let penType = weaponUsed[1].enchantment[enchant].penType
					// 				let element = weaponUsed[1].enchantment[enchant].element
					// 				let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, targetEnemy[resistType], player[penType])
					// 				let damageResisted = enchantmentDamage - damageAfterResist
					// 				weaponUsed[1].enchantment[enchant].flavorText(targetEnemy, damageAfterResist, element, damageResisted)
					// 			}
					// 		}
					// 	} else {
					// 		if (weaponUsed?.enchantment) {
					// 			for (let enchant in weaponUsed.enchantment) {
					// 				let enchantmentDamage = weaponUsed.enchantment[enchant].damage(targetEnemy)
					// 				let resistType = weaponUsed.enchantment[enchant].resistType
					// 				let penType = weaponUsed.enchantment[enchant].penType
					// 				let element = weaponUsed.enchantment[enchant].element
					// 				let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, targetEnemy[resistType], player[penType])
					// 				let damageResisted = enchantmentDamage - damageAfterResist
					// 				weaponUsed.enchantment[enchant].flavorText(targetEnemy, damageAfterResist, element, damageResisted)
					// 			}
					// 		}
					// 	}


					applyDamageToEnemy(targetEnemy, damageAfterArmor)
				}
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(player[abilityName])
		}
		resourceConsumed(ability)
		updateScroll()
	}, timeoutInterval)
}

function shredFunction(secondCommand, thirdCommand) {
	let ability = player.shred
	if (!player.currentWeaponRight().skillUsed == 'oneHanded' || !player.currentWeaponLeft().skillUsed == 'oneHanded') {
		let line1 = lineFunc()
		customizeEachWord(`You must be `, 'white', line1)
		customizeEachWord(`dual wielding `, 'yellow', line1)
		customizeEachWord(`to use `, 'white', line1)
		customizeEachWord(`${ability.name}`, ability.color, line1)
		return
	}
	let timeoutInterval = ability.windUp * 1000
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	// if (actionWait()) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			resourceConsumed(ability)
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(targetEnemy)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let allEnemies = getAllEnemiesInCombat()
				if (allEnemies[1]) {
					for (let i = 0; i < 2; i++) {
						baseDamage = player[abilityName].damage(allEnemies[i])
						penetrationType = calculatePenetrationRoll()
						penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(allEnemies[i], baseDamage, penetrationType)
						damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(allEnemies[i], weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(allEnemies[i], damageAfterArmor)
						applyDebuff(allEnemies[i], ability.debuff)
					}
				} else {
					baseDamage = player[abilityName].damage()
					penetrationType = calculatePenetrationRoll()
					penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					damageBlocked = baseDamage - damageAfterArmor
					ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
					applyDamageToEnemy(targetEnemy, damageAfterArmor)
					applyDebuff(targetEnemy, ability.debuff)
				}
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, timeoutInterval)
}



function valorStrikeFunction(secondCommand, thirdCommand) {
	let ability = player.valorStrike
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
	//windup
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(targetEnemy)
			player.isAbilityQueued = false
			player[abilityName].queued = false
			resourceConsumed(ability)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				baseDamage = player[abilityName].damage()
				penetrationType = calculatePenetrationRoll()
				penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				applyBuff(ability.buff)
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, ability.windUp * 1000)
}

function shieldSlamFunction() {
	let ability = player.shieldSlam
	let abilityName = ability.refName
	let timeoutInterval = ability.windUp * 1000
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	console.log(weaponUsed)
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
				return
			}
			if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let allEnemiesInCombat = getAllEnemiesInCombat()
				let numberOfEnemies = allEnemiesInCombat.length
				let abilityTargetsMax = ability.numberOfTargets()
				let numberOfTargets = Math.min(numberOfEnemies, abilityTargetsMax)
				let baseDamage = player[abilityName].damage()
				let damagePerEnemy = Math.ceil(baseDamage / numberOfTargets)
				player[abilityName].queued = false
				player.isAbilityQueued = false
				ability.flavorText2(weaponUsed)
				for (let i = 0; i < numberOfTargets; i++) {
					let targetEnemy = allEnemiesInCombat[i]
					let hitChance = playerAbilityHitChance(targetEnemy)
					if (hitChance == false) {
						ability.flavorTextMiss(targetEnemy, weaponUsed)
					} else if (hitChance == true) {
						penetrationType = calculatePenetrationRoll()
						penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, damagePerEnemy, penetrationType)
						damageBlocked = damagePerEnemy - damageAfterArmor
						console.log(penetrationType)
						console.log(damageAfterArmor)
						console.log(damageBlocked)
						console.log(damagePerEnemy)
						console.log(baseDamage)
						ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(targetEnemy, damageAfterArmor)
						applyDebuff(targetEnemy, ability.debuff)
					}
				} 
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
			}
			resourceConsumed(ability)
		}, timeoutInterval)
	}

function boomingMightFunction() {
	let ability = player.boomingMight
	let abilityName = ability.refName
	let timeoutInterval = ability.windUp * 1000
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	console.log(weapon1, ' WEAPON 1')
	console.log(weapon2, ' WEAPON 2')
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let allEnemiesInCombat = getAllEnemiesInCombat()
				let numberOfEnemies = allEnemiesInCombat.length
				let baseDamage = player[abilityName].damage()
				// let damagePerEnemy = Math.ceil(baseDamage / numberOfEnemies)
				player[abilityName].queued = false
				player.isAbilityQueued = false
				ability.flavorText2()
				allEnemiesInCombat.forEach(enemy => {
					let hitChance = playerAbilityHitChance(enemy)
					if (hitChance == false) {
						ability.flavorTextMiss(enemy)
					} else if (hitChance == true) {
						penetrationType = calculatePenetrationRoll()
						penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
						damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(enemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(enemy, damageAfterArmor)
						applyBuff(ability.buff)
					}
				})
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(player.boomingMight)
				updateScroll()
			}
			resourceConsumed(ability)
		}, timeoutInterval)
	}
//MONK MONK MONK MONK MONK MONK MONK MONK MONK MONK
// function empoweringStrikeFunction(secondCommand, thirdCommand) {
// 	let ability = player.empoweringStrike
// 	let abilityName = player.empoweringStrike.refName
// 	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
// 	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
// 	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
// 	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
// 	if (doesPlayerHaveAbility(player[abilityName])) {return}
// 	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
// 	if (abilityResourceCheck(player[abilityName])) {return}
// 	if (abilityCooldownCheck(player[abilityName])) {return}
// 	if (abilityCombatCheck()) {return}
// 	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
// 	let hitChance = playerAbilityHitChance(targetEnemy)
// 			if (hitChance == false) {
// 				ability.flavorTextMiss(targetEnemy, weaponUsed)
// 			} else if (hitChance == true) {
// 			let totalDamage = player[abilityName].damage(weapon1, weapon2)
// 			ability.flavorText(targetEnemy, weaponUsed, totalDamage)
// 			applyDamageToEnemy(targetEnemy, totalDamage)
// 			updateScroll()
// 			}
// 	}
function catalystFunction(secondCommand, thirdCommand) {
	let ability = player.catalyst
	let abilityName = player.catalyst.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	resourceConsumed(ability)
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
		player[abilityName].damage(targetEnemy)
		updateScroll()
		}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}

function tempestFunction(secondCommand, thirdCommand) {
	let ability = player.tempest
	let abilityName = player.tempest.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	resourceConsumed(ability)
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			player[abilityName].damage(targetEnemy)
			player.catalyst.sequence = 0
		}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function callOfWindFunctionRanged(secondCommand, thirdCommand) {
	let ability = player.callOfWind
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityCombatCheck()) {return}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	if (player.combat) {
		let line1 = lineFunc()
		customizeEachWord(`You cannot use this ability while engaged with an enemy.`, 'white', line1)
		return
	}
	let hitChance = playerAbilityHitChance(targetEnemy)
	if (hitChance == false) {
		//miss text needs to be for throwing out call of wind
		ability.flavorTextMissRanged(targetEnemy, weaponUsed)
	} else if (hitChance == true) {
		let baseDamage = player[abilityName].damageRanged(targetEnemy)
		let penetrationType = 'wind'
		let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy.windResist, player.windPen)
		let damageResisted = baseDamage - damageAfterResist
		ability.flavorTextRanged(targetEnemy, damageAfterResist, penetrationType, damageResisted)
		applyDamageToEnemy(targetEnemy, damageAfterResist)
		applyDebuff(targetEnemy, ability.debuff)
	}
	resourceConsumed(ability)
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function callOfWindFunctionCombat(secondCommand, thirdCommand) {
	let ability = player.callOfWind
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityCombatCheck()) {return}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	let targetEnemyWithDebuff = getAllEnemiesInRoom().find(enemy => enemy?.debuffs?.['callOfWind'])
	if (!targetEnemyWithDebuff) {
		let line1 = lineFunc()
		customizeEachWord(`You can only use this ability against an enemy affected with `, 'white', line1)
		customizeEachWord(`Call Of Wind`, ability.color, line1)
		customizeEachWord(`.`, 'white', line1)
		return
	}
	if (targetEnemyWithDebuff) {
		let hitChance = playerAbilityHitChance(targetEnemyWithDebuff)
		if (hitChance == false) {
			player.combat = true
			targetEnemyWithDebuff.combat = true
			ability.flavorTextMissCombat(targetEnemyWithDebuff, weaponUsed)
		} else if (hitChance == true) {
			player.combat = true
			targetEnemyWithDebuff.combat = true
			let baseDamage = player[ability.refName].damageCombat(targetEnemyWithDebuff)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemyWithDebuff, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorTextCombat(targetEnemyWithDebuff, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemyWithDebuff, damageAfterArmor)
			removeDebuff(targetEnemy, ability.debuff)
		}
		resourceConsumed(ability)
	} 
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function knuckleBlitzFunction(secondCommand, thirdCommand) {
	let ability = player.knuckleBlitz
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityCombatCheck()) {return}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	let comboCollectorStacks = player?.buffs?.comboCollector?.stacks ? player?.buffs?.comboCollector?.stacks + 1 : 1
	for (let i = 0; i < comboCollectorStacks; i++) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else {
			let baseDamage = player[abilityName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
		}
	}
	removeBuff(player.buffs.comboCollector)
	delete player.buffs.comboCollector
	resourceConsumed(ability)
	updateScroll()
}
	
function fireSealFunction(secondCommand, thirdCommand) {
	let ability = player.fireSeal
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let baseDamage = player[ability.refName].damage(targetEnemy)
				let penetrationType = calculatePenetrationRoll()
				let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				let damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				applyDebuff(targetEnemy, ability.debuff)
			}
			resourceConsumed(ability)
			updateScroll()
	}
function waterSealFunction(secondCommand, thirdCommand) {
	let ability = player.waterSeal
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, ability.debuff)
		}
		resourceConsumed(ability)
		updateScroll()	
	}
function earthSealFunction(secondCommand, thirdCommand) {
	let ability = player.earthSeal
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, ability.debuff)
		}
		resourceConsumed(ability)
		updateScroll()	
	}
function mysticFistFunction(secondCommand, thirdCommand) {
	let ability = player.mysticFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let numberOfSwings = 1
	for (let buff in player.buffs) {
		if (player.buffs[buff].seal) {
			numberOfSwings++
		}
	}
	for (let i = 0; i < numberOfSwings; i++) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[abilityName].damage(targetEnemy)
			let penetrationType = 'lightning'
			let damageAfterMagResist = calculateMagicDamageWithResist(baseDamage, targetEnemy.lightningResist, player.lightningPen)
			let damageBlocked = baseDamage - damageAfterMagResist
			ability.flavorText(targetEnemy, weaponUsed, damageAfterMagResist, penetrationType, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterMagResist)
			applyBuff(ability.buff)
			}
		}
		resourceConsumed(ability)
		updateScroll()	
	}
function unleashedPowerFunction(secondCommand, thirdCommand) {
	let ability = player.unleashedPower
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemies = getAllEnemiesInRoom(secondCommand, thirdCommand)
	let numberOfTargets = 1
	for (let buff in player.buffs) {
		if (player.buffs[buff].seal) {
			numberOfTargets++
		}
	}
	numberOfTargets = numberOfTargets > targetEnemies.length ? targetEnemies.length : numberOfTargets
	for (let i = 0; i < numberOfTargets; i++) {
		let hitChance = playerAbilityHitChance(targetEnemies[i])
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemies[i], weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[abilityName].damage(targetEnemies[i])
			let penetrationType = 'lightning'
			let damageAfterMagicResist = calculateMagicDamageWithResist(baseDamage, targetEnemies[i].lightningResist, player.lightningPen)
			let damageResisted = baseDamage - damageAfterMagicResist
			ability.flavorText(targetEnemies[i], weaponUsed, damageAfterMagicResist, penetrationType, damageResisted)
			applyDamageToEnemy(targetEnemies[i], damageAfterMagicResist)
			applyBuff(ability.buff)
			}
		}
		resourceConsumed(ability)
		updateScroll()	
	}


function blazingFistFunction(secondCommand, thirdCommand) {
	let ability = player.blazingFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
	}
function tidalFistFunction(secondCommand, thirdCommand) {
	let ability = player.tidalFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
}

function quakeFistFunction(secondCommand, thirdCommand) {
	let ability = player.quakeFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
}

function lightningFistFunction(secondCommand, thirdCommand) {
	let ability = player.lightningFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
}
function elementalTempestFunction(secondCommand, thirdCommand) {
	let ability = player.elementalTempest
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let baseDamage = player[ability.refName].damage(targetEnemy)
				let penetrationType = calculatePenetrationRoll()
				let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				let damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				if (targetEnemy?.debuffs?.hydroplosion) {
					//splash aoe
					let line1 = lineFunc()
					let combatEnemies = getAllEnemiesInCombat()
					let baseDamage = player[abilityName].hydroplosionDamage()
					let penetrationType = targetEnemy.debuffs.hydroplosion.element
					let enemyResistType = penetrationType == 'fire' ? 'fireResist' : 'waterResist'
					let playerPenType = penetrationType == 'fire' ? 'firePen' : 'waterPen'
					let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy[enemyResistType], player[playerPenType])
					let damageResisted = baseDamage - damageAfterResist
					applyDamageToEnemy(targetEnemy, damageAfterResist)
					customizeEachWord(`Elemental Tempest reacts with the energy from Hydroplosion!`, `monk-ability-text-color`, line1)	
					ability.flavorTextHydroplosion(targetEnemy, damageAfterResist, penetrationType, damageResisted)
					applyBuff(targetEnemy.debuffs.hydroplosion)	
					removeDebuff(targetEnemy, targetEnemy.debuffs.hydroplosion)
					delete targetEnemy.debuffs.hydroplosion
					let mainEnemyIndex = combatEnemies.indexOf(targetEnemy)
					let additionalEnemyIndex1 = mainEnemyIndex == 0 ? 2 : mainEnemyIndex - 1
					let additionalEnemyIndex2 = mainEnemyIndex + 1
					if (combatEnemies[additionalEnemyIndex2]) {
						let splitDamage = Math.ceil(baseDamage / 2)
						let damageAfterResist = calculateMagicDamageWithResist(splitDamage, combatEnemies[additionalEnemyIndex2][enemyResistType], player[playerPenType])
						let damageResisted = splitDamage - damageAfterResist
						ability.flavorTextHydroplosionAdditionalTargets(combatEnemies[additionalEnemyIndex2], damageAfterResist, penetrationType, damageResisted)
						applyDamageToEnemy(combatEnemies[additionalEnemyIndex2], damageAfterResist)
					}
					if (combatEnemies[additionalEnemyIndex1]) {
						let splitDamage = Math.ceil(baseDamage / 2)
						let damageAfterResist = calculateMagicDamageWithResist(splitDamage, combatEnemies[additionalEnemyIndex1][enemyResistType], player[playerPenType])
						let damageResisted = splitDamage - damageAfterResist
						ability.flavorTextHydroplosionAdditionalTargets(combatEnemies[additionalEnemyIndex1], damageAfterResist, penetrationType, damageResisted)
						applyDamageToEnemy(combatEnemies[additionalEnemyIndex1], damageAfterResist)
					}
				}
				if (targetEnemy?.debuffs?.thunderBlaze) {
					//combat aoe
					let line1 = lineFunc()
					customizeEachWord(`Elemental Tempest reacts with the energy from Thunder Blaze!`, `monk-ability-text-color`, line1)
					let baseDamage = player[abilityName].thunderBlazeDamage()
					let allEnemies = getAllEnemiesInCombat()
					let damageSplit = baseDamage / allEnemies.length
					for (let i = 0; i < allEnemies.length; i++) {
						let penetrationType = targetEnemy.debuffs.thunderBlaze.element
						let enemyResistType = penetrationType == 'fire' ? 'fireResist' : 'lightningResist'
						let playerPenType = penetrationType == 'fire' ? 'firePen' : 'lightningPen'
						let damageAfterResist = calculateMagicDamageWithResist(damageSplit, allEnemies[i][enemyResistType], player[playerPenType])
						let damageResisted = damageSplit - damageAfterResist
						applyDamageToEnemy(allEnemies[i], damageAfterResist)	
						ability.flavorTextThunderBlaze(allEnemies[i], damageAfterResist, penetrationType, damageResisted)
					}
					removeDebuff(targetEnemy, targetEnemy.debuffs.thunderBlaze)
					applyBuff(thunderBlazeBuff)			
					delete targetEnemy.debuffs.thunderBlaze
				}
				if (targetEnemy?.debuffs?.aquaVolt) {
					//single target
					let baseDamage = player[abilityName].aquaVoltDamage()
					let penetrationType = targetEnemy.debuffs.aquaVolt.element
					let enemyResistType = penetrationType == 'water' ? 'waterResist' : 'lightningResist'
					let playerPenType = penetrationType == 'water' ? 'waterPen' : 'lightningPen'
					let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy[enemyResistType], player[playerPenType])
					let damageResisted = baseDamage - damageAfterResist
					ability.flavorTextAquaVolt(targetEnemy, damageAfterResist, penetrationType, damageResisted)
					removeDebuff(targetEnemy, targetEnemy.debuffs.aquaVolt)
					applyBuff(aquaVoltBuff)			
					delete targetEnemy.debuffs.aquaVolt
					applyDamageToEnemy(targetEnemy, damageAfterResist)
				}
		
			}
			resourceConsumed(ability)
			updateScroll()
}

function transcendenceFunction(secondCommand, thirdCommand) {
	let ability = player.transcendence
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	//does player
	for (let buff in player.buffs) {
		if (player.buffs.hydroplosion) {
			applySkillBuff(ability.hydroplosionFire)
			if (player.buffs.hydroplosion.element == 'fire') {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.hydroplosionFire)
				ability.flavorTextHydroplosion(`a flaming avatar!`)
			} else {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.hydroplosionWater)
				ability.flavorTextHydroplosion(`a water avatar!`)
			}
			removeBuff(player.buffs[buff])
			delete player.buffs[buff]
		} 
		if (player.buffs.thunderBlaze) {
			if (player.buffs.thunderBlaze.element == 'fire') {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.thunderBlazeFire)
				ability.flavorTextThunderBlaze(`a flaming avatar!`)
			} else {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.thunderBlazeLightning)
				ability.flavorTextThunderBlaze(`a lightning avatar!`)
			}
			removeBuff(player.buffs[buff])
			delete player.buffs[buff]
		} 
		if (player.buffs.aquaVolt) {
			if (player.buffs.aquaVolt.element == 'water') {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.aquaVoltWater)
				ability.flavorTextThunderBlaze(`a water avatar!`)
			} else {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.aquaVoltLightning)
				ability.flavorTextThunderBlaze(`a lightning avatar!`)
			}
			removeBuff(player.buffs[buff])
			delete player.buffs[buff]
		} 
	}
	resourceConsumed(ability)
	updateScroll()
}


function applyMonkSeal(enemy, seal) {
		if (enemy.debuffs) {
			console.log(enemy.debuffs)
			if (enemy.debuffs[seal.refName]) {
				let enemySealDebuff = enemy.debuffs[seal.refName]
				let maxStacks = player[seal.refName].debuff.maxStacks()
				enemySealDebuff.stacks == maxStacks ? enemySealDebuff.stacks : enemySealDebuff.stacks++
			  } else {
				enemy.debuffs[seal.refName] = {
				stacks: 1
				}
			}
		} 
		if (!enemy.debuffs) {
			enemy.debuffs = {}
			if (!enemy.debuffs[seal.refName]) {
				enemy.debuffs[seal.refName] = {}
				enemy.debuffs[seal.refName].stacks = 1
			}
	
		} 
		enemy.debuffs[seal.refName].timeout = setTimeout(() => {
			delete enemy.debuffs[seal.refName];
			}, seal.duration)
	}
function monkComboHandler(enemy) {
	let seals = []
	for (let seal in enemy.debuffs) {
		if (enemy.debuffs[seal].type == 'seal') {
		seals.push(player[seal])
		}
	}
	console.log(seals)
	if (seals.length > 1) {
		return monkComboCombiner(enemy, seals)
	} else {
		return 0
	}
}
function monkComboCombiner(enemy, sealsArray) {
	//HYDROPLOSION
	if (sealsArray[0].refName == 'blazingFist' &&
		sealsArray[1].refName == 'tidalFist') {
		hydroplosion(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'tidalFist' &&
		sealsArray[1].refName == 'blazingFist') {
		hydroplosion(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'blazingFist' &&
		sealsArray[1].refName == 'quakeFist') {
		moltenQuake(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'quakeFist' &&
		sealsArray[1].refName == 'blazingFist') {
		moltenQuake(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'tidalFist' &&
		sealsArray[1].refName == 'quakeFist') {
		earthTide(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'quakeFist' &&
		sealsArray[1].refName == 'tidalFist') {
		earthTide(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'lightningFist' &&
		sealsArray[1].refName == 'blazingFist') {
		thunderBlaze(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'blazingFist' &&
		sealsArray[1].refName == 'lightningFist') {
		thunderBlaze(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'lightningFist' &&
		sealsArray[1].refName == 'tidalFist') {
		aquaVolt(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'tidalFist' &&
		sealsArray[1].refName == 'lightningFist') {
		aquaVolt(enemy, sealsArray)
	} 
}

function earthTide(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	earthTideFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	earthTideDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, earthTideDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function earthTideFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Earth Tide'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}


function moltenQuake(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	moltenQuakeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	moltenQuakeDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, moltenQuakeDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function moltenQuakeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Molten Quake'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}

function hydroplosion(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	hydroplosionFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	hydroplosionDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, hydroplosionDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function hydroplosionFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Hydroplosion'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}

function thunderBlaze(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	thunderBlazeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	thunderBlazeDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, thunderBlazeDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function thunderBlazeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Thunder Blaze'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}
function aquaVolt(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	aquaVoltFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	aquaVoltDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, aquaVoltDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function aquaVoltFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Aqua Volt'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}





function flameStrikeFunction(secondCommand, thirdCommand) {
	let ability = player.flameStrike
	let abilityName = player.flameStrike.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let totalDamage = player[abilityName].damage(weapon1, weapon2)
				ability.flavorText(targetEnemy, weaponUsed, totalDamage)
				targetEnemy.health = targetEnemy.health - totalDamage
				targetEnemy.death()
			if (player.buffs.fireSeal) {
				delete player.buffs.fireSeal
				let getEnemiesInCombat = getAllEnemiesInCombat()
				getEnemiesInCombat.forEach(enemy => {
					let totalDamage = player.flameStrike.sealBreakerDamage()
					ability.sealBreakerFlavorText(enemy, totalDamage)
					enemy.health -= totalDamage
					enemy.death()
			})
			}
			updateScroll()
			}
	}

function waveFistFunction(secondCommand, thirdCommand) {
	let ability = player.waveFist
	let abilityName = player.waveFist.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let totalDamage = player[abilityName].damage(weapon1, weapon2)
				ability.flavorText(targetEnemy, weaponUsed, totalDamage)
				targetEnemy.health = targetEnemy.health - totalDamage
				targetEnemy.death()
			if (player.buffs.waterSeal) {
				delete player.buffs.waterSeal
				let heal = ability.heal()
				if (player.health + heal > player.maxHealth) {
					heal = player.maxHealth - player.health
				}
				player.health += heal
				ability.sealBreakerFlavorText(heal)
				updatePlayerStats()
			}
			updateScroll()
			}
	}


	function riptideFistFunction(secondCommand, thirdCommand) {
		let ability = player.riptideFist
		let abilityName = player.riptideFist.refName
		let weaponTypesToCheck = player[abilityName].weaponTypesUsed
		let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
		let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
		let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
		if (doesPlayerHaveAbility(player[abilityName])) {return}
		if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
		if (abilityResourceCheck(player[abilityName])) {return}
		if (abilityCooldownCheck(player[abilityName])) {return}
		if (abilityCombatCheck()) {return}
		let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let sealAbilities = ['blazingFist', 'riptideFist']
			for (let i = 0; i < sealAbilities.length; i++) {
				if (player[sealAbilities[i]].stacks > 0 && player[sealAbilities[i]] != player[abilityName]) {
					player[sealAbilities[i]].stacks = 0
					player[abilityName].stacks = 0
					let comboDamage = player[abilityName].combo()
					player[abilityName].comboFlavorText(targetEnemy, comboDamage)
					targetEnemy.health = targetEnemy.health - comboDamage
					targetEnemy.death()
					updateScroll()
					return
				}
			}
					let totalDamage = player[abilityName].damage(weapon1, weapon2)
					ability.flavorText(targetEnemy, weaponUsed, totalDamage)
					targetEnemy.health = targetEnemy.health - totalDamage
					targetEnemy.death()
					updateScroll()
					if (player[abilityName].stacks < player[abilityName].level) {
						player[abilityName].stacks++
			}
				}
			}
function piercingArrowFunction(secondCommand, thirdCommand) {
	let ability = player.piercingArrow
	let abilityName = player.piercingArrow.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weaponUsed = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityQueueCheck()) {return}
	if (ability.queued && player.isAbilityQueued) { //TIMEDSHOT GETS EXECUTED
		player[abilityName].queued = false
		player.isAbilityQueued = false
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) { //MISSES
			player[abilityName].releaseTimer()
			player[abilityName].flavorTextMiss(targetEnemy, weaponUsed)
			clearInterval(piercingArrowInterval)
		} else if (hitChance == true) { //HITS
			let baseDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			console.log(penetrationType, 'PENETRATION TYPE')
			console.log(penetrationFlavorText, 'PENETRATION FLAVOR TEXT')
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			player[abilityName].releaseTimer(weaponUsed)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			// applyDebuff(targetEnemy, ability.debuff)
			// applyDebuff(targetEnemy, ability.debuff)
			// applyDamageToEnemy(targetEnemy, totalDamage)
			updateScroll()
		}
		resourceConsumed(ability)
	} else if (abilityQueueCheck()) {
		return
	} else if (!ability.queued) { 
		//TIMEDSHOT WINDS UP
		// initiateAbilityWindup(ability)
		player[abilityName].queued = true
		player.isAbilityQueued = true
		ability.windUpText()
		player[abilityName].initiateTimer(secondCommand, thirdCommand)
		}
}

function hydraArrowFunction(secondCommand, thirdCommand) {
	let ability = player.hydraArrow
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy()
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	abilityWindUpText(ability)
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName]) || checkAvailableEnemy(targetEnemy)) {
				quickMessage(`ability should no longer be queued`)
				player.isAbilityQueued = false
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
				return
			}
			if (player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let allCombatEnemies = getAllEnemiesInRoom(secondCommand, thirdCommand)
				for (let i = 0; i < ability.shotCount(); i++) {
					if (checkAvailableEnemy2(allCombatEnemies[i])) {break}
					let hitChance = playerAbilityHitChance(allCombatEnemies[i])
					if (hitChance == false) {
						ability.flavorTextMiss(allCombatEnemies[i], weaponUsed)
					} else if (hitChance == true) {
						let baseDamage = ability.damage()
						let penetrationType = calculatePenetrationRoll()
						let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(allCombatEnemies[i], baseDamage, penetrationType)
						let damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(allCombatEnemies[i], weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(allCombatEnemies[i], damageAfterArmor)
						applyDebuff(allCombatEnemies[i], ability.debuff)
						updateScroll()
						}
				}
				resourceConsumed(ability)
				player[abilityName].queued = false
				player.isAbilityQueued = false
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(player.hydraArrow)
				updateScroll()
			}
		}, player.hydraArrow.windUp * 1000)
	}

function rapidFireShotFunction(secondCommand, thirdCommand) {
	let ability = player.rapidFireShot
	let abilityName = ability.refName
	let weaponTypesToCheck = ability.weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy()
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	abilityWindUpText(ability)
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
				return
			}
			if (player[abilityName].cooldown == player[abilityName].cooldownSet) {
				for (let i = 0; i < player[abilityName].shotCount(); i++) {
					let targetEnemy = targetAnyEnemy()
					if (checkAvailableEnemy(targetEnemy)) {break}
					let hitChance = playerAbilityHitChance(targetEnemy)
					//apply
					player[abilityName].queued = false
					player.isAbilityQueued = false
					if (hitChance == false) {
						ability.flavorTextMiss(targetEnemy, weaponUsed)
					} else if (hitChance == true) {
						let baseDamage = ability.damage()
						let penetrationType = calculatePenetrationRoll()
						let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
						let damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(targetEnemy, damageAfterArmor)
						rangerRegularAttackApplyMark(targetEnemy)
						updateScroll()
						}
				}
				resourceConsumed(ability)
				player[abilityName].queued = false
				player.isAbilityQueued = false
				} else {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(player.rapidFireShot)
					updateScroll()
				}
			}, player.rapidFireShot.windUp * 1000)
			updateMonsterBox()
		}

function aimedShotFunction(secondCommand, thirdCommand) {
	let ability = player.aimedShot
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weapon)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	abilityWindUpText(ability)
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
				let hitChance = playerAbilityHitChance(targetEnemy)
				let totalDamage = player[abilityName].damage(weapon, targetEnemy)
				if (hitChance == false) {
					ability.flavorTextMiss(targetEnemy, weapon)
				} else if (hitChance == true) {
					rangerRegularAttackConsumeMark(targetEnemy)
					ability.flavorText(targetEnemy, weapon, totalDamage)
					applyDamageToEnemy(targetEnemy, totalDamage)
				}
			
				player[abilityName].queued = false
				player.isAbilityQueued = false
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(player.aimedShot)
			}
			updateScroll()
		}, player.aimedShot.windUp * 1000)
	}
		
function evasiveRollFunction() {
	let ability = player.evasiveRoll
	if (player.evasiveRoll.level <= 0) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You do not know the ability `, 'white', line1)
		customizeEachWord(`Evasive Roll `, 'ranger-color', line1)
		blankSpace()	
		return
	}
	if (abilityResourceCheck(ability)) {return}
	let allCombatEnemies = getAllEnemiesInCombat()
	player.combat = false
	allCombatEnemies.forEach(enemy => {
		enemy.combat = false
	})
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`You perform an `, 'white', line1)
	customizeEachWord(`Evasive Roll `, 'ranger-color', line1)
	customizeEachWord(`and break combat!`, 'white', line1)
	blankSpace()
	resourceConsumed(ability)
}

function calculateOnHitDamage(enemy, swingObject) {
	let damage = 0
	switch (player.guild) {
		case 'Warrior':
			damage += calculateBleedDamage(enemy, swingObject)
			damage += calculateFuryBonus(enemy, swingObject)
			damage += calculateKnightsResolveBonus()
			break;
		case 'Monk':
			// damage = calculateSealBreakerDamage(enemy, swingObject)	
			// swingObject.onHitOrBonusDamage = 'on hit'
			break;
		case 'Sinistral':
			applyShadowMark(enemy, swingObject)
			damage = calculateStealthDamage()
			break;
		case 'Ranger':
			damage = rangerRegularAttackConsumeMarkDamage(enemy, swingObject)
			// swingObject.onHitOrBonusDamage = 'bonus'
			rangerRegularAttackConsumeMark(enemy, swingObject)
			rangerRegularAttackApplyMark(enemy)
			calculateWeakSpot(enemy)
	}
	return damage
}
function calculateWeakSpot(enemy) {
	let procChance = player.weakSpot.chance()
	let roll = randomNumberRange(1, 100)
	if (procChance >= roll) {
	quickMessage(`weak spot applied`)
		applyDebuff(enemy, player.weakSpot.debuff)
	} 
}
function calculateStunningBlow() {
	let chanceToStun = player.stunningBlows.chanceToStun()
	let roll = randomNumberRange(1, 100)
	return chanceToStun >= randomNumberRange(1, 100)
}

function applyShadowMark(enemy, swingObject) {
	console.log(swingObject)
	if (!swingObject.weapon.enchantment[0]) {return}
	swingObject.weapon.enchantment.forEach(enchant => {
		if (enchant.refName == 'shadowVenom') {
			applyDebuff(enemy, player.shadowMark.debuff)
		}
	})
}

function calculateBuffDamage(enemy, swingObject) {
	let damage = 0
	for (let buff in player.buffs) {
		if (player.buffs[buff].onHit) {
			let buffDamage = player.buffs[buff].damage ? player.buffs[buff].damage() : 0
			damage += buffDamage
			swingObject.playerBuffOnHit[buff] = {
				flavorText: player.buffs[buff].flavorText,
				damage: buffDamage
			}
		}
	}
	return damage
}
function calculateWeaponEnchantmentDamage(enemy, swingObject) {
	let damage = 0
	for (let enchantment in swingObject.weapon.enchantment) {
		if (swingObject.weapon.enchantment[enchantment].damage) {
			let enchantmentDamage = swingObject.weapon.enchantment[enchantment].damage(enemy)
			let resistType = swingObject.weapon.enchantment[enchantment].resistType
			console.log(resistType, ' RESIST TYPE ON ENCHANTMENT OBJECT')
			console.log(enchantment, ' ENCHANTMENT')
			let penType = swingObject.weapon.enchantment[enchantment].penType
			let element = swingObject.weapon.enchantment[enchantment].element
			let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, enemy[resistType], player[penType])
			let damageResisted = enchantmentDamage - damageAfterResist

			damage += enchantmentDamage
			swingObject.weaponEnchantment[enchantment] = {
				flavorText: swingObject.weapon.enchantment[enchantment].flavorText,
				damage: enchantmentDamage,
				resistType: resistType,
				element: element,
				damageAfterResist: damageAfterResist,
				damageResisted: damageResisted
			}
		}
	}
	return damage
}

function calculateWeaponEnchantmentHeal(swingObject) {
	let heal = 0
	for (let enchantment in swingObject.weapon.enchantment) {
		if (swingObject.weapon.enchantment[enchantment].heal) {
			let healAmount = swingObject.weapon.enchantment[enchantment].heal()
			heal += healAmount
			swingObject.weaponHealingEnchantment[enchantment] = {
				flavorText: swingObject.weapon.enchantment[enchantment].flavorText,
				heal: healAmount
			}
		}
	}
	player.health + heal > player.maxHealth ? player.health = player.maxHealth : player.health += heal
	return heal
}

function calculateClassAdditionalEffects(enemy) {
	if (player.playerClass.name == 'Mystic Monk') {
		if (enemy.debuffs) {
			calculateFireSealBreak(enemy)
			calculateWaterSealBreak(enemy)
			calculateEarthSealBreak(enemy)
		}
	}
}

function calculateFireSealBreak(enemy) {
	if (enemy.debuffs.fireSeal) {
			enemy.debuffs.fireSeal.stacks++
			if (enemy.debuffs.fireSeal.numHitsToActivate == enemy.debuffs.fireSeal.stacks) {
				let combatEnemies = getAllEnemiesInCombat()
				let debuffToCalculateOffOf = enemy.debuffs.fireSeal
				let mainEnemyIndex = combatEnemies.indexOf(enemy)
				let additionalEnemyIndex1 = mainEnemyIndex == 0 ? 2 : mainEnemyIndex - 1
				let additionalEnemyIndex2 = mainEnemyIndex + 1
				let sealDamage = debuffToCalculateOffOf.damage()
				let resistType = debuffToCalculateOffOf.resistType
				let damageAfterResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player.firePen)
				let damageResisted = sealDamage - damageAfterResist
				let element = debuffToCalculateOffOf.element
				debuffToCalculateOffOf.flavorText(enemy, damageAfterResist, element, damageResisted)
				applyDamageToEnemy(enemy, damageAfterResist)
				if (combatEnemies[additionalEnemyIndex2]) {
					let sealDamage = debuffToCalculateOffOf.damage()
					let resistType = debuffToCalculateOffOf.resistType
					let damageAfterResist = calculateMagicDamageWithResist(sealDamage, combatEnemies[additionalEnemyIndex2][resistType], player.firePen)
					let damageResisted = sealDamage - damageAfterResist
					let element = debuffToCalculateOffOf.element
					debuffToCalculateOffOf.flavorTextCleave(combatEnemies[additionalEnemyIndex2], damageAfterResist, element, damageResisted)
					applyDamageToEnemy(combatEnemies[additionalEnemyIndex2], damageAfterResist)
				}
				if (combatEnemies[additionalEnemyIndex1]) {
					let sealDamage = debuffToCalculateOffOf.damage()
					let resistType = debuffToCalculateOffOf.resistType
					let damageAfterResist = calculateMagicDamageWithResist(sealDamage, combatEnemies[additionalEnemyIndex1][resistType], player.firePen)
					let damageResisted = sealDamage - damageAfterResist
					let element = debuffToCalculateOffOf.element
					debuffToCalculateOffOf.flavorTextCleave(combatEnemies[additionalEnemyIndex1], damageAfterResist, element, damageResisted)
					applyDamageToEnemy(combatEnemies[additionalEnemyIndex1], damageAfterResist)
				}
				enemy.debuffs.fireSeal.stacks = 0
				if (player.fireSeal.buff) {
					if (player.fireSeal.buff.type == 'enchantment') {
						applyWeaponEnchant([player.rightFist, player.leftFist], player.fireSeal.buff)
					}
					if (player.fireSeal.buff.seal) {
						applyBuff(player.fireSeal.buff)
					}
				}
				removeDebuff(enemy, enemy.debuffs.fireSeal)
			}
	}
}

function calculateWaterSealBreak(enemy) {
		if (enemy.debuffs.waterSeal) {
			enemy.debuffs.waterSeal.stacks++
			if (enemy.debuffs.waterSeal.numHitsToActivate == enemy.debuffs.waterSeal.stacks) {
				let debuffToCalculateOffOf = enemy.debuffs.waterSeal
				let sealDamage = debuffToCalculateOffOf.damage()
				let resistType = debuffToCalculateOffOf.resistType
				let damageAfterResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player.waterPen)
				let damageResisted = sealDamage - damageAfterResist
				let element = debuffToCalculateOffOf.element
				debuffToCalculateOffOf.flavorText(enemy, damageAfterResist, element, damageResisted)
				applyDamageToEnemy(enemy, damageAfterResist)
				enemy.debuffs.waterSeal.stacks = 0
				if (player.waterSeal.buff) {
					if (player.waterSeal.buff.type == 'enchantment') {
						applyWeaponEnchant([player.rightFist, player.leftFist], player.waterSeal.buff)
					}
					if (player.waterSeal.buff.seal) {
						applyBuff(player.waterSeal.buff)
					}
				}
				removeDebuff(enemy, enemy.debuffs.waterSeal)
			}
		}
}
function calculateEarthSealBreak(enemy) {
		if (enemy.debuffs.earthSeal) {
			enemy.debuffs.earthSeal.stacks++
			if (enemy.debuffs.earthSeal.numHitsToActivate == enemy.debuffs.earthSeal.stacks) {
				let debuffToCalculateOffOf = enemy.debuffs.earthSeal
				let sealDamage = debuffToCalculateOffOf.damage()
				let resistType = debuffToCalculateOffOf.resistType
				let damageAfterResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player.earthPen)
				let damageResisted = sealDamage - damageAfterResist
				let element = debuffToCalculateOffOf.element
				debuffToCalculateOffOf.flavorText(enemy, damageAfterResist, element, damageResisted)
				applyDamageToEnemy(enemy, damageAfterResist)
				enemy.debuffs.earthSeal.stacks = 0
				if (player.earthSeal.buff) {
					if (player.earthSeal.buff.type == 'enchantment') {
						// applyWeaponEnchant([player.rightFist, player.leftFist], player.earthSeal.buff)
					}
					if (player.earthSeal.buff.seal) {
						applyBuff(player.earthSeal.buff)
						applyMagicShieldToPlayer()
					}
				}
				removeDebuff(enemy, enemy.debuffs.earthSeal)
			}
		}
}

function calculateSealBreakerDamage(enemy, swingObject) {
	let damage = 0
	for (let sealBreaker in enemy.debuffs) {
		if (enemy.debuffs[sealBreaker]) {
			enemy.debuffs[sealBreaker].stacks++
			if (enemy.debuffs[sealBreaker].numHitsToActivate == enemy.debuffs[sealBreaker].stacks) {
				let sealDamage = enemy.debuffs[sealBreaker].damage(swingObject)
				let resistType = enemy.debuffs[sealBreaker].resistType
				let penType = enemy.debuffs[sealBreaker].penType
				let damageAfterMagResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player[penType])
				let damageResisted = sealDamage - damageAfterMagResist
				let element = enemy.debuffs[sealBreaker].element
				enemy.debuffs[sealBreaker].stacks = 0
				damage += damageAfterMagResist
				swingObject.classOnHitDisplay[sealBreaker] = {
					buffToApply: {},
					flavorText: enemy.debuffs[sealBreaker].flavorText,
					damage: sealDamage,
					resistType: resistType,
					element: element,
					damageAfterResist: damageAfterMagResist,
					damageResisted: damageResisted
				}
				if (player[sealBreaker].buff) {
					if (player[sealBreaker].buff.type == 'enchantment') {
						applyWeaponEnchant([player.rightFist, player.leftFist], player[sealBreaker].buff)
					}
					if (player[sealBreaker].buff.seal) {
						applyBuff(player[sealBreaker].buff)
					}
				}
				removeDebuff(enemy, enemy.debuffs[sealBreaker])
			}
		}
	}
	return damage
}
function applyBuffForReal(swingObject) {
	for (let buff in swingObject.classOnHitDisplay) {
		// applyBuff(swingObject.classOnHitDisplay[buff].buffToApply)
	}
}

// function displayOnHitDamage(enemy, swingObject) {
// 	if (swingObject.onHitOrBonusDamage == 'on hit') {
// 		swingObject.onHitFlavorText.forEach(display => {
// 			// display(enemy, swingObject)
// 		})
// 	}
// }
// function collectOnHitFlavorText(swingObject) {
// 	if (!swingObject.consumedMark) {
// 		return
// 	}
// 	let array = []
// 	for (const mark of swingObject.consumedMark) {
// 		if (!mark) {
// 			continue
// 		}
// 		array.push(mark.flavorText)
// 	}
// 	return array
// }
function displaySwing(enemy, rightOrLeftObject) {
	//onhit
	console.log(rightOrLeftObject)
	if (player.isStealthed) {
		sneakAttack(enemy)
	}
	if (rightOrLeftObject.weapon) {
		if (rightOrLeftObject.doesSwingHit) {
			if (player.playerClass.name == 'Mystic Monk') {
				rightOrLeftObject.realTotalDamage -= rightOrLeftObject.onHitDamage
			}
			rightOrLeftObject.weapon.swing(enemy, rightOrLeftObject)
			for (let enchantment in rightOrLeftObject.weaponEnchantment) {
				rightOrLeftObject.weaponEnchantment[enchantment].flavorText(enemy, rightOrLeftObject.weaponEnchantment[enchantment].damageAfterResist, rightOrLeftObject.weaponEnchantment[enchantment].element, rightOrLeftObject.weaponEnchantment[enchantment].damageResisted)
			}
			for (let playerBuff in rightOrLeftObject.playerBuffOnHit) {
				rightOrLeftObject.playerBuffOnHit[playerBuff].flavorText(enemy, rightOrLeftObject.playerBuffOnHit[playerBuff].damage)
			}
			for (let classOnHitEffect in rightOrLeftObject.classOnHitDisplay) {
				rightOrLeftObject.classOnHitDisplay[classOnHitEffect].flavorText(enemy, rightOrLeftObject.classOnHitDisplay[classOnHitEffect].damageAfterResist, rightOrLeftObject.classOnHitDisplay[classOnHitEffect].element, rightOrLeftObject.classOnHitDisplay[classOnHitEffect].damageResisted)
			}
			if (rightOrLeftObject.doesPlayerStun) {
				player.stunningBlows.flavorText(enemy)
			}
			for (let enchantment in rightOrLeftObject.weaponHealingEnchantment) {
				rightOrLeftObject.weaponHealingEnchantment[enchantment].flavorText(enemy, rightOrLeftObject.weaponHealingEnchantment[enchantment].heal)
			}
			if (player.thrillOfTheKill.level > 0) {
				thrillOfTheKillProc()
			}
			if (rightOrLeftObject.critDamage > 0) {
				quickMessage(`You crit`)
			}

		} else {
			rightOrLeftObject.weapon.miss(enemy, rightOrLeftObject)
		}
	}
	blankSpace()
}
function calculateBleedDamage(enemy, swingObject) {
	let damage = 0
	if (enemy?.debuffs?.bleed) {
		let debuff = enemy.debuffs.bleed
		damage = debuff.damage(enemy, swingObject)
	}
	return damage
}

function calculateBleedBonus(enemy, baseDamage) {
	let bleedBonus = 0
	if (enemy?.debuffs?.bleed) {
		bleedBonus = (player.bleed.bonusModifier() * enemy.debuffs.bleed.stacks) * baseDamage
		console.log(bleedBonus, ' BLEED BONUS')
	}
	return bleedBonus
}
function calculateFuryBonus(enemy, swingObject) {
	let furyBonus = 0
	if (!enemy?.debuffs?.fury) {return furyBonus}
	if (enemy?.debuffs?.fury) {
		furyBonus = (player.dualStrike.debuff.bonusModifier * enemy.debuffs.fury.stacks) * swingObject.totalDamage
		let stacks = enemy.debuffs.fury.stacks
		let ability = player.dualStrike
		resourceGained(ability, stacks, 'maxMight')
		removeDebuff(enemy, enemy.debuffs.fury)
	}
	console.log(furyBonus, ' FURY BONUS 50% OF DAMAGE')
	return Math.ceil(furyBonus)
}
function calculateKnightsResolveBonus() {
	let knightsResolveBonus = 0
	if (player.knightsResolve.level <= 0) {return knightsResolveBonus}
	knightsResolveBonus = player.knightsResolve.bonusDamage()
	console.log(knightsResolveBonus, ' KNIGHTS RESOLVE BONUS DAMAGE')
	return Math.ceil(knightsResolveBonus)
}

function calculateStealthDamage(enemy, swingObject) {
	//stealth check happens inside player.stealth.damageBonus
	//the player.stealth.damageBonus method also returns 0 if not stealthed
	return player.stealth.damageBonus()
}

function rangerRegularAttackConsumeMark(enemy, swingObject) {
	swingObject.consumedMark = []
	if (enemy.debuffs && enemy.debuffs.hydraArrow) {
		swingObject.consumedMark.push(enemy.debuffs.hydraArrow)
		removeDebuff(enemy, enemy.debuffs.hydraArrow)
		updateMonsterBox()
		delete enemy.debuffs.hydraArrow
	}
	if (enemy.debuffs && enemy.debuffs.piercingArrow) {
		swingObject.consumedMark.push(enemy.debuffs.piercingArrow)
		removeDebuff(enemy, enemy.debuffs.piercingArrow)
		updateMonsterBox()
		delete enemy.debuffs.piercingArrow
	}
}
function rangerRegularAttackConsumeMarkDamage(enemy, swingObject) {
	let damageToAddToTotal = 0
	if (enemy.debuffs && enemy.debuffs.hydraArrow) {
		let debuff = enemy.debuffs.hydraArrow
		let damage = debuff.damage(swingObject)
		damageToAddToTotal += damage
		console.log(damage + ' Hydra Arrow')
		// debuff.flavorText(enemy, damage)
	}
	if (enemy.debuffs && enemy.debuffs.piercingArrow) {
		let debuff = enemy.debuffs.piercingArrow
		let damage = debuff.damage(swingObject)
		damageToAddToTotal += damage
		console.log(damage + ' Piercing Arrow')
		// debuff.flavorText(enemy, damage)
	}
	if (enemy.debuffs && enemy.debuffs.markOfTheBeast) {
		let debuff = enemy.debuffs.markOfTheBeast
		let damage = debuff.damage(enemy, swingObject)
		damageToAddToTotal += damage
		console.log(damage, ' MARK OF THE BEAST BONUS DAMAGE')
		// debuff.flavorText(enemy, damage)
	}
	return Math.ceil(damageToAddToTotal)
}

function rangerRegularAttackApplyMark(enemy) {
	if (player.markOfTheBeast.level > 0) {
		applyDebuff(enemy, player.markOfTheBeast.debuff)
	}
}

function removeDebuff(enemy, debuff) {
	if (!enemy.debuffs) {
		return
	}
	if (enemy.health <= 0) {
		for (let item in enemy.debuffs) {
			clearTimeout(enemy.debuffs[item].timeout)
			// removeDebuffIcon(enemy, enemy.debuffs[item])
			delete enemy.debuffs[item]
		}
	}
	if (enemy.debuffs[debuff.refName]) {
		clearTimeout(enemy.debuffs[debuff.refName].timeout)
	} 
	delete enemy.debuffs[debuff.refName]
	updateMonsterBox()
}
function displayBuffTextAndTimer(buff, duration) {
    const buffContainer = document.getElementById('buffs-container');
    const buffElements = buffContainer.getElementsByClassName('buff');
	const durationElements = buffContainer.getElementsByClassName('duration')
	let chosenElement
	let chosenDurationElement
	let stacks = 1
	for (let i = 0; i < buffElements.length; i++) {
		const elementToCheck = buffElements[i]
		const durationElementToCheck = durationElements[i]
		if (elementToCheck.classList.contains(buff.refName)) {
			chosenElement = elementToCheck
			chosenDurationElement = durationElementToCheck
			stacks = player?.buffs[buff.refName] ? player?.buffs[buff.refName].stacks : 1
			break;
		} else {
		}
	}
    for (let i = 0; i < buffElements.length; i++) {
      const currentBuff = buffElements[i];
	  const currentDurationElement = durationElements[i]
	  if (chosenElement) {
		clearInterval(playerBuffIntervals[buff.refName])
		delete playerBuffIntervals[buff.refName]
		let durationStartTime = duration / 1000
		chosenDurationElement.innerHTML = `${durationStartTime}`;
		chosenElement.innerHTML = `${buff.name}: ${stacks}`;
		playerBuffIntervals[buff.refName] = setInterval(() => {
			const currentDuration = chosenDurationElement.innerHTML;
			if (durationStartTime > 1) {
			  durationStartTime--;
			  chosenDurationElement.innerHTML = `${durationStartTime}`;
			} else {
			  chosenElement.innerHTML = ''
			  chosenDurationElement.innerHTML = ``
			  chosenElement.classList.remove('occupied');
			  chosenElement.classList.remove(buff.refName)
			  clearInterval(playerBuffIntervals[buff.refName])
			  delete playerBuffIntervals[buff.refName]
			}
		  }, 1000)
		  return
	}
      if (!currentBuff.classList.contains('occupied')) {
        // Apply the buff
        currentBuff.innerHTML = `${buff.name}: ${stacks}`;
        currentBuff.classList.add('occupied');
		currentBuff.classList.add(buff.refName)
        // Simulate duration countdown
		let durationStartTime = duration / 1000
		currentDurationElement.innerHTML = `${durationStartTime}`;
        playerBuffIntervals[buff.refName] = setInterval(() => {
          const currentDuration = currentDurationElement.innerHTML;
          if (durationStartTime > 1) {
            durationStartTime--;
            currentDurationElement.innerHTML = `${durationStartTime}`;
          } else {
            currentBuff.innerHTML = ''
			currentDurationElement.innerHTML = ``
            currentBuff.classList.remove('occupied');
			currentBuff.classList.remove(buff.refName)
			clearInterval(playerBuffIntervals[buff.refName])
			delete playerBuffIntervals[buff.refName]
          }
        }, 1000);
        break
      }
    }
  }

  function removeBuff(buff) {
	if (!buff) {return}
    const buffContainer = document.getElementById('buffs-container');
    const buffElement = buffContainer.querySelector(`.${buff.refName}`);
	// const durationElement = buffContainer.querySelector(`.duration`)
	const durationElement = buffElement.nextElementSibling
	// const currentDurationElement = durationElements[i]
	//buff1interval
	buffElement.innerHTML = ''
	durationElement.innerHTML = ``
	buffElement.classList.remove('occupied');
	buffElement.classList.remove(buff.refName)
	clearTimeout(player.buffs[buff.refName].timeout)
	clearInterval(playerBuffIntervals[buff.refName])
	delete playerBuffIntervals[buff.refName]
	delete player.buffs[buff.refName]
  }

function applyWeaponEnchant(weaponOrWeapons, enchantment) {
	console.log(enchantment, ' ENCHANTMENT')
	let duration = enchantment.duration
	console.log(weaponOrWeapons, ' SINGLE WEAPON GETTING ENCHANTED')
	console.log(weaponOrWeapons[0], ' ARRAY WEAPON ITEM 1')
	console.log(weaponOrWeapons[1], ' ARRAY WEAPON ITEM 2')
	let enchantmentName = enchantment.refName
	let enchantmentToApply = enchantment
	if (Array.isArray(weaponOrWeapons)) {
		//weapon 1
		let previousStacks1 = weaponOrWeapons[0]?.enchantment[enchantmentName]?.stacks
		let previousStacks2 = weaponOrWeapons[1]?.enchantment[enchantmentName]?.stacks
		//////////////////////////////////////////////////////////////////////////////
		weaponOrWeapons[0].enchantment[enchantmentName] = enchantmentToApply
		if (previousStacks1 > weaponOrWeapons[0].enchantment[enchantmentName].stacks) {
			weaponOrWeapons[0].enchantment[enchantmentName].stacks = previousStacks1
		}
		clearTimeout(weaponOrWeapons[0].enchantment[enchantmentName].timeoute)
		weaponOrWeapons[0].enchantment[enchantmentName].timeoute = setTimeout(() => {
			clearTimeout(weaponOrWeapons[0].enchantment[enchantmentName].timeoute)
			delete weaponOrWeapons[0].enchantment[enchantmentName]
			let line1 = lineFunc()
			customizeEachWord(`${enchantment.name} `, enchantment.color, line1)
			customizeEachWord(`has worn off`, 'white', line1)
		}, duration)
		//weapon 2
		//////////////////////////////////////////////////////////////////////////////
		weaponOrWeapons[1].enchantment[enchantmentName] = enchantmentToApply
		if (previousStacks2 > weaponOrWeapons[1].enchantment[enchantmentName].stacks) {
			weaponOrWeapons[1].enchantment[enchantmentName].stacks = previousStacks2
		}
		clearTimeout(weaponOrWeapons[1].enchantment[enchantmentName].timeout)
		quickMessage(`Timeout is set just below`)
		weaponOrWeapons[1].enchantment[enchantmentName].timeout = setTimeout(() => {
			clearTimeout(weaponOrWeapons[1].enchantment[enchantmentName].timeout)
			delete weaponOrWeapons[1].enchantment[enchantmentName]
			let line1 = lineFunc()
			customizeEachWord(`${enchantment.name} `, enchantment.color, line1)
			customizeEachWord(`has worn off`, 'white', line1)		
		}, duration)
	} else {
		let previousStacks = weaponOrWeapons?.enchantment[enchantmentName]?.stacks
		weaponOrWeapons.enchantment[enchantmentName] = enchantmentToApply
		if (previousStacks > weaponOrWeapons.enchantment[enchantmentName].stacks) {
			weaponOrWeapons.enchantment[enchantmentName].stacks = previousStacks
		}
		clearTimeout(weaponOrWeapons.enchantment[enchantmentName].timeout)
		weaponOrWeapons.enchantment[enchantmentName].timeout = setTimeout(() => {
			clearTimeout(weaponOrWeapons.enchantment[enchantmentName].timeout)
			delete weaponOrWeapons.enchantment[enchantmentName]
			let line1 = lineFunc()
			customizeEachWord(`${enchantment.name} `, enchantment.color, line1)
			customizeEachWord(`has worn off`, 'white', line1)
		}, duration)
	}
}

function applyBuff(buff) {
	console.log(buff)
	let duration = typeof(buff.duration) == 'function' ? buff.duration() : buff.duration
	//stacks
	// let buff1 = document.querySelector('#buff1')
	let counter = duration / 1000
	// buff1.textContent = counter
	clearInterval(buff1Interval)
	buff1Interval = setInterval(() => {
		counter--
		// buff1.textContent = counter
		if (counter == 0) {
			clearInterval(buff1Interval)
		}
	}, 1000)
	//if player buff does not exist, apply it
	if (!player.buffs[buff.refName]) {
		player.buffs[buff.refName] = {
		...buff,
		timeout: setTimeout(() => {
		for (let addBuff in buff) {
			if (player.mods[addBuff] != undefined) {
				player.mods[addBuff] -= buff[addBuff]
			}
		}	
		updatePlayerStats()
		delete player.buffs[buff.refName];
		delete player.sealCounter[buff.refName]
		}, duration),
	}
		for (let addBuff in buff) {
			if (player.mods[addBuff] != undefined) {
				player.mods[addBuff] += buff[addBuff]
				updatePlayerStats()
			}
		}
	} 
	//stack
	//if the player buff does exist, replace it to refresh the duration
	else if (player.buffs[buff.refName]) {
		clearInterval(buff1Interval)
		// buff1.textContent = counter
			buff1Interval = setInterval(() => {
			counter--
			// buff1.textContent = counter
			if (counter == 0) {
				clearInterval(buff1Interval)
			}
		}, 1000)

		// player.buffs[buff.name].stacks < player.buffs[buff.name].maxStacks() ? player.buffs[buff.name].stacks++ : player.buffs[buff.name].stacks
		for (let addBuff in buff) {
			//if player.mods.str exists
			console.log(player.buffs[buff.refName], ' REFERENCE THE MAX STACKS HERE')
			if (player.mods[addBuff] && player.buffs[buff.refName].stacks < player.buffs[buff.refName].maxStacks()) {
				//buffMod = number of stacks of the buff the player has
				let buffMod = player.buffs[buff.refName].stacks
				let previousStatValue = buff[addBuff] * (buffMod - 1)
				let statValue = buff[addBuff] * buffMod
				//player.mods.str = buff.str * number of stacks
				//player.mods.str becomes 
				player.mods[addBuff] -= previousStatValue
				player.mods[addBuff] += statValue
				updatePlayerStats()
			}
		}
		if (player.buffs[buff.refName].stacks != undefined) {
			player.buffs[buff.refName].stacks < player.buffs[buff.refName].maxStacks() ? player.buffs[buff.refName].stacks++ : player.buffs[buff.refName].stacks
		}
		clearTimeout(player.buffs[buff.refName].timeout)
		player.buffs[buff.refName].timeout =  setTimeout(() => {
			for (let addBuff in buff) {
				if (player.mods[addBuff] != undefined) {
					let buffMod = player.buffs[buff.refName].stacks
					player.mods[addBuff] -= buff[addBuff] * buffMod
				}
			}		
			updatePlayerStats()
			delete player.buffs[buff.refName];
			delete player.sealCounter[buff.refName]
			}, duration)
		} 
	displayBuffTextAndTimer(buff, duration)
	updatePlayerStats()
  }

function applyDebuff(enemy, debuff) {
	// When applying the debuff, calculate the amount to debuff by multiplying by stacks
	if (!enemy.debuffs) {
		enemy.debuffs = {};
	}
	
	if (enemy.debuffs[debuff.refName] && enemy.debuffs[debuff.refName].duration) {
		clearTimeout(enemy.debuffs[debuff.refName].timeout);
	}

	if (!enemy.debuffs[debuff.refName]) {
		enemy.debuffs[debuff.refName] = { ...debuff };
		if (debuff.maxStacks) {enemy.debuffs[debuff.refName].stacks++}
		applyModifiedStats(enemy, debuff)

	} else if (debuff.maxStacks) {
			if (enemy.debuffs[debuff.refName].stacks < debuff.maxStacks()) {
				enemy.debuffs[debuff.refName].stacks++
				// addDebuffIcon(enemy, debuff);
				applyModifiedStats(enemy, debuff)

			}
		}
		// Apply modified stats immediately upon debuff application
		// addDebuffIcon(enemy, debuff);
	if (debuff.duration) {
		let duration = typeof(debuff.duration) == 'function' ? debuff.duration() : debuff.duration
		enemy.debuffs[debuff.refName].timeout = setTimeout(() => {
		if (enemy.health > 0) {
			let line1 = lineFunc()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`is no longer suffering from `, 'white', line1)
			customizeEachWord(`${debuff.name}`, debuff.color, line1)
			revertModifiedStats(enemy, debuff);
			removeDebuff(enemy, debuff);
			updateMonsterBox()
		}
		}, duration)
	}
	updateMonsterBox()
}

function applyModifiedStats(enemy, debuff) {
	if (debuff.modifiedStats) {
		for (let i = 0; i < debuff.modifiedStats.length; i++) {
			if (debuff.maxStacks) {
				if (enemy.debuffs[debuff.refName].stacks <= debuff.maxStacks()) {
					enemy[debuff.modifiedStats[i]] += debuff[debuff.modifiedStats[i]]
				}
			} else {
					enemy[debuff.modifiedStats[i]] += debuff[debuff.modifiedStats[i]]
			}
		}
	}
}
function revertModifiedStats(enemy, debuff) {
	if (debuff.modifiedStats) {
		for (let i = 0; i < debuff.modifiedStats.length; i++) {
			let enemyStacks = enemy.debuffs[debuff.refName].stacks ? enemy.debuffs[debuff.refName].stacks : 1
			let debuffValue = debuff[debuff.modifiedStats[i]] * enemyStacks
			enemy[debuff.modifiedStats[i]] -= debuffValue
		}
	}
}

function updateDebuffIcons(enemy, debuff) {
	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate');
	let allEnemiesInRoom = getAllEnemiesInRoom()
	// let enemyIndex = allEnemiesInRoom.indexOf(enemy);
	let statusEffectsBoxes = allMonsterBoxes.querySelectorAll('#monster-status-effects');
	for (let i = 0; i < allMonsterBoxes.length; i++) {
		console.log(i)
	}
}

function addDebuffIcon(enemy, debuff) {
	if (enemy.health <= 0) {return}
	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate');
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let enemyIndex = allEnemiesInRoom.indexOf(enemy);
	let statusBoxes = allMonsterBoxes[enemyIndex].querySelectorAll('#monster-status-effects');
	// Check if any of the status boxes already have the debuff class
	let alreadyHasDebuff = Array.from(statusBoxes).some(box => box.classList.contains(debuff.refName));
	// If no debuff class found, add it to the first empty slot
	if (!alreadyHasDebuff) {
		let emptySlot = Array.from(statusBoxes).find(box => box.classList.length === 0);
		if (emptySlot) {
			emptySlot.classList.add(debuff.refName);
			let stacks = enemy.debuffs[debuff.refName].stacks ? enemy.debuffs[debuff.refName].stacks : ``
			emptySlot.innerHTML = `${stacks}`
		}
	} else if (alreadyHasDebuff) {
		let debuffSlot = Array.from(statusBoxes).find(box => box.classList == debuff.refName)
		let stacks = enemy.debuffs[debuff.refName].stacks ? enemy.debuffs[debuff.refName].stacks : ``
		debuffSlot.innerHTML = `${stacks}`
	}
}

function grantBonusOnEnemyDeath(enemy) {
	if (!enemy) {
		quickMessage(`grant bonus`)
	}
}
// function removeDebuffIcon(enemy, debuff) {
// 	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate')
// 	let allEnemiesInRoom = getAllEnemiesInRoom()
// 	let enemyIndex = allEnemiesInRoom.indexOf(enemy)
// 	let statusBoxes = allMonsterBoxes[enemyIndex].querySelectorAll('#monster-status-effects')
// 	console.log(allMonsterBoxes)
// 	console.log(enemyIndex)
// 	console.log(allMonsterBoxes[enemyIndex])
// 	for (let i = 0; i < statusBoxes.length; i++) {
// 		if (statusBoxes[i].classList.length >= 0 && statusBoxes[i].classList.contains(debuff.refName)) {
// 			statusBoxes[i].classList.remove(debuff.refName)
// 			statusBoxes[i].innerHTML = ``
// 			return
// 		}
// 	}
// }




let macro = []

function setMacro(number, secondCommand) {
	if (secondCommand == 'ripslash') {
		macro[number - 1] = ripslash
	}
	quickMessage(`${secondCommand} set to macro ${number}`)
}

function useAbilityByNumber(number) {
	if (macro[number - 1] == undefined) {
		quickMessage(`You do not have an ability stored in this macro`)
	} else {
		macro[number - 1]()
	}
}

function checkConjuring() {
	if (player.isConjuring) {
		let line1 = lineFunc()
		customizeEachWord(`You are currently conjuring a spell [`, 'white', line1)
		customizeEachWord(`${Number(player.conjureTimer).toFixed(1)}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		return true
	}
}
function checkChanneling() {
	if (player.isChanneling) {
		let line1 = lineFunc()
		customizeEachWord(`You are currently channeling a spell [`, 'white', line1)
		customizeEachWord(`${Number(player.conjureTimer).toFixed(2)}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		return true
	}
}
function checkAvailableEnemy(enemy) {
	if (!enemy) {
		let line1 = lineFunc()
		customizeEachWord(`There is no enemy in the room for you to target`, 'white', line1)
		return true
	}
}
function checkAvailableEnemy2(enemy) {
	if (!enemy) {
		return true
	}
}

function checkMaxSpellsConjured() {
	if (player.spellsConjured.length == 1 && player.mindsEye.level == 0) {
		let line1 = lineFunc()
		customizeEachWord(`You already have the maximium number of spells conjured`, 'white', line1)
		return true
	}
	if (player.spellsConjured.length == 2 && player.mindsEye.level == 1) {
		let line1 = lineFunc()
		customizeEachWord(`You already have the maximium number of spells conjured`, 'white', line1)
		return true
	}
	if (player.spellsConjured.length == 3 && player.mindsEye.level == 2) {
		let line1 = lineFunc()
		customizeEachWord(`You already have the maximium number of spells conjured`, 'white', line1)
		return true
	}
}



function fireFunction() {
	let spell = player.fireflames
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}
function fire2Function() {
	let spell = player.inferno
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}
function fire3Function() {
	let spell = player.meteor
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}
function iceFunction() {
	let spell = player.frostfreeze
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
		return
	} else {
		handleSpellConjure(spell)
	}
}
function blizzardFunction() {
	let spell = player.blizzard
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
		return
	} else {
		handleSpellConjure(spell)
	}
}
function ice3Function() {
	let spell = player.cryoclast
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
		return
	} else {
		handleSpellConjure(spell)
	}
}
function boltFunction() {
	let spell = player.flashbolt
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}

//handles the summoning of the spell
function spellFunction(spell) {
	let secondCommand = spell
	spell = typeof(spell) == 'string' ? player[spell] : spell
	if (!spell) {
		quickMessage(`You do not know the spell, ${secondCommand}.`)
		return
	}
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		if (abilityResourceCheck(spell)) {return}
			handleSpellConjure(spell)
	}
	updatePlayerStats()
}
function handleSpellConjure(spell) {
	if (actionWait()) {return}
	if (checkConjuring()) {return}
	if (checkChanneling()) {return}
	if (checkMaxSpellsConjured()) {return}
	if (!player.isAlive) {return}
	resourceConsumed(spell)
	player.isConjuring = true
	spell.chambered = true
	spell.conjureAudio()
	spell.flavorTextConjure()
	player.spellsConjured.push(spell)
	initializeConjureBar(spell)
	spellConjureCount(spell)
}
//handles the channeling of the spell
async function handleSpellChannel(spell, targetedEnemy) {
	if (spell.type == 'restorative') {
		if (actionWait()) {return}
		if (checkConjuring()) {return}
		if (checkChanneling()) {return}
		player.stasis = true
		spell.flavorTextChannel()
		spellChannelCount(spell.channelTime())
		initiateCastBar(spell)
		await wait(spell.channelTime())
		player.channeling = false
		let spellIndex = player.spellsConjured.indexOf(spell)
		player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.cast()
		spell.castAudio()
	} else {
		let firstEnemy = targetedEnemy ? targetedEnemy : getAnyEnemyByFirst()
		if (actionWait()) {return}
		if (checkConjuring()) {return}
		if (checkChanneling()) {return}
		if (checkAvailableEnemy(firstEnemy)) {return}
		if (!player.isAlive) {return}
		player.stasis = true
		spell.flavorTextChannel(firstEnemy)
		spellChannelCount(spell.channelTime())
		initiateCastBar(spell)
		await wait(spell.channelTime())
		player.channeling = false
		let spellIndex = player.spellsConjured.indexOf(spell)
		player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		// if (checkAvailableEnemy(firstEnemy)) {return}
		if (!player.isAlive) {return}
		spell.cast(firstEnemy, spell)
		spell.castAudio()
	}
}

function target(secondCommand) {
	let target = !secondCommand ? 1 : secondCommand
	let index = target - 1
	let allEnemies = getAllEnemiesInRoom()
	if (player.spellsConjured[0].type == 'restorative') {
		handleSpellChannel(player.spellsConjured[0])
	} else if (!player.spellsConjured[0]) {
		quickMessage(`You don't have any spells conjured to cast`)
	} else if (!allEnemies[index]) {
		quickMessage(`There is no enemy by that number to target`)
	} else if (allEnemies[index]) {
		quickMessage(`${allEnemies[index].name} is being targeted`)
		if (player.spellsConjured[0]) {
			handleSpellChannel(player.spellsConjured[0], allEnemies[index])
		}
	}
}

function calculateBurnEffect(enemy, spell, damage, allEnemiesFromMethod) {
	let allEnemiesInRoom = allEnemiesFromMethod
	console.log(allEnemiesInRoom, ' ALL ENEMIES IN ROOM FIRST')
	console.log(allEnemiesFromMethod, ' ALL ENEMIES IN ROOM FIRST')
	let explosionDamage = Math.ceil(damage * 0.5) //AoE damage from Fire 2 hitting a burning target. It does 50% of Fire 2's damage
	if (enemy?.debuffs?.burn?.stacks >= 3 && spell.refName == 'meteor') {
		let damageBeforeResist = damage
		let damageAfterResist = calculateMagicDamageWithResist(damageBeforeResist, enemy.fireResist, player.firePen)
		let damageResisted = damageBeforeResist - damageAfterResist
		spell.specialEffect(enemy, damageAfterResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterResist)
		removeDebuff(enemy, enemy.debuffs.burn)
	}
	if (enemy?.debuffs?.burn && spell.refName == 'inferno') {
		let mainEnemyIndex = allEnemiesInRoom.indexOf(enemy)
		let additionalEnemy1
		let additionalEnemy2
		let debuffToApply = { ...enemy.debuffs.burn }
		debuffToApply.stacks--
		if (allEnemiesInRoom[2]) {
			if (mainEnemyIndex == 0) {
				//Additional enemies are the two after the main target
				additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex + 1]
				additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 2]
			} else if (mainEnemyIndex == allEnemiesInRoom.length - 1) {
				//additional enemies are the two before the main target
				additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
				additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex - 2]
			} else {
				//additional enemies are ones before and one after the main target
				additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
				additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 1]
			}
			let additionalDamage1 = calculateMagicDamageWithResist(explosionDamage, additionalEnemy1.fireResist, player.firePen)
			let damageResisted1 = explosionDamage - additionalDamage1
			spell.specialEffect(additionalEnemy1, additionalDamage1, damageResisted1)
			applyDebuff(additionalEnemy1, debuffToApply)
			applyDamageToEnemy(additionalEnemy1, additionalDamage1)
	
			let additionalDamage2 = calculateMagicDamageWithResist(explosionDamage, additionalEnemy2.fireResist, player.firePen)
			let damageResisted2 = explosionDamage - additionalDamage2
			spell.specialEffect(additionalEnemy2, additionalDamage2, damageResisted2)
			applyDebuff(additionalEnemy2, debuffToApply)
			applyDamageToEnemy(additionalEnemy2, additionalDamage2)
		} else if (allEnemiesInRoom[1]) {
			if (mainEnemyIndex == 0) {
				additionalEnemy1 = allEnemiesInRoom[1]
			} else if (mainEnemyIndex == 1) {
				additionalEnemy1 = allEnemiesInRoom[0]
			}
			let additionalDamage1 = calculateMagicDamageWithResist(explosionDamage, additionalEnemy1.fireResist, player.firePen)
			let damageResisted1 = explosionDamage - additionalDamage1
			spell.specialEffect(additionalEnemy1, additionalDamage1, damageResisted1)
			applyDebuff(additionalEnemy1, debuffToApply)
			applyDamageToEnemy(additionalEnemy1, additionalDamage1)
		}
	}
}

function calculateFrostbiteEffect(enemy, spell, damageObject) {
	let mainDamage = damageObject.damageBeforeMagicResist
	let mainAllEnemies = getAllEnemiesInRoom()
	let allEnemies = mainAllEnemies.slice(0, mainAllEnemies.length);
	if (spell.refName == 'cryoclast' && enemy?.debuffs?.frostbite?.stacks == 1) {
		quickMessage(`This should activate the Ice 3 AoE`)
		removeDebuff(enemy, player.frostfreeze.debuff)


		let damage = Math.ceil(mainDamage / allEnemies.length) //damage is split among all monsters in the room
		let mainEnemyIndex = allEnemies.indexOf(enemy)
		for (let i = 0; i < allEnemies.length; i++) {
			//maybe add removeDebuff(allEnemies[i], spell.debuff)
			//the above would activate ice 3s explosion AND remove all the debuffs from all enemies
			if (allEnemies[i].health > 0 && i != mainEnemyIndex) {
				let damageAfterResist = calculateMagicDamageWithResist(damage, enemy.iceResist, player.icePen)
				let damageResisted = damage - damageAfterResist
				spell.specialEffect2(allEnemies[i], damageAfterResist, damageResisted)
				applyDamageToEnemy(allEnemies[i], damageAfterResist)
				applyDebuff(allEnemies[i], spell.debuff)
			}
		}
	} else if (spell.refName == 'cryoclast' && enemy?.debuffs?.frostbite?.stacks == 2) {
		let damage = Math.ceil(mainDamage * 0.5) //damage is half that of the main spell
		let damageAfterResist = calculateMagicDamageWithResist(damage, enemy.iceResist, player.icePen)
		let damageResisted = damage - damageAfterResist
		removeDebuff(enemy, player.frostfreeze.debuff)
		if (enemy.health > 0) {
			spell.specialEffect(enemy, damageAfterResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterResist)
		}
	} else if (spell.refName == 'frostfreeze' && enemy?.debuffs?.frostbite?.stacks == 3) {
		let mainEnemyIndex = allEnemies.indexOf(enemy)
		let additionalEnemyIndex1 = mainEnemyIndex == 0 ? 2 : mainEnemyIndex - 1
		let additionalEnemyIndex2 = mainEnemyIndex + 1
		let splitDamage = Math.ceil(mainDamage * 0.5) //damage is half that of the main spell
		let damageAfterResist = calculateMagicDamageWithResist(splitDamage, enemy.iceResist, player.icePen)
		let damageResisted = splitDamage - damageAfterResist
		removeDebuff(enemy, player.frostfreeze.debuff)
		if (enemy.health > 0) {
			spell.specialEffect(enemy)
			spell.specialEffect2(enemy, damageAfterResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterResist)
		}
		if (allEnemies[additionalEnemyIndex2]) {
			let damageAfterResist = calculateMagicDamageWithResist(splitDamage, allEnemies[additionalEnemyIndex2].iceResist, player.icePen)
			let damageResisted = splitDamage - damageAfterResist
			spell.specialEffect2(allEnemies[additionalEnemyIndex2], damageAfterResist, damageResisted)
			applyDamageToEnemy(allEnemies[additionalEnemyIndex2], damageAfterResist)
			if (allEnemies[additionalEnemyIndex2]?.debuffs?.frostbite?.stacks < 2 || !allEnemies[additionalEnemyIndex2].debuffs) {
			applyDebuff(allEnemies[additionalEnemyIndex2], spell.debuff)
			}
		}
		if (allEnemies[additionalEnemyIndex1]) {
			let damageAfterResist = calculateMagicDamageWithResist(splitDamage, allEnemies[additionalEnemyIndex1].iceResist, player.icePen)
			let damageResisted = splitDamage - damageAfterResist
			spell.specialEffect2(allEnemies[additionalEnemyIndex1], damageAfterResist, damageResisted)
			applyDamageToEnemy(allEnemies[additionalEnemyIndex1], damageAfterResist)
			if (allEnemies[additionalEnemyIndex1]?.debuffs?.frostbite?.stacks < 2 || !allEnemies[additionalEnemyIndex1].debuffs) {
				applyDebuff(allEnemies[additionalEnemyIndex1], spell.debuff)
				}		
			}
	}
}

function calculateShockEffect(enemy, spell, damageObject) {
	let mainDamage = damageObject.damageBeforeMagicResist
	if (spell.refName == 'bolt') {}
	if (spell.refName == 'chainLightning') {
		let bonusDamage = mainDamage * 0.5
		return Math.ceil(bonusDamage)
	}
}

// function handleSpellCast(enemy, spell) {
// 	if (!player.isAlive) {return}
// 	if (checkAvailableEnemy(enemy)) {return}
// 	if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
// 	let spellIndex = player.spellsConjured.indexOf(spell)
// 	let damageBeforeMagicResist = spell.damage(enemy)
// 	let damageAfterMagicResist = calculateMagicDamageWithResist(damageBeforeMagicResist, enemyFireResist)
// 	let damageResisted = damageBeforeMagicResist - damageAfterMagicResist
// 	player.spellsConjured.splice(spellIndex, 1)
// 	spell.chambered = false
// 	spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
// 	applyDamageToEnemy(enemy, damageAfterMagicResist)
// 	//put bonus functions here
// 	calculateBurnEffect(enemy, spell, damageBeforeMagicResist)
// 	calculateFrostbiteEffect(enemy, spell, damageAfterMagicResist)
// 	//put bonus functions here
// }
// function handleSpellCastAoE(spell) {
// 	if (!player.isAlive) {return}
// 	let allEnemies = getAllEnemiesInRoom()
// 	let numberOfTargets = spell.numberOfTargets == 'all' ? allEnemies.length : spell.numberOfTargets
// 	console.log(numberOfTargets, ' NUMBER OF TARGETS')
// 	for (let i = 0; i < numberOfTargets; i++) {
// 		if (checkAvailableEnemy(allEnemies[i])) {return}
// 		if (spell.debuff) {applyDebuff(allEnemies[i], spell.debuff)}
// 		// let damageBeforeMagicResist = spell.damage(allEnemies[i])
// 		let damageBeforeMagicResist = spell.damage(numberOfTargets, allEnemies[i])

// 		let damageAfterMagicResist = calculateMagicDamageWithResist(damageBeforeMagicResist, enemyMagicResist)
// 		let damageResisted = damageBeforeMagicResist - damageAfterMagicResist
// 		quickMessage(`${damageBeforeMagicResist} before MR`)
// 		quickMessage(`${damageAfterMagicResist} after MR`)
// 		quickMessage(`${damageResisted} amount resisted`)
// 		spell.flavorTextCast(allEnemies[i], damageAfterMagicResist, damageResisted)
// 		applyDamageToEnemy(allEnemies[i], damageAfterMagicResist)
// 		//put bonus functions here
// 		calculateBurnEffect(allEnemies[i], spell, damageBeforeMagicResist)
// 		calculateFrostbiteEffect(allEnemies[i], spell, damageAfterMagicResist)
// 		//put bonus functions here
// 	}
// 	let spellIndex = player.spellsConjured.indexOf(spell)
// 	player.spellsConjured.splice(spellIndex, 1)
// 	spell.chambered = false
// }



function checkIfDuplicateSpell(spell) {
	let isSpellConjured = false
	player.spellsConjured.some(chamberedSpell => {
		if (chamberedSpell.refName == spell.refName) {
			console.log(chamberedSpell)
			console.log(spell)
			isSpellConjured = true
		}
	})
	return isSpellConjured
}

function initializeConjureBar(spell) {
	let conjureBarToUse
	let fullBar
	const conjureBar1 = document.querySelector('.bar-1')
	const conjureBar2 = document.querySelector('.bar-2')
	const conjureBar3 = document.querySelector('.bar-3')
	const isConjureBar1Full = Array.from(conjureBar1.classList).some(item => item == 'bar-1-full')
	const isConjureBar2Full = Array.from(conjureBar2.classList).some(item => item == 'bar-2-full')
	const isConjureBar3Full = Array.from(conjureBar3.classList).some(item => item == 'bar-3-full')
	if (!isConjureBar1Full) {
		conjureBarToUse = conjureBar1
		fullBar = 'bar-1-full'
	} else if (!isConjureBar2Full) {
		conjureBarToUse = conjureBar2
		fullBar = 'bar-2-full'
	} else {
		conjureBarToUse = conjureBar3
		fullBar = 'bar-3-full'
	}
	conjureBarToUse.classList.add(`${spell.conjureBarColor}`)
	conjureBarToUse.classList.add(`${spell.refName}`)
	let conjureTime = Math.floor(spell.conjureTime())
	let remainingTime = conjureTime
	const intervalId = setInterval(() => {
		if (remainingTime <= 0) {
			conjureBarToUse.classList.add(`${fullBar}`)
			clearInterval(intervalId)
			return
		}
		const width = ((conjureTime - remainingTime) / conjureTime) * 100
		conjureBarToUse.style.width = `${width}%`
		remainingTime -= 10
	}, 10)
}

function initiateCastBar(spell) {
	let castBarToUse;
	const castBar1 = document.querySelector('.bar-1');
	const castBar2 = document.querySelector('.bar-2');
	const castBar3 = document.querySelector('.bar-3');
	const castBar1Array = Array.from(castBar1.classList);
	const castBar2Array = Array.from(castBar2.classList);
	const castBar3Array = Array.from(castBar3.classList);

	if (castBar1Array.some(item => item == spell.refName)) {
		castBarToUse = castBar1;
	} else if (castBar2Array.some(item => item == spell.refName)) {
		castBarToUse = castBar2;
	} else {
		castBarToUse = castBar3;
	}

	castBarToUse.style.width = '0%'; // Start from 100%
	const castTime = spell.channelTime();
	let startTime;
	let animationId;

	function animateBar(timestamp) {
		if (!startTime) {
			startTime = timestamp;
		}
		const progress = Math.max(1 - (timestamp - startTime) / castTime, 0); // Reverse progress calculation
		const width = progress * 100;
		castBarToUse.style.width = `${width}%`;

		if (progress > 0) {
			animationId = requestAnimationFrame(animateBar);
		} else {
			castBarToUse.style.width = '0%';
			let test = Array.from(castBarToUse.classList)
			castBarToUse.classList = test[0]
		}
	}

	animationId = requestAnimationFrame(animateBar);

	function stopAnimation() {
		cancelAnimationFrame(animationId);
	}

    // Stop animation if needed
    // For example, if the spell is interrupted
    // setTimeout(stopAnimation, 0); // Example usage
}

// function initiateCastBar2(spell) {
// 	let castBarToUse
// 	const castBar1 = document.querySelector('.bar-1')
// 	const castBar2 = document.querySelector('.bar-2')
// 	const castBar3 = document.querySelector('.bar-3')
// 	const castBar1Array = Array.from(castBar1.classList)
// 	const castBar2Array = Array.from(castBar2.classList)
// 	const castBar3Array = Array.from(castBar3.classList)
// 	if (castBar1Array.some(item => item == spell.refName)) {
// 		castBarToUse = castBar1
// 		// castBarToUse.classList.remove('bar-1-full')
// 	} else if (castBar2Array.some(item => item == spell.refName)) {
// 		castBarToUse = castBar2
// 		// castBarToUse.classList.remove('bar-2-full')
// 	} else {
// 		castBarToUse = castBar3
// 		// castBarToUse.classList.remove('bar-3-full')
// 	}
// 	console.log(castBarToUse)
// 	// const castingBar = document.querySelector('.bar-1')
// 	castBarToUse.style.width = '100%'
// 	let castTime = spell.channelTime()
// 	let remainingTime = castTime
// 	let intervalDuration = 10
// 	const intervalId = setInterval(() => {
// 		remainingTime -= intervalDuration
// 		quickMessage(`Cast milliseconds: ${remainingTime}`)
// 		if (remainingTime <= 0) {
// 			castBarToUse.style.width = '0%'
// 			let test = Array.from(castBarToUse.classList)
// 			castBarToUse.classList = test[0]
// 			clearInterval(intervalId)
// 		} else {
// 			const width = (remainingTime / castTime) * 100
// 			castBarToUse.style.width = `${width}%`
// 		}
// 	}, intervalDuration)
// }



///////////////////////////////////////////////////////////////////////////////////////////////
function updateScroll() {
	masterArea.scrollTop = masterArea.scrollHeight
}

newLocation = function (x, y, z, s) {
	currentArea.isPlayerHere = false
	let newArea = allAreas.find(area => area.x == x && area.y == y && area.z == z)
	if (!newArea) {
		quickMessage(`This area does not exist`)
		return
	}
	if (player.x === x && player.y === y && player.z === z) {
		previousArea = currentArea
		currentArea = newArea
		additional.innerHTML = playerProxy.x + ', ' + playerProxy.y + ', ' + currentArea.descriptions.areaName + ' ' + currentArea.id
	}
	player.roomId = currentArea.id
	currentArea.isPlayerHere = true
}

//Changes players x, y, or z coordinate if a move is possible and is made
//the locationCheck parameter below calls the newLocation function above

//Rolls to see if a enemy will spawn
function onRoomEntry() {
	if (currentArea.descriptions.onEntry != undefined) {
		currentArea.descriptions.onEntry()
	}
	if (currentArea.onEntry != undefined) {
		currentArea.onEntry()
	}
}
function itemRoll() {
	weaponGen(crudeShiv(3, true))
	weaponGen(crudeShiv(3, true))
	weaponGen(dirk(3, true))
	weaponGen(dirk(3, true))
	weaponGen(stiletto(3, true))
	weaponGen(stiletto(3, true))
	weaponGen(crescentDagger(3, true))
	weaponGen(crescentDagger(3, true))

	weaponGen(trainingShortsword(3, true))
	weaponGen(shortsword(3, true))
	weaponGen(broadSword(3, true))
	weaponGen(gladius(3, true))
	weaponGen(sabre(3, true))

	weaponGen(trainingTwoHandedSword(3, true))
	weaponGen(longsword(3, true))
	weaponGen(claymore(3, true))
	weaponGen(bastardSword(3, true))
	weaponGen(greatsword(3, true))

	weaponGen(shortbow(3, true))
	weaponGen(longbow(3, true))
	weaponGen(battleBow(3, true))

	armorGen(clothCap(3, true))
	armorGen(apprenticeRobes(3, true))
	armorGen(clothGloves(3, true))
	armorGen(sandals(3, true))

	armorGen(mailChestGuard(3, true))
	armorGen(leatherShoulderguards(3, true))

	armorGen(leatherGloves(3, true))
	armorGen(plateLeggings(3, true))
	armorGen(plateBoots(3, true))
	armorGen(squiresShield(3, true))
	armorGen(galvadianKiteShield(3, true))
	armorGen(bronzeShield(3, true))
	armorGen(galvadianKiteShield(3, true))
	consumableGen(smallPotion(3, true))
}

//Spawns a enemy if the roll === enemy spawn chance
//setInterval(enemySpawn, 5000);
//_________________________________________________________________________________________________________________________________________________________________________________________________________________
//paragraph elements
let enemy1 = document.getElementById('enemy1')
let enemy2 = document.getElementById('enemy2')
let enemy3 = document.getElementById('enemy3')

//ITEMS_________________ITEMS______________________ITEMS___________________ITEMS______________________ITEMS________________________ITEMS
//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////
function apple() {
	let apple = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Apple',
		refName: 'apple',
		color: 'green',
		keywords: ['food', 'apple'],
		type: {
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 10,
			manaBonus: 10,
			duration: 30000,
		},
		desc: function() {
			let line1 = lineFunc()
			allItemDescription(`A solid red apple. Looks delicious!`, 'white', line1)
		},
		price: 1,
		sellValue: 1,

	}
	return apple
}
function mudBall() { //eat for health
	let mudball = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mudball',
		refName: 'mudball',
		color: 'green',
		keywords: ['mud', 'ball', 'mudball'],
		type: {
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 10,
			manaBonus: 0,
			duration: 100000,
		},
		sellValue: 10,
		description: `A moist ball of mud - Try eating it or giving it to someone who likes to play with mud!`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return mudball
}

function waterBerry() { //eat for mana
	let waterBerry = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Water Berry',
		color: 'green',
		keywords: ['water', 'berry', 'water berry'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 0,
			manaBonus: 10,
			duration: 100000,
		},
		sellValue: 10,
		description: `A plump, luscious, Water Berry - Try eating it or giving it to someone who is thirsty!`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return waterBerry
}
function grassFruit() { //eat for mana
	let grassFruit = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Grass Fruit',
		color: 'green',
		keywords: ['grass', 'fruit', 'grass fruit'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 5,
			manaBonus: 5,
			duration: 100000,
		},
		sellValue: 10,
		description: `A Grass Fruit! You're not sure what it is, but it looks kinda tastey.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return grassFruit
}

function halfEatenFish() {
	let halfEatenFish = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Half Eaten Fish',
		refName: 'halfEatenFish',
		color: 'green',
		keywords: ['half', 'eaten', 'fish', 'half eaten', 'eaten fish', 'half eaten fish'],
		type: {
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 20,
			manaBonus: 20,
			duration: 30000,
		},
		price: 0,
		sellValue: 5,
		desc: function() {
			let line1 = lineFunc()
			allItemDescription(`The front half of a medium sized fish. The backbone and tail skeleton are still attached.`, 'white', line1)
		},
	}
	return halfEatenFish
}

function rawBoarMeat() {
	let rawBoarMeat = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Raw Boar Meat',
		refName: 'rawBoarMeat',
		color: 'green',
		keywords: ['raw', 'boar', 'meat', 'raw boar', 'boar meat', 'raw boar meat'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: true,
		cookedVersion: boarSteak,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 10,
			manaBonus: 10,
			duration: 10000,
		},
		sellValue: 8,
		description: `A big hunk of boar meat`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return rawBoarMeat
}

function boarSteak() {
	let boarSteak = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Boar Steak',
		refName: 'boarSteak',
		color: 'green',
		keywords: ['boar', 'steak', 'boar steak'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
			let line1 = lineFunc()
			customizeEachWord(`You sizzle up a juicy `, 'white', line1)
			customizeEachWord(`${this.name}`, 'green', line1)
			customizeEachWord(`!`, 'white', line1)
		},
		buff: {
			name: 'Sated',
			healthBonus: 30,
			manaBonus: 30,
			duration: 60000,
		},
		sellValue: 15,
		description: `A cooked boar steak`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return boarSteak
}
function applePie() {
	let applePie = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Apple Pie',
		refName: 'appliePie',
		color: 'green',
		keywords: ['apple', 'pie', 'apple pie'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
		},
		buff: {
			name: 'Sated',
			healthBonus: 80,
			manaBonus: 80,
			duration: 60000,
		},
		price: 100,
		sellValue: 12,
		description: `A scrumptious smelling apple pie!`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return applePie
}





function koboldSkull() {
	let koboldSkull = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Kobold Skull',
		refName: 'koboldSkull',
		color: 'green',
		keywords: ['kobold', 'skull', 'kobold skull'],
		type: { quest: true },
		sellValue: 2,
		description: `The small, cracked skull of a kobold`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return koboldSkull
}
function legBone() { //used in crafting to craft two-handed weapons
	let legBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leg Bone',
		refName: 'legBone',
		color: 'green',
		keywords: ['leg', 'bone', 'leg bone'],
		type: { quest: true },
		sellValue: 15,
		description: `A human femur`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return legBone
}
function crackedBone() { //used in crafting to craft one handed weapons and daggers
	let crackedBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cracked Bone',
		refName: 'crackedBone',
		color: 'green',
		keywords: ['cracked', 'bone', 'cracked bone'],
		type: { sell: true },
		sellValue: 10,
		description: `A cracked, human bone`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return crackedBone
}
function ribCage() { //used in crafting to craft one handed weapons and daggers
	let ribCage = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rib Cage',
		refName: 'ribCage',
		color: 'green',
		keywords: ['rib', 'cage', 'rib cage'],
		type: { quest: true },
		sellValue: 5,
		description: `A human ribcage`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ribCage
}


function cultTexts() {
	let cultTexts = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cult Texts',
		refName: 'cultTexts',
		color: 'green',
		keywords: ['cult', 'texts', 'text', 'cult texts'],
		type: { quest: true },
		sellValue: 0,
		description: `A book adorned with strange symbols`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return cultTexts
}
// function thievesJewel() { 
// 	let thievesJewel = {
// 		id: function () {
// 			for (let i = 0; i < 50; i++) {
// 				if (!pushItem[i]) {
// 					return i
// 				}
// 			}
// 		},
// 		roomId: currentArea.id,
// 		name: `Thieve's Jewel`,
// 		refName: 'thievesJewel',
// 		color: 'green',
// 		keywords: [`thieve's`, 'jewel', `thieve's jewel`],
// 		type: { quest: true },
// 		sellValue: 0,
// 		description: `A beautifully cut, yellow Topaz`,
// 		desc: function () {
// 			allItemDescription(this)
// 		},
// 	}
// 	return thievesJewel
// }
// function secretText() { 
// 	let secretText = {
// 		id: function () {
// 			for (let i = 0; i < 50; i++) {
// 				if (!pushItem[i]) {
// 					return i
// 				}
// 			}
// 		},
// 		roomId: currentArea.id,
// 		name: 'Secret Text',
// 		refName: 'secretText',
// 		color: 'green',
// 		keywords: [`secret`, `text`, `secret text`],
// 		type: { quest: true },
// 		sellValue: 0,
// 		description: `A book with Monk's Guild imagery painted all over it`,
// 		desc: function () {
// 			allItemDescription(this)
// 		},
// 	}
// 	return secretText
// }




function generateId() {
	for (let i = 0; i < 50; i++) {
		if (!pushItem[i]) {
			return i
		}
	}
}




//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////


//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
function wormGuts(level, isMonsterDrop) { //QUEST FOR TIM-TIM
	let wormGuts = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Worm Guts',
		refName: 'wormGuts',
		color: 'green',
		keywords: ['worm', 'guts', 'worm guts'],
		type: { quest: true },
		sellValue: 5,
		description: `Mushy, stinky worm guts`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return wormGuts
}
function littleBoneToy(level, isMonsterDrop) { //QUEST FOR MOTHER WITH BABY
	let littleBoneToy = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Little Bone Toy',
		refName: 'littleBoneToy',
		color: 'green',
		keywords: ['little', 'bone', 'toy', 'little bone', 'bone toy', 'little bone toy'],
		type: { quest: true },
		sellValue: 5,
		description: `You can barely make out that it's a toy at all with how crudely it was crafted. Upon closer inspection, it looks to be made of small.. Human bones?`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return littleBoneToy
}

function goblinHead(monsterLevel) {
	let goblinHead = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: '',
		name: 'goblin head',
		color: 'green',
		experience: 10,
		keywords: ['goblin', 'head', 'goblin head'],
		type: { quest: true },
		sellValue: monsterLevel,
		description: `A decapitated goblin's with a pained expression frozen on its face`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return goblinHead
}
function tutorialKey() {
	let tutorialKey = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: 3,
		name: 'Simple Key',
		color: 'green',
		keywords: ['simple', 'key', 'simple key'],
		type: { quest: true },
		roomToUnlock: 'Galvadia Welcome Area 5',
		description: `A simple looking key`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return tutorialKey
}
function pairOfGlasses() {
	let pairOfGlasses = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: 7,
		name: 'Pair of Glasses',
		color: 'green',
		keywords: ['pair', 'glasses', 'pair of glasses'],
		type: { quest: true },
		description: `A pair of silver bifocals. Perhaps they belong to Egbert?`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return pairOfGlasses
}
function ratCarcass(level, isMonsterDrop) { //used in crafting to craft leather armor
	let ratCarcass = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Carcass',
		color: 'green',
		keywords: ['rat', 'carcass', 'rat carcass'],
		type: { quest: false },
		sellValue: 1,
		description: '...The lifeless corpse of a rat... Looks like some of the parts could be salvaged for use in crafting',
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratCarcass
}
function ratHide() { //used in crafting to craft leather armor
	let ratHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Hide',
		color: 'green',
		keywords: ['rat', 'hide', 'rat hide'],
		type: { quest: false },
		sellValue: 0,
		description: 'The skinned hide of a rat',
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratHide
}
function tannedRatHide(level, isMonsterDrop) { //used in crafting to craft leather armor
	let tannedRatHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Tanned Rat Hide',
		color: 'green',
		keywords: ['tanned', 'rat', 'hide', 'tanned rat', 'rat hide', 'tanned rat hide'],
		type: { quest: false },
		sellValue: 1,
		description: 'A well tanned rat hide ready for use',
		desc: function () {
			allItemDescription(this)
		},
	}
	return tannedRatHide
}

function ratTail(level, isMonsterDrop) { //used in crafting to craft leather armor
	let ratTail = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Tail',
		refName: 'ratTail',
		color: 'green',
		keywords: ['rat', 'tail', 'rat tail'],
		type: { quest: true },
		sellValue: 20,
		description: `A thick, long rat tail`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratTail
}
function ratSkin(level, isMonsterDrop) {
	let ratSkin = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Skin',
		refName: 'ratSkin',
		color: 'green',
		keywords: ['rat', 'skin', 'rat skin'],
		type: { quest: true },
		sellValue: 10,
		description: `The thin hide of a rat`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratSkin
}
function stagAntlers(level, isMonsterDrop) {
	let stagAntlers = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stag Antlers',
		refName: 'stagAnterls',
		color: 'green',
		keywords: ['antlers'],
		type: { sell: true },
		sellValue: 77,
		description: `A large rack of Stag Antlers.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return stagAntlers
}
function brokenAntlers(level, isMonsterDrop) {
	let brokenAntlers = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stag Antlers',
		refName: 'stagAnterls',
		color: 'green',
		keywords: ['antlers'],
		type: { sell: true },
		sellValue: 22,
		description: `Broken Stag antlers.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return brokenAntlers
}

function smallSackOfGold(level, isMonsterDrop) {
	let smallSackOfGold = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Sack of Gold',
		refName: 'smallSackOfGold',
		color: 'green',
		keywords: ['small sack', 'sack', 'small sack of gold'],
		type: { quest: true },
		sellValue: randomNumberRange(25, 40),
		description: `A small sack of coins`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return smallSackOfGold
}
/////////////////////////////////                  CRAFTING                    /////////////////////////////////
/////////////////////////////////                  CRAFTING                    /////////////////////////////////
/////////////////////////////////                  CLOTH                    /////////////////////////////////
function thinFiber() {
	let thinFiber = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Thin Fiber',
		refName: 'thinFiber',
		color: 'green',
		keywords: ['thin', 'fiber', 'thin fiber'],
		type: { 
			quest: true ,
			crafting: true,
		},			
		sellValue: 10,
		description: `Thin fibrous material used for weaving cloth armor. A tailor would have use for this.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return thinFiber
}
function refinedFiber() {
	let refinedFiber = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Refined Fiber',
		refName: 'refinedFiber',
		color: 'green',
		keywords: ['refined', 'fiber', 'refined fiber'],
		type: { 
			quest: true ,
			crafting: true,
		},	
		sellValue: 38,
		description: `Thin yet refined fibers used for weaving cloth armor. Turn this in to a tailor so they can craft more items`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return refinedFiber
}
/////////////////////////////////                  LEATHER                    /////////////////////////////////
function lightHide(level, isMonsterDrop) { //used for crafting tier 1 and 2
	let lightHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Light Hide',
		refName: 'lightHide',
		color: 'green',
		keywords: ['light', 'hide', 'light hide'],
		type: { 
			quest: true,
			crafting: true,
		},
		sellValue: 35,
		description: `The thin hide of an animal. Turn this in to a leatherworker so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return lightHide
}
function thickHide(level, isMonsterDrop) { //used for crafting tier 3 and 4
	let thickHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Thick Hide',
		refName: 'thickHide',
		color: 'green',
		keywords: ['thick', 'hide', 'thick hide'],
		type: { 
			quest: true ,
			crafting: true,
		},		
		sellValue: 55,
		description: `The thick hide of an animal. Turn this in to a leatherworker so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return thickHide
}
/////////////////////////////////                  PLATE                    /////////////////////////////////
function copperOre() { //used in crafting to craft leather armor
	let copperOre = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Copper Ore',
		refName: 'copperOre',
		color: 'green',
		keywords: ['copper', 'ore', 'copper ore'],
		type: { 
			quest: true ,
			crafting: true,
		},
		sellValue: 47,
		description: `A small lump of copper ore. Turn this in to a blacksmith or armor smith so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return copperOre
}
function ironOre() { //used in crafting to craft leather armor
	let ironOre = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Iron Ore',
		refName: 'ironOre',
		color: 'green',
		keywords: ['iron', 'ore', 'iron ore'],
		type: { 
			quest: true ,
			crafting: true,
		},		sellValue: 84,
		description: `A small lump of iron ore. Turn this in to a blacksmith or armor smith so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ironOre
}

function crucifix(level, isMonsterDrop) { //QUEST ITEM FOR CATHEDRAL
	let crucifix = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crucifix',
		refName: 'crucifix',
		color: 'green',
		keywords: ['crucifix'],
		type: { quest: true },
		sellValue: 22,
		description: `An ornately carved crucifix. It has dried blood around the edges..`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return crucifix
}

function brightYellowFlower() { //QUEST ITEM FOR THE GLADE
	let brightYellowFlower = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bright Yellow Flower',
		refName: 'brightYellowFlower',
		color: 'green',
		keywords: ['bright', 'yellow', 'flower', 'bright yellow', 'yellow flower', 'bright yellow flower'],
		type: { quest: true },
		sellValue: 0,
		description: `A bright yellow flower`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return brightYellowFlower
}
function sackOfGrain() { //QUEST ITEM FOR THE WAGON IN TOWN
	let sackOfGrain = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sack of Grain',
		refName: 'sackOfGrain',
		color: 'green',
		keywords: ['sack', 'grain', 'sack of grain'],
		type: { quest: true },
		sellValue: 0,
		description: `A large sack of grain`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return sackOfGrain
}

function largeBone(level, isMonsterDrop) { //used in crafting to craft leather armor
	let largeBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Large Bone',
		refName: 'largeBone',
		color: 'green',
		keywords: ['large', 'bone', 'large bone'],
		type: { sell: true },
		sellValue: 35,
		description: `A large, human bone.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return largeBone
}
function smallBone(level, isMonsterDrop) { //used in crafting to craft leather armor
	let smallBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Bone',
		refName: 'smallBone',
		color: 'green',
		keywords: ['small', 'bone', 'small bone'],
		type: { sell: true },
		sellValue: 14,
		description: `A small, human bone`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return smallBone
}



function dirtyRags(level, isMonsterDrop) { //used in crafting to craft leather armor
	let dirtyRags = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Dirty Rags',
		refName: 'dirtyRags',
		color: 'green',
		keywords: ['dirty', 'rags', 'dirty rags'],
		type: { quest: true },
		sellValue: 5,
		description: `These are dirty cloth rags look to be torn pieces of various clothing items`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return dirtyRags
}


function silverOre() { //used in crafting to craft leather armor
	let silverOre = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silver Ore',
		refName: 'silverOre',
		color: 'green',
		keywords: ['silver', 'ore', 'silver ore'],
		type: { quest: true },
		sellValue: 100,
		description: `A small lump of silver ore`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return silverOre
}

function pickleLily() {//RARE FLOWER FOR KASIA
	let pickleLily = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bright Yellow Flower',
		refName: 'brightYellowFlower',
		color: 'green',
		keywords: ['bright', 'yellow', 'flower', 'bright yellow', 'yellow flower', 'bright yellow flower'],
		type: { quest: true },
		sellValue: 0,
		description: `A beautiful pink and green flower. Someone who loves flowers would absolutely love this.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return pickleLily
}

function luckyCoin() {//QUEST FOR SYLAS
	let luckyCoin = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Lucky Coin',
		refName: 'luckyCoin',
		color: 'green',
		keywords: ['lucky', 'coin', 'lucky coin'],
		type: {
			quest: true,
		},
		sellValue: 0,
		description: `The gold coin has what looks to be a tree minted on one side, and a stag on the other. Both sides are smoothed down from years of being flipped and rubbed. `,
		desc: function () {
			allItemDescription(this)
		},
	}
	return luckyCoin
}
pushItem.push(luckyCoin())
pushItem.push(tutorialKey())
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
function phi() { //place holder item
	let phi = {
		roomId: currentArea.id,
		name: '???',
		color: 'white',
		keywords: [],
		mods: {},
		type: {},
		price: '',
		sellValue: 0,
	}
	return phi
}
function pieceOfBlob() {
	let pieceOfBlob = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Piece of Blob',
		color: 'green',
		keywords: ['piece', 'blob', 'piece of blob'],
		type: {
			quest: true,
		},
		sellValue: 10,
		description: '',
		desc: () => {
			quickMessage('The leftover material from a blob. Perhaps it has some use?', 'desciptions')
		},
	}
	return pieceOfBlob
}
function grassDust() {
	let grassDust = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Grass Dust',
		color: 'green',
		keywords: ['grass', 'dust', 'grass dust'],
		type: {
			sell: true,
		},
		sellValue: 10,
		description: `The remains of a low level grass elemental, in powder form..`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return grassDust
}
function waterDust() {
	let waterDust = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Water Dust',
		color: 'green',
		keywords: ['water', 'dust', 'water dust'],
		type: {
			sell: true,
		},
		sellValue: 10,
		description: `The remains of a low level water elemental, in powder form..`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return waterDust
}
function mudDust() {
	let mudDust = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mud Dust',
		color: 'green',
		keywords: ['mud', 'dust', 'mud dust'],
		type: {
			sell: true,
		},
		sellValue: 10,
		description: `The remains of a low level earth elemental, in powder form..`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return mudDust
}
function flowerBasket(monsterLevel) { //tier 0.5
	let flowerBasket = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Flower Basket',
		refName: 'flowerBasket',
		picture: '',
		color: 'green',
		keywords: ['basket', 'flower basket'],
		requirements: {
			int: 3,
		},
		type: {
		},
		price: 50,
		sellValue: 15,
		description: `A basket used for collecting plants and flowers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return flowerBasket
}
function pickaxe(monsterLevel) { //tier 0.5
	let pickaxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Pickaxe',
		refName: 'pickaxe',
		picture: 'images/weapons/two handed axes/pickaxe/pickaxe.png',
		color: 'green',
		keywords: ['pickaxe'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
			str: 3,
		},
		type: {
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 250,
		sellValue: 15,
		description: `An axe used for mining ore.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return pickaxe
}
function skinningKnife(monsterLevel) { //tier 0.5
	let skinningKnife = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Skinning Knife',
		refName: 'skinningKnife',
		picture: 'images/weapons/daggers/skinning knife/skinning knife.png',
		color: 'green',
		keywords: ['pickaxe'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
			dex: 3,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 50,
		sellValue: 15,
		description: `A knife used for skinning carcassed.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return skinningKnife
}


//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////

//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////

function trainingBow(monsterLevel) { //tier 1
	if (backpack != undefined) {
	}
	let trainingBow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Bow',
		picture: 'images/weapons/bows/training bow/training bow.png',
		color: 'green',
		keywords: ['training', 'bow', 'training bow'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(5, 5),
		mods: {
			piercingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'Bow',
			damageType: `Piercing`,
			twoHanded: true,
			weapon: true,
			bow: true,
			ranged: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 0,
		sellValue: 10,
		description: `A training bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),	}
	return trainingBow
}
function crudelyCarvedBow(monsterLevel) { //tier 1.5
	if (backpack != undefined) {
	}
	let crudelyCarvedBow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crudely Carved Bow',
		color: 'green',
		keywords: ['crudely', 'carved', 'bow', 'crudely carved', 'carved bow', 'crudely carved bow'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(7, 7),
		mods: {
			str: 0,
			agi: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 0,
			bluntPen: 0,
			weight: 3,
		},
		type: {
			twoHanded: true,
			weapon: true,
			bow: true,
			ranged: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 25,
		sellValue: 9,
		description: `A bow made of animal bone with crude animal sinew for a bowstring`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),	}
	return crudelyCarvedBow
}
function shortbow(monsterLevel) { //tier 2
	let shortbow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Short Bow',
		color: 'green',
		keywords: ['short', 'bow', 'short bow'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(10, 10),
		mods: {
			piercingPen: 1,
			weight: 3,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 75,
		sellValue: 32,
		description: `Short bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),	}
	return shortbow
}
function longbow(monsterLevel) { //tier 3
	let longbow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Longbow',
		color: 'green',
		keywords: ['long', 'bow', 'long bow', 'longbow'],
		botDamage: randomNumberRange(6, 6),
		topDamage: randomNumberRange(15, 15),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 250,
		sellValue: 68,
		description: `Long Bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),
		}
	return longbow
}
function honedLongbow(monsterLevel) { //tier 4
	let honedLongbow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Honed Longbow',
		picture: 'images/weapons/bows/honed longbow/honed longbow.png',
		color: 'green',
		keywords: ['honed', 'longbow', 'honed lonbow'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(18, 18),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 750,
		sellValue: 151,
		description: `Honed Longbow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),
		}
	return honedLongbow
}
function battleBow(monsterLevel) { //tier 5
	if (backpack != undefined) {
	}
	let battleBow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Battle Bow',
		color: 'green',
		keywords: ['battle', 'bow', 'battle bow'],
		botDamage: randomNumberRange(11, 11),
		topDamage: randomNumberRange(25, 25),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 750,
		sellValue: 151,
		description: `Battle Bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),
		}
	return battleBow
}

//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////

//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////

function leatherGrips(monsterLevel) { //tier 1.5
	let leatherGrips = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Leather Grips`,
		color: 'green',
		keywords: ['leather', 'grips', 'leather grips'],
		botDamage: randomNumberRange(2, 2),
		topDamage: randomNumberRange(3, 3),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 50,
		sellValue: 6,
		description: `Old leather pugilist gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return leatherGrips
}
function hardenedLeatherFists(monsterLevel) { //tier 2
	let hardenedLeatherFists = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Hardened Leather Fists`,
		picture: {
			right:'images/weapons/fist weapons/hardened leather fists/hardened leather fists right.png',
			left:'images/weapons/fist weapons/hardened leather fists/hardened leather fists left.png' ,
		},
		color: 'green',
		keywords: ['hardened', 'leather', 'fists', 'hardened leather', 'leather fists', 'hardened leather fists'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(4, 4),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 75,
		sellValue: 18,
		description: `Old leather pugilist gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return hardenedLeatherFists
}
function studdedLeatherFists(monsterLevel) { //tier 3
	let studdedLeatherFists = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Studded Leather Fists`,
		picture: {
			right:'images/weapons/fist weapons/studded leather fists/studded leather fists right.png',
			left:'images/weapons/fist weapons/studded leather fists/studded leather fists left.png' ,
		},
		color: 'green',
		keywords: ['studded', 'leather', 'fists', 'studded leather', 'leather fists', 'studded leather fists'],
		botDamage: randomNumberRange(4, 11),
		topDamage: randomNumberRange(4, 11),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 250,
		sellValue: 25,
		description: `Old leather pugilist gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return studdedLeatherFists
}
function fighterFists(monsterLevel) { //tier 4
	let fighterFists = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Fighter Fists`,
		picture: {
			right:'images/weapons/fist weapons/fighter fists/fighter fists right.png',
			left:'images/weapons/fist weapons/fighter fists/fighter fists left.png' ,
		},
		color: 'green',
		keywords: ['fighter', 'fists', 'fighter fists'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(15, 15),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 700,
		sellValue: 80,
		description: `Fighter Fists`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return fighterFists
}
function brawlersGloves(monsterLevel) { //tier 5
	let brawlersGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Brawler's Gloves`,
		picture: {
			right:'images/weapons/fist weapons/brawlers gloves/brawlers gloves right.png',
			left:'images/weapons/fist weapons/brawlers gloves/brawlers gloves left.png' ,
		},
		color: 'green',
		keywords: ['brawler', "brawler's", 'gloves', 'brawler gloves', "brawler's gloves"],
		botDamage: randomNumberRange(9, 5),
		topDamage: randomNumberRange(20, 20),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 1000,
		sellValue: 80,
		description: `Brawler's Gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return brawlersGloves
}









//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////

//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
function muddyDagger(monsterLevel) { //tier 0.5
	let muddyDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Dagger',
		picture: 'images/fake url path',
		color: 'green',
		keywords: ['muddy', 'dagger', 'muddy dagger'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(2, 2),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 0,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 0,
		sellValue: 7,
		description: `A training dagger`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
		}
	return muddyDagger
}
function trainingDagger(monsterLevel) { //tier 1
	let trainingDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Dagger',
		picture: {
			right: 'images/weapons/daggers/training dagger/training dagger right.png',
			left: 'images/weapons/daggers/training dagger/training dagger left.png',
		},
		color: 'green',
		keywords: ['training', 'dagger', 'training dagger'],
		botDamage: randomNumberRange(2, 2),
		topDamage: randomNumberRange(3, 3),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 0,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 30,
		sellValue: 10,
		description: `A training dagger`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return trainingDagger
}
function boneDagger(monsterLevel) { //tier 1.5
	let boneDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bone Dagger',
		color: 'green',
		keywords: ['bone', 'dagger', 'bone dagger'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(5, 5),
		mods: {
			weight: 1,
			slashingPen: 0,
			piercingPen: 0,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 30,
		sellValue: 5,
		description: `A dagger made entirely of bone`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return boneDagger
}

function crudeShiv(monsterLevel) { //tier 1.5
	let crudeShiv = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crude Shiv',
		color: 'green',
		keywords: ['crude', 'shiv', 'crude shiv'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(5, 5),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 20,
		sellValue: 5,
		description: `This looks like it was put together from two other broken daggers`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return crudeShiv
}
function dirk(monsterLevel) { //tier 2
	let dirk = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		picture: {
			right: "images/weapons/daggers/dirk/dirk right.png",
			left: "images/weapons/daggers/dirk/dirk left.png",
		},
		roomId: currentArea.id,
		name: 'Dirk',
		color: 'green',
		keywords: ['dagger', 'dirk'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(4, 4),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 50,
		sellValue: 8,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return dirk
}
function stiletto(monsterLevel) { //tier 3
	let stiletto = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stiletto',
		color: 'green',
		keywords: ['stilleto'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(6, 6),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 125,
		sellValue: 24,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return stiletto
}
function crescentDagger(monsterLevel) { //tier 4
	let crescentDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crescent Dagger',
		color: 'green',
		picture: {
			left: 'images/weapons/daggers/crescent dagger/crescent dagger left.png',
			right: 'images/weapons/daggers/crescent dagger/crescent dagger right.png',
		},
		keywords: ['crescent', 'dagger', 'crescent dagger'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(7, 7),
		mods: {
			agi: 5,
			dex: 5,
			slashingPen: 10,
			piercingPen: 10,
			weight: 5,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 420,
		sellValue: 55,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return crescentDagger
}
function mageMasher(monsterLevel) { //tier 5
	let mageMasher = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mage Masher',
		color: 'green',
		keywords: ['mage', 'masher', 'mage masher'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(11, 14),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 1,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 420,
		sellValue: 55,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return mageMasher
}
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////

//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
function muddyShortsword(monsterLevel) { //tier 0.5
	let muddyShortsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Muddy Shortsword',
		picture: 'images/weapons/one handed swords/training shortsword/training shortsword.png',
		color: 'green',
		keywords: ['muddy', 'shortsword', 'muddy shortsword'],
		botDamage: randomNumberRange(2, 2),
		topDamage: randomNumberRange(3, 3),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		requirements: {},
		type: {
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 25,
		sellValue: 7,
		description: `A muddy and rusted blade likely discarded long ago because of it's poor condition`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return muddyShortsword
}

function trainingShortsword(monsterLevel) { //tier 1
	let trainingShortsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Shortsword',
		picture: {
			right: "images/weapons/one handed swords/training shortsword/training shortsword right.png",
			left: "images/weapons/one handed swords/training shortsword/training shortsword left.png",
		},
		color: 'green',
		keywords: ['training', 'sword', 'short', 'shortsword', 'training shortsword'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(4, 4),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		requirements: {
		},
		type: {
			weapon: true,
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			oneHanded: true,
			sword: true,
			slashing: true,
			piercing: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 25,
		sellValue: 7,
		description: `Almost the length of a dagger, and easy enough to wield for the unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return trainingShortsword
}
function rustySword(monsterLevel) { //tier 1.5
	let rustySword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rusty Sword',
		picture: {
			right: "images/weapons/one handed swords/training shortsword/training shortsword right.png",
			left: "images/weapons/one handed swords/training shortsword/training shortsword left.png",
		},
		color: 'green',
		keywords: ['rusty', 'sword', 'rusty sword'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(6, 6),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		requirements: {
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 100,
		sellValue: 7,
		description: `A rusty sword`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return rustySword
}
function shortsword(monsterLevel) { //tier 2
	let shortsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shortsword',
		picture: {
			right: "images/weapons/one handed swords/training shortsword/training shortsword right.png",
			left: "images/weapons/one handed swords/training shortsword/training shortsword left.png",
		},		color: 'green',
		keywords: ['short', 'sword', 'shortsword', 'short sword'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(5, 5),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 50,
		sellValue: 10,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return shortsword
}
function broadSword(monsterLevel) { //tier 3
	let broadSword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Broadsword',
		picture: {
			right: "images/weapons/one handed swords/broadsword/broadsword right.png",
			left: "images/weapons/one handed swords/broadsword/broadsword left.png",
		},		
		color: 'green',
		keywords: ['broad', 'sword', 'broadsword', 'broad sword'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(12, 12),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 250,
		sellValue: 32,
		description: `A broadsword.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return broadSword
}

function gladius(monsterLevel) { //tier 4
	let gladius = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Gladius',
		picture: {
			right: "images/weapons/one handed swords/gladius/gladius right.png",
			left: "images/weapons/one handed swords/gladius/gladius left.png",
		},			color: 'green',
		keywords: ['gladius'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 600,
		sellValue: 80,
		description: `A well crafted gladius.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return gladius
}

function sabre(monsterLevel) { //tier 5
	let itemPrice = 1000
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let sabre = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sabre',
		color: 'green',
		keywords: ['sabre'],
		botDamage: randomNumberRange(8, 9),
		topDamage: randomNumberRange(17, 20),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: itemPrice,
		sellValue: sellValue,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		}
	return sabre
}

//////////////////////////////////////////////////////////////////////////////////////////////////////AXES
//////////////////////////////////////////////////////////////////////////////////////////////////////AXES

function handAxe(monsterLevel) { //tier 2
	let handAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Hand Axe',
		picture: 'images/weapons/one handed axes/hand axe/hand axe.png',
		color: 'green',
		keywords: ['hand', 'axe', 'hand axe'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(9, 9),
		mods: {
			slashingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing`,
			weapon: true,
			oneHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 50,
		sellValue: 10,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return handAxe
}

function beardedAxe(monsterLevel) { //tier 3
	let beardedAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bearded Axe',
		picture: 'images/weapons/one handed axes/bearded axe/bearded axe.png',
		color: 'green',
		keywords: ['bearded', 'axe', 'bearded axe'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(12, 12),
		mods: {
			slashingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing`,
			weapon: true,
			oneHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 250,
		sellValue: 32,
		description: `A bearded axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return beardedAxe
}
function serratedAxe(monsterLevel) { //tier 4
	let serratedAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Serrated Axe',
		color: 'green',
		keywords: ['serrated', 'axe', 'serrated axe'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing`,
			weapon: true,
			oneHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 600,
		sellValue: 80,
		description: `A well crafted bronze axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return serratedAxe
}
//////////////////////////////////////////////////////////////////MACES
//////////////////////////////////////////////////////////////////MACES
function boneClub(monsterLevel) { //tier 1.5
	let boneClub = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bone Club',
		color: 'green',
		keywords: ['bone', 'club', 'bone club'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(5, 5),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		requirements: {
			str: 2,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			club: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 25,
		sellValue: 7,
		description: `What looks to be a medium sized bone of an animal`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return boneClub
}

function mace(monsterLevel) { //tier 2
	let mace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mace',
		picture: {
			left: 'images/weapons/one handed maces/mace/mace left.png',
			right: 'images/weapons/one handed maces/mace/mace right.png'
		},		
		color: 'green',
		keywords: ['mace'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(9, 9),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 50,
		sellValue: 10,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return mace
}

function stoutedMace(monsterLevel) { //tier 3
	let stoutedMace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stouted Mace',
		picture: {
			left: 'images/weapons/one handed maces/stouted mace/stouted mace left.png',
			right: 'images/weapons/one handed maces/stouted mace/stouted mace right.png'
		},
		color: 'green',
		keywords: ['stouted', 'mace', 'stouted mace'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(12, 12),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 250,
		sellValue: 32,
		description: `A stouted mace.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return stoutedMace
}
function flangedMace(monsterLevel) { //tier 4
	let flangedMace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Flanged Mace',
		picture: 'images/weapons/one handed maces/flanged mace/flanged mace.png',
		color: 'green',
		keywords: ['flanged', 'mace', 'flanged mace'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(15, 15),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 600,
		sellValue: 80,
		description: `A well crafted flanged mace.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return flangedMace
}
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////

//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
function trainingTwoHandedSword(monsterLevel) {//tier 1
	let trainingTwoHandedSword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Two-Handed Sword',
		picture: "images/weapons/two handed swords/training two handed sword/training two handed sword.png",
		color: 'green',
		keywords: ['training', 'two-handed', 'sword', 'training sword', 'training two-handed sword', 'two handed', 'twohanded', 'two handed sword', 'training two handed sword'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(6, 6),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
			str: 1,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			skillUsed: `Two Handed`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 5,
		sellValue: 5,
		description: `A sword just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),	
	}
	return trainingTwoHandedSword
}
function largeBoneClub(monsterLevel) { //tier 1.5
	let largeBoneClub = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Large Bone Club',
		color: 'green',
		keywords: ['large', 'bone', 'club', 'large bone', 'bone club', 'large bone club'],
		botDamage: randomNumberRange(6, 6),
		topDamage: randomNumberRange(7, 7),
		mods: {
			weight: 10,
		},
		requirements: {
			str: 3,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			skillUsed: `Two Handed`,
			weapon: true,
			twoHanded: true,
			club: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 35,
		sellValue: 7,
		description: `What looks to be the large leg bone of an animal or creature`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),	
	}
	return largeBoneClub
}
function boneTippedSpear(monsterLevel) { //tier 1.5
	let boneTippedSpear = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bone-Tipped Spear',
		color: 'green',
		keywords: ['bone', 'tipped', 'spear', 'bone-tipped', 'bone-tipped spear', 'bone tipped', 'bone tipped spear'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(10, 10),
		mods: {
			weight: 10,
			piercingPen: 0,
		},
		requirements: {
			str: 3,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Piercing`,
			weapon: true,
			twoHanded: true,
			spear: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 5,
		sellValue: 7,
		description: `A long sliver of wood that looks very similar to the wood used in Galvadian buildings. It's stopped with a sharpened piece of bone`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),	
	}
	return boneTippedSpear
}
function longsword(monsterLevel) { //tier 2
	let longsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Longsword',
		picture: "images/weapons/two handed swords/longsword/longsword.png",
		color: 'green',
		keywords: ['longsword'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(8, 8),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 100,
		sellValue: 37,
		description: `A sword just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return longsword
}

function poleAxe(monsterLevel) { //tier 2
	let poleAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Poleaxe',
		picture: 'images/weapons/two handed axes/poleaxe/poleaxe.png',
		color: 'green',
		keywords: ['pole', 'axe', 'poleaxe'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(10, 10),
		mods: {
			slashingPen: 0,
			weight: 10,
		},
		requirements: {
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 100,
		sellValue: 37,
		description: `An axe just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return poleAxe
}


function sledgehammer(monsterLevel) { //tier 2
	let sledgehammer = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sledgehammer',
		picture: 'images/weapons/two handed maces/sledgehammer/sledgehammer.png',
		color: 'green',
		keywords: ['sledgehammer'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(10, 10),
		mods: {
			bluntPen: 0,
			weight: 10,
		},
		requirements: {
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 100,
		sellValue: 37,
		description: `A mace just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return sledgehammer
}
function claymore(monsterLevel) { //tier 3
	let claymore = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Claymore',
		picture: "images/weapons/two handed swords/claymore/claymore.png",
		color: 'green',
		keywords: ['claymore'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(11, 11),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 20,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 500,
		sellValue: 77,
		description: `A long, double edged broadsword. You typically see these wielded by the town guards.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return claymore
}
function beardedPoleAxe(monsterLevel) { //tier 3
	let beardedPoleAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bearded Poleaxe',
		picture: "images/weapons/two handed maces/maul/maul.png",
		color: 'green',
		keywords: ['bearded', 'poleaxe', 'bearded poleaxe'],
		botDamage: randomNumberRange(8, 8),
		topDamage: randomNumberRange(17, 17),
		mods: {
			slashingPen: 0,
			weight: 20,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 500,
		sellValue: 75,
		description: `A large, sturdy two-handed axe`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return beardedPoleAxe
}
function maul(monsterLevel) { //tier 3
	let maul = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Maul',
		picture: 'images/weapons/two handed maces/maul/maul.png',
		color: 'green',
		keywords: ['maul'],
		botDamage: randomNumberRange(8, 8),
		topDamage: randomNumberRange(17, 17),
		mods: {
			bluntPen: 0,
			weight: 30,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 500,
		sellValue: 75,
		description: `A large, sturdy two-handed mace`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return maul
}
function bastardSword(monsterLevel) { //tier 4
	let bastardSword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bastard Sword',
		picture: "images/weapons/two handed swords/bastard sword/bastard sword.png",
		color: 'green',
		keywords: ['bastard', 'sword', 'bastard sword'],
		botDamage: randomNumberRange(12, 12),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A little shorter than the claymore, but is lighter and more wieldy for a two handed sword.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return bastardSword
}
function berserkBlade(monsterLevel) { //tier 4
	let berserkBlade = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Berserk Blade',
		picture: "images/weapons/two handed swords/berserk blade/berserk blade.png",
		color: 'green',
		keywords: ['berserk', 'blade', 'berserk blade'],
		botDamage: randomNumberRange(12, 12),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 10,
			piercingPen: 10,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `This sword is a Warrior's Guild heirloom that is passed down only to those who have proven themselves to be fearless in the face of death.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return berserkBlade
}
function serratedPoleaxe(monsterLevel) { //tier 4
	let serratedPoleaxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Serrated Poleaxe',
		color: 'green',
		keywords: ['serrated', 'poleaxe', 'serrated poleaxe'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			slashingPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large, sturdy axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return serratedPoleaxe
}
function battleAxe(monsterLevel) { //tier 5
	let battleAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Two-Handed Battle Axe',
		color: 'green',
		keywords: ['two', 'two handed', 'two-handed', 'two handed battle', 'battle axe', 'battle', 'axe', 'two handed battle axe', 'two-handed battle axe'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			slashingPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large, sturdy axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return battleAxe
}
function flangedMaul(monsterLevel) { //tier 4
	let flangedMaul = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Flanged Maul',
		color: 'green',
		keywords: ['flanged', 'maul', 'flanged maul'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			bluntPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large maul with a just long enough to wield with two hands`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return flangedMaul
}
function warHammer(monsterLevel) { //tier 5
	let warHammer = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Warhammer',
		color: 'green',
		keywords: ['warhammer', 'hammer'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			bluntPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large maul with a just long enough to wield with two hands`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return warHammer
}


function greatsword(monsterLevel) { //tier 5
	let itemPrice = 1000
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let greatsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Greatsword',
		color: 'green',
		keywords: ['greatsword'],
		botDamage: randomNumberRange(10, 12),
		topDamage: randomNumberRange(30, 34),
		mods: {
			slashingPen: 15,
			piercingPen: 7,
			bluntPen: 0,
			weight: 30,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: itemPrice,
		sellValue: sellValue,
		description: `Just as long as the claymore, but twice as wide. It has no hilt to reduce the already strenuous weight.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return greatsword
}

//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////

//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////

function trainingStaff(monsterLevel) { //tier 1
	let itemPrice = 10
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let trainingStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Staff',
		color: 'green',
		keywords: ['training', 'staff', 'training staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 3,
			weight: 1,
		},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		requirements: {
			arcaneKnowledge: 2,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: itemPrice,
		sellValue: sellValue,
		description: `Just as long as the claymore, but twice as wide. It has no hilt to reduce the already strenuous weight.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return trainingStaff
}
function woodenStaff(monsterLevel) { //tier 2
	let woodenStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Wooden Staff',
		color: 'green',
		keywords: ['wooden', 'staff', 'wooden staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 7,
			weight: 5,
		},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 80,
		sellValue: 150,
		description: `A long wooden staff`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return woodenStaff
}

function powerStaff(monsterLevel) { //tier 3
	let powerStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Power Staff',
		color: 'green',
		keywords: ['power', 'staff', 'power staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 18,
			weight: 5,
		},
		requirements: {},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 250,
		sellValue: 92,
		description: `A strong Mage staff`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return powerStaff
}
function runeStaff(monsterLevel) { //tier 4
	let runeStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rune Staff',
		color: 'green',
		keywords: ['runed', 'staff', 'runed staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 30,
			weight: 8,
		},
		requirements: {},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1200,
		sellValue: 140,
		description: `A strong Mage staff`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return runeStaff
}

//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////

//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////

//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////

//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
function mailChestGuard() {
	let mailChestGuard = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Chestguard',
		color: 'green',
		keywords: ['mail', 'chestguard', 'mail chestguard'],
		mods: {
			weight: 20,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 3,
		},
		type: {
			armor: true,
			chest: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 80,
		sellValue: 10,
		description: '',
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailChestGuard
}
function mailHelm() {
	let mailHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Helm',
		color: 'green',
		keywords: ['mail', 'helm', 'mail helm'],
		mods: {
			weight: 10,
			slashingArmor: 0,
			piercingArmor: 0,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			helm: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 80,
		sellValue: 10,
		description: 'Mail Helm',
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailHelm
}
function mailGloves() {
	let mailGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Gloves',
		color: 'green',
		keywords: ['mail', 'gloves', 'mail gloves'],
		mods: {
			weight: 10,
			slashingArmor: 2,
			piercingArmor: 0,
			bluntArmor: 0,
		},
		type: {
			armor: true,
			hands: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Mail Gloves',
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailGloves
}
function mailBoots() {
	let mailBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Boots',
		color: 'green',
		keywords: ['mail boots', 'mail', 'boots'],
		mods: {
			weight: 10,
			slashingArmor: 0,
			piercingArmor: 2,
			bluntArmor: 0,
		},
		type: {
			armor: true,
			feet: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Boots',
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailBoots
}
function mailLegs() {
	let mailLegs = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Legs',
		color: 'green',
		keywords: ['mail legs', 'mail', 'legs'],
		mods: {
			weight: 20,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			feet: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Mail legs.',
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailLegs
}
function mailShoulders() {
	let mailShoulders = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Shoulders',
		color: 'green',
		keywords: ['mail shoulders', 'mail', 'shoulders'],
		mods: {
			weight: 20,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			feet: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Mail shoulders.',
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailShoulders
}

function ringmailHauberk(monsterLevel) {
	let ringmailHauberk = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmamil Hauberk',
		color: 'green',
		keywords: ['ringmail', 'hauberk', 'ringmail hauberk'],
		mods: {
			weight: 15,
			slashingArmor: 5,
			piercingArmor: 5,
			bluntArmor: 5,		
		},
		type: {
			armor: true, //isArmor: 'true'
			chest: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Chestguard`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailHauberk
}
function ringmailLeggings(monsterLevel) {
	let ringmailLeggings = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Leggings',
		color: 'green',
		keywords: ['ringmail', 'leggings', 'ringmail leggings'],
		mods: {
			weight: 5,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 3,		
		},
		type: {
			armor: true, //isArmor: 'true'
			legs: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'

		},
		price: 1000,
		sellValue: 500,
		description: `Legplates`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailLeggings
}
function ringmailShoulders() {
	let ringmailShoulders = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Shoulderdrapes',
		color: 'green',
		keywords: ['ringmail', 'shoulders', 'ringmail shoulders'],
		mods: {
			weight: 10,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,		
		},
		type: {
			armor: true, //isArmor: 'true'
			shoulders: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Shoulderguards`,
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailShoulders
}
function ringmailHelm() { //tier 3
	let ringmailHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Helm',
		color: 'green',
		keywords: ['ringmail', 'helm', 'ringmail helm'],
		mods: {
			weight: 10,
			slashingArmor: 0,
			piercingArmor: 0,
			bluntArmor: 3,
		},
		type: {
			armor: true, //isArmor: 'true'
			helm: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Plate Helmet`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailHelm
}
function ringmailGloves(monsterLevel) {
	let ringmailGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Gloves',
		color: 'green',
		keywords: ['ringmail', 'gloves', 'ringmail gloves'],
		mods: {
			weight: 5,
			slashingArmor: 3,
			piercingArmor: 0,
			bluntArmor: 0,		},
		requirements: {
			guild: 'Warrior',
		},
		type: {
			armor: true,
			feet: true,
			plate: true,
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Plate Gauntlets`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailGloves
}
function ringmailStompers(monsterLevel) {
	let ringmailStompers = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Stompers',
		color: 'green',
		keywords: ['ringmail', 'stompers', 'ringmail stompers'],
		mods: {
			weight: 5,
			slashingArmor: 0,
			piercingArmor: 3,
			bluntArmor: 0,		
		},
		requirements: {
			guild: 'Warrior',
		},
		type: {
			armor: true,
			feet: true,
			plate: true,
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Plate boots`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailStompers
}

//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////

////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////

function clothCap(monsterLevel) { //tier 2
	let clothCap = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Cap',
		color: 'green',
		keywords: ['cloth cap', 'cloth', 'cap'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		requirements: {
			int: 2,
		},
		type: {
			armor: true,
			head: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 125,
		description: `A very light cap. Provides minimal use for defense, but you feel slightly smarter wearing it`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothCap
}
function silkHat(monsterLevel) { //tier 3
	let silkHat = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Hat',
		color: 'green',
		keywords: ['silk hat', 'cloth', 'hat'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		requirements: {
			int: 2,
		},
		type: {
			armor: true,
			head: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 120,
		sellValue: 125,
		description: `A very light cap. Provides minimal use for defense, but you feel slightly smarter wearing it`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkHat
}
function apprenticeRobes(monsterLevel) { //tier 2
	let apprenticeRobes = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Apprentice Robes',
		color: 'green',
		keywords: ['apprentice', 'robes', 'apprentice robes'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 80,
		sellValue: 8,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return apprenticeRobes
}
function silkVestments(monsterLevel) { //tier 3
	let silkVestments = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Vestments',
		color: 'green',
		keywords: ['silk', 'vestments', 'silk vestments'],
		mods: {
			weight: 1,
			wis: 2,
			spellPower: 5,
		},
		type: {
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 240,
		sellValue: 24,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkVestments
}
function clothMantle(monsterLevel) { //tier 2
	let clothMantle = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Mantle',
		color: 'green',
		keywords: ['cloth', 'mantle', 'cloth mantle'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 5,
		},
		type: {
			armor: true,
			shoulders: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 5,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothMantle
}
function silkShoulders(monsterLevel) { //tier 3
	let silkShoulders = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Shoulders',
		color: 'green',
		keywords: ['silk', 'shoulders', 'silk shoulders'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 5,
		},
		type: {
			armor: true,
			shoulders: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 150,
		sellValue: 15,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkShoulders
}
function clothPants(monsterLevel) { //tier 2
	let clothPants = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Pants',
		color: 'green',
		keywords: ['cloth', 'pants', 'cloth pants'],
		mods: {
			weight: 1,
			spellPower: 2,
		},
		type: {
			armor: true,
			legs: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 70,
		sellValue: 7,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothPants
}
function silkTrousers(monsterLevel) { //tier 3
	let silkTrousers = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Trousers',
		color: 'green',
		keywords: ['silk', 'trousers', 'silk trousers'],
		mods: {
			weight: 1,
			spellPower: 2,
		},
		type: {
			armor: true,
			legs: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 210,
		sellValue: 21,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkTrousers
}
function clothGloves(monsterLevel) { //tier 2
	let clothGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Gloves',
		color: 'green',
		keywords: ['cloth', 'gloves', 'cloth gloves'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			hands: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 5,
		description: `Provides little defense, but allows the wearer to maintain their finger dexterity`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothGloves
}
function silkGloves(monsterLevel) { //tier 3
	let silkGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Gloves',
		color: 'green',
		keywords: ['silk', 'gloves', 'silk gloves'],
		mods: {
			weight: 1,
			armor: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			hands: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 150,
		sellValue: 15,
		description: `Provides little defense, but allows the wearer to maintain their finger dexterity`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkGloves
}
function sandals(monsterLevel) { //tier 2
	let sandals = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sandals',
		color: 'green',
		keywords: ['sandals'],
		mods: {
			weight: 1,
			armor: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			feet: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 5,
		description: `Basic foot protection`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return sandals
}
function silkFootwraps(monsterLevel) { //tier 3
	let silkFootwraps = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Footwraps',
		color: 'green',
		keywords: ['silk', 'footwraps', 'silk footwraps'],
		mods: {
			weight: 1,
			armor: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			feet: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 150,
		sellValue: 15,
		description: `Basic foot protection`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkFootwraps
}
function cultRobes(monsterLevel) { //tier 2.5
	let cultRobes = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cult Robes',
		color: 'green',
		keywords: ['cult', 'robes', 'cult robes'],
		mods: {
			weight: 0,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		sellValue: 40,
		description: `The robes still smell of someone else`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return cultRobes
}

////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////

////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////



////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////

////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
function muddyGloves(monsterLevel) {  //tier 0.5
	let muddyGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Muddy Gloves',
		color: 'green',
		keywords: ['muddy', 'gloves', 'muddy gloves'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 0,
			bluntArmor: 0,
		},
		type: {
			material: 'Leather',
			armor: true,
			hands: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 0,
		sellValue: 12,
		description: `Holes have been eaten into most parts of these gloves`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return muddyGloves
}

function shoddyJerkin(monsterLevel) { //tier 1
	let shoddyJerkin = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shoddy Jerkin',
		color: 'green',
		keywords: ['shoddy', 'jerkin', ' shoddy jerkin'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,		
		},
		type: {
			armor: true,
			body: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'body',
		desc: function () {
			itemDescription(this)
		},
	}
	return shoddyJerkin
}

function waterloggedBoots(monsterLevel) { //tier 1
	let waterloggedBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Waterlogged Boots',
		color: 'green',
		keywords: ['waterlogged', 'boots', 'waterlogged boots'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 1,
			bluntArmor: 0,
		},
		requirements: {
		},
		type: {
			armor: true,
			feet: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 0,
		sellValue: 12,
		description: `Ragged boots that look like they were taken off a dead body`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return waterloggedBoots
}

function grassStainedHat(monsterLevel) { //tier 0.5
	let grassStainedHat = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Grass Stained Hat',
		color: 'green',
		keywords: ['grass', 'stained', 'hat', 'grass stained', 'stained hat', 'grass stained hat'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 0,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 0,
		sellValue: 12,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return grassStainedHat
}
function leatherCap(monsterLevel) { //tier 2
	let leatherCap = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Cap',
		color: 'green',
		keywords: ['leather', 'cap', 'leather cap'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 0,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 50,
		sellValue: 6,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherCap
}

function studdedLeatherHelm(monsterLevel) { //tier 3
	let studdedLeatherHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Helm',
		color: 'green',
		keywords: ['leather', 'helm', 'leather helm', 'studded leather', 'studded leather helm'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 180,
		sellValue: 18,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherHelm
}

function leatherTunic(monsterLevel) { //tier 2
	let leatherTunic = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Tunic',
		color: 'green',
		keywords: ['leather', 'tunic', 'leather tunic'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 80,
		sellValue: 8,
		description: `A simple tunic sturdy enough for training.`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherTunic
}
function studdedLeatherJerkin(monsterLevel) { //tier 3
	let studdedLeatherJerkin = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Jerkin',
		color: 'green',
		keywords: ['leather', 'jerkin', 'leather jerkin', 'studded leather jerkin'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 240,
		sellValue: 24,
		description: `A simple jerkin sturdy enough for training.`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherJerkin
}

function shoulderguards(monsterLevel) { //tier 2
	let shoulderguards = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shoulderguards',
		color: 'green',
		keywords: ['shoulderguards'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			shoulders: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 60,
		sellValue: 5,
		description: 'Leather shoulderguards',
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return shoulderguards
}

function studdedShoulderguards(monsterLevel) { //tier 3
	let studdedShoulderguards = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Shoulderguards',
		color: 'green',
		keywords: ['studded', 'shoulderguards', 'studded shoulderguards'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			shoulders: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 150,
		sellValue: 15,
		description: 'Leather shoulderguards',
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedShoulderguards
}

function leatherPants(monsterLevel) { //tier 2
	let leatherPants = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Pants',
		color: 'green',
		keywords: ['leather ', 'pants', 'leather pants'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			legs: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 70,
		sellValue: 7,
		description: 'Leather pants',
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherPants
}
function studdedTrousers(monsterLevel) { //tier 3
	let studdedTrousers = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Trousers',
		color: 'green',
		keywords: ['studded', 'trousers', 'studded trousers'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			legs: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 210,
		sellValue: 21,
		description: 'Leather pants',
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedTrousers
}

function leatherGloves(monsterLevel) { //tier 2
	let leatherGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Gloves',
		color: 'green',
		keywords: ['leather', 'gloves', 'leather gloves'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 0,
			bluntArmor: 0,
		},
		type: {
			skillUsed: 'Hand Protection',
			armor: true,
			hands: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 50,
		sellValue: 5,
		description: `Gloves`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherGloves
}
function studdedLeatherGloves(monsterLevel) { //tier 3
	let studdedLeatherGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Gloves',
		color: 'green',
		keywords: ['leather', 'gloves', 'leather gloves', 'studded leather gloves'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			skillUsed: 'Hand Protection',
			armor: true,
			hands: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 200,
		sellValue: 100,
		description: `Gloves`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherGloves
}

function leatherBoots(monsterLevel) { //tier 2
	let leatherBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Boots',
		color: 'green',
		keywords: ['leather', 'boots', 'leather boots'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 1,
			bluntArmor: 0,
		},
		requirements: {
		},
		type: {
			armor: true,
			feet: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 50,
		sellValue: 100,
		description: `A simple boots sturdy enough for training.`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherBoots
}
function studdedLeatherBoots(monsterLevel) { //tier 3
	let studdedLeatherBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Boots',
		color: 'green',
		keywords: ['leather', 'boots', 'leather boots', 'studded leather boots'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		requirements: {
		},
		type: {
			armor: true,
			feet: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 200,
		sellValue: 100,
		description: `A simple boots sturdy enough for training.`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherBoots
}

function ratSkullHelm(monsterLevel) {  //tier 2.5
	let ratSkullHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Skull Helm',
		color: 'green',
		keywords: ['rat', 'skull', 'helm', 'rat skull', 'skull helm', 'rat skull helm'],
		mods: {
			weight: 1,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A giant rat's skull a little larger than the size of a human head`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return ratSkullHelm
}

function ratHideTunic(monsterLevel) {  //tier 2.5
	let ratHideTunic = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Hide Tunic',
		color: 'green',
		keywords: ['rat', 'hide', 'tunic', 'rat hide', 'hide tunic', 'rat hide tunic'],
		mods: {
			weight: 1,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A tunic stitched together of what looks to be hundreds of rat skins`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return ratHideTunic
}

function ratHidePants(monsterLevel) {  //tier 2.5
	let ratHidePants = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Hide Pants',
		color: 'green',
		keywords: ['rat', 'hide', 'pants', 'rat hide', 'hide pants', 'rat hide pants'],
		mods: {
			weight: 1,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			legs: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A pair of pants stitched together with rat skin, tails and all.`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return ratHidePants
}








////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////

/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
function trainingShield(monsterLevel) {
	let trainingShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: "Training Shield",
		picture: 'images/armor/shields/training shield/training shield.png',
		color: 'green',
		keywords: ['training shield', 'training', 'shield'],
		mods: {
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
			weight: 5,
		},	
		type: {
			skillUsed: 'Shields',
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 80,
		sellValue: 8,
		description: `This shield is about as sturdy as a dinner plate with a turd on it.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return trainingShield
}
function squiresShield(monsterLevel) {
	let squiresShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: "Squire's Shield",
		picture: `images/armor/shields/squire's shield/squire's shield.png`,
		color: 'green',
		keywords: ["squire's", 'shield', "squire's shield", 'squire shield'],
		mods: {
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
			weight: 5,		},
		requirements: {
			shields: 2,
		},
		type: {
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 50,
		sellValue: 8,
		description: `This shield is about as sturdy as a dinner plate with a turd on it.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return squiresShield
}
function bronzeShield(monsterLevel) {
	let bronzeShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bronze Shield',
		color: 'green',
		keywords: ['bronze', 'shield', 'bronze shield'],
		mods: {
			slashingArmor: 4,
			piercingArmor: 4,
			bluntArmor: 4,
			weight: 5,
		},
		requirements: {
			shields: 3,
		},
		type: {
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 250,
		sellValue: 25,
		description: `This shield is about as sturdy as a dinner plate with a turd on it.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return bronzeShield
}

function galvadianKiteShield(monsterLevel) {
	let galvadianKiteShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Galvadian Kite Shield',
		color: 'green',
		keywords: ['galvadian', 'kite', 'shield', 'galvadian kite', 'kite shield', 'galvadian kite shield'],
		mods: {
			slashingArmor: 6,
			piercingArmor: 6,
			bluntArmor: 6,
			weight: 15,		
		},
		requirements: {
			shields: 4,
		},
		type: {
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 2000,
		sellValue: 1000,
		description: ``,
		desc: function () {
			itemDescription(this)
		},
	}
	return galvadianKiteShield
}

///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////
///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////

function koboldToothNecklace() {
	let koboldToothNecklace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Kobold Tooth Necklace',
		color: 'green',
		keywords: ['kobold', 'tooth', 'necklace', 'kobold tooth', 'tooth necklace', 'kobold tooth necklace'],
		mods: {
			str: 1,
			dex: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			neck: true,
			jewelry: true,
		},
		price: 10,
		sellValue: 5,
		description: `A necklace made from Kobold teeth`,
		slot: 'neck',
		desc: function () {
			itemDescription(this)
		},
	}
	return koboldToothNecklace
}

function oldRing(monsterLevel) {
	let itemPrice = 100
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let oldRing = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'old ring',
		color: 'green',
		keywords: ['old', 'ring', 'old ring'],
		mods: {
			int: 5,
			wis: 5,
		},
		type: {
			armor: true,
			ring: true,
		},
		slot: slot13,
		desc: function () {
			itemDescription(this)
		},
	}
	return oldRing
}

///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////
///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////

//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
function smallPotion(monsterLevel) {
	let smallPotion = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Potion',
		color: 'green',
		keywords: ['small', 'potion', 'small potion', 'small pot', 'pot'],
		type: {
			consumable: true,
			drink: true,
			potionType: 'Health Potion',
		},
		property: function () {
			var currentHealth = player.health
			var maxHealth = player.maxHealth
			var healthDifference = maxHealth - currentHealth
			if (healthDifference >= 20) {
				player.health = currentHealth + 20
				quickMessage(`You restore 20 hit points`)
			} else {
				player.health = currentHealth + healthDifference
				quickMessage(`You restore ${healthDifference} hit points`)
			}
			displayPlayerHealthFunc()
			updatePlayerStats()
		},
	}
	return smallPotion
}
//_________________________________________________________________________________________________________________
function statDrink(secondCommand) {
	let selectedItem = pushItem.find(item => item.keywords.find(keyword => keyword == secondCommand))
	let line1 = document.createElement('div')
	if (secondCommand == undefined) {
		customizeEachWord(`You must specify what you want to drink`, 'white', line1)
	} else if (selectedItem == undefined) {
		customizeEachWord(`You do not have a ${secondCommand} to drink`, 'white', line1)
	} else if (selectedItem.type != drink) {
		customizeEachWord(`It would be proposterous to try to drink a ${secondCommand}!`, 'white', line1)
	} else if (selectedItem.roomId == backpack) {
		customizeEachWord(`You must first hold your ${selectedItem.name} before drinking it`, 'white', line1)
	} else if (selectedItem.roomId == slot1 || selectedItem.roomId == slot2) {
		selectedItem.property()
		if (player.rightHand == selectedItem.name) {
			player.rightHand = empty
		} else {
			player.leftHand = empty
		}
		let removeThisItem = pushItem.findIndex(x => x.id == selectedItem.id)
		pushItem.splice(removeThisItem, 1)
	}
}
//item is in right hand, item type is armor
function getAllItemsOnPerson() {
	return pushItem.filter(
		item =>
			item.roomId == 'right hand' ||
			item.roomId == 'left hand' ||
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet' ||
			item.roomId == 'backpack'
	)
}
function donWearEquip(secondCommand) {
	let allItemsOnPerson = pushItem.filter(
		item =>
			item.roomId == 'right hand' ||
			item.roomId == 'left hand' ||
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet' ||
			item.roomId == 'backpack'
	)
	let itemInBackpack = allItemsOnPerson.find(item => item.roomId == 'backpack' && item.keywords.find(keyword => keyword == secondCommand))
	let selectedItem = allItemsOnPerson.find(item => item.roomId == 'right hand' && item.type.armor) || allItemsOnPerson.find(item => item.roomId == 'left hand' && item.type.armor)
	let selectedSlot = selectedItem ? selectedItem.slot : undefined
	//if target item is in right hand or left hand and item of that type is NOT equipped
	if (secondCommand == undefined || /^\s*$/.test(secondCommand) == true) {
		quickMessage(`You must specify what you want to unpack.`)
	}
	if (selectedItem != undefined && player[selectedSlot] == empty && selectedItem.type.armor != undefined) {
		if (requirementsMet(selectedItem) == false) {
			quickMessage(`You do not meet the requirements to equip your ${selectedItem.name}`)
			return
		}
		let line1 = lineFunc()
		customizeEachWord(`You equip your `, 'white', line1)
		customizeEachWord(`${selectedItem.name}`, selectedItem.color, line1)
		let rightOrLeft = selectedItem.roomId == slot1 ? true : false
		if (rightOrLeft) {
			player.rightHand = empty
		} else if (rightOrLeft == false) {
			player.leftHand = empty
		}
		selectedItem.roomId = selectedSlot
		player[selectedSlot] = selectedItem.name
		armorAddPlayerAttribute(selectedItem)
		//if target item is in right hand or left hand and item of that type IS equipped
	} else if (itemInBackpack != undefined && itemInBackpack.type.armor != undefined) {
		quickMessage(`You need to wield your ${itemInBackpack.name} before equipping it`)
	} else if ((itemInBackpack != undefined && itemInBackpack.type.armor != undefined) || (selectedItem != undefined && player[selectedSlot] != empty)) {
		quickMessage(`You already have something equipped in that slot.`)
	} else if (itemInBackpack != undefined && itemInBackpack.type.armor == undefined) {
		quickMessage(`You cannot wear a ${itemInBackpack.name}`)
	} else if (selectedItem == undefined && itemInBackpack == undefined) {
		quickMessage(`You do not own a ${secondCommand} to equip`)
		// } else if (selectedItem == undefined) {
		// 	quickMessage(`You need to wield something first before attempting to equip it.`)
	} else if (itemInBackpack == undefined) {
		quickMessage(`You do not own a ${secondCommand} to equip.`)
	} else {
		quickMessage(`Command not yet coded`)
	}

	// if (secondCommand == undefined) {
	// 	quickMessage(`You must specify what you want to equip`)
	// } else if (selectedItem == undefined && allItemsOnPerson.find(item => item.keywords.find(keyword => keyword == secondCommand)) != undefined) {
	// 	quickMessage(`You do not have a ${secondCommand} to wear`)
	// } else if (player[selectedSlot] != empty) {
	// 	quickMessage(`You already have something equipped of that armor type`)
	// } else if (!selectedItem.type.armor) {
	// 	quickMessage(`It would be proposterous to wear a ${secondCommand}`)
	// } else if (selectedItem.roomId == backpack) {
	// 	quickMessage(`You must first wield your ${selectedItem.name} before equipping it`)
	// } else if ((selectedItem.type.armor && selectedItem.roomId == slot1) || selectedItem.roomId == slot2) {
	// 	quickMessage(`You equip your ${selectedItem.name}`)
	// 	let rightOrLeft = selectedItem.roomId == slot1 ? true : false
	// 	if (rightOrLeft) {
	// 		player.rightHand = empty
	// 	} else if (rightOrLeft == false) {
	// 		player.leftHand = empty
	// 	}
	// 	selectedItem.roomId = selectedSlot
	// 	player[selectedSlot] = selectedItem.name
	// 	armorAddPlayerAttribute(selectedItem)
	// }
	updateWeaponIcons()
	updatePlayerStats()
}

function requirementsMet(item) {
	if (!item || !item.requirements) {
	  console.log('No item requirements');
	  return true;
	}
	for (const [stat, requirement] of Object.entries(item.requirements)) {
	  if (stat === 'guild' && player[stat] !== requirement) {
		quickMessage(`Your class cannot equip this!`);
		return false;
	  }
	  const playerStat = player[stat]?.level !== undefined ? player[stat].level : player[stat];
	  if (playerStat < requirement) {
		let line1 = lineFunc()
		customizeEachWord(`Your `, 'white', line1)
		customizeEachWord(`${item.name} `, item.color, line1)
		customizeEachWord(`requires `, 'white', line1)
		if (player[stat].name) {
			customizeEachWord(`a `, 'white', line1)
			customizeEachWord(`${player[stat].name} `, 'green', line1)
			customizeEachWord(`skill level of `, 'white', line1)
			customizeEachWord(`${requirement} `, 'light-blue', line1)
			customizeEachWord(`to use.`, 'white', line1)
		} else {
			customizeEachWord(`${requirement} `, 'light-blue', line1)
			customizeEachWord(`${capitalizeFirstLetter(stat)} `, 'green', line1)
			customizeEachWord(`to use.`, 'white', line1)
		}
		return false;
	  }
	}
	return true;
}

function unequipRemove(secondCommand) {
	let allItemsEquipped = pushItem.filter(
		item =>
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet'
	)
	let selectedItem = allItemsEquipped.find(item => item.keywords.find(keyword => keyword == secondCommand))
	let selectedItemBySlot = allItemsEquipped.find(item => item.slot == secondCommand)

	let selectedSlot = selectedItem ? selectedItem.slot : undefined

	if (secondCommand == undefined) {
		quickMessage(`You must specify what you want to unequip`)
	} else if (selectedItem == undefined) {
		quickMessage(`You do not have a ${secondCommand} to unequip`)
	} else if (player[selectedSlot] == empty) {
		quickMessage(`You do not have anything equipped in that slot to unequip`)
	} else if ((selectedItem.type.armor != undefined && selectedItem.roomId == selectedItem.slot) || selectedItem.roomId == selectedItem.slot) {
		itemRemoved(selectedItem, selectedSlot)
	}
	updateWeaponIcons()
	updatePlayerStats()
	updateInventory()
}
function itemRemoved(selectedItem, selectedSlot) {
	let line1 = lineFunc()
	if (player.rightHand == empty) {
		selectedItem.roomId = slot1
		player.rightHand = selectedItem.name
		player[selectedSlot] = empty
		armorRemovePlayerAttribute(selectedItem)
		customizeEachWord(`You unequip your `, 'white', line1)
		customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
		customizeEachWord(`to your right hand.`, 'white', line1)
	} else if (player.leftHand == empty) {
		selectedItem.roomId = slot2
		player.leftHand = selectedItem.name
		player[selectedSlot] = empty
		armorRemovePlayerAttribute(selectedItem)
		customizeEachWord(`You unequip your `, 'white', line1)
		customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
		customizeEachWord(`to your left hand.`, 'white', line1)	
	} else {
		quickMessage(`Your hands are too full to carry anything else`)
	}
}
function weaponOrShieldAddPlayerAttribute(moddedWeaponOrShield) {
	if (moddedWeaponOrShield.type.shield) {
		player.mods.armor += player.shields.rating()
	}
	if (moddedWeaponOrShield.type.weapon || moddedWeaponOrShield.type.shield) {
		let moddedWeaponOrShieldMods = moddedWeaponOrShield.mods
		let moddedWeaponOrShieldKeys = Object.keys(moddedWeaponOrShieldMods)
		for (let i = 0; i < moddedWeaponOrShieldKeys.length; i++) {
			//CHANGE TO ONLY USING THE TOP LINE OF CODE WHEN READY TO SWITCH OVER TO COMBINING MODDED VALUES INSTEAD OF DIRECTLY MODDING THE PLAYER
			player.mods[moddedWeaponOrShieldKeys[i]] = player.mods[moddedWeaponOrShieldKeys[i]] + moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
			// player[moddedWeaponOrShieldKeys[i]] = player[moddedWeaponOrShieldKeys[i]] + moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
		}
	}
	updatePlayerStats()
}

function weaponOrShieldRemovePlayerAttribute(moddedWeaponOrShield) {
	console.log(moddedWeaponOrShield)
	if (moddedWeaponOrShield.type.shield) {
		player.mods.armor -= player.shields.rating()
	}
	if (moddedWeaponOrShield.type.weapon || moddedWeaponOrShield.type.shield) {
		console.log('This should add stats to player')
		let moddedWeaponOrShieldMods = moddedWeaponOrShield.mods
		let moddedWeaponOrShieldKeys = Object.keys(moddedWeaponOrShieldMods)
		for (let i = 0; i < moddedWeaponOrShieldKeys.length; i++) {
			//CHANGE TO ONLY USING THE TOP LINE OF CODE WHEN READY TO SWITCH OVER TO COMBINING MODDED VALUES INSTEAD OF DIRECTLY MODDING THE PLAYER
			player.mods[moddedWeaponOrShieldKeys[i]] = player.mods[moddedWeaponOrShieldKeys[i]] - moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
			// player[moddedWeaponOrShieldKeys[i]] = player[moddedWeaponOrShieldKeys[i]] - moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]

		}
	}
	updatePlayerStats()
}
function armorAddPlayerAttribute(moddedArmor) {
	if (moddedArmor.type.armor) {
		let moddedArmorMods = moddedArmor.mods
		let moddedArmorKeys = Object.keys(moddedArmorMods)
		for (let i = 0; i < moddedArmorKeys.length; i++) {
			//CHANGE TO ONLY USING THE TOP LINE OF CODE WHEN READY TO SWITCH OVER TO COMBINING MODDED VALUES INSTEAD OF DIRECTLY MODDING THE PLAYER
			player.mods[moddedArmorKeys[i]] = player.mods[moddedArmorKeys[i]] + moddedArmorMods[moddedArmorKeys[i]]
			player[moddedArmorKeys[i]] = player[moddedArmorKeys[i]] + moddedArmorMods[moddedArmorKeys[i]]

		}
	}
	updatePlayerStats()
}
function armorRemovePlayerAttribute(moddedArmor) {
	if (moddedArmor.type.armor) {
		let moddedArmorMods = moddedArmor.mods
		let moddedArmorKeys = Object.keys(moddedArmorMods)
		for (let i = 0; i < moddedArmorKeys.length; i++) {
			//CHANGE TO ONLY USING THE TOP LINE OF CODE WHEN READY TO SWITCH OVER TO COMBINING MODDED VALUES INSTEAD OF DIRECTLY MODDING THE PLAYER
			player.mods[moddedArmorKeys[i]] = player.mods[moddedArmorKeys[i]] - moddedArmorMods[moddedArmorKeys[i]]
			player[moddedArmorKeys[i]] = player[moddedArmorKeys[i]] - moddedArmorMods[moddedArmorKeys[i]]

		}
	}
	updatePlayerStats()
}

//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////

function trainingDummy(area) {
	let trainingDummy = {
		color: `red`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			let description = `This Training Dummy looks indestructible`
			enemyDescription(this, description)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 0,
		factor: 1,
		experience: () => 1,
		armor: 0,
		slashingArmor: 30,
		piercingArmor: 30,
		bluntArmor: 30,
		fireResist: 10,
		waterResist: 10,
		earthResist: 10,
		iceResist: 10,
		lightningResist: 10,
		windResist: 10,
		shadowResist: 0,
		poisonResist: 10,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy
}
function trainingDummy2(area) {
	let trainingDummy2 = {
		color: `yellow`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 2',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy2
}
function trainingDummy3(area) {
	let trainingDummy3 = {
		color: `orange`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 3',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy3
}
function trainingDummy4(area) {
	let trainingDummy4 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 4',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy4
}
function trainingDummy5(area) {
	let trainingDummy5 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 5',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy5
}
function trainingDummy6(area) {
	let trainingDummy6 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 6',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy6
}
function trainingDummy7(area) {
	let trainingDummy7 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 7',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy7
}
function trainingDummy8(area) {
	let trainingDummy8 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 8',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy8
}
function trainingDummy9(area) {
	let trainingDummy9 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 9',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy9
}
function trainingDummy10(area) {
	let trainingDummy10 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		enemyAttackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 10',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy10
}

function contagionEnemyDies(enemy) {
	if (enemy?.debuffs?.poison) {
		let allEnemiesInRoom = getAllEnemiesInRoom()
		let targetEnemyIndex = allEnemiesInRoom.indexOf(enemy)
		allEnemiesInRoom.splice(targetEnemyIndex, 1)
		let debuffToApply = {...enemy.debuffs.poison}
		debuffToApply.stacks -= 1
		for (let i = 0; i < allEnemiesInRoom.length; i++) {
			applyDebuff(allEnemiesInRoom[i], debuffToApply)
		}
	}
}

function applyThrillOfTheKill(enemy) {
	if (player.thrillOfTheKill.level > 0) {
		player.thrillOfTheKill.activate(enemy)
	}
}
function thrillOfTheKillProc() {
	if (player.buffs.thrillOfTheKill) {
		let healAmount = player.buffs.thrillOfTheKill.heal()
		player.health + healAmount > player.maxHealth ? player.health = player.maxHealth : player.health += healAmount
		player.buffs.thrillOfTheKill.flavorText(healAmount)
	}
}
 
 
 function enemyDeathConditionals(enemy) {
	contagionEnemyDies(enemy)
	applyThrillOfTheKill(enemy)
}

function enemyDeath(enemy) {
	if (enemy.health <= 0) {
		enemyDeathConditionals(enemy)
		if (player.killList[enemy.refName] == undefined) {
			player.killList[enemy.refName] = 1
		} else {
			player.killList[enemy.refName]++
		}
		//turn all this text into its own function
		const line1 = document.createElement('div')
		const line2 = document.createElement('div')
		const line3 = document.createElement('div')
		line3.classList.add('item-drops-margin')
		customizeEachWord(`The `, 'white', line1)
		customizeEachWord(`${enemy.name} `, 'red', line1)
		customizeEachWord(`${enemy.deathPhrase} `, 'white', line1)
		customizeEachWord(`(`, 'white', line1)
		customizeEachWord(`you gain `, 'white', line1)
		customizeEachWord(`${enemy.experience} `, 'light-blue', line1)
		customizeEachWord(`experience points!)`, 'white', line1)
		//enemy had nothing of value
		if (enemy.gold == 0 && !enemy.itemDrops[0]) {
			customizeEachWord(`${enemy.name} `, 'red', line2)
			customizeEachWord(`had nothing of value`, 'white', line2)
			blankSpace()
		} else if (enemy.gold == 0 && enemy.itemDrops[0]) {
			//ITEM ONLY DROP
			customizeEachWord(`The `, 'white', line2)
			customizeEachWord(`${enemy.name} `, 'red', line2)
			customizeEachWord(`dropped:`, 'white', line2)
			enemy.itemDrops.forEach(item => {
				let lineX = document.createElement('div')
				lineX.classList.add('item-drops-margin')
				customizeEachWord(`${item.name}`, 'green', lineX)
			})
			blankSpace()
		} else if (enemy.gold > 0 && !enemy.itemDrops[0]) {
			//GOLD ONLY DROP
			customizeEachWord(`The `, 'white', line2)
			customizeEachWord(`${enemy.name} `, 'red', line2)
			customizeEachWord(`dropped: `, 'white', line2)
			customizeEachWord(`${enemy.gold} `, 'yellow', line3)
			customizeEachWord(`gold piece(s) `, 'white', line3)
			blankSpace()
		} else {
			//GOLD AND ITEM DROP
			customizeEachWord(`The `, 'white', line2)
			customizeEachWord(`${enemy.name} `, 'red', line2)
			customizeEachWord(`dropped:`, 'white', line2)
			customizeEachWord(`${enemy.gold} `, 'yellow', line3)
			customizeEachWord(`gold piece(s) `, 'white', line3)
			enemy.itemDrops.forEach(item => {
				let lineX = document.createElement('div')
				lineX.classList.add('item-drops-margin')
				customizeEachWord(`${item.name}`, 'green', lineX)
			})
			blankSpace()
		}
		clearInterval(enemy.enemyBehaviorInterval)
		const removeThisMonster = pushMonster.indexOf(enemy)
		const removeThisRoomEnemy = roomEnemies.indexOf(enemy)
		playerGainKillExperience(enemy.experience)
		enemy.itemDrops.forEach(item => item.name)
		pushMonster.splice(removeThisMonster, 1)
		roomEnemies.splice(removeThisRoomEnemy, 1)
		enemy.itemDrops.forEach(droppedItem => (droppedItem.roomId = currentArea.id))
		enemy.itemDrops.forEach(addItem => pushItem.push(addItem)) //add to combatCheck?
		currentArea.gold = currentArea.gold + enemy.gold
		combatCheck()
		playerLevelFunc()
	}
}
function masterMonster(area) {
	let masterMonster = {
		color: `red`,
		entersTheRoomPhrase: `masters in!`,
		advancePhrase: `advances toward you..`,
		deathPhrase: `lets out a final "masters!" before it flops over dead `,
		entersExitsRoomPhrase: `hobbles`,
		strikePhrase: 'bites at you and hits!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: 'leaps across the room and bites your neck!',
		rangedMissPhrase: 'leaps at you and misses!',
		hostile: true,
		combat: false,
		armor: 1,
		damageTypes: ['slashing', 'piercing', 'blunt'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 25,
			ranged: 25,
			meleeAbility: 25,
			rangedAbility: 25,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Master Monster',
		refName: 'master',
		keywords: ['master'],
		health: () => 10000 + (this.level * this.con),
		maxHealth: () => 10000 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		itemDrops: [],
		gold: function () {
			randomNumberRange(100, 1000)
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratTail]
			const probability = [10]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		level: () => {
			let level = randomNumberRange(1, 1)
			return level
		},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(1, 2)
		},
		hitChance: function(enemy) {
		let enemyHitChance =  calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 2000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 50,
				ability2: 50,
			},
			ability1: {
				name: 'Ability 1',
				color: 'purple',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 5000,
				damage: function() {return randomNumberRange(5, 5)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`RANGED ABILITY 1 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A RANGED ABILITY 1`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`does something wild, and its wacky stuper, it swings at you and [RANGED]`, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			},
			ability2: {
				name: 'Ability 2',
				color: 'pink',
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				combatType: 'ranged',
				castTime: 1000,
				damage: function() {return randomNumberRange(6, 6)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`RANGED ABILITY 2 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR RANGED ABILITY 2`, 'white', line1)
				},
			}
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 50,
				ability2: 50,
			},
			ability1: {
				name: 'Melee Ability 1: Master Attack!',
				color: 'brown',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRE, WATER, ICE LIGHTNING, ETC
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'melee',
				castTime: 2000,
				damage: function() {return randomNumberRange(7, 7)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`MELEE ABILITY 1 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A MELEE ABILITY 1`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`does something wild, and its wacky stuper, it swings at you and [MELEE] `, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			},
			ability2: {
				name: 'Melee Ability 2: Master Attack 2!',
				color: 'grey',
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				combatType: 'melee',
				castTime: 5000,
				damage: function() {return randomNumberRange(8, 8)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`MELEE ABILITY 2 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR MELEE ABILITY 2`, 'white', line1)
				},

			}
		},
		desc: function () {
			let description = `A little aggressive Master Monster. It squeeks often.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return masterMonster
}
function rat(area) {
	let rat = {
		color: `red`,
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `scurries toward you..`,
		deathPhrase: `lets out a final "squeek!" before it flops over dead `,
		entersExitsRoomPhrase: `hobbles`,
		hostile: true,
		combat: false,
		armor: 0,
		damageTypes: [], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Rat',
		refName: 'rat',
		keywords: ['rat'],
		level: () => {
			let level = randomNumberRange(1, 1)
			return level
		},
		health: () => 13 + (this.level * this.con),
		maxHealth: () => 13 + (this.level * this.con),
		enemyAttackPower: () => 1,
		accuracy: () => this.dex,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(2, 8)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratTail]
			const probability = [10]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		str: () => 1 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 1 + this.level,
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(1, 1)
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 4000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 50,
				ability2: 50,
			},
			ability1: {
				damage: function() {return randomNumberRange(10, 20)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`RANGED PHYSICAL ABILITY USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A RANGED PHYSICAL ABILITY [5 SECONDS UNTIL CAST]`, 'white', line1)
				},
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 5000,
			},
			ability2: {
				damage: function() {return randomNumberRange(10, 20)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`RANGED MAGIC ABILITY USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A RANGED MAGIC ABILITY [1 SECOND UNTIL CAST]`, 'white', line1)
				},
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				combatType: 'ranged',
				castTime: 1000,
			}
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
				ability2: 0,
			},
			ability1: {
				damage: function() {return randomNumberRange(30, 30)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`MELEE PHYSICAL ABILITY USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A MELEE PHYSICAL ABILITY [2 SECOND UNTIL CAST]`, 'white', line1)
				},
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'melee',
				castTime: 2000,
			},
			ability2: {
				damage: function() {return randomNumberRange(30, 30)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`MELEE MAGIC ABILITY USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A MELEE MAGIC ABILITY [5 SECONDS UNTIL CAST]`, 'white', line1)
				},
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				combatType: 'melee',
				castTime: 5000,
			}
		},
		desc: function () {
			let description = `A little aggressive field rat. It squeeks often.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'bites at you and hits!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: 'leaps across the room and bites your neck!',
		rangedMissPhrase: 'leaps at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return rat
}
//TRAINING FIELDS
function mudling(area) {
	let mudling = {
		color: `red`,
		picture: "images/monsters/elementals/mudling/mudling.png",
		entersTheRoomPhrase: `plops in!`,
		advancePhrase: `flops toward you..`,
		deathPhrase: `sinks into a lifeless puddle`,
		strikePhrase: 'plops at you and hits!',
		missPhrase: 'plops at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		entersExitsRoomPhrase: `plops`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Mudling',
		refName: 'mudling',
		keywords: ['mudling'],
		level: () => {
			let level = randomNumberRange(1, 3)
			return level
		},
		health: () => 15 + (this.level * this.con),
		maxHealth: () => 15 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(3, 4)
		},
		gold: function() {
			return randomNumberRange(5, 8)
		},
		itemDropsRoll: function () {
			const itemDrops =  [mudBall]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},
		enemyMoveSpeed: 6000,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		damageTypes: ['slashing'],
		attackTypes: { 
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance =  calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `The Mudling looks to be a low form of earth elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return mudling
}
function waterling(area) {
	let waterling = {
		color: `red`,
		picture: "images/monsters/elementals/waterling/waterling.png",
		entersTheRoomPhrase: `drips in!`,
		advancePhrase: `splashes toward you`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 1,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Waterling',
		refName: 'waterling',
		keywords: ['waterling'],
		level: () => {
			let level = randomNumberRange(1, 3)
			return level
		},
		health: () => 15 + (this.level * this.con),
		maxHealth: () => 15 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(3, 4)
		},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(5, 8)
		},
		itemDropsRoll: function () {
			const itemDrops =  [waterBerry]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},

		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		desc: function () {
			let description = `The Waterling looks to be a low form of water elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'splashes on you!',
		missPhrase: 'splashes at you and misses!',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return waterling
}
function grassling(area) {
	let grassling = {
		color: `red`,
		picture: "images/monsters/elementals/grassling/grassling.png",
		entersTheRoomPhrase: `wafts in!`,
		advancePhrase: `waddles up to you..`,
		deathPhrase: `wilts over and fades away`,
		entersExitsRoomPhrase: `blows`,
		hostile: true,
		combat: false,
		armor: 1,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Grassling',
		refName: 'grassling',
		keywords: ['grassling'],
		level: () => {
			let level = randomNumberRange(1, 3)
			return level
		},
		health: () => 15 + (this.level * this.con),
		maxHealth: () => 15 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => enemyKillExperience(this),
		damageCalculation: function() {
			return randomNumberRange(3, 6)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		gold: function () {
			return randomNumberRange(5, 8)
		},
		itemDropsRoll: function () {
			const itemDrops =  [grassFruit]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],

		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		desc: function () {
			let description = `The Grassling looks to be a low form of air elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'whips itself at you and hits!',
		missPhrase: 'whips itself at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return grassling
}
function mudlet(area) {
	let mudlet = {
		color: `red`,
		picture: "images/monsters/elementals/mudlet/mudlet.png",
		entersTheRoomPhrase: `plops in!`,
		advancePhrase: `flops toward you..`,
		deathPhrase: `sinks into a lifeless puddle`,
		entersExitsRoomPhrase: `plops`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Mudlet',
		refName: 'mudlet',
		keywords: ['mudlet'],
		level: () => {
			let level = randomNumberRange(3, 4)
			return level
		},
		health: () => 30 + (this.level * this.con),
		maxHealth: () => 30 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(5, 6)
		},
		gold: function () {
			return randomNumberRange(8, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [mudBall, muddyGloves]
			const probability = [50, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		enemyMoveSpeed: 6000,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 50,
			rangedAbility: 0,
		},
		
		itemDrops: [],

		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Gurgle Slap',
				color: 'brown',
				damageType: 'physical',
				penetrationTypes: ['blunt'],
				combatType: 'melee',
				castTime: 3000,
				damage: function() {return randomNumberRange(7, 8)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`With a gurgling lurch forward, the `, 'white', line1)
					customizeEachWord(`Mudlet `, 'red', line1)
					customizeEachWord(`slaps you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Mudlet `, 'red', line1)
					customizeEachWord(`looks to be preparing for something...`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`lunges forward with a `, 'white', line1)
					customizeEachWord(`Gurgling Lurch `, this.color, line1)
					customizeEachWord(`and `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
			},
		},
		desc: function () {
			let description = `The Mudlet looks to be a low form of earth elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'plops at you and hits!',
		missPhrase: 'plops at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return mudlet
}
function waterlet(area) {
	let waterlet = {
		color: `red`,
		picture: "images/monsters/elementals/waterlet/waterlet.png",
		entersTheRoomPhrase: `drips in!`,
		advancePhrase: `splashes toward you`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 1,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Waterlet',
		refName: 'waterlet',
		keywords: ['waterlet'],
		level: () => {
			let level = randomNumberRange(3, 4)
			return level
		},
		health: () => 30 + (this.level * this.con),
		maxHealth: () => 30 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(5, 6)
		},
		gold: function () {
			return randomNumberRange(8, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [waterBerry, waterloggedBoots]
			const probability = [50, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 100,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Stinging Wind',
				color: 'light-green',
				damage: function() {return randomNumberRange(10, 20)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`whips its body toward you, sending a blade of wind at you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`begins dancing back and forth..`, 'white', line1)
				}, 
				damageType: 'wind',
				penetrationTypes: ['piercing'],
				combatType: 'ranged',
				castTime: 5000,
			},
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(1, 10)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`With a gurgling lurch forward, the `, 'white', line1)
					customizeEachWord(`Mudling `, 'red', line1)
					customizeEachWord(`slaps you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Mudling `, 'red', line1)
					customizeEachWord(`looks to be preparing for something...`, 'white', line1)
				}, 
				damageType: 'physical',
				penetrationTypes: [],
				combatType: 'melee',
				castTime: 3000,
			},
		},
		desc: function () {
			let description = `The Waterling looks to be a low form of water elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return waterlet
}
function grasslet(area) {
	let grasslet = {
		color: `red`,
		picture: "images/monsters/elementals/grasslet/grasslet.png",
		entersTheRoomPhrase: `wafts in!`,
		advancePhrase: `waddles up to you..`,
		deathPhrase: `wilts over and fades away`,
		entersExitsRoomPhrase: `blows`,
		hostile: true,
		combat: false,
		armor: 1,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Grasslet',
		refName: 'grasslet',
		keywords: ['grasslet'],
		level: () => {
			let level = randomNumberRange(3, 4)
			return level
		},
		health: () => 30 + (this.level * this.con),
		maxHealth: () => 30 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 20,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(5, 6)
		},
		gold: function () {
			return randomNumberRange(8, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [grassFruit, grassStainedHat]
			const probability = [50, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 100,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		enemyMoveSpeed: 6000,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Stinging Wind',
				color: 'wind',
				damageType: 'wind', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				// penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 5000,
				damage: function() {return randomNumberRange(5, 6)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`whips its body toward you, sending a blade of wind at you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`begins dancing back and forth..`, 'white', line1)
				}, 
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`whips its body at you and`, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			},
		},
		desc: function () {
			let description = `The Grasslet looks to be a low form of air elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'whips itself at you and hits!',
		missPhrase: 'whips itself at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return grasslet
}
function lesserMudElemental(area) {
	let lesserMudElemental = {
		color: `red`,
		picture: "images/monsters/elementals/lesser mud elemental/lesser mud elemental.png",
		entersTheRoomPhrase: `gurgles in!`,
		advancePhrase: `bubbles toward you..`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Lessser Mud Ele',
		refName: 'lesserMudElemental',
		keywords: ['lesser', 'mud', 'elemental', 'lesser mud elemental'],
		level: () => {
			let level = randomNumberRange(5, 5)
			return level
		},
		health: () => 50 + (this.level * this.con),
		maxHealth: () => 50 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 7,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		gold: function () {
			return randomNumberRange(15, 25)
		},
		itemDropsRoll: function () {
			const itemDrops =  [mudBall, muddyGloves]
			const probability = [100]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 50,
			rangedAbility: 0,
		},
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		enemyMoveSpeed: 6000,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(7, 9)
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(6, 9)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`With a gurgling lurch forward, the `, 'white', line1)
					customizeEachWord(`Lesser Mud Elemental `, 'red', line1)
					customizeEachWord(`slaps you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Mud Elemental `, 'red', line1)
					customizeEachWord(`looks to be preparing for something...`, 'white', line1)
				}, 
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Lesser Mud Elemental `, 'red', line1)
					customizeEachWord(`lurches forward to slap you but `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
				damageType: 'physical',
				penetrationTypes: ['slashing'],
				combatType: 'melee',
				castTime: 3000,
			},
		},
		desc: function () {
			let description = `The Mud Elemental looks to be a low form of earth elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			fieldsTrainer.questSequence.third = true
			currentArea.npc.pop()
			enemyDeath(enemy)
		},
		strikePhrase: 'reaches out with a muddy appendage and slaps you!',
		missPhrase: 'tries to slap you, but misses!',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return lesserMudElemental
}
function lesserWaterElemental(area) {
	let lesserWaterElemental = {
		color: `red`,
		picture: "images/monsters/elementals/lesser water elemental/lesser water elemental.png",
		entersTheRoomPhrase: `gurgles in!`,
		advancePhrase: `bubbles toward you..`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Lesser Water Ele',
		refName: 'lesserWaterElemental',
		keywords: ['lesser', 'water', 'elemental', 'lesser water elemental', 'water elemental', 'lesser water'],
		level: () => {
			let level = randomNumberRange(5, 5)
			return level
		},
		health: () => 50 + (this.level * this.con),
		maxHealth: () => 50 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 7,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		gold: function () {
			return randomNumberRange(15, 25)
		},
		itemDropsRoll: function () {
			const itemDrops =  [waterBerry, waterloggedBoots]
			const probability = [100, 100]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 100,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(7, 9)
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		desc: function () {
			let description = `The Lesser Water Elemental looks to be a low form of water elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			fieldsTrainer.questSequence.third = true
			currentArea.npc.pop()
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return lesserWaterElemental
}
function lesserGrassElemental(area) {
	let lesserGrassElemental = {
		color: `red`,
		picture: "images/monsters/elementals/lesser grass elemental/lesser grass elemental.png",
		entersTheRoomPhrase: `gurgles in!`,
		advancePhrase: `bubbles toward you..`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Lesser Grass Ele',
		refName: 'lesserGrassElemental',
		keywords: ['lesser', 'grass', 'elemental', 'lesser grass elemental'],
		level: () => {
			let level = randomNumberRange(5, 5)
			return level
		},
		health: () => 50 + (this.level * this.con),
		maxHealth: () => 50 + (this.level * this.con),
		con: () => 5,
		enemyAttackPower: () => 7,
		accuracy: () => 0,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(15, 25)
		},
		itemDropsRoll: function () {
			const itemDrops =  [grassFruit, grassStainedHat]
			const probability = [100, 100]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 50,
			meleeAbility: 0,
			rangedAbility: 50,
		},
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(3, 4)
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Stinging Wind',
				color: 'light-green',
				damage: function() {return randomNumberRange(3, 5)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Lesser Grass Elemental `, 'red', line1)
					customizeEachWord(`whips its body toward you, sending a blade of wind at you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Lesser Grass Elemental `, 'red', line1)
					customizeEachWord(`begins dancing back and forth..`, 'white', line1)
				}, 
				damageType: 'wind',
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 5000,
			},
		},
		desc: function () {
			let description = `The Lesser Grass Elemental looks to be a low form of grass elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			fieldsTrainer.questSequence.third = true
			currentArea.npc.pop()
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'whips itself at you and hits!',
		rangedMissPhrase: 'whips itself at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return lesserGrassElemental
}
//GRAVEYARD
function skeleton(area) {
	let skeleton = {
		color: `red`,
		picture: "images/monsters/undead/skeletons/skeleton/skeleton.png",
		entersTheRoomPhrase: `clacks in!`,
		advancePhrase: `creeps toward you..`,
		deathPhrase: `lets out a hoarse scream as the magic leaves its bones`,
		entersExitsRoomPhrase: `creeps`,
		hostile: true,
		combat: false,
		armor: 0,
		slashingArmor: 4,
		piercingArmor: 8,
		bluntArmor: 4,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Skeleton',
		refName: 'skeleton',
		keywords: ['skeleton'],
		level: () => {
			let level = randomNumberRange(5, 8)
			return level
		},
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(8, 12)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(20, 35)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [smallBone, largeBone, crackedBone, copperOre]
			const probability = [10, 10, 20, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A skeleton animated by magic`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'swings its bony arm at you!',
		missPhrase: 'swings its bony arm at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 6000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return skeleton
}
function cultist(area) {
	let cultist = {
		color: `red`,
		picture: "images/monsters/humanoids/cultist/cultist.png",
		entersTheRoomPhrase: `looms in!`,
		advancePhrase: `strides toward you..`,
		deathPhrase: `collapses into a pile of robes`,
		entersExitsRoomPhrase: `strides`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Cultist',
		refName: 'cultist',
		keywords: ['cultist'],
		level: () => {
			let level = randomNumberRange(5, 8)
			return level
		},
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(8, 12)
		},
		gold: function () {
			return randomNumberRange(15, 40)
		},
		itemDropsRoll: function () {
			const itemDrops =  [cultRobes, crucifix]
			const probability = [20, 20]
			if (!pushItem.find(item => item.refName == 'cultTexts')) {
				itemDrops.push(cultTexts)
				probability.push(100)
			}
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		itemDrops: [],

		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A hooded figure holding a sharp dagger at its side.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'slashes at you with a dagger!',
		missPhrase: 'slashes at you with a dagger and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 6000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return cultist
}
function giantRat(area) {
	let giantRat = {
		color: `red`,
		picture: "images/monsters/animals/giant rat/giant rat.png",
		entersTheRoomPhrase: `squeeks in!`,
		advancePhrase: `scurries toward you..`,
		deathPhrase: `wimpers as it flops over dead`,
		entersExitsRoomPhrase: `scurries`,
		hostile: true,
		combat: false,
		armor: 0,
		damageTypes: ['slashing'],		
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		strikePhrase: 'bares its fangs at you and bites!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Giant Rat',
		refName: 'giantRat',
		keywords: ['giant', 'rat', 'giant rat'],
		level: () => {
			let level = randomNumberRange(5, 8)
			return level
		},
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(3, 7)
		},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(10, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratTail, ratSkin, lightHide]
			const probability = [10, 20, 10]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A big ole rat`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 6000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return giantRat
}
function graveWorm(area) {
	let graveWorm = {
		color: `red`,
		picture: "images/monsters/insects/graveworm/graveworm.png",
		entersTheRoomPhrase: `squishes in!`,
		advancePhrase: `writhes toward you..`,
		deathPhrase: `turns into a pile of pink mess`,
		entersExitsRoomPhrase: `writhes`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Grave Worm',
		refName: 'graveWorm',
		keywords: ['grave', 'worm', 'grave worm'],
		level: () => {
			let level = randomNumberRange(5, 8)
			return level
		},
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(2, 5)
		},
		gold: function () {
			return randomNumberRange(10, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [wormGuts]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['slashing'],		
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A thick, pink grave worm. Disgusting.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'bites at you!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return graveWorm
}
//THE SHALLOWS
function wildBoar(area) {
	let wildBoar = {
		color: `red`,
		picture: "images/monsters/animals/wild boar/wild boar.png",
		entersTheRoomPhrase: `charges in!`,
		advancePhrase: `charges toward you..`,
		deathPhrase: `lets out a shrill squeal as it thuds to the ground`,
		entersExitsRoomPhrase: `charges`,
		hostile: true,
		combat: false,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Wild Boar',
		refName: 'wildBoar',
		keywords: ['wild', 'boar', 'wild boar'],
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 5,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(8, 12)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(20, 40)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [rawBoarMeat, lightHide]
			const probability = [40, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		armor: 0,
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A large wild boar`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'runs at you and gores you with its tusks!',
		missPhrase: 'runs at you to gore you but misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return wildBoar
}
function stag(area) {
	let stag = {
		color: `red`,
		picture: "images/monsters/animals/stag/stag.png",
		entersTheRoomPhrase: `trots in!`,
		advancePhrase: `charges toward you..`,
		deathPhrase: `collapses to the ground`,
		entersExitsRoomPhrase: `trots`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Stag',
		refName: 'stag',
		keywords: ['stag'],
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 5,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(8, 12)
		},
		gold: function () {
			let goldAmount = randomNumberRange(20, 40)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [brokenAntlers, lightHide, stagAntlers]
			const probability = [20, 20, 7]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['blunt'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 3,
		bluntArmor: 10,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A large wild stag`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'rears back and clops you with its hooves!',
		missPhrase: 'stamps at you but misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return stag
}
function impling(area) {
	let impling = {
		color: `red`,
		picture: "images/monsters/imps/impling/impling.png",
		entersTheRoomPhrase: `troddles in!`,
		advancePhrase: `hops toward you..`,
		deathPhrase: `curses you as its scream turns to silence`,
		entersExitsRoomPhrase: `troddles`,
		hostile: true,
		combat: false,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Impling',
		refName: 'impling',
		keywords: ['impling'],
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		health: () => 20 + (this.level * this.con),
		maxHealth: () => 20 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 10,
		dodge: () => 5,
		experience: () => Math.floor((this.health / 2) - player.level + 10 < 0 ? 0 : (this.health / 2) - player.level) + 125,
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(35, 65)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [clothCap, silkFootwraps]
			const probability = [10, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		armor: 0,
		damageTypes: [], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 100,
		},
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(5, 10)
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(10, 20)},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Impling `, 'red', line1)
					customizeEachWord(`begins chanting strange words of magic..`, 'white', line1)
				},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`With outstretched fingers, the `, 'white', line1)
					customizeEachWord(`Impling `, 'red', line1)
					customizeEachWord(`shoots out a small streak of `, 'white', line1)
					customizeEachWord(`fire `, 'fire', line1)
					customizeEachWord(`at you!`, 'white', line1)

				},
				name: 'Fireball',
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				color: 'fire',
				penetrationTypes: [],
				combatType: 'ranged',
				castTime: 3000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A small Impling`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return impling
}
function bandit(area) {
	let bandit = {
		color: `red`,
		entersTheRoomPhrase: `sneaks in!`,
		advancePhrase: `advances toward you..`,
		deathPhrase: `falls to the ground dead`,
		entersExitsRoomPhrase: `sneaks`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Bandit',
		refName: 'bandit',
		keywords: ['bandit'],
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		health: () => 110 + (this.level * this.con),
		maxHealth: () => 110 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 10,
		dodge: () => 20,
		experience: () => Math.floor((this.health / 2) - player.level < 0 ? 0 : (this.health / 2) - player.level) + 30,
		damageCalculation: function() {
			return randomNumberRange(10, 20)
		},
		gold: function () {
			return randomNumberRange(25, 50)
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A cloaked, hooded Bandit.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'slashes his daggers at you!',
		missPhrase: 'slashes his daggers at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return bandit
}
//KOBOLD CAVES
function koboldChild(area) {
	let koboldChild = {
		color: `red`,
		picture: "images/monsters/kobolds/kobold child/kobold child.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a high pitched cry as it dies!`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Child',
		refName: 'koboldChild',
		keywords: ['kobold', 'child', 'kobold child'],
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		health: () => 0 + (this.level * this.con),
		maxHealth: () => 0 + (this.level * this.con),
		con: () => 10,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(5, 10)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(20, 50)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [littleBoneToy, dirtyRags, halfEatenFish, lightHide]
			const probability = [10, 5, 5, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A skeleton animated by magic`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'swings at you with a stick!',
		missPhrase: 'swings a stick at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldChild
}
function koboldScoundrel(area) {
	let koboldScoundrel = {
		color: `red`,
		picture: "images/monsters/kobolds/kobold scoundrel/kobold scoundrel.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a soft howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Scoundrel',
		refName: 'koboldScoundrel',
		keywords: ['kobold', 'scoundrel', 'kobold scoundrel'],
		level: () => {
			let level = randomNumberRange(12, 15)
			return level
		},
		health: () => 75 + (this.level * this.con),
		maxHealth: () => 75 + (this.level * this.con),
		con: () => 15,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(10, 20)
		},
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [rustySword, leatherGrips, dirtyRags, halfEatenFish, ironOre, lightHide]
			const probability = [5, 5, 5, 5, 5, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A skeleton animated by magic`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'jabs at you with a broken spear!',
		missPhrase: 'swings its bony arm at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldScoundrel
}
function koboldSpearthrower(area) {
	let koboldSpearthrower = {
		color: `red`,
		picture: "images/monsters/kobolds/kobold spearthrower/kobold spearthrower.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a whimpy howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Spearthrower',
		refName: 'koboldSpearthrower',
		keywords: ['kobold', 'thrower', 'kobold thrower'],
		health: () => 75 + (this.level * this.con),
		maxHealth: () => 75 + (this.level * this.con),
		con: () => 15 + this.level,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		level: () => {
			let level = randomNumberRange(12, 15)
			return level
		},
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [boneTippedSpear, dirtyRags, halfEatenFish, copperOre, lightHide]
			const probability = [5, 5, 5, 5, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 50,
		},
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(10, 15)
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Aimed Spear',
				color: 'red',
				damage: function() {return randomNumberRange(9, 12)},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Spearthrower `, 'red', line1)
					customizeEachWord(`postures to take aim at you!`, 'white', line1)
				}, 
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Spearthrower `, 'red', line1)
					customizeEachWord(`launches a spear at you!`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Spearthrower `, 'red', line1)
					customizeEachWord(`launches a spear at you and `, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
				damageType: 'physical',
				penetrationTypes: ['piercing'],
				combatType: 'ranged',
				castTime: 4000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A Kobold Spearthrower`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'jabs is spear at you!',
		missPhrase: 'lunges forward with its spear at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldSpearthrower
}
function koboldArcher(area) {
	let koboldArcher = {
		color: `red`,
		picture: "images/monsters/kobolds/kobold archer/kobold archer.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a whimpy howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 100,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Archer',
		refName: 'koboldArcher',
		keywords: ['kobold', 'archer', 'kobold archer'],
		health: () => 50 + (this.level * this.con),
		maxHealth: () => 50 + (this.level * this.con),
		con: () => 15,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [crudelyCarvedBow, crudeShiv, dirtyRags, halfEatenFish, koboldToothNecklace, copperOre]
			const probability = [5, 5, 5, 5, 5, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(10, 15)
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Aimed Spear',
				color: 'green',
				damage: function() {return randomNumberRange(9, 12)},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Archer `, 'red', line1)
					customizeEachWord(`draws back its bow taking aim at you!`, 'white', line1)
				}, 
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Archer `, 'red', line1)
					customizeEachWord(`lets fly an arrow at you!`, 'white', line1)
				}, 
				damageType: 'physical',
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 4000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A Kobold Archer`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'fires an arrow at you!',
		rangedMissPhrase: 'fires an arrow at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldArcher
}
function koboldDigger(area) {
	let koboldDigger = {
		color: `red`,
		picture: "images/monsters/skeleton1.jpg",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a whimpy howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Digger',
		refName: 'koboldDigger',
		keywords: ['kobold', 'digger', 'kobold digger'],
		level: () => {
			let level = randomNumberRange(9, 12)
			return level
		},
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 15,
		enemyAttackPower: () => 7,
		accuracy: () => 5,
		dodge: () => 0,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(12, 18)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [dirtyRags, halfEatenFish, copperOre, pickaxe]
			const probability = [20, 20, 5, 25]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Aimed Spear',
				color: 'green',
				damage: function() {return randomNumberRange(9, 12)},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Archer `, 'red', line1)
					customizeEachWord(`draws back its bow taking aim at you!`, 'white', line1)
				}, 
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Archer `, 'red', line1)
					customizeEachWord(`lets fly an arrow at you!`, 'white', line1)
				}, 
				damageType: 'physical',
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 4000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A Kobold Digger`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'fires an arrow at you!',
		rangedMissPhrase: 'fires an arrow at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldDigger
}

function koboldChief(area) {
	let koboldChief = {
		color: `red`,
		picture: "images/monsters/kobolds/kobold chief/kobold chief.png",
		entersTheRoomPhrase: `jumps in!`,
		advancePhrase: `charges toward you..`,
		deathPhrase: `lets out a gurgling murmur as its eyes stare blankly.`,
		entersExitsRoomPhrase: `charges`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Chief',
		refName: 'koboldChief',
		keywords: ['kobold', 'chief', 'kobold chief'],
		level: () => {
			return 16
		},
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 20,
		enemyAttackPower: () => 7,
		accuracy: () => 10,
		dodge: () => 10,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(20, 35)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(100, 200)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratHideTunic, ratHidePants, ratSkullHelm, copperOre, halfEatenFish, lightHide]
			const probability = [50, 50, 50, 100, 100, 100]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 75,
			ranged: 0,
			meleeAbility: 25,
			rangedAbility: 0,
		},
		slashingArmor: 20,
		piercingArmor: 20,
		bluntArmor: 20,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(30, 30)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`Kobold Chief `, 'red', line1)
					customizeEachWord(`leaps and slashes down at you with its spear!`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`Kobold Chief `, 'red', line1)
					customizeEachWord(`lets out a furious cry as it prepares to attack!`, 'white', line1)
				},
				name: 'Leap Strike',
				color: 'green',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				penetrationTypes: ['slashing'],
				combatType: 'melee',
				castTime: 3000,
			},
		},
		desc: function () {
			let description = `A Kobold Chief`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			customizeEachWord(`${enemy.name} `, 'white', line1)
			customizeEachWord(`swings its 10 inch tinky at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
		},
		strikePhrase: 'slashes you with its spear!',
		missPhrase: 'swings its spear at your and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 3000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldChief
}
//GNOLL PLAINS

//gnoll brute
//gnoll magi
//gnoll skirmisher
//gnoll pack leader



function gnollSkirmisher(area) {
	let gnollSkirmisher = {
		color: `red`,
		picture: "images/monsters/kobolds/kobold chief/kobold chief.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs toward you..`,
		deathPhrase: `lets out a painful howl.`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Gnoll Skirmisher',
		refName: 'gnollSkirmisher',
		keywords: ['gnoll', 'skirmisher', 'gnoll skirmisher'],
		level: () => {
			return 16
		},
		health: () => 75 + (this.level * this.con),
		maxHealth: () => 75 + (this.level * this.con),
		con: () => 20,
		enemyAttackPower: () => 7,
		accuracy: () => 10,
		dodge: () => 10,
		experience: () => {return enemyKillExperience(this)},
		damageCalculation: function() {
			return randomNumberRange(18, 32)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(50, 80)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 15,
		piercingArmor: 15,
		bluntArmor: 5,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `A Gnoll Skirmisher`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			customizeEachWord(`${enemy.name} `, 'white', line1)
			customizeEachWord(`swings its 10 inch tinky at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
		},
		strikePhrase: 'slashes you with its spear!',
		missPhrase: 'swings its spear at your and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return gnollSkirmisher
}



function enemyIsOneRoomFromPlayer(enemy) {
	let playerCoords = {
    	x: player.x,
    	y: player.y,
    	z: player.z
    }

    let enemyCoords = {
        x: enemy.x,
        y: enemy.y,
        z: enemy.z
    };
    // Calculate Manhattan distance
    let distance = Math.abs(enemyCoords.x - playerCoords.x) + Math.abs(enemyCoords.y - playerCoords.y);
    // Check if the distance is exactly 1
    return distance === 1;
}

function strikePhraseFunc(enemyName, enemyColor, enemyDamage, damageType, armorBlockAmount, phrase) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	blankSpace()
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${phrase}`, 'white', line1)
	customizeEachWord(`You are hit for `, 'yellow', line2)
	customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
	if (damageType != undefined) {
		customizeEachWord(`${damageType} `, damageType, line2)
	}
	customizeEachWord(`damage. `, 'yellow', line2)
	customizeEachWord(`(Your armor blocks `, 'white', line2)
	customizeEachWord(`${armorBlockAmount}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
	updateScroll()
}
function strikeMissPhraseFunc(enemyName, enemyColor, enemyMissPhrase) {
	let line1 = document.createElement('div')
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${enemyMissPhrase}`, 'white', line1)
	updateScroll()
}
function enemyAbilityMissPhraseFunc(enemy) {
	let line1 = document.createElement('div')
	customizeEachWord(`${enemy.name} `, enemy.color, line1)
	customizeEachWord(`${enemyMissPhrase}`, 'white', line1)
	updateScroll()
}
function rangedAttackPhraseFunc(enemyName, enemyColor, enemyDamage, damageType, armorBlockAmount, phrase) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	blankSpace()
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${phrase}`, 'white', line1)
	customizeEachWord(`You are hit for `, 'yellow', line2)
	customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
	if (damageType != undefined) {
		customizeEachWord(`${damageType} `, damageType, line2)
	}
	customizeEachWord(`damage. `, 'yellow', line2)
	customizeEachWord(`(your armor blocks `, 'white', line2)
	customizeEachWord(`${armorBlockAmount}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
	updateScroll()
}
function rangedMissPhraseFunc(enemyName, enemyColor, enemyMissPhrase) {
	let line1 = document.createElement('div')
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${enemyMissPhrase}`, 'white', line1)
	updateScroll()
}
function rangedAbilityPhraseFunc(ability) {
	console.log(ability)
	let line1 = document.createElement('div')
	blankSpace()
	ability.abilityPhrase()
	customizeEachWord(`${ability.name} `, ability.color, line1)
	customizeEachWord(`hits you for `, 'yellow', line1)
	customizeEachWord(`${ability.totalDamage} `, 'light-blue', line1)
	if (ability.penetrationType) {
		customizeEachWord(`${ability.penetrationType} `, `${ability.penetrationType}`, line1)
	}
	if (ability.damageType != 'physical') {
		customizeEachWord(`${ability.damageType} `, ability.damageType, line1)
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(You resist `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
	} else {
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(Your armor blocks `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
		}
		blankSpace()
		updateScroll()
}
function meleeAbilityPhraseFunc(ability, enemyName, enemyColor) {
	//abilityObject.totalDamage, abilityObject.damageType, abilityObject.mitigationAmount
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	blankSpace()
	ability.abilityPhrase()
	customizeEachWord(`${ability.name} `, ability.color, line1)
	customizeEachWord(`hits you for `, 'yellow', line1)
	customizeEachWord(`${ability.totalDamage} `, 'light-blue', line1)
	if (ability.penetrationType) {
		customizeEachWord(`${ability.penetrationType} `, `${ability.penetrationType}`, line1)
	}
	if (ability.damageType != 'physical') {
		customizeEachWord(`${ability.damageType} `, ability.damageType, line1)
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(You resist `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
	} else {
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(Your armor blocks `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
		}
		blankSpace()
		updateScroll()
}

function playerStealthCheck(enemy) {
	if (coordinatesMatch(player, enemy) && player.isStealthed) {
		let line1 = lineFunc()
		if (player.level + player.stealth.level < enemy.level) {
			customizeEachWord(`You have been discovered!`, 'white', line1)
			player.isStealthed = false
			return true
		} else if (player.level + player.stealth.level >= enemy.level) {
				customizeEachWord(`The ${enemy.name} is completely unaware of your presence.`, 'white', line1)
				return false
		}
	}

}
function playerSpellsList() {
	blankSpace()
	for (let spell in player) {
		if (player[spell].conjureTime) {
			if (player[spell].level > 0) {
				let line = lineFunc()
				customizeEachWord(`${player[spell].name}`, player[spell].color, line)
				customizeEachWord(`: Level `, 'white', line)
				customizeEachWord(`${player[spell].level}`, 'light-blue', line)
			}
		}
	}
	blankSpace()
}
function playerAbilitiesList() {
	blankSpace()
	for (let ability in player) {
		if (player[ability].resourceName) {
			if (player[ability].level > 0) {
				let line = lineFunc()
				customizeEachWord(`${player[ability].name}`, player[ability].color, line)
				customizeEachWord(`: Level `, 'white', line)
				customizeEachWord(`${player[ability].level}`, 'light-blue', line)
			}
		}
	}
	blankSpace()
}

function playerSkillsList() {
	blankSpace()
	for (let skill in player) {
		if (player[skill].type == 'skill') {
			if (player[skill].level > 0) {
				let line = lineFunc()
				customizeEachWord(`${player[skill].name}`, player[skill].color, line)
				customizeEachWord(`: Level `, 'white', line)
				customizeEachWord(`${player[skill].level}`, 'light-blue', line)
			}
		}
	}
	blankSpace()
}


// async function monsterBehavior(enemy) {
// 	while (enemy.isAlive() && !enemy.isStunned) {
// 		//sets attack timer interval, can be moved to enemy object later
// 		enemy.attackTimer = enemy.capturedAttackTimer ? enemy.capturedAttackTimer : 3000
// 		clearInterval(enemy.attackTimerInterval)
// 		enemy.attackTimerInterval = setInterval(() => {
// 			enemy.attackTimer -= 100
// 			if (enemy.attackTimer <= 0) {
// 				enemy.attackTimer = 3000
// 			}
// 		}, 100)
// 		enemy.isBehaviorRunning = true
// 		//
// 		if (enemy.wasStunned) {
// 			quickMessage(`Attack should happen in ${enemy.capturedAttackTimer}`)
// 			await waitForNextAction(enemy.capturedAttackTimer)
// 			enemy.wasStunned = false
// 		} else {
// 			await waitForNextAction(enemy.enemyMoveSpeed)

// 		}
// 		if (!enemy.isAlive()) {return}
// 		playerStealthCheck(enemy)
// 		if (!player.isStealthed) {
//     		let attackType = determineEnemyAttackType(enemy);
//         	console.log(attackType)
//         	let currentAttackType = attackType;
//         	let shouldEngage = shouldEngagePlayer(enemy, currentAttackType);
//         	if (!player.isAlive) {
// 	            console.log('enemy should be moving')
//             	enemy.enemyMove(enemy);
//         	} else if (shouldEngage && enemy.isAlive() && !enemy.isStunned) {
// 	            await engagePlayer(enemy)
// 				await waitForNextAction(enemy.enemyMoveSpeed)
//             	if (currentAttackType == 'melee'&& enemy.isAlive() && !enemy.isStunned) {
// 					await enemySwing(enemy)
// 				} 
//             	if (currentAttackType == 'meleeAbility'&& enemy.isAlive()) {
// 					await enemyMeleeAbility(enemy)
// 				} 
//         	} else if (!coordinatesMatch(enemy, player) && !enemy.isStunned) {
// 	            enemy.enemyMove(enemy);
//         	}  else if (currentAttackType == 'melee' && enemy.isAlive() && !enemy.isStunned) {
// 				await enemySwing(enemy)
// 			} else if (currentAttackType == 'ranged' && enemy.isAlive() && !enemy.isStunned) {
// 	            await enemyRangedAttack(enemy);
//         	} else if (currentAttackType == 'rangedAbility' && enemy.isAlive() && !enemy.isStunned) {
// 	            await enemyRangedAbility(enemy);
//         	} else if (currentAttackType == 'meleeAbility' && enemy.isAlive() && !enemy.isStunned) {
// 	            await enemyMeleeAbility(enemy);
//         	} else {
// 	            enemy.enemyMove(enemy);
//         	}
// 			updateMonsterBox()
//     	} else {
// 			enemy.enemyMove(enemy)
// 			updateMonsterBox()
// 		}
// 	}
// 	enemy.isBehaviorRunning = false
// }

async function monsterBehavior(enemy) {
	while (enemy.isAlive() && !enemy.isStunned) {
	// let enemyAttackTimer = enemy.capturedAttackTimer ? enemy.capturedAttackTimer : enemy.enemyMoveSpeed
		enemy.attackTimer = enemy.capturedAttackTimer ? enemy.capturedAttackTimer : enemy.enemyMoveSpeed;
		clearInterval(enemy.attackTimerInterval);
		enemy.attackTimerInterval = setInterval(() => {
		enemy.attackTimer -= 100
		// console.log(enemy.attackTimer)
		if (enemy.attackTimer <= 0) {
			enemy.attackTimer = enemy.enemyMoveSpeed;
			enemy.capturedAttackTimer = undefined
		}
	}, 100);

	enemy.isBehaviorRunning = true;
	let timerToUse
	if (enemy.capturedAttackTimer) {
		timerToUse = enemy.capturedAttackTimer
		// quickMessage(`${timerToUse} timer set (CAPTURED ATTACK TIMER)`)
	} else {
		timerToUse = enemy.enemyMoveSpeed
		// quickMessage(`${timerToUse} timer set (RESETS TO DEFAULT)`)
	  }

	  if (enemy.capturedAttackTimer) {
		// quickMessage(`Attack should happen in ${enemy.capturedAttackTimer}`);
		await waitForNextAction(timerToUse);
	  } else {
		// quickMessage(`timer resset to ddefault`)
		await waitForNextAction(timerToUse);
	  }
  
	  if (!enemy.isAlive()) {
		return;
	  }
  
	  playerStealthCheck(enemy)
	  if (!player.isStealthed && !enemy.isStunned) {
		  let attackType = determineEnemyAttackType(enemy);
		  console.log(attackType)
		  let currentAttackType = attackType;
		  let shouldEngage = shouldEngagePlayer(enemy, currentAttackType);
		  let doesPlayerSideStep = player.sideStep.calculate(enemy)
		  if (!player.isAlive) {
			  enemy.enemyMove(enemy);
			  enemy.capturedAttackTimer = undefined
		  } else if (shouldEngage && enemy.isAlive() && !enemy.isStunned) {
			if (doesPlayerSideStep) {
				player.sideStep.flavorText(enemy)
				player.quickshot.strike(enemy)
			} else {
			await engagePlayer(enemy)
			await waitForNextAction(timerToUse)
			if (currentAttackType == 'melee' && enemy.isAlive() && !enemy.isStunned && enemy.combat) {
				await enemySwing(enemy)
					enemy.capturedAttackTimer = undefined
				} else if (currentAttackType == 'meleeAbility'&& enemy.isAlive() && enemy.combat) {
					await enemyMeleeAbility(enemy)
					enemy.capturedAttackTimer = undefined
				} else if (!enemy.combat && coordinatesMatch(enemy, player) && shouldEngage) {
					await engagePlayer(enemy)
				} else {
					enemy.enemyMove(enemy)
				}
			}

		  } else if (!coordinatesMatch(enemy, player) && !enemy.isStunned) {
			  enemy.enemyMove(enemy);
			  enemy.capturedAttackTimer = undefined
		  }  else if (currentAttackType == 'melee' && enemy.isAlive() && !enemy.isStunned) {
			  await enemySwing(enemy)
		  } else if (currentAttackType == 'ranged' && enemy.isAlive() && !enemy.isStunned) {
			  await enemyRangedAttack(enemy);
		  } else if (currentAttackType == 'rangedAbility' && enemy.isAlive() && !enemy.isStunned) {
			  await enemyRangedAbility(enemy);
		  } else if (currentAttackType == 'meleeAbility' && enemy.isAlive() && !enemy.isStunned) {
			  await enemyMeleeAbility(enemy);
		  } else {
			  enemy.enemyMove(enemy);
		  }
		  updateMonsterBox()
	  } else {
		  enemy.enemyMove(enemy)
		  updateMonsterBox()
	  }  
	  enemy.isBehaviorRunning = false;
	}
  }
  

async function shouldEngagePlayer(enemy, attackType) {
	if (coordinatesMatch(enemy, player) && player.isAlive && !enemy.combat && (attackType == 'melee' || attackType == 'meleeAbility') && !player.isStealthed) {return true}
}

async function shouldEnemyMove(enemy) {
	if (!coordinatesMatch(player, enemy)) {return true}
	if (coordinatesMatch(player, enemy) && !player.isAlive) {return true}
}

async function engagePlayer(enemy) {
	if (!player.isAlive) {return}
	let line1 = lineFunc()
	customizeEachWord(`The `, 'white', line1)
	customizeEachWord(`${enemy.name} `, 'red', line1)
	customizeEachWord(`${enemy.advancePhrase} `, 'white', line1)
	player.combat = true
	enemy.combat = true
}

function calculateEnemyHitChance(enemy) {
	let playerValues = player.dodge
	let enemyValues = enemy.level + enemy.accuracy + 75
	console.log(enemyValues - playerValues, ' ENEMY HIT CHANCE')
	return enemyValues - playerValues
}

function determineEnemyAttackType(enemy) {
	let roll = randomNumberRange(1, 100)
	let cumulativeProbability = 0
	let length = 0
	for (const [type, probability] of Object.entries(enemy.attackTypes)) {
		cumulativeProbability += probability
		length++
		if (roll <= cumulativeProbability) {
			return type
		} 
	}
	let index = randomNumberRange(0, length - 1)
	return Object.keys(enemy.attackTypes)[index]
	// return Object.keys(enemy.attackTypes).shift()
}
function determineEnemyAbility(abilitiesToChooseFrom) {
	let roll = randomNumberRange(1, 100)
	let cumulativeProbability = 0 
	for (const [ability, probability] of Object.entries(abilitiesToChooseFrom.abilityUseChance)) {
		cumulativeProbability += probability
		if (roll <= cumulativeProbability) {
			return ability
		} 
	}
	return Object.keys(abilitiesToChooseFrom.abilityUseChance).pop()
}

async function enemySwing(enemy) { //CALCULATE ENEMY ATTACK FUNCTION IS USED
	//if swing misses, -> nothing else should calculate
	//did swing land?
	//did player block?
	//is damage 0?
	if (!coordinatesMatch(enemy, player) || !player.isAlive) {
		enemy.enemyMove(enemy)
		return
	}
	let swingObject = calculateEnemyAttack(enemy)
	if (!swingObject.enemyHits) {
		//this is a miss
		//no counter or pre-emptive strike should happen
		strikeMissPhraseFunc(enemy.name, enemy.color, enemy.missPhrase)
		if (player.dodgeStrike.level > 0) {player.dodgeStrike.strike(enemy)}
	} else if (swingObject.wasBlocked == false) {
		//this is a hit and the player did not shield block
		//player can counter or pre-emptive strike here
		if (player.preemptiveStrike.level > 0) {player.preemptiveStrike.strike(enemy)}
		//if the enemy is still alive after preemptive strike, it will now hit the player
		if (enemy.health > 0) {
			// enemy.strikePhrase(swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount)
			console.log(swingObject)
			if (enemy.swing) {
				enemy.swing()
			}
			strikePhraseFunc(enemy.name, enemy.color, swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount, enemy.strikePhrase)
			applyDamageToPlayer(swingObject.totalDamage)
			if (!player.isAlive) {return}
			if (player.counterAttack.level > 0) {player.counterAttack.strike(enemy)}
			if (player.hardenedSkin.level > 0) {player.hardenedSkin.activate(enemy)}
			if (player.battleRage.level > 0) {player.battleRage.activate(enemy)}
		} else {
			return
		}
	} else if (swingObject.wasBlocked) {
		//this is a hit and the player blocked with shield
		//player cannot counter or pre-emptive strike if attack was blocked
		quickMessage(`You blocked the attack! Figure out block formula and complete the rest of this function`)
	}
	// if (counterAttackRoll()) {attack(enemy)}
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}

function enemyMissProcs() {}
function enemyHitsProcs() {}

async function enemyRangedAttack(enemy) { //CALCULATE ENEMY ATTACK FUNCTION IS USED
	let swingObject = calculateEnemyAttack(enemy)
	if (!swingObject.enemyHits) {
		//this is a miss
		//no counter or pre-emptive strike should happen
		rangedMissPhraseFunc(enemy.name, enemy.color, enemy.rangedMissPhrase)
	} else if (swingObject.wasBlocked == false) {
		if (enemy.health > 0) {
			rangedAttackPhraseFunc(enemy.name, enemy.color, swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount, enemy.rangedAttackPhrase)
			applyDamageToPlayer(swingObject.totalDamage)
		} else {
			return
		}
	} else if (swingObject.wasBlocked) {
		//this is a hit and the player blocked with shield
		//player cannot counter or pre-emptive strike if attack was blocked
		quickMessage(`You blocked the attack! Figure out block formula and complete the rest of this function`)
	}
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}

async function enemyRangedAbility(enemy) { //CALCULATE
	let abilityObject = calculateEnemyRangedAbility(enemy)
	if (!player.isAlive || !coordinatesMatch(player, enemy)) {
		enemy.enemyMove(enemy)
		return
	}
	abilityObject.windUpPhrase()
	await waitForNextAction(abilityObject.castTime)
	if (!player.isAlive || !coordinatesMatch(player, enemy)) {
		enemy.enemyMove(enemy)
		return
	}
	console.log(abilityObject)
	if (abilityObject.enemyHits == false) {
		abilityObject.flavorTextMiss(enemy)
	} else if (enemy.health > 0) {
		rangedAbilityPhraseFunc(abilityObject, enemy.color, enemy.name)
		applyDamageToPlayer(abilityObject.totalDamage)
	}
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}

async function enemyMeleeAbility(enemy) { //CALCULATE PHYSICAL ABILITY
	let abilityObject = calculateEnemyMeleeAbility(enemy)
	if (!player.isAlive || !coordinatesMatch(player, enemy) || !enemy.combat) {
		// let test = enemyIsOneRoomFromPlayer(enemy)
		enemy.enemyMove(enemy)
		return
	}
	abilityObject.windUpPhrase()
	await waitForNextAction(abilityObject.castTime)
	if (!player.isAlive || !coordinatesMatch(player, enemy) || !enemy.combat) {
		// let test = enemyIsOneRoomFromPlayer(enemy)
		enemy.enemyMove(enemy)
		return
	}
	console.log(abilityObject)
	if (abilityObject.enemyHits == false) {
		abilityObject.flavorTextMiss(enemy)
	} else if (enemy.health > 0) {
		meleeAbilityPhraseFunc(abilityObject, enemy.name, enemy.color)
		applyDamageToPlayer(abilityObject.totalDamage)
	} 
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}


function calculateEnemyAttack(enemy) {
	const damageType = enemy.damageTypes[randomNumberRange(0, enemy.damageTypes.length - 1)] != undefined ? enemy.damageTypes[randomNumberRange(0, enemy.damageTypes.length - 1)] : undefined
	let damageObject = {
		enemyHits: enemy.hitChance(enemy), //checks if enemy misses its swing
		enemyRawDamage: enemy.damageCalculation(), //raw damage before any mitigation
		mitigationAmount: 0,
		totalDamage: 0,
		damageType: damageType,
		//checks to see if player is wearing any slashing/piercing/blunt armor
		playerPenArmor: damageType == 'slashing' ? player.slashingArmor : damageType == 'piercing' ? player.piercingArmor : damageType == 'blunt' ? player.bluntArmor : undefined,
		playerArmor: player.armor <= 0 ? 0 : player.armor,
		wasBlocked: false,
	}
	damageObject.playerPenArmor = damageObject.playerPenArmor < 0 ? 0 : damageObject.playerPenArmor
	if (damageObject.damageType !== undefined) {
		const damageWithoutArmorPenalty = (damageObject.enemyRawDamage - damageObject.playerPenArmor) * (1000 / (1000 + damageObject.playerPenArmor)) <= 0 ? 0 : (damageObject.enemyRawDamage - damageObject.playerPenArmor) * (1000 / (1000 + damageObject.playerPenArmor))
		damageObject.totalDamage = Math.floor(damageWithoutArmorPenalty) <= 0 ? 0 : Math.floor(damageWithoutArmorPenalty)
	  } else {
		const damageWithoutArmorPenalty = (damageObject.enemyRawDamage - damageObject.playerArmor) * (1000 / (1000 + damageObject.playerArmor)) <= 0 ? 0 : (damageObject.enemyRawDamage - damageObject.playerArmor) * (1000 / (1000 + damageObject.playerArmor))
		// const damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))

		damageObject.totalDamage = Math.floor(damageWithoutArmorPenalty) <= 0 ? 0 : Math.floor(damageWithoutArmorPenalty)
	  }
	damageObject.mitigationAmount = Math.floor(damageObject.enemyRawDamage - damageObject.totalDamage)
	let doesPlayerHaveShield = pushItem.some(item => item.type.shield == true && (item.roomId == 'right hand' || item.roomId == 'left hand'))
	let isAttackBlocked = player.block.blockRoll()
	if (doesPlayerHaveShield && isAttackBlocked) {
		damageObject.wasBlocked = true
	}
	return damageObject
}

function calculateEnemyRangedAbility(enemy) {
	let enemyAbilityObject = enemy.rangedAbilityCalculation
	let chosenAbilityName = determineEnemyAbility(enemyAbilityObject) //this will be a string like ability1, ability2, ability3, etc
	let chosenAbility = enemyAbilityObject[chosenAbilityName]
	if (chosenAbility.damageType == 'fire') {
		
	}
	if (chosenAbility.damageType != 'physical') {
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.totalDamage = Math.floor(chosenAbility.rawDamage * (1 - player.magicResist[chosenAbility.damageType] * 0.01))
		chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
		return chosenAbility
	} else {
		const penetrationType = chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] != undefined ? chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] : undefined
		chosenAbility.enemyHits = enemy.hitChance(enemy)
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.penetrationType = penetrationType
		chosenAbility.playerPenArmor = penetrationType == 'slashing' ? player.slashingArmor : penetrationType == 'piercing' ? player.piercingArmor : penetrationType == 'blunt' ? player.bluntArmor : undefined
		chosenAbility.playerArmor = player.armor <= 0 ? 0 : player.armor
		if (chosenAbility.penetrationType !== undefined) {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerPenArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  	} else {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  }
	  chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
	  return chosenAbility
	}
}
function calculateEnemyMeleeAbility(enemy) {
	let enemyAbilityObject = enemy.meleeAbilityCalculation
	let chosenAbilityName = determineEnemyAbility(enemyAbilityObject) //this will be a string like ability1, ability2, ability3, etc
	let chosenAbility = enemyAbilityObject[chosenAbilityName]
	if (chosenAbility.damageType != 'physical') {
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.totalDamage = Math.floor(chosenAbility.rawDamage * (1 - player.magicResist[chosenAbility.damageType] * 0.01))
		chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
		return chosenAbility
	} else {
		const penetrationType = chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] != undefined ? chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] : undefined
		chosenAbility.enemyHits = enemy.hitChance(enemy)
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.penetrationType = penetrationType
		chosenAbility.playerPenArmor = penetrationType == 'slashing' ? player.slashingArmor : penetrationType == 'piercing' ? player.piercingArmor : penetrationType == 'blunt' ? player.bluntArmor : undefined
		chosenAbility.playerArmor = player.armor <= 0 ? 0 : player.armor
		if (chosenAbility.penetrationType !== undefined) {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerPenArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  	} else {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  }
	  chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
	  return chosenAbility
	}
}









async function enemyMove(enemy) {
	quickMessage('before quickmessage')
	return new Promise((resolve) => {
		console.log('enemy should be moving')
		resolve();
	})
	// enemy.enemyMove()
}
async function waitForNextAction(delayInMilliseconds) {
	await new Promise((resolve) => setTimeout(resolve, delayInMilliseconds));
  }



function coordinatesMatch(a, b) {
	return a.x === b.x && a.y === b.y && a.z === b.z
}


function goblin(area) {
	let goblinLevel
	let goblin = {
		color: `enemy-red`,
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(3, 7)
			goblinLevel = level
			return level
		},
		str: () => 2 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.enemyAttackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a goblin`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: "'s body goes limp and plops to the ground",
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings its weapon at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		enemyAttackPower: () => this.str + goblinLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Goblin',
		refName: 'goblin',
		keywords: ['goblin'],
		abilityName: 'Goblin Punch',
		abilityUseChance: 0,
		useAbility: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let roll = randomNumberRange(1, 100)
			if (roll == 101) {
				customizeEachWord(`${this.name} `, 'red', line1)
				customizeEachWord(`throws its arms in the air, head back screaming`, 'white', line1)
				let ability1Timeout = setTimeout(() => {
					if (this.health > 0) {
						let damage = this.abilityDamage()
						blankSpace()
						customizeEachWord(`The ${this.name} `, 'red', line2)
						customizeEachWord(`rushes forward, throwing its fist at you hitting you with `, 'white', line2)
						customizeEachWord(`Goblin Punch! `, 'light-green', line2)
						customizeEachWord(`Goblin Punch `, 'light-green', line3)
						customizeEachWord(`hits you for `, 'yellow', line3)
						customizeEachWord(`${damage} `, 'light-blue', line3)
						customizeEachWord(`damage.`, 'yellow', line3)
						blankSpace()
						player.health = player.health - damage
						displayPlayerHealthFunc()
						updatePlayerStats()
					} else {
						clearTimeout(ability1Timeout)
					}
					clearInterval(this.enemyBehaviorInterval)
					this.enemyBehavior()
				}, 1000)
			}
		},

		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return goblin
}
function kobold(area) {
	let koboldLevel
	let kobold = {
		color: `enemy-red`,
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(3, 7)
			koboldLevel = level
			return level
		},
		str: () => 3 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.enemyAttackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a kobold`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: 'lets out a cry as it falls to the ground',
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings its weapon at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		enemyAttackPower: () => this.str + koboldLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold',
		refName: 'kobold',
		keywords: ['kobold'],
		abilityName: 'Kobold Punch',
		abilityUseChance: 0,
		useAbility: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let roll = randomNumberRange(1, 100)
			if (roll == 101) {
				customizeEachWord(`${this.name} `, 'red', line1)
				customizeEachWord(`begins sobbing uncontrollably`, 'white', line1)
				let ability1Timeout = setTimeout(() => {
					if (this.health > 0) {
						let damage = this.abilityDamage()
						blankSpace()
						customizeEachWord(`The ${this.name} `, 'red', line2)
						customizeEachWord(`runs up and punches you in the nuts with `, 'white', line2)
						customizeEachWord(`${this.abilityName}!`, 'light-green', line2)
						customizeEachWord(`${this.abilityName} `, 'light-green', line3)
						customizeEachWord(`hits you for `, 'yellow', line3)
						customizeEachWord(`${damage} `, 'light-blue', line3)
						customizeEachWord(`damage.`, 'yellow', line3)
						blankSpace()
						player.health = player.health - damage
						displayPlayerHealthFunc()
						updatePlayerStats()
					} else {
						clearTimeout(ability1Timeout)
					}
					clearInterval(this.enemyBehaviorInterval)
					this.enemyBehavior()
				}, 1000)
			}
		},

		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			// this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return kobold
}
function orc(area) {
	let orcLevel
	let orc = {
		color: `enemy-red`,
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(7, 12)
			orcLevel = level
			return level
		},
		str: () => 3 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.enemyAttackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is an orc`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: 'lets out a cry as it falls to the ground',
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings its weapon at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		enemyAttackPower: () => this.str + orcLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Orc',
		refName: 'orc',
		keywords: ['orc'],
		abilityName: 'Orc Punch',
		abilityUseChance: 0,
		useAbility: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let roll = randomNumberRange(1, 100)
			if (roll == 101) {
				customizeEachWord(`${this.name} `, 'red', line1)
				customizeEachWord(`begins sobbing uncontrollably`, 'white', line1)
				let ability1Timeout = setTimeout(() => {
					if (this.health > 0) {
						let damage = this.abilityDamage()
						blankSpace()
						customizeEachWord(`The ${this.name} `, 'red', line2)
						customizeEachWord(`runs up and punches you in the nuts with `, 'white', line2)
						customizeEachWord(`${this.abilityName}!`, 'light-green', line2)
						customizeEachWord(`${this.abilityName} `, 'light-green', line3)
						customizeEachWord(`hits you for `, 'yellow', line3)
						customizeEachWord(`${damage} `, 'light-blue', line3)
						customizeEachWord(`damage.`, 'yellow', line3)
						blankSpace()
						player.health = player.health - damage
						displayPlayerHealthFunc()
						updatePlayerStats()
					} else {
						clearTimeout(ability1Timeout)
					}
					clearInterval(this.enemyBehaviorInterval)
					this.enemyBehavior()
				}, 1000)
			}
		},

		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			// this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return orc
}

function despawnAfter5Minutes(enemy) {
	let count = 0
	let despawn = setInterval(() => {
		if (count == 300) {
			let enemyIndex = pushMonster.indexOf(enemy)
			enemy.health = 0
			pushMonster.splice(enemyIndex, 1)
			clearInterval(enemy.enemyBehaviorInterval)
			clearInterval(despawn)
		} else if (enemy.health <= 0 || enemy.health == undefined) {
			clearInterval(enemy.enemyBehaviorInterval)
			clearInterval(despawn)
		} else if (coordinatesMatch(player, enemy) && player.isAlive) {
			count = 0
		}
		// console.log('not cleared')
		// console.log(enemy.health, ' ENEMY HEALTH')
		// console.log(count)
		count++
	}, 1000)
}

function blob(area) {
	let blobLevel
	let blob = {
		color: `enemy-red`,
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(1, 5)
			blobLevel = level
			return level
		},
		str: () => 1 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		advancePhrase: `slimes toward you..`,
		desc: () => {
			enemyDescription(this.health, this.enemyAttackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`Looks to be a lower form of blob.`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `splashes into bits and sinks into the ground`,
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`spits at you and hits!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`spits at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		enemyAttackPower: () => 2 + blobLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Blob',
		refName: 'blob',
		keywords: ['blob'],
		abilityName: 'Blob Toss',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			this.itemDrops.push(pieceOfBlob(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return blob
}

//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS
//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS
//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS
//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS

function enemyBehaviorNormal(enemy) {
	let interval = enemy.mainInterval
	enemy.enemyBehaviorInterval = setInterval(() => {
		if (enemy.combat === false && enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
			//This is if player is hidden
			if (player.isStealthed == true) {
				if (player.stealth.level * 3 + player.level / 2 >= enemy.level) {
					quickMessage(`The ${enemy.name} cannot find you and moves on`)
				} else {
					quickMessage(`You have been spotted!`)
					player.isStealthed = false
				}
			} else {
				player.isStealthed = false
				let line2 = document.createElement('div')
				if (player.sideStep.level > 0) {
					quickMessage('1')
					let randomNumber = randomNumberRange(1, 10)
					if (randomNumber <= 5) {
						let line1 = lineFunc()
						blankSpace()
						customizeEachWord(`You sidestep the `, 'white', line1)
						customizeEachWord(`${enemy.name}`, enemy.nameColor, line1)
						blankSpace()
						sideStepRoll(enemy)
					}
				} else {
					customizeEachWord(`${enemy.name} `, 'red', line2)
					customizeEachWord(`${enemy.advancePhrase}`, 'white', line2)
					updateScroll()
					player.combat = true
					enemy.combat = player.combat
				}
			}
		} else if (enemy.combat == true && enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
			if (enemy.useAbility && enemy.abilityUseChance <= randomNumberRange(1, 100)) {
				console.log('ability should be used here')

				enemy.useAbility()
			} else {
				console.log('regular swing should be used here')
				enemySwing(enemy)
			}
		}
		enemy.enemyMove()
		console.log(interval, ' ENEMY MAIN INTERVAL')
	}, interval)
}
function rangedEnemyBehaviorNormal(enemy) {
	let interval = enemy.mainInterval
	enemy.enemyBehaviorInterval = setInterval(() => {
		if (coordinatesMatch(enemy, player) && player.isAlive == true) {
			//This is if player is hidden
			if (player.isStealthed == true) {
				if (player.stealth.level * 3 + player.level / 2 >= enemy.level) {
					quickMessage(`The ${enemy.name} cannot find you and moves on`)
				} else {
					quickMessage(`You have been spotted!`)
					player.isStealthed = false
				}
			} else if (enemy.useAbility && enemy.abilityUseChance >= randomNumberRange(1, 100)) {
				enemy.useAbility()
			} else {
				rangedEnemySwing(enemy)
			}
		}
		enemy.enemyMove()
		console.log(interval, ' ENEMY MAIN INTERVAL')
	}, interval)
}

function playerAbilityChecks(enemy, enemyDamage) {
	let doesPlayerHaveShield = pushItem.some(item, ({ roomId }) => roomId == 'right hand' || (roomId == 'left hand' && item.type.shield == 'true'))
	if (player.block.level > 0 && doesPlayerHaveShield == true && enemyDamage != false) {
		blockRoll(enemy, enemyDamage)
	} else if (player.counterAttack.level > 0) {
		counterAttackRoll(enemy)
	} else if (player.preemptiveStrike.level > 0) {
		preemptiveStrikeRoll(enemy)
	}
}
function blockRoll(enemy, enemyDamage) {
	let blockAmount = player.block.blockAmount()
	let negatedDamage = enemyDamage - blockAmount
	let finalDamage = negatedDamage <= 0 ? 0 : negatedDamage
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	player.health = player.health - finalDamage
	blankSpace()
	customizeEachWord(`The `, 'white', line1)
	customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
	customizeEachWord(`swings at you!`, 'white', line1)
	customizeEachWord(`You block the attack with your shield and take `, 'yellow', line2)
	customizeEachWord(`${finalDamage} `, 'red', line2)
	customizeEachWord(`damage.`, 'yellow', line2)
	customizeEachWord(`(your block negates ${blockAmount}, armor negates ${playerBlockedDamage} damage)`, 'white', line2)
	blankSpace()
	displayPlayerHealthFunc()
	updatePlayerStats()
	updateScroll()
}




function sideStepRoll(enemy) {
	let sideStepRoll = player.sideStep.level * 5
	let randomRoll = randomNumberRange(1, 100)
	let line1 = document.createElement('div')
	if (randomRoll <= sideStepRoll) {
		blankSpace()
		customizeEachWord(`You `, 'white', line1)
		customizeEachWord(`SIDE STEP `, 'yellow', line1)
		customizeEachWord(`the enemy's attempt to advance you!`, 'white', line1)
		blankSpace()
		updateScroll()
	} else {
		blankSpace()
		customizeEachWord(`The `, 'white', line1)
		customizeEachWord(`${enemy.name} `, 'red', line1)
		customizeEachWord(`${enemy.advancePhrase}`, 'white', line1)
		blankSpace()
		updateScroll()
		player.combat = true
		enemy.combat = player.combat
	}
}

function cleaveAbility(targetedMonster) {
	let allMonstersInRoom = getAllEnemiesInRoom()
	let targetedMonsterIndex = allMonstersInRoom.indexOf(targetedMonster)
	let previousMonster = allMonstersInRoom[targetedMonsterIndex - 1]
	let previousPreviousMonster = allMonstersInRoom[targetedMonsterIndex - 2]
	let nextMonster = allMonstersInRoom[targetedMonsterIndex + 1]
	let nextNextMonster = allMonstersInRoom[targetedMonsterIndex + 2]
	if (previousMonster != undefined || nextMonster != undefined) {
		if (player.cleave.level > 0) {
			if (player.cleave.level == 1) {
				if (previousMonster != undefined && previousMonster.combat == true) {
					cleaveCounter = 1
					attack(previousMonster)
					cleaveCounter = 0
				} else if (nextMonster != undefined && nextMonster.combat == true) {
					cleaveCounter = 1
					attack(nextMonster)
					cleaveCounter = 0
				}
			}
			if (player.cleave.level == 2) {
				if (nextMonster != undefined && nextNextMonster != undefined) {
					cleaveCounter++
					if (nextMonster.combat == true) {
						attack(nextMonster)
					}
					if (nextNextMonster.combat == true) {
						attack(nextNextMonster)
					}
				} else if (previousMonster != undefined && nextMonster != undefined) {
					cleaveCounter++
					if (previousMonster.combat == true) {
						attack(previousMonster)
					}
					if (nextMonster.combat == true) {
						attack(nextMonster)
					}
				} else if (previousMonster != undefined && previousPreviousMonster != undefined) {
					cleaveCounter++
					if (previousMonster.combat == true) {
						attack(previousMonster)
					}
					if (previousPreviousMonster.combat == true) {
						attack(previousPreviousMonster)
					}
				}
			}
		}
	}
}

function displayDeathMessage() {
	let line1 = lineFunc()	
	let line2 = lineFunc()	
	let line3 = lineFunc()	
	let line4 = lineFunc()	
	blankSpace()
	customizeEachWord(`************************************************`, 'white', line1)
	customizeEachWord(`*************** You have been slain! ***************`, 'white', line2)
	customizeEachWord(`************************************************`, 'white', line3)
	blankSpace()
	customizeEachWord(`You cannot do anything while dead. You must type REVIVE in order to resurrect.`, `white`, line4)
	blankSpace()
}

function playerDeath() {
	displayDeathMessage()
	deathResetUI()
	player.isAlive = false
	player.combat = false
	for (let i = 0; i < pushMonster.length; i++) {
		pushMonster[i].combat = false
	}
}
function deathResetUI() {
	player.spellsConjured = []
	const conjureBar1 = document.querySelector('.bar-1')
	const conjureBar2 = document.querySelector('.bar-2')
	const conjureBar3 = document.querySelector('.bar-3')
	let cbArray1 = Array.from(conjureBar1.classList)
	let cbArray2 = Array.from(conjureBar2.classList)
	let cbArray3 = Array.from(conjureBar3.classList)
	conjureBar1.classList = cbArray1[0]
	conjureBar2.classList = cbArray2[0]
	conjureBar3.classList = cbArray3[0]

	conjureBar1.style.width = ''	
	conjureBar2.style.width = ''	
	conjureBar3.style.width = ''

	player.warriorAbilityQueue = false
	for (let spell in player) {
		if (player[spell].chambered) {
			player[spell].chambered = false
		}
	}
}


function applyDamageToPlayer(damage) {
	damage = Math.floor(damage)
	if (player.magicShield > 0) {
		//damage = 10
		//magic shield = 3
		let damageToApplyToHealth = Math.abs(player.magicShield + damage)
		player.magicShield = player.magicShield - damage < 0 ? 0 : player.magicShield - damage
		if (player.magicShield <= 0) {
			player.health -= damageToApplyToHealth
		}
	} else {
		player.health = player.health - damage < 0 ? 0 : player.health - damage
	}
	updatePlayerStats()
	displayPlayerHealthFunc()
	if (player.health <= 0) {playerDeath()}
	updateScroll()
}
function applyHealToPlayer(healAmount) {
	player.health += healAmount
	updatePlayerStats()
	displayPlayerHealthFunc()
	updateScroll()
}
function applyMagicShieldToPlayer() {
	let shieldAmount = player.barrier.maxShield()
	player.maxShield = shieldAmount
	player.barrier.flavorTextCast(shieldAmount)
	player.magicShield = shieldAmount
	updatePlayerStats()
	displayPlayerHealthFunc()
	updateScroll()
}

function preemptiveStrikeRoll() {
	return player.preemptiveStrike.level * 5 >= randomNumberRange(1, 100)
}
function counterAttackRoll() {
	return player.counterAttack.level * 5 >= randomNumberRange(1, 100)
}
function performPreemptiveStrike() {

}

function enemyPicksUpItemsAndGold(enemy, area) {
	if (!coordinatesMatch(enemy, player)) {
		// quickMessage(`enemy should pick up stuff`)
		enemy.gold += area.gold
		area.gold = 0
		pushItem.forEach(item => {
			if (item.roomId == enemy.roomId) {
				quickMessage(`Item picked up, should be in monster inventory`)
				enemy.itemDrops.push(item)
				pushItem.splice(pushItem.indexOf(item), 1)
			}
		})
	}
}



function enemyMoveOneRoom(enemy) {
	if (!enemy.isAlive()) {return}
	let enemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemyPicksUpItemsAndGold(enemy, enemyArea)
	enemy.roomId = enemyArea.id
	let canMonsterExit = enemyArea.descriptions.zoneExits.toLowerCase()
	let line = lineFunc()
	if (coordinatesMatch(enemy, player) && player.isStealthed == false && player.isAlive) {
		enemy.moveSwitch = 0 //Switches to always finding player
	} else if (coordinatesMatch(enemy, player) == false && player.isStealthed == false) {
		if (enemy.y == player.y - 1 && enemy.x == player.x - 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('northeast') != -1) {
				enemy.y = enemy.y + 1
				enemy.x = enemy.x + 1
				direction = 'southwest'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y + 1 && enemy.x == player.x - 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southeast') != -1) {
				enemy.y = enemy.y - 1
				enemy.x = enemy.x + 1
				direction = 'northwest'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y + 1 && enemy.x == player.x + 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southwest') != -1) {
				enemy.y = enemy.y - 1
				enemy.x = enemy.x - 1
				direction = 'northeast'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y - 1 && enemy.x == player.x + 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('northwest') != -1) {
				enemy.y = enemy.y + 1
				enemy.x = enemy.x - 1
				direction = 'southeast'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y + 1 && enemy.x == player.x && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('south') != -1) {
				console.log(enemy, ' THIS THIS THIS THIS THIS')
				enemy.y = enemy.y - 1
				direction = 'north'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x + 1 && enemy.y == player.y && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('west') != -1) {
				enemy.x = enemy.x - 1
				direction = 'east'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y - 1 && enemy.x == player.x && enemy.z == player.z && currentArea.hostile == true) {
			console.log('ENEMY MOVE ONE ROOM 4')
			console.log(canMonsterExit)
			if (canMonsterExit.search('north') != -1) {
				enemy.y = enemy.y + 1
				direction = 'south'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x - 1 && enemy.y == player.y && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('east') != -1) {
				enemy.x = enemy.x + 1
				direction = 'west'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z + 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('up') != -1) {
				enemy.z = enemy.z + 1
				direction = 'below'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z - 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('down') != -1) {
				enemy.z = enemy.z - 1
				direction = 'above'
				customizeEachWord(`${enemy.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from ${direction}`, 'white', line)
				updateScroll()
			}
		} else {
			let canMonsterExitSplit = canMonsterExit.split(' ')
			let numberOfDirectionsToMove = canMonsterExitSplit.length
			let randomIndexChosen = randomNumberRange(0, numberOfDirectionsToMove)
			let randomlyChosenDirection = canMonsterExitSplit[randomIndexChosen]
			let coordinateXToTest = 0
			let coordinateYToTest = 0
			let coordinateZToTest = 0
			if (randomlyChosenDirection == 'northwest') {
				coordinateXToTest = -1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'north') {
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'northeast') {
				coordinateXToTest = 1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'east') {
				coordinateXToTest = 1
			} else if (randomlyChosenDirection == 'southeast') {
				coordinateXToTest = 1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'south') {
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'southwest') {
				coordinateXToTest = -1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'west') {
				coordinateXToTest = -1
			} else if (randomlyChosenDirection == 'up') {
				coordinateZToTest = 1
			} else if (randomlyChosenDirection == 'down') {
				coordinateZToTest = -1
			}
			let newAreaForMonsterToMove = allAreas.find(area => {
				return area.x == enemyArea.x + coordinateXToTest && area.y == enemyArea.y + coordinateYToTest && area.z == enemyArea.z + coordinateZToTest
			})
			if (newAreaForMonsterToMove.hostile == true) {
				enemy.x = newAreaForMonsterToMove.x
				enemy.y = newAreaForMonsterToMove.y
				enemy.z = newAreaForMonsterToMove.z
			}
		}
	} else {
		let canMonsterExitSplit = canMonsterExit.split(' ')
		let numberOfDirectionsToMove = canMonsterExitSplit.length - 1
		let randomIndexChosen = randomNumberRange(0, numberOfDirectionsToMove)
		let randomlyChosenDirection = canMonsterExitSplit[randomIndexChosen]
		let enemyEntersFromThisDirection
		let coordinateXToTest = 0
		let coordinateYToTest = 0
		let coordinateZToTest = 0
		if (randomlyChosenDirection == 'northwest') {
			coordinateXToTest = -1
			coordinateYToTest = 1
		} else if (randomlyChosenDirection == 'north') {
			coordinateYToTest = 1
		} else if (randomlyChosenDirection == 'northeast') {
			coordinateXToTest = 1
			coordinateYToTest = 1
		} else if (randomlyChosenDirection == 'east') {
			coordinateXToTest = 1
		} else if (randomlyChosenDirection == 'southeast') {
			coordinateXToTest = 1
			coordinateYToTest = -1
		} else if (randomlyChosenDirection == 'south') {
			coordinateYToTest = -1
		} else if (randomlyChosenDirection == 'southwest') {
			coordinateXToTest = -1
			coordinateYToTest = -1
		} else if (randomlyChosenDirection == 'west') {
			coordinateXToTest = -1
		} else if (randomlyChosenDirection == 'up') {
			coordinateZToTest = 1
		} else if (randomlyChosenDirection == 'down') {
			coordinateZToTest = -1
		}
		switch (randomlyChosenDirection) {
			case 'northwest':
				enemyEntersFromThisDirection = 'southeast'
				break
			case 'north':
				enemyEntersFromThisDirection = 'south'
				break
			case 'northeast':
				enemyEntersFromThisDirection = 'southweast'
				break
			case 'east':
				enemyEntersFromThisDirection = 'west'
				break
			case 'southeast':
				enemyEntersFromThisDirection = 'northwest'
				break
			case 'south':
				enemyEntersFromThisDirection = 'north'
				break
			case 'southwest':
				enemyEntersFromThisDirection = 'northeast'
				break
			case 'west':
				enemyEntersFromThisDirection = 'east'
				break
			default:
				quickMessage(`figure out why this message is displayed`)
		}
		let newAreaForMonsterToMove = allAreas.find(area => {
			return area.x == enemyArea.x + coordinateXToTest && area.y == enemyArea.y + coordinateYToTest && area.z == enemyArea.z + coordinateZToTest
		})
		if (newAreaForMonsterToMove.hostile == true) {
			let line1 = document.createElement('div')
			if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
				customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
				customizeEachWord(` moves to the ${randomlyChosenDirection}`, 'white', line1)
			}
			enemy.x = newAreaForMonsterToMove.x
			enemy.y = newAreaForMonsterToMove.y
			enemy.z = newAreaForMonsterToMove.z
			if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
				customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
				customizeEachWord(`enters the room from the ${enemyEntersFromThisDirection}`, 'white', line1)
			}
		}
	}
	let newEnemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemy.roomId = newEnemyArea.id
}

function enemyAlwaysFindsPlayer(enemy) {
	const path = trackPlayer(enemy)
	console.log(path, ' PATH PATH PATH PATH')
	let enemyDirection

	let monsterX = enemy.x
	let monsterY = enemy.y
	let monsterZ = enemy.z

	if (path != null) {
		if (path[0] == 0 && path[1] == 1 && path[2] == 0) {
			enemyDirection = 'south'
		} else if (path[0] == 0 && path[1] == -1 && path[2] == 0) {
			enemyDirection = 'north'
		} else if (path[0] == 1 && path[1] == 0 && path[2] == 0) {
			enemyDirection = 'west'
		} else if (path[0] == -1 && path[1] == 0 && path[2] == 0) {
			enemyDirection = 'east'
		} else if (path[0] == 0 && path[1] == 0 && path[2] == 1) {
			enemyDirection = 'below'
		} else if (path[0] == 0 && path[1] == 0 && path[2] == -1) {
			enemyDirection = 'above'
		} else if (path[0] == 1 && path[1] == 1 && path[2] == 0) {
			enemyDirection = 'southwest'
		} else if (path[0] == -1 && path[1] == 1 && path[2] == 0) {
			enemyDirection = 'southeast'
		} else if (path[0] == 1 && path[1] == -1 && path[2] == 0) {
			enemyDirection = 'northwest'
		} else if (path[0] == -1 && path[1] == -1 && path[2] == 0) {
			enemyDirection = 'northeast'
		}
	}

	if (path !== null) {
		let enemyLocation = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
		let potentialLocation = allAreas.find(area => area.x == enemyLocation.x + path[0] && area.y == enemyLocation.y + path[1] && area.z == enemyLocation.z + path[2])
		if (potentialLocation.hostile == false) {
			enemy.moveSwitch = 1
			quickMessage(`Behavior switched`)
		} else {
			console.log(enemyLocation, ' ENEMY LOCATION')
			console.log(potentialLocation, ' POTENTIAL LOCATION')
			enemy.x += path[0]
			enemy.y += path[1]
			enemy.z += path[2]
			let line1 = document.createElement('div')
			if (coordinatesMatch(enemy, player)) {
				if (enemyDirection == 'above' || enemyDirection == 'below') {
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`${enemy.entersExitsRoomPhrase} in from ${enemyDirection}`, 'white', line1)
				} else {
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${enemyDirection}`, 'white', line1)
					console.log(`Monster moved to room (${monsterX}, ${monsterY}, ${monsterZ})`)
				}
			} else {
				console.log('No valid path found')
			}
		}
	}
}

function enemyMovesRandomly(enemy) {
	const enemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemyPicksUpItemsAndGold(enemy, enemyArea)
	enemy.roomId = enemyArea.id
	const availableDirections = enemyArea.descriptions.zoneExits.split(' ')
	let directionEntersFrom
	let directionMovesTo

	for (let i = 0; i < availableDirections.length; i++) {
		const randomDirectionIndex = Math.floor(Math.random() * availableDirections.length)
		const randomDirection = availableDirections[randomDirectionIndex].toLowerCase()

		let dx = 0
		let dy = 0
		let dz = 0

		switch (randomDirection) {
			case 'north':
				directionEntersFrom = 'south'
				dy = 1
				break
			case 'south':
				directionEntersFrom = 'north'
				dy = -1
				break
			case 'east':
				directionEntersFrom = 'west'
				dx = 1
				break
			case 'west':
				directionEntersFrom = 'east'
				dx = -1
				break
			case 'northeast':
				directionEntersFrom = 'southwest'
				dx = 1
				dy = 1
				break
			case 'southeast':
				directionEntersFrom = 'northwest'
				dx = 1
				dy = -1
				break
			case 'southwest':
				directionEntersFrom = 'northeast'
				dx = -1
				dy = -1
				break
			case 'northwest':
				directionEntersFrom = 'southeast'
				dx = -1
				dy = 1
				break
			case 'up':
				directionEntersFrom = 'below'
				dz = 1
				break
			case 'down':
				directionEntersFrom = 'above'
				dz = -1
				break
			default:
				console.log('figure out what went wrong here')
		}

		const futureArea = allAreas.find(area => area.x == enemyArea.x + dx && area.y == enemyArea.y + dy && area.z == enemyArea.z + dz)

		if (futureArea && futureArea.hostile == true) {
			enemy.x += dx
			enemy.y += dy
			enemy.z += dz
			directionEntersFrom = /* calculate direction */
			directionMovesTo = randomDirection

			if (coordinatesMatch(enemy, player)) {
				enemy.moveSwitch = 0
				let line1 = lineFunc()
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${directionEntersFrom}`, 'white', line1)
			} else if (!coordinatesMatch(enemy, player) && coordinatesMatch(enemyArea, player)) {
				let line1 = lineFunc()
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} to the ${directionMovesTo}`, 'white', line1)
			}

			// Break out of the loop after a valid move
			break;
		}
		// Optionally add an else statement for handling non-hostile areas
	}
	let newEnemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemy.roomId = newEnemyArea.id
}

function npcMovesRandomly2(npc) {
	const currentRoom = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	const availableDirections = currentRoom.descriptions.zoneExits.split(' ')
	console.log(availableDirections.length, ' AVAILABLE DIRECTIONS LEGNTH')
	if (coordinatesMatch(player, npc) == true) {
		console.log(' NPC IS IN THE SAME ROOM AS PLAYER, NPC DOES NOT MOVE!!!')
	} else {
		for (let i = 0; i < availableDirections.length; i++) {
			const randomDirectionIndex = Math.floor(Math.random() * availableDirections.length)
			const randomDirection = availableDirections[randomDirectionIndex].toLowerCase()
			let directionEntersFrom
			console.log(currentRoom, ' CURRENT ROOM')
			console.log(availableDirections, ' AVAILABLE DIRECTIONS')
			console.log(randomDirectionIndex, ' RANDOM DIRECTION INDEX')
			console.log(randomDirection, ' RANDOM DIRECTION')
			let dx = 0
			let dy = 0
			let dz = 0
			switch (randomDirection) {
				case 'north':
					directionEntersFrom = 'south'
					dy = 1
					break
				case 'south':
					directionEntersFrom = 'north'
					dy = -1
					break
				case 'east':
					directionEntersFrom = 'west'
					dx = 1
					break
				case 'west':
					directionEntersFrom = 'east'
					dx = -1
					break
				case 'northeast':
					directionEntersFrom = 'southwest'
					dx = 1
					dy = 1
					break
				case 'southeast':
					directionEntersFrom = 'northwest'
					dx = 1
					dy = -1
					break
				case 'southwest':
					directionEntersFrom = 'northeast'
					dx = -1
					dy = -1
					break
				case 'northwest':
					directionEntersFrom = 'southeast'
					dx = -1
					dy = 1
					break
				case 'up':
					directionEntersFrom = 'below'
					dz = 1
					break
				case 'down':
					directionEntersFrom = 'above'
					dz = -1
					break
				default:
					console.log('figure out what went wrong here')
			}
		}
		let futureArea = allAreas.find(area => area.x == currentRoom.x + dx && area.y == currentRoom.y + dy && area.z == currentRoom.z + dz)
		if (futureArea.hostile == false && moveSwitch == 0) {
			npc.x += dx
			npc.y += dy
			npc.z += dz
			if (coordinatesMatch(npc, player) == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, npc.nameColor, line1)
				customizeEachWord(`${npc.entersExitsRoomPhrase} from the ${directionEntersFrom}`, 'white', line1)
			}
		} else if (futureArea.hostile == true) {
			console.log(' NPC STOPPED ITSELF FROM MOVING INTO HOSTILE ZONE')
		}
	}
}

function trackPlayer(enemy) {
	let monsterX = enemy.x
	let monsterY = enemy.y
	let monsterZ = enemy.z

	let playerX = player.x
	let playerY = player.y
	let playerZ = player.z

	let enemyLocation = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	let possibleExits = Object.keys(enemyLocation.descriptions.zoneExitsBool)

	const distanceX = Math.abs(playerX - monsterX)
	const distanceY = Math.abs(playerY - monsterY)
	const distanceZ = Math.abs(playerZ - monsterZ)

	if (distanceX === 0 && distanceY === 0 && distanceZ === 0) {
		return null
	}

	// Initialize variables for the chosen path and the minimum distance to the player
	let path = null
	let minDistance = Infinity

	// Check each possible path from the current room to the player
	for (let i = 0; i < possibleExits.length; i++) {
		const exit = possibleExits[i]
		let newPath = null

		// Calculate the new coordinates based on the chosen exit
		switch (exit) {
			case 'north':
				newPath = [0, 1, 0]
				break
			case 'south':
				newPath = [0, -1, 0]
				break
			case 'east':
				newPath = [1, 0, 0]
				break
			case 'west':
				newPath = [-1, 0, 0]
				break
			case 'up':
				newPath = [0, 0, 1]
				break
			case 'down':
				newPath = [0, 0, -1]
				break
			case 'northeast':
				newPath = [1, 1, 0]
				break
			case 'northwest':
				newPath = [-1, 1, 0]
				break
			case 'southeast':
				newPath = [1, -1, 0]
				break
			case 'southwest':
				newPath = [-1, -1, 0]
				break
			default:
				newPath = null
		}

		// If a valid path was found, calculate the distance to the player
		if (newPath !== null) {
			const newMonsterX = monsterX + newPath[0]
			const newMonsterY = monsterY + newPath[1]
			const newMonsterZ = monsterZ + newPath[2]
			const newDistanceX = Math.abs(playerX - newMonsterX)
			const newDistanceY = Math.abs(playerY - newMonsterY)
			const newDistanceZ = Math.abs(playerZ - newMonsterZ)
			const totalDistance = newDistanceX + newDistanceY + newDistanceZ

			// If the total distance is less than the minimum distance, choose this path
			if (totalDistance < minDistance) {
				path = newPath
				minDistance = totalDistance
			}
		}
	}
	return path
}
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
function enemyTracksPlayerBy1Room() {
	let enemyArea = allAreas.find(area => area.x == this.x && area.y == this.y && area.z == this.z)
	let canMonsterExit = enemyArea.descriptions.zoneExits
	let line = document.createElement('div')
	if (this.y == player.y && this.x == player.x && this.z == player.z) {
	} else if (!coordinatesMatch(player, enemy)) {
		if (this.y == player.y - 1 && this.x == player.x - 1 && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southwest') != -1) {
				this.y = this.y + 1
				this.x = this.x + 1
				direction = 'northeast'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y + 1 && this.x == player.x - 1 && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('northwest') != -1) {
				this.y = this.y - 1
				this.x = this.x + 1
				direction = 'southeast'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y + 1 && this.x == player.x + 1 && this.z == player.z && currentArea.hostile == true) {
			console.log(1)
			if (canMonsterExit.search('northeast') != -1) {
				this.y = this.y - 1
				this.x = this.x - 1
				direction = 'southwest'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y - 1 && this.x == player.x - 1 && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southeast') != -1) {
				this.y = this.y - 1
				this.x = this.x + 1
				direction = 'northwest'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y + 1 && this.x == player.x && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('south') != -1) {
				console.log(this, ' THIS THIS THIS THIS THIS')
				this.y = this.y - 1
				direction = 'north'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x + 1 && this.y == player.y && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('west') != -1) {
				this.x = this.x - 1
				direction = 'east'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y - 1 && this.x == player.x && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('north') != -1) {
				console.log(this.y, ' THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS')
				this.y = this.y + 1
				direction = 'south'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x - 1 && this.y == player.y && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('east') != -1) {
				this.x = this.x + 1
				direction = 'west'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x && this.y == player.y && this.z == player.z + 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('up') != -1) {
				this.z = this.z + 1
				direction = 'below'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x && this.y == player.y && this.z == player.z - 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('down') != -1) {
				this.z = this.z - 1
				direction = 'above'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, 'red', line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from ${direction}`, 'white', line)
				updateScroll()
			}
		} else {
			let canMonsterExitSplit = canMonsterExit.split(' ')
			let numberOfDirectionsToMove = canMonsterExitSplit.length
			let randomIndexChosen = randomNumberRange(0, numberOfDirectionsToMove)
			let randomlyChosenDirection = canMonsterExitSplit[randomIndexChosen]
			let coordinateXToTest = 0
			let coordinateYToTest = 0
			let coordinateZToTest = 0

			if (randomlyChosenDirection == 'Northwest') {
				coordinateXToTest = -1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'north') {
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'northeast') {
				coordinateXToTest = 1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'east') {
				coordinateXToTest = 1
			} else if (randomlyChosenDirection == 'southeast') {
				coordinateXToTest = 1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'south') {
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'southwest') {
				coordinateXToTest = -1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'west') {
				coordinateXToTest = -1
			} else if (randomlyChosenDirection == 'up') {
				coordinateZToTest = 1
			} else if (randomlyChosenDirection == 'down') {
				coordinateZToTest = -1
			}
			let newAreaForMonsterToMove = allAreas.find(area => {
				return area.x == enemyArea.x + coordinateXToTest && area.y == enemyArea.y + coordinateYToTest && area.z == enemyArea.z + coordinateZToTest
			})
			if (newAreaForMonsterToMove.hostile == true) {
				console.log(newAreaForMonsterToMove, ' NEW AREA FOR MONSTER TO MOVE')
				this.x = newAreaForMonsterToMove.x
				this.y = newAreaForMonsterToMove.y
				this.z = newAreaForMonsterToMove.z
			}
		}
	}
}
function shackledGoblin(area) {
	let shackledGoblinLevel
	let shackledGoblin = {
		color: `enemy-red`,
		x: function () {
			return area.x
		},
		y: function () {
			return area.y
		},
		z: function () {
			return area.z
		},
		level: () => {
			let level = randomNumberRange(1, 1)
			shackledGoblinLevel = level
			return level
		},
		str: () => 2 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.enemyAttackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a shackled goblin`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: "'s body goes limp and plops to the ground",
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`claws at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`claws at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		enemyAttackPower: () => this.str + shackledGoblinLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Shackled Goblin',
		refName: 'shackled goblin',
		keywords: ['shackled', 'goblin', 'shackled goblin'],
		abilityName: '',
		abilityUseChance: 0,
		useAbility: function () {},
		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 1)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(1, 1)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(1, 1)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(1, 1)
				return gold
			}
		},
		itemDropsRoll: function () {
			this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return shackledGoblin
}

function woundedGoblinScout(area) {
	let woundedGoblinScout = {
		isAlive: function() {
			return this.health > 0
		},
		enemyMoveSpeed: 6000,
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(2, 3)
		},		
		rangedAbilityCalculation: {},
		meleeAbilityCalculation: {},
		color: `enemy-red`,
		x: function () {
			return area.x
		},
		y: function () {
			return area.y
		},
		z: function () {
			return area.z
		},
		level: () => {
			let level = randomNumberRange(2, 2)
			woundedGoblinScout = level
			return level
		},
		str: () => 1 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `limps in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.enemyAttackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a Wounded Goblin Scout`)
		},
		death: async function () {
			if (player.killList[this.refName] == undefined) {
				player.killList[this.refName] = 1
			} else {
				player.killList[this.refName]++
			}
			enemyDeath(this)
			await dialogueWait(1000)
			let line1 = lineFunc()
			customizeEachWord(`${egbert.name} `, egbert.nameColor, line1)
			customizeEachWord(`strides in from the south`, 'white', line1)
			egbert.y++
			egbert.questSequence.sixth = true
			currentArea.npc.push(egbert)
			await dialogueWait(1000)

			galvadiaWelcomeArea14.npc = []
			egbert.speak()
		},
		deathPhrase: "'s body goes limp and plops to the ground",
		strikePhrase: `swings at you and scratches you with its claws!`,
		missPhrase: 'swings at you and misses!',		
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		entersExitsRoomPhrase: '',
		hostile: true,
		combat: false,
		health: () => 12,
		maxHealth: () => 12,
		enemyAttackPower: () => this.str,
		accuracy: () => this.dex,
		dodge: () => 5,
		hitChance: function () {
			return 80
		},
		damageTypes: [], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		experience: () => 5,
		armor: 0,
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Goblin Scout',
		refName: 'goblin_scout',
		keywords: ['goblin', 'scout', 'goblin scout'],
		itemDrops: [],
		gold: function () {
			return randomNumberRange(4, 6)
		},
		itemDropsRoll: function () {
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 6000,
		enemyBehavior: function () {
			console.log(this)
			monsterBehavior(this)
		},
	}
	return woundedGoblinScout
}

function customizeEachWord(message, addClass, line) {
	const classOrClassArray = addClass
	let span = document.createElement('span') //string 1
	span.textContent = message
	if (Array.isArray(classOrClassArray)) {
		classOrClassArray.forEach(classToAdd => span.classList.add(classToAdd))
	} else {
		span.classList.add(classOrClassArray)
	}
	line.appendChild(span)
	masterArea.appendChild(line)
	updateScroll()
}

function customizeNPCDialogue(message, wordColor, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(wordColor)
	span.classList.add('bold')
	line.appendChild(span)
	masterArea.appendChild(line)
	updateScroll()
}
function customizeGameDialogue(message, wordColor, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(wordColor)
	span.classList.add('italic')
	line.appendChild(span)
	masterArea.appendChild(line)
	updateScroll()
}

//randomNumberRange(3, 10) will return range of numbers between 3 and 9. what is returned is (min, max -1) technically
function randomNumberRange(min, max) {
	return Math.floor(Math.random() * (max + 1 - min) + min)
}
function randomSingleNumber(maxNumber) {
	return Math.floor(Math.random() * maxNumber) + 1
}
function enemyLocation(directionMonsterComesInFrom) {}

function dragon() {
	let dragon = {
		randomItemDrops: Math.floor(Math.random() * 10) + 1,
		name: 'Dragon',
		level: 99,
		abilityName: 'Fire breath',
		abilityDamage: Math.floor(Math.random() * 187) + 1,
		itemDrops: function () {
			if (dragon.randomItemDrops < 3) {
				return dragonTooth + ', ' + dragonScale
			} else if (dragon.randomItemDrops < 5) {
				return dragonTooth
			} else if (dragon.randomItemDrops <= 5) {
				return dragonScale
			} else if (dragon.randomItemDrops > 5) {
				return dragonSword
			}
		},
	}
	return dragon
}

function startBehavior() {
	for (let i = 0; i < pushMonster.length; i++) {
		if (pushMonster[i].behaviorInterval == false) {
			pushMonster[i].enemyBehavior()
			pushMonster[i].behaviorInterval = true
		}
	}
}
class NPC {
	constructor() {}
}
//enemy class mob generator
function monsterGen(enemy) {
	if (pushMonster.length < 100) {
		this.isAlive = enemy.isAlive
		this.enemyMoveSpeed = enemy.enemyMoveSpeed
		this.shouldEngagePlayer = enemy.shouldEngagePlayer
		this.shouldAttackPlayer = enemy.shouldAttackPlayer
		this.damageCalculation = enemy.damageCalculation
		this.rangedAbilityCalculation = enemy.rangedAbilityCalculation
		this.meleeAbilityCalculation = enemy.meleeAbilityCalculation
		this.color = enemy.color
		this.picture = enemy.picture
		this.x = enemy.x()
		this.y = enemy.y()
		this.z = enemy.z()
		this.level = enemy.level()
		this.con = enemy.con()
		this.entersTheRoomPhrase = enemy.entersTheRoomPhrase
		this.advancePhrase = enemy.advancePhrase
		this.desc = enemy.desc
		this.death = enemy.death
		this.deathPhrase = enemy.deathPhrase
		this.strikePhrase = enemy.strikePhrase
		this.missPhrase = enemy.missPhrase
		this.rangedAttackPhrase = enemy.rangedAttackPhrase
		this.rangedMissPhrase = enemy.rangedMissPhrase
		this.entersExitsRoomPhrase = enemy.entersExitsRoomPhrase
		this.hostile = enemy.hostile
		this.combat = enemy.combat
		this.health = enemy.health()
		this.maxHealth = enemy.maxHealth()
		this.enemyAttackPower = enemy.enemyAttackPower()
		this.accuracy = enemy.accuracy()
		this.dodge = enemy.dodge()
		this.hitChance = enemy.hitChance
		this.damageTypes = enemy.damageTypes
		this.attackTypes = enemy.attackTypes
		this.experience = enemy.experience()
		this.armor = enemy.armor
		this.slashingArmor = enemy.slashingArmor
		this.piercingArmor = enemy.piercingArmor
		this.bluntArmor = enemy.bluntArmor
		this.statusEffects = enemy.statusEffects
		this.roomId = enemy.roomId
		this.randomItemDrops = enemy.randomItemDrops
		this.name = enemy.name
		this.refName = enemy.refName
		this.keywords = enemy.keywords
		this.itemDrops = enemy.itemDrops
		this.gold = enemy.gold()
		this.itemDropsRoll = enemy.itemDropsRoll()
		this.id = enemy.id()
		this.enemyMove = enemy.enemyMove
		this.moveSwitch = enemy.moveSwitch
		this.enemyBehaviorInterval = enemy.enemyBehaviorInterval
		this.behaviorInterval = enemy.behaviorInterval
		this.mainInterval = enemy.mainInterval
		this.enemyBehavior = enemy.enemyBehavior
		pushMonster.push(
			new Monster(
				this.isAlive,
				this.enemyMoveSpeed,
				this.shouldEngagePlayer,
				this.shouldAttackPlayer,
				this.damageCalculation,
				this.rangedAbilityCalculation,
				this.meleeAbilityCalculation,
				this.color,
				this.picture,
				this.x,
				this.y,
				this.z,
				this.level,
				this.con,
				this.entersTheRoomPhrase,
				this.advancePhrase,
				this.desc,
				this.death,
				this.deathPhrase,
				this.strikePhrase,
				this.missPhrase,
				this.rangedAttackPhrase,
				this.rangedMissPhrase,
				this.entersExitsRoomPhrase,
				this.hostile,
				this.combat,
				this.health,
				this.maxHealth,
				this.enemyAttackPower,
				this.accuracy,
				this.dodge,
				this.hitChance,
				this.damageTypes,
				this.attackTypes,
				this.experience,
				this.armor,
				this.slashingArmor,
				this.piercingArmor,
				this.bluntArmor,
				this.statusEffects,
				this.roomId,
				this.randomItemDrops,
				this.name,
				this.refName,
				this.keywords,
				this.itemDrops,
				this.gold,
				this.itemDropsRoll,
				this.id,
				this.enemyMove,
				this.moveSwitch,
				this.enemyBehaviorInterval,
				this.behaviorInterval,
				this.mainInterval,
				this.enemyBehavior
			)
		)
		if (enemy.x() == player.x && enemy.y() == player.y && enemy.z() == player.z) {
			let line1 = document.createElement('div')
			customizeEachWord(`${enemy.name} `, 'red', line1)
			customizeEachWord(`${enemy.entersTheRoomPhrase}`, 'white', line1)
		}
		startBehavior()
		updateMonsterBox()
	}

}

function updateMonsterBox() {
	updateRoomEnemies()
	let allEnemiesInRoom = roomEnemies
	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate');
	allMonsterBoxes.forEach((monsterBox, index) => {
		let enemy = allEnemiesInRoom[index];
		if (enemy) {
			let monsterName = monsterBox.querySelector('.monster-name');
			let monsterPicture = monsterBox.querySelector('.monster-picture');
			let monsterHealthBar = monsterBox.querySelector('.enemy-health-bar');
			let monsterStatusEffects = monsterBox.querySelectorAll('#monster-status-effects');
			// Reset debuff slots
			monsterStatusEffects.forEach(debuffSlot => {
				debuffSlot.classList.remove(...debuffSlot.classList);
				debuffSlot.textContent = ''; // Reset debuff stack display
			});
	
			// Update name, picture, and health bar
			monsterName.textContent = enemy.name;
			monsterPicture.src = enemy.picture;
			monsterHealthBar.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
	
			// Update debuffs
			if (enemy.debuffs) {
				Object.keys(enemy.debuffs).forEach((debuffName, debuffIndex) => {
					let debuffSlot = monsterStatusEffects[debuffIndex];
					if (debuffSlot) {
						if (!debuffSlot.classList.contains(debuffName)) {
							debuffSlot.classList = `${debuffName}`;
						}
						// Update debuff stack display
						if (enemy.debuffs[debuffName].stacks) {
							debuffSlot.textContent = enemy.debuffs[debuffName].stacks;
						}
					}
				});
			}
		}
	});
	

	
	// let allEnemiesInRoom = getAllEnemiesInRoom()
	// let allMonsterBoxes = document.querySelectorAll('.monster-nameplate')
	// for (let i = 0; i < allMonsterBoxes.length; i++) {
	// 	let monsterName = allMonsterBoxes[i].querySelector('.monster-name')
	// 	let monsterPicture = allMonsterBoxes[i].querySelector('.monster-picture')
	// 	let monsterHealthBar = allMonsterBoxes[i].querySelector('.enemy-health-bar')
	// 	let monsterStatusEffects = allMonsterBoxes[i].querySelectorAll('#monster-status-effects')

	// 	if (allEnemiesInRoom[i]) {
	// 		quickMessage('1')	
	// 		monsterName.textContent = allEnemiesInRoom[i].name
	// 		monsterPicture.src = allEnemiesInRoom[i].picture
	// 		monsterHealthBar.style.width = `${allEnemiesInRoom[i].health / allEnemiesInRoom[i].maxHealth * 100}%`
	// 			for (let j = 0; j < 5; j++) {
	// 				if (allEnemiesInRoom[i].debuffs) {
	// 					quickMessage(`2`)
	// 					for (let debuff in allEnemiesInRoom[i].debuffs) {
	// 						console.log(debuff)
	// 						console.log(monsterStatusEffects[j], ' MONSTER STATUS EFFECTS J')
	// 						if (monsterStatusEffects[j].classList.contains(debuff)) {
	// 							//do nothing
	// 						} else {
	// 							monsterStatusEffects[j].className = debuff
	// 						}
	// 					}
	// 				} else {
	// 				// monsterStatusEffects[i].className = ``

	// 			}
	// 		}
	// 	} else {
	// 		// monsterName.textContent = ``
	// 		// monsterPicture.src = ``
	// 		// monsterHealthBar.style.width = ``
	// 	}
	// }




	if (allEnemiesInRoom.length === 0) {
		allMonsterBoxes.forEach(box => box.classList.add('hide'));
	} else {
		allMonsterBoxes.forEach((box, index) => {
			if (index < allEnemiesInRoom.length) {
				box.classList.remove('hide');
			} else {
				box.classList.add('hide');
			}
		});
	}



	// for (let i = 0; i < allEnemiesInRoom.length; i++) {
	// 	if (allMonsterNamePlates[i]) {
	// 		allMonsterNamePlates[i].textContent = allEnemiesInRoom[i].name
	// 		allMonsterPictureBox[i].src = allEnemiesInRoom[i].picture
	// 	}
	// 	if (allMonsterHealthBars[i]) {
	// 		allMonsterHealthBars[i].style.width = `${allEnemiesInRoom[i].health / allEnemiesInRoom[i].maxHealth * 100}%`
	// 	}
	// }
}



class Monster {
	constructor(
		isAlive,
		enemyMoveSpeed,
		shouldEngagePlayer,
		shouldAttackPlayer,
		damageCalculation,
		rangedAbilityCalculation,
		meleeAbilityCalculation,
		color,
		picture,
		x,
		y,
		z,
		level,
		con,
		entersTheRoomPhrase,
		advancePhrase,
		desc,
		death,
		deathPhrase,
		strikePhrase,
		missPhrase,
		rangedAttackPhrase,
		rangedMissPhrase,
		entersExitsRoomPhrase,
		hostile,
		combat,
		health,
		maxHealth,
		enemyAttackPower,
		accuracy,
		dodge,
		hitChance,
		damageTypes,
		attackTypes,
		experience,
		armor,
		slashingArmor,
		piercingArmor,
		bluntArmor,
		statusEffects,
		roomId,
		randomItemDrops,
		name,
		refName,
		keywords,
		itemDrops,
		gold,
		itemDropsRoll,
		id,
		enemyMove,
		moveSwitch,
		enemyBehaviorInterval,
		behaviorInterval,
		mainInterval,
		enemyBehavior
	) {
		this.isAlive = isAlive
		this.enemyMoveSpeed = enemyMoveSpeed
		this.shouldEngagePlayer = shouldEngagePlayer
		this.shouldAttackPlayer = shouldAttackPlayer
		this.damageCalculation = damageCalculation
		this.rangedAbilityCalculation = rangedAbilityCalculation
		this.meleeAbilityCalculation = meleeAbilityCalculation
		this.color = color
		this.picture = picture
		this.x = x
		this.y = y
		this.z = z
		this.level = level
		this.con = con
		this.entersTheRoomPhrase = entersTheRoomPhrase
		this.advancePhrase = advancePhrase
		this.desc = desc
		this.death = death
		this.deathPhrase = deathPhrase
		this.strikePhrase = strikePhrase
		this.missPhrase = missPhrase
		this.rangedAttackPhrase = rangedAttackPhrase
		this.rangedMissPhrase = rangedMissPhrase
		this.entersExitsRoomPhrase = entersExitsRoomPhrase
		this.hostile = hostile
		this.combat = combat
		this.health = health
		this.maxHealth = maxHealth
		this.enemyAttackPower = enemyAttackPower
		this.accuracy = accuracy
		this.dodge = dodge
		this.hitChance = hitChance
		this.damageTypes = damageTypes
		this.attackTypes = attackTypes
		this.experience = experience
		this.armor = armor
		this.slashingArmor = slashingArmor
		this.piercingArmor = piercingArmor
		this.bluntArmor = bluntArmor
		this.statusEffects = statusEffects
		this.roomId = roomId
		this.randomItemDrops = randomItemDrops
		this.name = name
		this.refName = refName
		this.keywords = keywords
		this.itemDrops = itemDrops
		this.gold = gold
		this.itemDropsRoll = itemDropsRoll
		this.id = id
		this.enemyMove = enemyMove
		this.moveSwitch = moveSwitch
		this.enemyBehaviorInterval = enemyBehaviorInterval
		this.behaviorInterval = behaviorInterval
		this.mainInterval = mainInterval
		this.enemyBehavior = enemyBehavior
	}
}

//QUEST ITEMS/SELLABLES/CRAFTING MATERIALS
//FOOD
//WEAPON GEN
//ARMOR GEN

function questItemGen(item) {
	this.id = item.id()
	this.roomId = item.roomId
	this.name = item.name
	this.refName = item.refName
	this.color = item.color
	this.keywords = item.keywords
	this.type = item.type
	this.sellValue = item.sellValue
	this.description = item.description
	this.desc = item.desc
	pushItem.push(new QuestItem(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.sellValue, this.description, this.desc))
}
class QuestItem {
	constructor(id, roomId, name, refName, color, keywords, type, sellValue, description, desc) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
	}
}

function craftingMaterialGen(item) {
	this.id = item.id()
	this.roomId = item.roomId
	this.name = item.name
	this.refName = item.refName
	this.color = item.color
	this.keywords = item.keywords
	this.type = item.type
	this.sellValue = item.sellValue
	this.description = item.description
	this.desc = item.desc
	pushItem.push(new craftingMaterial(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.sellValue, this.description, this.desc))
}
class craftingMaterial {
	constructor(id, roomId, name, refName, color, keywords, type, sellValue, description, desc) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
	}
}



function foodGen(food) {
	this.id = food.id()
	this.roomId = food.roomId
	this.name = food.name
	this.refName = food.refName
	this.color = food.color
	this.keywords = food.keywords
	this.type = food.type
	this.cookable = food.cookable
	this.cookedVersion = food.cookedVersion
	this.cookPhrase = food.cookPhrase
	this.buff = food.buff
	this.desc = food.desc
	this.price = food.price
	this.sellValue = food.sellValue
	pushItem.push(new Food(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.cookable, this.cookedVersion, this.cookPhrase, this.buff, this.desc, this.price, this.sellValue))
} 
class Food {
	constructor(id, roomId, name, refName, color, keywords, type, cookable, cookedVersion, cookPhrase, buff, desc, price, sellValue) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.cookable = cookable
		this.cookedVersion = cookedVersion
		this.cookPhrase = cookPhrase
		this.buff = buff
		this.desc = desc
		this.price = price
		this.sellValue = sellValue
	}
}




function weaponGen(item) {
	this.id = item.id()
	this.roomId = item.roomId
	this.name = item.name
	this.picture = item.picture
	this.color = item.color
	this.keywords = item.keywords
	this.botDamage = item.botDamage
	this.topDamage = item.topDamage
	this.mods = item.mods
	this.requirements = item.requirements
	this.type = item.type
	this.enchantment = item.enchantment
	this.skillUsed = item.skillUsed
	this.price = item.price
	this.sellValue = item.sellValue
	this.description = item.description
	this.desc = item.desc
	this.swing = item.swing
	this.miss = item.miss
	pushItem.push(new Weapon(this.id, this.roomId, this.name, this.picture, this.color, this.keywords, this.topDamage, this.botDamage, this.mods, this.requirements, this.type, this.enchantment, this.skillUsed, this.price, this.sellValue, this.description, this.desc, this.swing, this.miss))
}
class Weapon {
	constructor(id, roomId, name, picture, color, keywords, topDamage, botDamage, mods, requirements, type, enchantment, skillUsed, price, sellValue, description, desc, swing) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.picture = picture
		this.color = color
		this.keywords = keywords
		this.topDamage = topDamage
		this.botDamage = botDamage
		this.mods = mods
		this.requirements = requirements
		this.type = type
		this.enchantment = enchantment
		this.skillUsed = skillUsed
		this.price = price
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
		this.swing = swing
		this.miss = miss
	}
}
function armorGen(armor) {
	this.id = armor.id()
	this.roomId = armor.roomId
	this.name = armor.name
	this.picture = armor.picture
	this.color = armor.color
	this.keywords = armor.keywords
	this.mods = armor.mods
	this.requirements = armor.requirements
	this.type = armor.type
	this.price = armor.price
	this.sellValue = armor.sellValue
	this.description = armor.description
	this.slot = armor.slot
	this.desc = armor.desc
	pushItem.push(new Armor(this.id, this.roomId, this.name, this.picture, this.color, this.keywords, this.mods, this.requirements, this.type, this.price, this.sellValue, this.description, this.slot, this.desc))
}
class Armor {
	constructor(id, roomId, name, picture, color, keywords, mods, requirements, type, price, sellValue, description, slot, desc) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.picture = picture
		this.color = color
		this.keywords = keywords
		this.mods = mods
		this.requirements = requirements
		this.type = type
		this.price = price
		this.sellValue = sellValue
		this.description = description
		this.slot = slot
		this.desc = desc
	}
}

function consumableGen(consumable) {
	this.id = consumable.id()
	this.roomId = consumable.roomId
	this.name = consumable.name
	this.color = consumable.color
	this.keywords = consumable.keywords
	this.property = consumable.property
	this.type = consumable.type
	this.manaRestore = consumable.manaRestore
	this.strengthUp = consumable.strengthUp
	this.agilityUp = consumable.agilityUp
	this.dexterityUp = consumable.dexterityUp
	this.intelligenceUp = consumable.intelligenceUp
	this.wisdomUp = consumable.wisdomUp
	this.attackUp = consumable.attackUp
	this.armorUp = consumable.armorUp
	this.piercingArmorUp = consumable.piercingArmorUp
	this.slashingArmorUp = consumable.slashingArmorUp
	this.bluntArmorUp = consumable.bluntArmorUp
	pushItem.push(
		new Consumable(
			this.id,
			this.roomId,
			this.name,
			this.color,
			this.keywords,
			this.property,
			this.type,
			this.manaRestore,
			this.strengthUp,
			this.agilityUp,
			this.dexterityUp,
			this.intelligenceUp,
			this.wisdomUp,
			this.attackUp,
			this.armorUp,
			this.piercingArmorUp,
			this.slashingArmorUp,
			this.bluntArmorUp
		)
	)
}

class Consumable {
	constructor(id, roomId, name, color, keywords, property, type, manaRestore, strengthUp, agilityUp, dexterityUp, intelligenceUp, wisdomUp, attackUp, armorUp, piercingArmorUp, slashingArmorUp, bluntArmorUp) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.color = color
		this.keywords = keywords
		this.property = property
		this.type = type
		this.manaRestore = manaRestore
		this.strengthUp = strengthUp
		this.dexterityUp = dexterityUp
		this.intelligenceUp = intelligenceUp
		this.wisdomUp = wisdomUp
		this.attackUp = attackUp
		this.armorUp = armorUp
		this.piercingArmorUp = piercingArmorUp
		this.slashingArmorUp = slashingArmorUp
		this.bluntArmorUp = bluntArmorUp
	}
}




function spawnObject(secondCommand) {
	if (secondCommand == 'hellguardian') {
		monsterGen(hellGuardian(currentArea))
	}
}

function speak(secondCommand) {
	console.log('SPEAK')
	let validNpcs = currentArea.npc
	const specifiedNpc = validNpcs.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	console.log(specifiedNpc)
	if (validNpcs) {
		if (secondCommand == undefined) {
			quickMessage(`You must specify who you want to talk to`)
		} else if (specifiedNpc == undefined) {
			quickMessage(`You do not see anyone here named ${secondCommand} to speak to`)
		} else if (specifiedNpc && specifiedNpc.speak) {
			specifiedNpc.speak()
		} else {
			let line1 = document.createElement('div')
			customizeEachWord(`${specifiedNpc.name} `, specifiedNpc.nameColor, line1)
			customizeEachWord(`will not speak to you `, 'white', line1)
		}
	}
}

function enemySpawn() {

}

function displayNPCName(peopleDiv, npc) {
	const npcDiv = document.createElement('div')
	const firstNameSpan = document.createElement('span')
	const firstNameNode = document.createTextNode(`${npc.name}`)
	if (npc.prefix != null) {
		const prefixSpan = document.createElement('span')
		const prefixNode = document.createTextNode(`${npc.prefix}`)
		prefixSpan.classList.add(npc.prefixColor)
		prefixSpan.appendChild(prefixNode)
		npcDiv.appendChild(prefixSpan)
	}

	firstNameSpan.classList.add(npc.nameColor)
	firstNameSpan.appendChild(firstNameNode)
	npcDiv.appendChild(firstNameSpan)

	if (npc.suffix != null) {
		const suffixSpan = document.createElement('span')
		const suffixNode = document.createTextNode(`${npc.suffix}`)
		suffixSpan.classList.add(npc.suffixColor)
		suffixSpan.appendChild(suffixNode)
		npcDiv.appendChild(suffixSpan)
	}
	peopleDiv.appendChild(npcDiv)
}

function npcsAll() {
	return currentArea.npc
}
function npcByName(secondCommand) {
	return npcsAll().find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	
}
function npcByNumber() {}


function offerQuest(secondCommand) {
	let doesValidQuestNpcExist = npcsAll().some(npc => npc.quest) //true if found, false if not
	let specifiedNpc = npcByName(secondCommand) //specified npc by second command
	let allQuestGivers = npcsAll().filter(npc => npc.quest) //all quest givers in the room
	let line1 = lineFunc()
	if (!doesValidQuestNpcExist) { //no quest giver is in the room
		customizeEachWord(`There is nobody here offering quests`, 'white', line1) 
		return
	}
	if (!specifiedNpc && secondCommand) { //player specifies a name, but an npc by that input is not in the room
		customizeEachWord(`There is nobody here by the name of ${secondCommand} offering any quests`, 'white', line1)
		return
	}
	if (specifiedNpc && specifiedNpc.quest) { //
		specifiedNpc.offer()
		return
	}
	if (allQuestGivers.length == 1) {
		allQuestGivers[0].offer()
		return
	}
	if (allQuestGivers.length > 1) {
		customizeEachWord(`You must specify who you wish to offer`, 'white', line1)
	}
}



//EXAMINE FUNCITON - for examining items in backpack, held, and equipped
function inspect(secondCommand, thirdCommand) {
	let allItemsOnPerson = pushItem.filter(
		item =>
			item.roomId == 'right hand' ||
			item.roomId == 'left hand' ||
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet' ||
			item.roomId == 'backpack'
	)
	let allItemsEquipped = allItemsOnPerson.filter(
		item =>
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet'
	)
	let rightHandItem = allItemsOnPerson.find(item => item.roomId == 'right hand')
	let leftHandItem = allItemsOnPerson.find(item => item.roomId == 'left hand')
	let allItemsHeld = []
	allItemsHeld.push(rightHandItem, leftHandItem)

	let equippedItemsMapped = allItemsEquipped.map(item => item.roomId)

	let targetItemsOnPerson = allItemsOnPerson.filter(item => item.keywords.find(keyword => keyword == secondCommand))
	targetItemsOnPerson.sort((a, b) => (a.name > b.name ? 1 : -1))

	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack') //Every item in backpack - not held or equipped
	allItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))

	let targetItemsInBackpack = pushItem.filter(item => item.keywords.find(keyword => keyword == secondCommand) && item.roomId == 'backpack') //array of items on person that matches the item's keyword
	targetItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))

	if (secondCommand == undefined || /^\s*$/.test(secondCommand) == true) {
		console.log(1)
		quickMessage(`You must specify what you want to examine.`)
	} else if (secondCommand == 'left' && leftHandItem != undefined) {
		console.log(2)
		findAny(leftHandItem)
	} else if (secondCommand == 'right' && rightHandItem != undefined) {
		console.log(3)
		findAny(rightHandItem)
	} else if (secondCommand == 'left' && leftHandItem == undefined) {
		console.log(4)
		quickMessage(`You do not have anything in your left hand to examine.`)
	} else if (secondCommand == 'right' && rightHandItem == undefined) {
		console.log(5)
		quickMessage(`You do not have anything in your right hand to examine.`)
	} else if (isNaN(secondCommand) && secondCommand != undefined && targetItemsOnPerson[0] == undefined) {
		console.log(6)
		quickMessage(`You do not have a ${secondCommand} in your backpack to examine`) //add a way for it to say a or an ${secondCommand} depending on if it starts with a vowel or not
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] == undefined) {
		console.log(7)
		quickMessage(`You do not have an item in that slot to examine.`)
	} else if (!isNaN(thirdCommand) && targetItemsInBackpack[thirdCommand - 1] == undefined) {
		console.log(8)
		quickMessage(`You do not have an item in that slot to examine.`)
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] != undefined) {
		console.log(9)
		findAny(allItemsInBackpack[secondCommand - 1], allItemsInBackpack)
	} else if (targetItemsOnPerson[0] != undefined && targetItemsOnPerson[1] == undefined && isNaN(thirdCommand)) {
		console.log(10)
		findAny(targetItemsOnPerson[0])
	} else if (allItemsHeld[0] != undefined && allItemsHeld[1] != undefined) {
		console.log(12)
		findAny(allItemsHeld[0])
	} else if (allItemsHeld[0] == undefined && allItemsHeld[1] != undefined && player[allItemsHeld[1].slot] == empty) {
		console.log(13)
		findAny(allItemsHeld[1])
	} else if (!isNaN(thirdCommand) == true && thirdCommand != undefined && targetItemsInBackpack[thirdCommand - 1] != undefined) {
		console.log(targetItemsInBackpack[thirdCommand - 1])
		findAny(targetItemsInBackpack[thirdCommand - 1], allItemsInBackpack)
	} else if (targetItemsOnPerson[0] != undefined && targetItemsOnPerson[1] != undefined) {
		console.log(15)
		if (rightHandItem != undefined && rightHandItem.keywords.find(keyword => keyword == secondCommand) != undefined) {
			console.log(16)
			findAny(rightHandItem)
		} else if (leftHandItem != undefined && leftHandItem.keywords.find(keyword => keyword == secondCommand) != undefined) {
			console.log(17)
			findAny(leftHandItem)
		} else {
			quickMessage(`You must specify which ${secondCommand} you want to examine.`)
		}
		let itemEquipped
		let isItemEquipped
		targetItemsOnPerson.forEach(item => {
			if (equippedItemsMapped.includes(item.roomId)) {
				console.log(18)
				itemEquipped = item
				isItemEquipped = true
			} else if (allItemsHeld.includes(item.roomId)) {
				console.log(19)
				itemEquipped = item
				isItemEquipped = true
			}
		})
		if (isItemEquipped == true) {
			findAny(itemEquipped)
		} else if (isItemEquipped == false) {
			console.log(20)
			quickMessage(`You must specify which ${secondCommand} you want to examine.`)
		} else {
			console.log(21)
		}
	}
}
// function findItemInRoom(secondCommand, thirdCommand) {
// 	let allItemsInBackpack = pushItem.filter(items => items.roomId == backpack)
// 	let itemInRightHand = pushItem.filter(item => item.roomId == rightHand)
// 	let itemInLeftHand = pushItem.filter(item => item.roomId == leftHand)

// 	let allItemsInRoom = pushItem.filter(items => items.roomId == currentArea.id)
// 	let allSpecifiedItemsInRoom = allItemsInRoom.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
// 	let itemObject = allItemsInRoom.find(({ keywords }) => keywords.some(x => x == secondCommand))
// 	if (thirdCommand != undefined && isNaN(thirdCommand) == false) {
// 		if (allSpecifiedItemsInRoom[thirdCommand - 1] != undefined) {
// 			if (allSpecifiedItemsInRoom[thirdCommand - 1].type.weapon) {
// 				findWeapon(allSpecifiedItemsInRoom[thirdCommand - 1])
// 			} else if (allSpecifiedItemsInRoom[thirdCommand - 1].type.armor) {
// 				findArmor(allSpecifiedItemsInRoom[thirdCommand - 1])
// 			}
// 		} else {
// 			quickMessage(`You do not own that number of ${itemObject.name}`)
// 		}
// 	} else if (itemObject != undefined) {
// 		if (allSpecifiedItemsInRoom[0].type.weapon) {
// 			findWeapon(allSpecifiedItemsInRoom[0])
// 		} else if (allSpecifiedItemsInRoom[0].type.armor) {
// 			findArmor(allSpecifiedItemsInRoom[0])
// 		}
// 	} else {
// 		return false
// 	}
// }

//INSPECT FUNCITON - for examining items equipped or in backpack
function findItemInBackpack(command, secondCommand, thirdCommand) {
	let allItemsInBackpack = pushItem.filter(items => items.roomId == backpack)
	let itemInRightHand = pushItem.filter(item => item.roomId == rightHand)
	let itemInLeftHand = pushItem.filter(item => item.roomId == leftHand)
	let allItemsInBackpackAndEquipped = pushItem.filter(items => {
		let nonNumId
		if (isNaN(items.roomId) == true) return items
	})

	let allSpecifiedItemsInRoom = allItemsInBackpack.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	let itemObject = allItemsInRoom.find(({ keywords }) => keywords.some(x => x == secondCommand))
	if (thirdCommand != undefined && isNaN(thirdCommand) == false) {
		if (allSpecifiedItemsInRoom[thirdCommand - 1] != undefined) {
			if (allSpecifiedItemsInRoom[thirdCommand - 1].type.weapon) {
				findWeapon(allSpecifiedItemsInRoom[thirdCommand - 1])
			} else if (allSpecifiedItemsInRoom[thirdCommand - 1].type.armor) {
				findArmor(allSpecifiedItemsInRoom[thirdCommand - 1])
			}
		} else {
			quickMessage(`You do not own that number of ${itemObject.name}`)
		}
	} else if (itemObject != undefined) {
		if (allSpecifiedItemsInRoom[0].type.weapon) {
			findWeapon(allSpecifiedItemsInRoom[0])
		} else if (allSpecifiedItemsInRoom[0].type.armor) {
			findArmor(allSpecifiedItemsInRoom[0])
		}
	} else {
		return false
	}
}

//EXAMINE FUNCITON - for examining items on person
function findItemOnPerson(secondCommand, thirdCommand) {
	let allItemsInBackpack = pushItem.filter(items => items.roomId == backpack)
	let itemInRightHand = pushItem.filter(item => item.roomId == rightHand)
	let itemInLeftHand = pushItem.filter(item => item.roomId == leftHand)

	let allSpecifiedItemsInRoom = allItemsInBackpack.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	let itemObject = allItemsInRoom.find(({ keywords }) => keywords.some(x => x == secondCommand))
	if (thirdCommand != undefined && isNaN(thirdCommand) == false) {
		if (allSpecifiedItemsInRoom[thirdCommand - 1] != undefined) {
			if (allSpecifiedItemsInRoom[thirdCommand - 1].type.weapon) {
				findWeapon(allSpecifiedItemsInRoom[thirdCommand - 1])
			} else if (allSpecifiedItemsInRoom[thirdCommand - 1].type.armor) {
				findArmor(allSpecifiedItemsInRoom[thirdCommand - 1])
			}
		} else {
			quickMessage(`You do not own that number of ${itemObject.name}`)
		}
	} else if (itemObject != undefined) {
		if (allSpecifiedItemsInRoom[0].type.weapon) {
			findWeapon(allSpecifiedItemsInRoom[0])
		} else if (allSpecifiedItemsInRoom[0].type.armor) {
			findArmor(allSpecifiedItemsInRoom[0])
		}
	} else {
		return false
	}
}

function findAny(item) {
	let targetItem = item
	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack')
	allItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))
	console.log(targetItem, 'TARGET ITEM')
	console.log(allItemsInBackpack, 'ALL ITEMS IN BACKPACK')
	let itemSlot = () => {
		if (targetItem.roomId == 'backpack') {
			return `Backpack slot ${allItemsInBackpack.indexOf(targetItem) + 1}`
		} else if (item.roomId == 'right hand') {
			return 'right hand'
		} else if (item.roomId == 'left hand') {
			return 'left hand'
		} else {
			return item.roomId
		}
	}
	console.log(targetItem, ' TARGET ITEM')
	console.log(targetItem.type, ' ITEM TYPE')
	let isWeapon = item.type['weapon'] != undefined ? item : undefined
	let isArmor = item.type['armor'] != undefined ? item : undefined
	let isShield = item.type['shield'] != undefined ? item : undefined
	let isConsumable = item.type.weapon != undefined ? item : undefined
	let isQuest = item.type.quest != undefined ? item : undefined
	if (isWeapon != undefined) {
		item.desc(itemSlot(), item.botDamage, item.topDamage, item.name, item.mods)
	} else if (isArmor != undefined) {
		item.desc(itemSlot(), item.name, item.mods, item.id)
	} else if (isShield != undefined) {
		item.desc(itemSlot() + ' slot ' + itemSlot(), item.name, item.mods)
	} else if (isConsumable != undefined) {
		item.desc(/*consumable info*/)
	} else if (isQuest) {
		item.desc(/*quest info*/)
	} else {
		item.desc()
	}
}

function showItemDescription(item) {
	let itemValues = Object.values(item)
	let itemKeys = Object.keys(item)
	for (let i = 0; i < itemKeys.length; i++) {
		if (itemValues[i] != 0) {
			if (itemKeys[i] == 'armor') {
				let textDiv = document.createElement('div')
				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
				textDiv.appendChild(textNode)
				masterArea.appendChild(textDiv)
			} else {
				let textDiv = document.createElement('div')
				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
				textDiv.appendChild(textNode)
				masterArea.appendChild(textDiv)
			}
		}
	}
}
//INSPECT FUNCTION - for inspecting items only in your inventory or that you're wielding/wearing
function findItemInventory(secondCommand, thirdCommand) {
	let allInventory = pushItem.filter(allItems => isNaN(allItems.roomId))
	let allSpecifiedInventory = allInventory.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	let targetItem = allSpecifiedInventory.find(target => target.roomId == 'right hand' || target.roomId == 'left hand' || target.keywords.find(keyword => keyword == secondCommand))
	let targetItemRightHand = allSpecifiedInventory.find(target => target.roomId == 'right hand')
	let targetItemLeftHand = allSpecifiedInventory.find(target => target.roomId == 'left hand')
	let targetItemInBackpack = allInventory.find(target => target.keywords.find(keyword => keyword == secondCommand))
	if (thirdCommand != undefined && !isNaN(thirdCommand)) {
		if (allSpecifiedInventory[thirdCommand - 1] != undefined) {
			return allSpecifiedInventory[thirdCommand - 1].desc(allSpecifiedInventory[thirdCommand - 1].botDamage, allSpecifiedInventory[thirdCommand - 1].topDamage, allSpecifiedInventory[thirdCommand - 1].roomId)
		} else if (thirdCommand == undefined && isNaN(thirdCommand) == true) {
			quickMessage(`You do not own that number of ${targetItem.name}`)
		}
	} else if (targetItemRightHand != undefined) {
		console.log('inspect right hand')
		return targetItemRightHand.desc(targetItemRightHand.id, targetItemRightHand.botDamage, targetItemRightHand.topDamage, targetItemRightHand.roomId)
	} else if (targetItemLeftHand != undefined) {
		console.log('inspect left hand')
		return targetItemLeftHand.desc(targetItemLeftHand.botDamage, targetItemLeftHand.topDamage, targetItemLeftHand.roomId)
	} else if (targetItemInBackpack != undefined) {
		console.log('inspect in backpack')
		return targetItemInBackpack.desc(targetItemInBackpack.botDamage, targetItemInBackpack.topDamage, targetItemInBackpack.roomId)
	}
}

function examine(secondCommand, thirdCommand) {
	let allItemsInRoom = pushItem.filter(items => items.roomId == currentArea.id)
	let allSpecifiedItemsInRoom = allItemsInRoom.filter(items => items.keywords.find(keyword => keyword == secondCommand))
	let firstSpecifiedItem = allSpecifiedItemsInRoom[0] != undefined ? allSpecifiedItemsInRoom.find(item => item.keywords.find(keyword => keyword == secondCommand)) : undefined
	let specifiedByNumber = allSpecifiedItemsInRoom[1] != undefined ? allSpecifiedItemsInRoom.filter(item => item.keywords.filter(keyword => keyword == secondCommand))[thirdCommand - 1] : undefined
	let firstMonsterInRoom = pushMonster.find(enemy => currentArea.id == enemy.roomId)
	let specifiedEnemy = pushMonster.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	console.log(firstMonsterInRoom, ' FIRST MONSTER IN THE ROOM')
	let roomInteractable = currentArea.interactables && currentArea.interactables[secondCommand] != undefined ? currentArea.interactables[secondCommand] : undefined
	//inspects object from the room description
	if (specifiedEnemy) {
		specifiedEnemy.desc() 
		return
	}
	if (roomInteractable && roomInteractable.names.find(name => name == secondCommand) != undefined) {
		roomInteractable.desc()
	}
	//inspects NPC
	else if (currentArea.npc[0] != undefined && currentArea.npc.find(npc => npc.keywords.find(keyword => keyword == secondCommand))) {
		let npc = currentArea.npc.find(npc => npc.keywords.find(keyword => keyword == secondCommand))
		npc.desc()
	} else if (firstMonsterInRoom != undefined && firstMonsterInRoom.keywords.find(keyword => keyword == secondCommand)) {
		firstMonsterInRoom.desc()

		//inspects item on the ground
	} else if (secondCommand == undefined || /^\s*$/.test(secondCommand) == true) {
		quickMessage(`You must specify what you want to inspect.`)
	} else if (!isNaN(secondCommand) && allItemsInRoom[secondCommand - 1] == undefined) {
		quickMessage(`You do not see that number of item to inspect.`)
	} else if (!isNaN(secondCommand) && allItemsInRoom[secondCommand - 1] != undefined) {
		findAny(allItemsInRoom[secondCommand - 1])
	} else if (firstSpecifiedItem == undefined) {
		quickMessage(`You do not see a ${secondCommand} to inspect.`)
	} else if (allSpecifiedItemsInRoom == undefined) {
		quickMessage(`You do not see a ${secondCommand} to inspect`)
	} else if (!isNaN(thirdCommand) == true && allSpecifiedItemsInRoom[thirdCommand - 1] == undefined) {
		quickMessage(`You do not see that number of ${secondCommand} to inspect.`)
	} else if (firstSpecifiedItem != undefined && specifiedByNumber == undefined) {
		console.log('first')
		findAny(firstSpecifiedItem)
	} else if (specifiedByNumber != undefined && !isNaN(thirdCommand) == true) {
		console.log('second')
		findAny(specifiedByNumber)
	}
}

function colorText() {
	const span1 = document.createElement('span')
	const textNode = document.createTextNode('damage')
}

let preRace = {
	maxHealth: 0,
	maxMana: 0,
	healthMultiplier: 0,
	manaMultiplier: 0,
	str: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	mys: 0,
	con: 0,
	oneHanded: 0,
	twoHanded: 0,
	daggers: 0,
	unarmed: 0,
	bows: 0,
	shields: 0,
	lockpicking: 0,
	tactics: 0,
	vigilance: 0,
	initiation: 0,
	fleetFooted: 0,
	toughness: 0,
	dodging: 0,
	stealth: 0,
	ridingSkill: 0,
	rest: 0,
	perception: 0,
	athletics: 0,
	vigor: 0,
	devotion: 0,
	fireflames: 0,
	frostfreeze: 0,
	flashbolt: 0,
}

let preClass = {
	healthPerLevel: 0,
	maxHealth: 0,
	healthMultiplier: 0,
	maxMana: 0,
	manaMultiplier: 0,
	str: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	mys: 0,
	con: 0,
	oneHanded: 0,
	twoHanded: 0,
	daggers: 0,
	unarmed: 0,
	bows: 0,
	shields: 0,
	lockpicking: 0,
	tactics: 0,
	vigilance: 0,
	initiation: 0,
	fleetFooted: 0,
	toughness: 0,
	dodging: 0,
	stealth: 0,
	ridingSkill: 0,
	rest: 0,
	perception: 0,
	athletics: 0,
	vigor: 0,
	devotion: 0,
	fireflames: 0,
	frostfreeze: 0,
	flashbolt: 0,
}

let playerBaseStats = {
	maxHealth: 0,
	health: 0,
	maxMana: 0,
	mana: 0,

	healthMultiplier: 0,
	manaMultiplier: 0,

	raceHealthMultiplier: 0,
	manaMultiplier: 0,

	str: 0,
	con: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	advanceTimer: 0,
	retreatTimer: 0,
	twoHanded: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	oneHanded: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	unarmed: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	daggers: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	bows: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	dualWield: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
}

function removePreClassStats() {
	let preClassKeys = Object.keys(playerBaseStats)
	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			player[stat] = player[stat] - preClass[stat]
		}
	})

	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			player[stat].level = player[stat].level - preClass[stat].level
			player[stat].speed = player[stat].speed - preClass[stat].speed
		}
	})
}
function addPreClassStats() {
	let preClassKeys = Object.keys(playerBaseStats)
	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			console.log(player['maxHealth'], ' PLAYER MAX HEALTH')
			console.log(preClass['maxHealth'], ' PRECLASS MAX HEALTH')
			player[stat] = player[stat] + preClass[stat]
			console.log(player['maxHealth'], ' PLAYER MAX HEALTH')
			console.log(preClass['maxHealth'], ' PRECLASS MAX HEALTH')
		}
	})

	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			console.log(player[stat].speed, `PLAYER ${stat} STAT BEFORE`)
			player[stat].level = player[stat].level + preClass[stat].level
			player[stat].speed = player[stat].speed + preClass[stat].speed
			console.log(player[stat].speed, `PLAYER ${stat} STAT AFTER`)
		}
	})
}
function removePreRaceStats() {
	let preRaceKeys = Object.keys(playerBaseStats)
	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			player[stat] = player[stat] - preRace[stat]
		}
	})

	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			player[stat].level = player[stat].level - preRace[stat].level
			player[stat].speed = player[stat].speed - preRace[stat].speed
		}
	})
}
function addPreRaceStats() {
	let preRaceKeys = Object.keys(playerBaseStats)
	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			player[stat] = player[stat] + preRace[stat]
		}
	})

	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			player[stat].level = player[stat].level + preRace[stat].level
			player[stat].speed = player[stat].speed + preRace[stat].speed
		}
	})
}

function removeStartingClassSkills() {
	preClass.healthPerLevel = 0

	preClass.str = 0
	preClass.dex = 0
	preClass.agi = 0
	preClass.int = 0
	preClass.wis = 0
	preClass.mys = 0
	preClass.con = 0
	//weapon skills
	preClass.unarmed = 0
	preClass.oneHanded = 0
	preClass.twoHanded = 0
	preClass.daggers = 0
	preClass.bows = 0
	preClass.shields = 0
	//secondary skills
	preClass.stealth = 0
	preClass.dodge = 0
	//spells
	preClass.fireflames = 0
	preClass.frostfreeze = 0
	preClass.flashbolt = 0
}
function removeStartingRaceSkills() {
	preRace.str = 0
	preRace.dex = 0
	preRace.agi = 0
	preRace.int = 0
	preRace.wis = 0
	preRace.mys = 0
	preRace.con = 0
	//weapon skills
	preRace.unarmed = 0
	preRace.oneHanded = 0
	preRace.twoHanded = 0
	preRace.daggers = 0
	preRace.bows = 0
	preRace.shields = 0
	//secondary skills
	preRace.stealth = 0
	preRace.dodge = 0
	//spells
	preRace.fireflames = 0
	preRace.frostfreeze = 0
	preRace.flashbolt = 0
}

function combineClassAndRaceValues() {
	player.str = preClass.str + preRace.str
	player.dex = preClass.dex + preRace.dex
	player.agi = preClass.agi + preRace.agi
	player.int = preClass.int + preRace.int
	player.wis = preClass.wis + preRace.wis
	player.mys = preClass.mys + preRace.mys
	player.con = preClass.con + preRace.con

	player.manaMultiplier = preClass.manaMultiplier + preRace.manaMultiplier
	player.healthMultiplier = preClass.healthMultiplier + preRace.healthMultiplier

	player.oneHanded.level = preClass.oneHanded + preRace.oneHanded
	player.twoHanded.level = preClass.twoHanded + preRace.twoHanded
	player.daggers.level = preClass.daggers + preRace.daggers
	player.unarmed.level = preClass.unarmed + preRace.unarmed
	player.bows.level = preClass.bows + preRace.bows
	player.shields.level = preClass.shields + preRace.shields

	player.stealth.level = preClass.stealth + preRace.stealth
	player.lockpicking.level = preClass.lockpicking + preRace.lockpicking
	player.tactics.level = preClass.tactics + preRace.tactics
	player.vigilance.level = preClass.vigilance + preRace.vigilance
	player.initiation.level = preClass.initiation + preRace.initiation
	player.fleetFooted.level = preClass.fleetFooted + preRace.fleetFooted
	player.toughness.level = preClass.toughness + preRace.toughness
	player.dodging.level = preClass.dodging + preRace.dodging
	player.ridingSkill.level = preClass.ridingSkill + preRace.ridingSkill
	player.rest.level = preClass.rest + preRace.rest + 1
	player.perception.level = preClass.perception + preRace.perception
	player.athletics.level = preClass.athletics + preRace.athletics
	player.vigor.level = preClass.vigor + preRace.vigor
	player.devotion.level = preClass.devotion + preRace.devotion

	player.fireflames.level = preClass.fireflames + preRace.fireflames
	player.frostfreeze.level = preClass.frostfreeze + preRace.frostfreeze
	player.flashbolt.level = preClass.flashbolt + preRace.flashbolt
}


let berserkerClass = {
	name: 'Berserker',
	color: 'warrior-color',
}
let fighterClass = {
	name: 'Fighter',
	color: 'warrior-color',
}
let knightClass = {
	name: 'Knight',
	color: 'warrior-color',
}
let assassinClass = {
	name: 'Assassin',
	color: 'sinistral-color',
}
let thiefClass = {
	name: 'Thief',
	color: 'sinistral-color',
}
let shadowbladeClass = {
	name: 'Shadowblade',
	color: 'sinistral-color',
}
let martialMonkClass = {
	name: 'Martial Monk',
	color: 'monk-color',
}
let mysticMonkClass = {
	name: 'Mystic Monk',
	color: 'monk-color',
}
let elementalMonkClass = {
	name: 'Elemental Monk',
	color: 'monk-color',
}
let rangerClass = {
	name: 'Ranger',
	color: 'ranger-color',
}
let pyromancerClass = {
	name: 'Pyromancer',
	color: 'pyromancer-color',
}
let cryoMageClass = {
	name: 'Cryo Mage',
	color: 'cryo-mage-color',
}
let lightningMagusClass = {
	name: 'Lightning Magus',
	color: 'lightning-magus-color',
}
//relegated variables. Remove these when possible
let monkClass = {
	name: 'Monk',
	color: 'monk-color',
}
let warriorClass = {
	name: 'Warrior',
	color: 'warrior-color',
}

function startBerserker(event) {
	if (player.playerClass.name != 'Berserker') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Berserker'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('warrior-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('warrior-resource-bar')

		player.playerClass = berserkerClass
		player.guild = 'Warrior'
		preClass.healthMultiplier = 3.0
		preClass.manaMultiplier = 1.0
		player.might = 5
		player.maxMight = 5

		preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 10

		preClass.str = 2
		preClass.con = 2
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyBerserkerClassDescription()
		preClass.twoHanded = 1

		player.advanceTimer = 2
		player.retreatTimer = 4

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...velthash}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('twohanded')
	}
}
function startFighter(event) {
	if (player.playerClass.name != 'Fighter') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Fighter'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('warrior-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('warrior-resource-bar')

		player.playerClass = fighterClass
		player.guild = 'Warrior'
		preClass.healthMultiplier = 3.0
		preClass.manaMultiplier = 1.0
		player.might = 5
		player.maxMight = 5

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 2
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 1
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyFighterClassDescription()

		preClass.oneHanded = 1

		player.advanceTimer = 2
		player.retreatTimer = 4

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...velthash}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('shortsword')
		unpack('shortsword')
	}
}
function startKnight(event) {
	if (player.playerClass.name != 'Knight') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Knight'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('warrior-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('warrior-resource-bar')

		applyKnightClassDescription()
		player.playerClass = knightClass
		player.guild = 'Warrior'
		preClass.healthMultiplier = 3.0
		preClass.manaMultiplier = 1.0
		player.might = 5
		player.maxMight = 5

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 2
		preClass.con = 2
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyKnightClassDescription()

		preClass.oneHanded = 1
		preClass.shields = 1

		player.advanceTimer = 2
		player.retreatTimer = 4

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...velthash}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('sword')
		unpack('shield')
	}
}

function startThief(event) {
	if (player.playerClass.name != 'Thief') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Thief'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('sinistral-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('sinistral-resource-bar')

		player.playerClass = thiefClass
		player.guild = 'Sinistral'
		preClass.healthMultiplier = 1.5
		preClass.manaMultiplier = 1.0

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyThiefClassDescription()

		preClass.daggers = 1
		preClass.dodging = 1
		preClass.stealth = 1

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...zel}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('dagger')
		unpack('dagger')
	}
}
function startAssassin(event) {
	if (player.playerClass.name != 'Assassin') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Assassin'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('sinistral-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('sinistral-resource-bar')

		player.playerClass = assassinClass
		player.guild = 'Sinistral'
		preClass.healthMultiplier = 1.5
		preClass.manaMultiplier = 1.0

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyAssassinClassDescription()

		preClass.daggers = 1
		preClass.dodging = 1
		preClass.stealth = 1
		preClass.dodge = 100

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...zel}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('dagger')
		unpack('dagger')
	}
}
function startShadowblade(event) {
	if (player.playerClass.name != 'Shadowblade') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Shadowblade'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('sinistral-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('sinistral-resource-bar')

		player.playerClass = shadowbladeClass
		player.guild = 'Sinistral'
		preClass.healthMultiplier = 1.5
		preClass.manaMultiplier = 1.0

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyShadowbladeClassDescription()

		preClass.daggers = 1
		preClass.dodging = 1
		preClass.stealth = 1

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...zel}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
		// unpack('dagger')
		// unpack('dagger')
	}
}

function startMartialMonk(event) {
	if (player.playerClass.name != 'Martial Monk') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Martial Monk'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('monk-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('monk-resource-bar')

		player.playerClass = martialMonkClass
		player.guild = 'Monk'
		preClass.healthMultiplier = 2.5
		preClass.manaMultiplier = 1.0

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyMartialMonkClassDescription()

		preClass.unarmed = 1
		preClass.dodging = 1
		preClass.toughness = 1

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...sitoria}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
	}
}
function startMysticMonk(event) {
	if (player.playerClass.name != 'Mystic Monk') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Mystic Monk'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('monk-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('monk-resource-bar')

		player.playerClass = mysticMonkClass
		player.guild = 'Monk'
		preClass.healthMultiplier = 2.5
		preClass.manaMultiplier = 1.0

		preClass.maxHealth = 5
		preClass.maxMana = 5

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyMysticMonkClassDescription()

		preClass.unarmed = 1
		preClass.dodging = 1
		preClass.toughness = 1

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...sitoria}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
	}
}
function startElementalMonk(event) {
	if (player.playerClass.name != 'Elemental Monk') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Elemental Monk'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('monk-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('monk-resource-bar')

		player.playerClass = elementalMonkClass
		player.guild = 'Monk'
		preClass.healthMultiplier = 2.5
		preClass.manaMultiplier = 1.0

		preClass.maxHealth = 8
		preClass.maxMana = 20

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyElementalMonkClassDescription()

		preClass.unarmed = 1
		preClass.dodging = 1
		preClass.toughness = 1

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...sitoria}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
	}
}

function startPyromancer(event) {
	if (player.playerClass.name != 'Pyromancer') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Pyromancer'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('pyromancer-resource-bar')
		resourceText.textContent = ''
		resourceBar.classList.add('pyromancer-resource-bar')
		player.playerClass = pyromancerClass
		player.guild = 'Mage'
		preClass.healthMultiplier = 1.0
		preClass.manaMultiplier = 2.0
		preClass.maxHealth = 6
		preClass.maxMana = 10

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 2
		preClass.wis = 2
		preClass.mys = 1
		applyPyromancerClassDescription()

		player.advanceTimer = 2
		player.retreatTimer = 2

		preClass.fireflames = 1
		console.log(player.fireflames)
		combineClassAndRaceValues()
		console.log(player.fireflames)

		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...olivandra}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
	}
}
function startCryoMage(event) {
	if (player.playerClass.name != 'Cryo Mage') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Cryo Mage'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('cryo-mage-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('cryo-mage-resource-bar')
		player.playerClass = cryoMageClass
		player.guild = 'Mage'
		preClass.healthMultiplier = 1.0
		preClass.manaMultiplier = 2.0
		preClass.maxHealth = 6
		preClass.maxMana = 10

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 2
		preClass.wis = 2
		preClass.mys = 1
		applyCryoMageClassDescription()

		player.advanceTimer = 2
		player.retreatTimer = 2

		preClass.frostfreeze = 1

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...olivandra}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
	}
}
function startLightningMagus(event) {
	if (player.playerClass.name != 'Lightning Magus') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Lightning Magus'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('lightning-magus-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('lightning-magus-resource-bar')
		player.playerClass = lightningMagusClass
		player.guild = 'Mage'
		preClass.healthMultiplier = 1.0
		preClass.manaMultiplier = 2.0
		preClass.maxHealth = 6
		preClass.maxMana = 10

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 2
		preClass.wis = 2
		preClass.mys = 1
		applyLightningMagusClassDescription()

		player.advanceTimer = 2
		player.retreatTimer = 2

		preClass.flashbolt = 1

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...olivandra}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
	}
}

function startRanger(event) {
	if (player.playerClass.name != 'Ranger') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Ranger'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('ranger-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('ranger-resource-bar')

		player.playerClass = rangerClass
		player.guild = 'Ranger'
		preClass.healthMultiplier = 2.0
		preClass.manaMultiplier = 2.0

		preClass.maxHealth = 4
		preClass.maxMana = 10

		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		applyRangerClassDescription()

		preClass.bows = 1

		player.advanceTimer = 2
		player.retreatTimer = 2

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()

		fieldsTrainer = {...tilwin}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
		unpack('bow')
	}
}

// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES

function startHuman(event) {
	if (player.race != 'Human') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Human'
		player.race = 'Human'
		preRace.healthMultiplier = 10.0
		preRace.manaMultiplier = 0
		preRace.maxHealth = 10
		preRace.maxMana = 10

		preRace.str = 1
		preRace.dex = 1
		preRace.agi = 1
		preRace.int = 1
		applyHumanRaceDescription()


		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startDwarf(event) {
	if (player.race != 'Dwarf') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Dwarf'
		player.race = 'Dwarf'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 0
		preRace.maxHealth = 10
		preRace.maxMana = 5

		preRace.str = 1
		preRace.con = 2
		preRace.wis = 2
		
		applyDwarfRaceDescription()

		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startElf(event) {
	if (player.race != 'Elf') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Elf'
		player.race = 'Elf'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 0.5
		preRace.maxHealth = 5
		preRace.maxMana = 20

		preRace.int = 2
		preRace.wis = 1
		preRace.mys = 1

		applyElfRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startHalfElf(event) {
	if (player.race != 'Half-Elf') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Half-Elf'
		player.race = 'Half-Elf'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 1.0
		preRace.maxHealth = 5
		preRace.maxMana = 10

		preRace.dex = 1
		preRace.agi = 1
		preRace.mys = 1

		applyHalfElfRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}

function startHalfMinotaur() {
	if (player.race != 'Half-Minotaur') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Half-Minotaur'
		player.race = 'Half-Minotaur'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 1.0
		preRace.maxHealth = 5
		preRace.maxMana = 1

		preRace.str = 2
		preRace.con = 1

		applyHalfMinotaurRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startTiefling() {
	if (player.race != 'Tiefling') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Human'
		player.race = 'Tiefling'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 2.0

		preRace.agi = 1
		preRace.int = 1
		preRace.wis = 1

		preRace.maxHealth = 5
		preRace.maxMana = 15

		applyTieflingRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startCatline() {
	if (player.race != 'Catline') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Catline'
		player.race = 'Catline'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 2.0

		preRace.dex = 1
		preRace.agi = 1
		preRace.mys = 1

		preRace.maxHealth = 5
		preRace.maxMana = 5

		applyCatlineRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startGnome() {
	if (player.race != 'Gnome') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Gnome'
		player.race = 'Gnome'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 2.0

		preRace.int = 1
		preRace.wis = 2
		preRace.mys = 1

		preRace.maxHealth = 5
		preRace.maxMana = 10

		applyGnomeRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startHalfling() {
	if (player.race != 'Halfling') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Halfling'
		player.race = 'Halfling'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 2.0

		preRace.dex = 2
		preRace.agi = 1

		preRace.maxHealth = 5
		preRace.maxMana = 5

		applyHalflingRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startFaerie() {
	if (player.race != 'Faerie') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Faerie'
		player.race = 'Faerie'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 2.0

		preRace.agi = 1
		preRace.int = 1
		preRace.wis = 1
		preRace.mys = 1

		preRace.maxHealth = 5
		preRace.maxMana = 5

		applyFaerieRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startDragonKin() {
	if (player.race != 'Dragonkin') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Dragonkin'
		player.race = 'Dragonkin'
		preRace.healthMultiplier = 1.0
		preRace.manaMultiplier = 2.0

		preRace.str = 1
		preRace.dex = 1
		preRace.int = 1
		preRace.mys = 1

		preRace.maxHealth = 5
		preRace.maxMana = 5

		applyDragonKinRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}

function removePlayerClassClass() {
	// document.getElementById('warrior-button').classList.remove('class-race-select')
	// document.getElementById('rogue-button').classList.remove('class-race-select')
	// document.getElementById('monk-button').classList.remove('class-race-select')
	// classNode.classList.remove('class-race-select')
	// classNode2.classList.remove('class-race-select')
	// classNode3.classList.remove('class-race-select')
}

function removeRaceClass() {
	document.getElementById('human-button').classList.remove('class-race-select')
	document.getElementById('elf-button').classList.remove('class-race-select')
	document.getElementById('half-elf-button').classList.remove('class-race-select')
}

// const strButtonIncrease = document.getElementById('strIncrease')
// const conButtonIncrease = document.getElementById('conIncrease')
// const dexButtonIncrease = document.getElementById('dexIncrease')
// const agiButtonIncrease = document.getElementById('agiIncrease')
// const intButtonIncrease = document.getElementById('intIncrease')
// const wisButtonIncrease = document.getElementById('wisIncrease')

// strButtonIncrease.addEventListener('click', statButtonStrIncrease)
// conButtonIncrease.addEventListener('click', statButtonConIncrease)
// dexButtonIncrease.addEventListener('click', statButtonDexIncrease)
// agiButtonIncrease.addEventListener('click', statButtonAgiIncrease)
// intButtonIncrease.addEventListener('click', statButtonIntIncrease)
// wisButtonIncrease.addEventListener('click', statButtonWisIncrease)

// const strButtonDecrease = document.getElementById('strDecrease')
// const conButtonDecrease = document.getElementById('conDecrease')
// const dexButtonDecrease = document.getElementById('dexDecrease')
// const agiButtonDecrease = document.getElementById('agiDecrease')
// const intButtonDecrease = document.getElementById('intDecrease')
// const wisButtonDecrease = document.getElementById('wisDecrease')

// strButtonDecrease.addEventListener('click', statButtonStrDecrease)
// conButtonDecrease.addEventListener('click', statButtonConDecrease)
// dexButtonDecrease.addEventListener('click', statButtonDexDecrease)
// agiButtonDecrease.addEventListener('click', statButtonAgiDecrease)
// intButtonDecrease.addEventListener('click', statButtonIntDecrease)
// wisButtonDecrease.addEventListener('click', statButtonWisDecrease)

function statButtonIncrease(stat) {
	alert('works')
	player[stat]++
	updatePlayerStats
}

function statButtonStrIncrease() {
	if (player.attributePoints > 0) {
		player.str++
		player.attributePoints--
		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonConIncrease() {
	if (player.attributePoints > 0) {
		player.con++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonDexIncrease() {
	if (player.attributePoints > 0) {
		player.dex++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonAgiIncrease() {
	if (player.attributePoints > 0) {
		player.agi++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonIntIncrease() {
	if (player.attributePoints > 0) {
		player.int++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonWisIncrease() {
	if (player.attributePoints > 0) {
		player.wis++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}

function statButtonStrDecrease() {
	player.str--
	player.attributePoints++
	updatePlayerStats()
}
function statButtonConDecrease() {
	player.con--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonDexDecrease() {
	player.dex--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonAgiDecrease() {
	player.agi--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonIntDecrease() {
	player.int--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonWisDecrease() {
	player.wis--
	player.attributePoints++

	updatePlayerStats()
}

function addWeapons() {}
addWeapons()

currentArea = galvadiaWelcomeArea17_combatRoom1
player.x = currentArea.x
player.y = currentArea.y
player.z = currentArea.z
previousArea = currentArea

function displayClassSelection() {
	const classAndRaceContainer = document.createElement('div')
	classAndRaceContainer.setAttribute('id', 'class-and-race-container')
	classAndRaceContainer.classList.add('class-and-race-container')

	let characterCreationWindow = document.createElement('div')
	let characterCreationNode = document.createTextNode('Character creation')
	characterCreationWindow.classList.add('character-creation')
	characterCreationWindow.appendChild(characterCreationNode)

	classAndRaceContainer.appendChild(characterCreationWindow)

	const confirmationMainDiv = document.createElement('div')
	const confirmationMainNode = document.createTextNode(
		'Select your class and race by clicking on the portrait. Your class will dictate which guild you join, and each class has their own unique sets of combat abilities. Your race is supplemental to your class, providing you with minor starting skills and small stat boosts.'
	)
	confirmationMainDiv.classList.add('character-confirmation')
	confirmationMainDiv.appendChild(confirmationMainNode)
	classAndRaceContainer.appendChild(confirmationMainDiv)

	const classMainContainer = document.createElement('div')
	const classHeadingContainer = document.createElement('div')
	const classHeadingNode = document.createTextNode(`Choose your class`)
	classMainContainer.classList.add('main-class-container')
	classHeadingContainer.classList.add('start-heading-container')

	const classDescriptionAndDetailsContainer = document.createElement('div')
	const classDescriptionContainer = document.createElement('div')
	const classDetailsContainer = document.createElement('div')

	classDescriptionAndDetailsContainer.classList.add('class-description-and-details-container')
	classDescriptionContainer.classList.add('start-description')
	classDetailsContainer.classList.add('start-details')
	classDescriptionAndDetailsContainer.appendChild(classDescriptionContainer)
	classDescriptionAndDetailsContainer.appendChild(classDetailsContainer)
	/////////////////////////////////////////////////////////////////////
	//WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR
	//BERSERKER BERSERKER BERSERKER BERSERKER BERSERKER BERSERKER BERSERKER 
	const berserkerSelectDiv = document.createElement('div')
	const berserkerHeadingDiv = document.createElement('div')
	berserkerHeadingDiv.textContent = 'Berserker'
	berserkerSelectDiv.classList.add('class-option', 'berserker', 'warrior')

	berserkerSelectDiv.addEventListener('click', startBerserker)
	berserkerSelectDiv.appendChild(berserkerHeadingDiv)
	classDescriptionContainer.appendChild(berserkerSelectDiv)
	//
	//BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN
	const fighterSelectDiv = document.createElement('div')
	const fighterHeadingDiv = document.createElement('div')
	fighterHeadingDiv.textContent = 'Fighter'
	fighterSelectDiv.classList.add('class-option', 'fighter', 'warrior')

	fighterSelectDiv.addEventListener('click', startFighter)
	fighterSelectDiv.appendChild(fighterHeadingDiv)
	classDescriptionContainer.appendChild(fighterSelectDiv)
	//
	//KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT
	const knightSelectDiv = document.createElement('div')
	const knightHeadingDiv = document.createElement('div')
	knightHeadingDiv.textContent = 'Knight'
	knightSelectDiv.classList.add('class-option', 'knight', 'warrior')

	knightSelectDiv.addEventListener('click', startKnight)
	knightSelectDiv.appendChild(knightHeadingDiv)
	classDescriptionContainer.appendChild(knightSelectDiv)
	//
	//ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN
	const assassinSelectDiv = document.createElement('div')
	const assassinHeadingDiv = document.createElement('div')
	assassinHeadingDiv.textContent = 'Assassin'
	assassinSelectDiv.classList.add('class-option', 'assassin', 'sinistral-icon')
	
	assassinSelectDiv.addEventListener('click', startAssassin)
	assassinSelectDiv.appendChild(assassinHeadingDiv)
	classDescriptionContainer.appendChild(assassinSelectDiv)
	
	//
	//THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF 
	const thiefSelectDiv = document.createElement('div')
	const thiefHeadingDiv = document.createElement('div')
	thiefHeadingDiv.textContent = 'Thief'
	thiefSelectDiv.classList.add('class-option', 'thief', 'sinistral-icon')

	thiefSelectDiv.addEventListener('click', startThief)
	thiefSelectDiv.appendChild(thiefHeadingDiv)
	classDescriptionContainer.appendChild(thiefSelectDiv)
	//
	//SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE 
	const shadowbladeSelectDiv = document.createElement('div')
	const shadowbladeHeadingDiv = document.createElement('div')
	shadowbladeHeadingDiv.textContent = 'Shadowblade'
	shadowbladeSelectDiv.classList.add('class-option', 'shadowblade', 'sinistral-icon')

	shadowbladeSelectDiv.addEventListener('click', startShadowblade)
	shadowbladeSelectDiv.appendChild(shadowbladeHeadingDiv)
	classDescriptionContainer.appendChild(shadowbladeSelectDiv)
	//

	//MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK 
	const martialMonkSelectDiv = document.createElement('div')
	const martialMonkHeadingDiv = document.createElement('div')
	martialMonkHeadingDiv.textContent = 'Martial Monk'
	martialMonkSelectDiv.classList.add('class-option', 'martialMonk', 'monk')

	martialMonkSelectDiv.addEventListener('click', startMartialMonk)
	martialMonkSelectDiv.appendChild(martialMonkHeadingDiv)
	classDescriptionContainer.appendChild(martialMonkSelectDiv)
	//
	//MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK
	const mysticMonkSelectDiv = document.createElement('div')
	const mysticMonkHeadingDiv = document.createElement('div')
	mysticMonkHeadingDiv.textContent = 'Mystic Monk'
	mysticMonkSelectDiv.classList.add('class-option', 'mysticMonk', 'monk')

	mysticMonkSelectDiv.addEventListener('click', startMysticMonk)
	mysticMonkSelectDiv.appendChild(mysticMonkHeadingDiv)
	classDescriptionContainer.appendChild(mysticMonkSelectDiv)
	//
	//ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK 
	const elementalMonkSelectDiv = document.createElement('div')
	const elementalMonkHeadingDiv = document.createElement('div')
	elementalMonkHeadingDiv.textContent = 'Elemental Monk'
	elementalMonkSelectDiv.classList.add('class-option', 'elementalMonk', 'monk')

	elementalMonkSelectDiv.addEventListener('click', startElementalMonk)
	elementalMonkSelectDiv.appendChild(elementalMonkHeadingDiv)
	classDescriptionContainer.appendChild(elementalMonkSelectDiv)
	//
	//SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER
	const mageSelectDiv = document.createElement('div')
	const mageHeadingDiv = document.createElement('div')
	mageHeadingDiv.textContent = 'Pyromancer'
	mageSelectDiv.classList.add('class-option', 'pyromancer')
	mageSelectDiv.addEventListener('click', startPyromancer)
	mageSelectDiv.appendChild(mageHeadingDiv)
	classDescriptionContainer.appendChild(mageSelectDiv)

	const iceMageSelectDiv = document.createElement('div')
	const iceMageHeadingDiv = document.createElement('div')
	iceMageHeadingDiv.textContent = 'Cryo Mage'
	iceMageSelectDiv.classList.add('class-option', 'cryoMage')
	iceMageSelectDiv.addEventListener('click', startCryoMage)
	iceMageSelectDiv.appendChild(iceMageHeadingDiv)
	classDescriptionContainer.appendChild(iceMageSelectDiv)

	const lightningMageSelectDiv = document.createElement('div')
	const lightningMageHeadingDiv = document.createElement('div')
	lightningMageHeadingDiv.textContent = 'Lightning Magus'
	lightningMageSelectDiv.classList.add('class-option', 'lightningMagus')
	lightningMageSelectDiv.addEventListener('click', startLightningMagus)
	lightningMageSelectDiv.appendChild(lightningMageHeadingDiv)
	classDescriptionContainer.appendChild(lightningMageSelectDiv)
	//SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER
	//RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER
	const rangerSelectDiv = document.createElement('div')
	const rangerHeadingDiv = document.createElement('div')
	rangerHeadingDiv.textContent = 'Ranger'
	// const rangerP1 = document.createElement('p')
	// const rangerP2 = document.createElement('p')
	// const rangerP3 = document.createElement('p')
	// rangerP1.textContent = '.'
	// rangerP2.textContent = '.'
	// rangerP3.textContent = '.'
	rangerSelectDiv.classList.add('class-option', 'ranger')

	rangerSelectDiv.addEventListener('click', startRanger)
	rangerSelectDiv.appendChild(rangerHeadingDiv)
	// rangerSelectDiv.appendChild(rangerP1)
	// rangerSelectDiv.appendChild(rangerP2)
	// rangerSelectDiv.appendChild(rangerP3)
	classDescriptionContainer.appendChild(rangerSelectDiv)
	// classAndDescriptionsContainer.appendChild(classDescriptionContainer)
	//
	classHeadingContainer.appendChild(classHeadingNode)

	classMainContainer.appendChild(classHeadingContainer)
	classMainContainer.appendChild(classDescriptionAndDetailsContainer)

	classAndRaceContainer.appendChild(classMainContainer)
	masterArea.appendChild(classAndRaceContainer)
	// Add event listeners to class options
	let classOptions = document.querySelectorAll('.class-option')
	classOptions.forEach(option => {
		option.addEventListener('click', selectClass)
	})
	// Function to handle class selection
	function selectClass() {
		// Deselect all options
		classOptions.forEach(option => {
			option.classList.remove('selected')
		})
		// Select the clicked option
		this.classList.add('selected')
	}
}

function displayRaceSelection() {
	const raceMainContainer = document.createElement('div')
	const raceHeadingContainer = document.createElement('div')
	const raceHeadingNode = document.createTextNode(`Choose your race`)

	raceMainContainer.classList.add('main-race-container')
	raceHeadingContainer.classList.add('start-heading-container')

	const raceDescriptionAndDetailsContainer = document.createElement('div')
	raceDescriptionAndDetailsContainer.classList.add('race-description-and-details-container')
	const raceContainer = document.createElement('div')
	const raceDetailsContainer = document.createElement('div')
	raceDescriptionAndDetailsContainer.appendChild(raceContainer)
	raceDescriptionAndDetailsContainer.appendChild(raceDetailsContainer)
	raceContainer.classList.add('race-description')
	raceDetailsContainer.classList.add('race-details')

	//HUMAN
	const humanSelectDiv = document.createElement('div')
	const humanHeadingDiv = document.createElement('div')
	humanHeadingDiv.textContent = 'Human'
	humanSelectDiv.classList.add('race-option', 'human')

	humanSelectDiv.addEventListener('click', startHuman)
	humanSelectDiv.appendChild(humanHeadingDiv)
	raceContainer.appendChild(humanSelectDiv)
	//DWARF
	const dwarfSelectDiv = document.createElement('div')
	const dwarfHeadingDiv = document.createElement('div')
	dwarfHeadingDiv.textContent = 'Dwarf'
	dwarfSelectDiv.classList.add('race-option', 'dwarf')

	dwarfSelectDiv.addEventListener('click', startDwarf)
	dwarfSelectDiv.appendChild(dwarfHeadingDiv)
	raceContainer.appendChild(dwarfSelectDiv)
	//ELF
	const elfSelectDiv = document.createElement('div')
	const elfHeadingDiv = document.createElement('div')
	elfHeadingDiv.textContent = 'Elf'
	const elfP1 = document.createElement('p')
	const elfP2 = document.createElement('p')
	const elfP3 = document.createElement('p')
	elfSelectDiv.classList.add('race-option', 'elf')
	
	elfSelectDiv.addEventListener('click', startElf)
	elfSelectDiv.appendChild(elfHeadingDiv)
	elfSelectDiv.appendChild(elfP1)
	elfSelectDiv.appendChild(elfP2)
	elfSelectDiv.appendChild(elfP3)
	raceContainer.appendChild(elfSelectDiv)
	//HALF-ELF
	const halfElfSelectDiv = document.createElement('div')
	const halfElfHeadingDiv = document.createElement('div')
	halfElfHeadingDiv.textContent = 'Half-Elf'
	halfElfSelectDiv.classList.add('race-option', 'halfElf')

	halfElfSelectDiv.addEventListener('click', startHalfElf)
	halfElfSelectDiv.appendChild(halfElfHeadingDiv)
	raceContainer.appendChild(halfElfSelectDiv)
	//HALF-MINOTAUR
	const halfMinotaurSelectDiv = document.createElement('div')
	const halfMinotaurHeadingDiv = document.createElement('div')
	halfMinotaurHeadingDiv.textContent = 'Half-Minotaur'
	halfMinotaurSelectDiv.classList.add('race-option', 'halfMinotaur')

	halfMinotaurSelectDiv.addEventListener('click', startHalfMinotaur)
	halfMinotaurSelectDiv.appendChild(halfMinotaurHeadingDiv)
	raceContainer.appendChild(halfMinotaurSelectDiv)
	//CENTAUR
	const tieflingSelectDiv = document.createElement('div')
	const tieflingHeadingDiv = document.createElement('div')
	tieflingHeadingDiv.textContent = 'Tiefling'
	tieflingSelectDiv.classList.add('race-option', 'tiefling')

	tieflingSelectDiv.addEventListener('click', startTiefling)
	tieflingSelectDiv.appendChild(tieflingHeadingDiv)
	raceContainer.appendChild(tieflingSelectDiv)
	//CATLINE
	const catlineSelectDiv = document.createElement('div')
	const catlineHeadingDiv = document.createElement('div')
	catlineHeadingDiv.textContent = 'Catline'
	catlineSelectDiv.classList.add('race-option', 'catline')

	catlineSelectDiv.addEventListener('click', startCatline)
	catlineSelectDiv.appendChild(catlineHeadingDiv)
	raceContainer.appendChild(catlineSelectDiv)
	//GNOME
	const gnomeSelectDiv = document.createElement('div')
	const gnomeHeadingDiv = document.createElement('div')
	gnomeHeadingDiv.textContent = 'Gnome'
	gnomeSelectDiv.classList.add('race-option', 'gnome')

	gnomeSelectDiv.addEventListener('click', startGnome)
	gnomeSelectDiv.appendChild(gnomeHeadingDiv)
	raceContainer.appendChild(gnomeSelectDiv)
	//HALFLING
	const halflingSelectDiv = document.createElement('div')
	const halflingHeadingDiv = document.createElement('div')
	halflingHeadingDiv.textContent = 'Halfling'
	halflingSelectDiv.classList.add('race-option', 'halfling')

	halflingSelectDiv.addEventListener('click', startHalfling)
	halflingSelectDiv.appendChild(halflingHeadingDiv)
	raceContainer.appendChild(halflingSelectDiv)
	//FAERIE
	const faerieSelectDiv = document.createElement('div')
	const faerieHeadingDiv = document.createElement('div')
	faerieHeadingDiv.textContent = 'Faerie'
	faerieSelectDiv.classList.add('race-option', 'faerie')

	faerieSelectDiv.addEventListener('click', startFaerie)
	faerieSelectDiv.appendChild(faerieHeadingDiv)
	raceContainer.appendChild(faerieSelectDiv)
	//DRAGONKIN
	const dragonKinSelectDiv = document.createElement('div')
	const dragonKinHeadingDiv = document.createElement('div')
	dragonKinHeadingDiv.textContent = 'DragonKin'
	dragonKinSelectDiv.classList.add('race-option', 'dragonKin')

	dragonKinSelectDiv.addEventListener('click', startDragonKin)
	dragonKinSelectDiv.appendChild(dragonKinHeadingDiv)
	raceContainer.appendChild(dragonKinSelectDiv)
	raceMainContainer.appendChild(raceDescriptionAndDetailsContainer)
	//Placeholder 1
	const placeholderSelectDiv = document.createElement('div')
	const placeholderHeadingDiv = document.createElement('div')
	placeholderHeadingDiv.textContent = ''
	placeholderSelectDiv.classList.add('race-option')

	// placeholderSelectDiv.addEventListener('click', startDragonKin)
	placeholderSelectDiv.appendChild(placeholderHeadingDiv)
	raceContainer.appendChild(placeholderSelectDiv)
	raceMainContainer.appendChild(raceDescriptionAndDetailsContainer)
	//Placeholder 2
	const placeholder2SelectDiv = document.createElement('div')
	const placeholder2HeadingDiv = document.createElement('div')
	placeholder2HeadingDiv.textContent = ''
	placeholder2SelectDiv.classList.add('race-option')

	// placeholder2SelectDiv.addEventListener('click', startDragonKin)
	placeholder2SelectDiv.appendChild(placeholder2HeadingDiv)
	raceContainer.appendChild(placeholder2SelectDiv)
	raceMainContainer.appendChild(raceDescriptionAndDetailsContainer)


	document.getElementById('class-and-race-container').appendChild(raceMainContainer)
	let classOptions = document.querySelectorAll('.race-option')
	classOptions.forEach(option => {
		option.addEventListener('click', selectClass)
	})
	// Function to handle class selection
	function selectClass() {
		// Deselect all options
		classOptions.forEach(option => {
			option.classList.remove('selected')
		})
		// Select the clicked option
		this.classList.add('selected')
	}
}

function displayClassDetails() {
	const warriorsGuildDescription = ``
	const descriptionText = ``
	const startDetailsContainer = document.querySelector('.start-details')

	const classDescriptionContainer = createDivElement('', ['classDescriptionContainer'])
	const classHeading = createDivElement(``, ['classHeading'])
	const classDescription = createDivElement(descriptionText, ['classDescription'])
	classDescriptionContainer.appendChild(classHeading)
	classDescriptionContainer.appendChild(classDescription)

	const startingStuffContainer = createDivElement(``, ['startingStuffContainer'])
	const startingStatsContainer = createDivElement(``, ['startingStatsContainer'])
	const statsHeading = createDivElement(``, ['statsHeading'])
	const statsDetails1 = createDivElement(``, ['statsDetails1'])
	const statsDetails2 = createDivElement(``, ['statsDetails2'])
	const statsDetails3 = createDivElement(``, ['statsDetails3'])
	const statsDetails4 = createDivElement(``, ['statsDetails4'])
	const statsDetails5 = createDivElement(``, ['statsDetails5'])
	const statsDetails6 = createDivElement(``, ['statsDetails6'])
	const statsDetails7 = createDivElement(``, ['statsDetails7'])
	const startingSkillsContainer = createDivElement(``, ['startingSkillsContainer'])
	const startingSkillsHeading = createDivElement(``, ['startingSkillsHeading'])
	const startingSkillsDetails1 = createDivElement(``, ['startingSkillsDetails1'])
	const startingSkillsDetails2 = createDivElement(``, ['startingSkillsDetails2'])
	const startingSkillsDetails3 = createDivElement(``, ['startingSkillsDetails3'])
	const startingSkillsDetails4 = createDivElement(``, ['startingSkillsDetails4'])
	const startingSkillsDetails5 = createDivElement(``, ['startingSkillsDetails5'])
	const startingSkillsDetails6 = createDivElement(``, ['startingSkillsDetails6'])
	const abilitiesContainer = createDivElement(``, ['abilitiesContainer'])
	const abilitiesHeading = createDivElement(``, ['abilitiesHeading'])
	const abilitiesDetails1 = createDivElement(``, ['abilitiesDetails1'])
	const abilitiesDetails2 = createDivElement(``, ['abilitiesDetails2'])
	const abilitiesDetails3 = createDivElement(``, ['abilitiesDetails3'])
	const abilitiesDetails4 = createDivElement(``, ['abilitiesDetails4'])
	const abilitiesDetails5 = createDivElement(``, ['abilitiesDetails5'])
	const abilitiesDetails6 = createDivElement(``, ['abilitiesDetails6'])
	startingStuffContainer.appendChild(startingStatsContainer)
	startingStuffContainer.appendChild(startingSkillsContainer)
	startingStuffContainer.appendChild(abilitiesContainer)
	startingStatsContainer.appendChild(statsHeading)
	startingStatsContainer.appendChild(statsDetails1)
	startingStatsContainer.appendChild(statsDetails2)
	startingStatsContainer.appendChild(statsDetails3)
	startingStatsContainer.appendChild(statsDetails4)
	startingStatsContainer.appendChild(statsDetails5)
	startingStatsContainer.appendChild(statsDetails6)
	startingStatsContainer.appendChild(statsDetails7)
	startingSkillsContainer.appendChild(startingSkillsHeading)
	startingSkillsContainer.appendChild(startingSkillsDetails1)
	startingSkillsContainer.appendChild(startingSkillsDetails2)
	startingSkillsContainer.appendChild(startingSkillsDetails3)
	startingSkillsContainer.appendChild(startingSkillsDetails4)
	startingSkillsContainer.appendChild(startingSkillsDetails5)
	startingSkillsContainer.appendChild(startingSkillsDetails6)
	abilitiesContainer.appendChild(abilitiesHeading)
	abilitiesContainer.appendChild(abilitiesDetails1)
	abilitiesContainer.appendChild(abilitiesDetails2)
	abilitiesContainer.appendChild(abilitiesDetails3)
	abilitiesContainer.appendChild(abilitiesDetails4)
	abilitiesContainer.appendChild(abilitiesDetails5)
	abilitiesContainer.appendChild(abilitiesDetails6)

	const guildDescriptionContainer = createDivElement(``, ['guildDescriptionContainer'])
	const guildHeading = createDivElement(`Warrior's Guild`, ['guildHeading'])
	const guildDescription = createDivElement(warriorsGuildDescription, ['guildDescription'])
	guildDescriptionContainer.appendChild(guildHeading)
	guildDescriptionContainer.appendChild(guildDescription)

	startDetailsContainer.appendChild(classDescriptionContainer)
	startDetailsContainer.appendChild(startingStuffContainer)
	startDetailsContainer.appendChild(guildDescriptionContainer)
}
function displayRaceDetails() {
	const descriptionText = ''
	const raceDetailsContainer = document.querySelector('.race-details')

	const raceDescriptionContainer = createDivElement('', ['raceDescriptionContainer'])
	const raceDescriptionHeading = createDivElement(descriptionText, ['raceDescriptionHeading'])
	const raceDescription = createDivElement(descriptionText, ['raceDescription'])


	const raceStartingStuffContainer = createDivElement(``, ['startingStuffContainer'])
	const raceStatsContainer = createDivElement(``, ['startingStatsContainer'])
	const raceStatsHeading = createDivElement(``, ['raceStatsHeading'])
	const raceDetails1 = createDivElement(``, ['raceDetails1'])
	const raceDetails2 = createDivElement(``, ['raceDetails2'])
	const raceDetails3 = createDivElement(``, ['raceDetails3'])
	const raceDetails4 = createDivElement(``, ['raceDetails4'])
	const raceDetails5 = createDivElement(``, ['raceDetails5'])
	const raceDetails6 = createDivElement(``, ['raceDetails6'])
	const raceDetails7 = createDivElement(``, ['raceDetails7'])

	const raceSkillsContainer = createDivElement(``, ['raceSkillsContainer'])
	const raceSkillsHeading = createDivElement(``, ['raceSkillsHeading'])
	const raceSkillsDetails1 = createDivElement(``, ['raceSkillsDetails1'])
	const raceSkillsDetails2 = createDivElement(``, ['raceSkillsDetails2'])
	const raceSkillsDetails3 = createDivElement(``, ['raceSkillsDetails3'])
	const raceSkillsDetails4 = createDivElement(``, ['raceSkillsDetails4'])
	const raceSkillsDetails5 = createDivElement(``, ['raceSkillsDetails5'])
	const raceSkillsDetails6 = createDivElement(``, ['raceSkillsDetails6'])

	// raceDescriptionContainer.appendChild(raceHeading)
	raceDescriptionContainer.appendChild(raceDescriptionHeading)
	raceDescriptionContainer.appendChild(raceDescription)
	raceStartingStuffContainer.appendChild(raceStatsContainer)
	raceStartingStuffContainer.appendChild(raceSkillsContainer)
	raceStatsContainer.appendChild(raceStatsHeading)
	raceStatsContainer.appendChild(raceDetails1)
	raceStatsContainer.appendChild(raceDetails2)
	raceStatsContainer.appendChild(raceDetails3)
	raceStatsContainer.appendChild(raceDetails4)
	raceStatsContainer.appendChild(raceDetails5)
	raceStatsContainer.appendChild(raceDetails6)
	raceStatsContainer.appendChild(raceDetails7)

	raceSkillsContainer.appendChild(raceSkillsHeading)
	raceSkillsContainer.appendChild(raceSkillsDetails1)
	raceSkillsContainer.appendChild(raceSkillsDetails2)
	raceSkillsContainer.appendChild(raceSkillsDetails3)
	raceSkillsContainer.appendChild(raceSkillsDetails4)
	raceSkillsContainer.appendChild(raceSkillsDetails5)
	raceSkillsContainer.appendChild(raceSkillsDetails6)

	raceDetailsContainer.appendChild(raceDescriptionContainer)
	raceDetailsContainer.appendChild(raceStartingStuffContainer)
}
const warriorsGuildDescription = `The classes of the Warrior's Guild include Berserkers, Fighters, and Knights. They each prefer their own weapon types, but share the affinity to wear mail and plate armor, and will also make use of leather armor if need be. Warriors thrive in combat, eventually able to stay in combat with multiple enemies for extended periods of time. Because of this, and their lack of cowardice, they take longer to recover from retreating.`
const sinistralsGuildDescription = `Sinistrals include Asssassins, Thieves, and Shadowblades. All three use daggers as their weapon of choice, and prefer wearing leather armor.`
const monksGuildDescription = `The Monk's Guild consists of Martial Monks, Mystic Monks, and Elemental Monks. They all prefer using their fists as their weapon of choice. Monk's specialize in fast, multiple strikes. The classes vary in their armor preference, but most choose leather with some exceptions to wear cloth if it enhances their Mysticism. Monk's are very well rounded with their abilities allowing them to be quick, tough, strong, and even able to heal themselves.`
const magesGuildDescription = `Mages include Pyromancers, Cryo Mages, and the Lightning Magus. They each have powerful spells that affect both single and multiple targets. The only problem they face is dealing with elemental resistant enemies, but that can be dealt with by spell penetration. Early on, Mages might wear some leather for the armor value, but eventually move on to only wearing cloth armor to enhance their spell casting.`
const rangersGuildDescription = `The Ranger's Guild consists of only Ranger classes. They are unique in that they are the only class able to hit enemies without the need to engage combat. While they are also strong physically, they later learn how to use magic to enhance their combat capabilities, and even learn how to heal themselves.`
function applyBerserkerClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `The Berserker uses two handed weapons to devastate their foes. They specialize in powerful, single strikes, and eventually learn how to hit multiple enemies with a single swing. Berserkers find their home in the Warrior's Guild.`

	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Berserker`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Two Handed Weapons`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Ripslash`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Cyclone`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Cataclysm`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Warrior's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = warriorsGuildDescription
}
function applyFighterClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `The Fighter prefers dual wielding one handed weapons. They specialize in multiple, single target strikes. At higher levels, they become masters of one on one combat. Fighters find their home in the Warrior's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Fighter`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `One Handed Weapons`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Dualstrike`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Blade Blitz`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Shred`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Warrior's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = warriorsGuildDescription
}
function applyKnightClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Knights prefer fighting with a one handed weapon and shield. They are the most durable class, and are also able to deal significant damage of their own. At later levels, they excel at ataking on multiple enemies at once. Knights find their home in the Warrior's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Knight`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `One Handed Weapons`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Shields`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Valor Strike`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Shield Slam`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Booming Might`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Warrior's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = warriorsGuildDescription
}
function applyAssassinClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Assassins thrive in the shadows, and use daggers as their weapon of choice. Their most lethal attack comes from their Ambush ability that can only be used when stealthed. Assassins follow the leadership of the Sinistral's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Assassin`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Ambush`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Backstab`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Guillotine`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Sinistral's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = sinistralsGuildDescription
}
function applyThiefClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Thieves can use daggers or one handed weapons alongside their poison abilities. Applying poison to enemies, they are able to increase damage of their other abilties. Thieves follow the leadership of the Sinistral's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Thief`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Venomblade`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Contagion`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Bane`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Sinistral's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = sinistralsGuildDescription
}
function applyShadowbladeClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Shadowblades can train in either dagger or one handed weapon skill. Shadowblades follow the leadership of the Sinistral's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Shadowblade`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Shadow Daggers`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Shadowsurge`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Shadow Venom`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Sinistral's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = sinistralsGuildDescription
}
function applyMartialMonkClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Martial Monks are devouts of unarmed combat, primarily using their physicality in battle. Using their fists, they perform combos that weaken their enemies and empower their own attacks. They prefer leather armor, but can make use of mail and plate if their strength allows. Martial Monks reside in the Monk's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Martial Monk`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Unarmed`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Catalyst`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Tempest`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = ``
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Monk's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = monksGuildDescription
}
function applyMysticMonkClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Mystic Monks use both their physical and mystic prowess in combat by applying elemental Seals to the enemy, and then breaking them for powerful effects. Mystic Monks like to wear leather armor, and make use of cloth when it can improve their Mysticism. Mystic Monk's reside in the Monk's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Mystic Monk`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Unarmed`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Elemental Seals`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Body Slam`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Unleashed Power`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Monk's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = monksGuildDescription
}
function applyElementalMonkClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Elemental Monks use their fists as a delivery method for their elemental strikes. Their elemental strikes can be combined to create powerful effects. Elemental Monk's reside in the Monk's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Elemental Monk`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Unarmed`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Elemental Strikes`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Elemental Tempest`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Transcendence`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Monk's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = monksGuildDescription
}
function applyPyromancerClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Pyromancers use fire spells to blast their foes. They are are well equipped to deal with single or multiple enemies. Pyromancers are found in the Mage's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Pyromancer`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Devotion`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Fireflames`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Inferno`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Meteor`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Mage's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = magesGuildDescription
}
function applyCryoMageClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Cryo Mages use ice spells to blast their foes. They are are well equipped to deal with single or multiple enemies. Pyromancers are found in the Mage's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Cryo Mage`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Devotion`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Frostfreeze`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Blizzard`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Cryoclast`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Mage's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = magesGuildDescription
}
function applyLightningMagusClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `The Lightning Magus use lightning spells to blast their foes. They are are well equipped to deal with single or multiple enemies. Pyromancers are found in the Mage's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Lightning Magus`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Devotion`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Flashbolt`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Chain Lightning`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Gigavolt`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Mage's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = magesGuildDescription
}
function applyRangerClassDescription() {	
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = rangersGuildDescription
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Ranger`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Bows`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Piercing Arrow`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Rapid Fire`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Hydra Arrow`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Ranger's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = rangersGuildDescription
}
function applyHumanRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Human`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyDwarfRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``
	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Dwarf`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyElfRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``
	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Elf`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyHalfElfRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``
	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Half Elf`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyHalfMinotaurRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Half Minotaur`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyTieflingRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Tiefling`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyCatlineRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Catline`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyGnomeRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Gnome`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyHalflingRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Halfling`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyFaerieRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Faerie`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyDragonKinRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Dragon Kin`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}

function increaseWeaponSkill() {
	player.twoHanded.level = 30
	player.oneHanded.level = 30
	player.daggers.level = 30
	player.unarmed.level = 30
	player.bows.level = 30
	player.str = 10
	player.dex = 10
	player.agi = 10
	player.skillPoints = 100
	player.attributePoints = 100
	player.health = 1000
	player.maxHealth = 1000
	player.combat = false
	recall(-7, 4, 0)
	updatePlayerStats()
}
function decreaseWeaponSkill() {
	player.currentWeaponSkill.level--
	updatePlayerStats()
}

function gainLevel() {
	player.level++
	player.skillPoints += player.level + 3
	player.attributePoints += player.level % 2 == 0 ? 2 : 1
	let skillPoints = player.level + 3
	let attributePoints = player.level % 2 == 0 ? 2 : 1
	blankSpace()
	quickMessage(`Dev level up! You are now level ${player.level}!`)
	quickMessage(`You gain ${skillPoints} skill points!`)
	quickMessage(`You gain ${attributePoints} attribute points!`)
	blankSpace()
	updatePlayerStats()
}
function loseLevel() {
	player.skillPoints -= player.level + 3
	player.attributePoints -= player.level % 2 == 0 ? 2 : 1
	let skillPoints = player.level + 3
	let attributePoints = player.level % 2 == 0 ? 2 : 1
	player.level--
	blankSpace()
	quickMessage(`Dev level down! You are now level ${player.level}!`)
	quickMessage(`You lose ${skillPoints} skill points!`)
	quickMessage(`You lose ${attributePoints} attribute points!`)
	blankSpace()
	updatePlayerStats()
}

let healthBarTest = document.querySelector('.health-bar-container')
let manaBarTest = document.querySelector('.mana-bar-container')
healthBarTest.addEventListener('click', gainLevel)
manaBarTest.addEventListener('click', loseLevel)


function welcome() {
	let welcomeWindow = document.createElement('div')
	let welcomeNode = document.createElement('img')
	welcomeNode.src = "images/galvadia_title2.jpg"
	welcomeWindow.classList.add('welcome')
	welcomeWindow.appendChild(welcomeNode)
	masterArea.appendChild(welcomeWindow)
}

function confirmationButtonFunction() {
	const disappear = document.getElementById('class-and-race-container')
	disappear.remove()
	commandLine.focus()
	areaCompiler(currentArea)
	setTimeout(() => {
		//
		// setTimeout(() => {
		// 	gameDialogue(
		// 		`You just woke up in your home. You've spent the last year training at the academy in hopes of one day joining the ${player.playerClass}'s guild. Today is your final evaluation where you must put all your training to the test. Travel west to the Castle Training Halls where will begin your test`
		// 	)
		// }, 1000)
	}, 1000)
	// displayArea(currentArea)
}

function displayCharacterConfirmation() {
	const confirmationButtonDiv = document.createElement('div')
	const confirmationButton = document.createElement('button')
	confirmationButton.addEventListener('click', confirmationButtonFunction)
	confirmationButtonDiv.classList.add('character-confirmation')
	confirmationButton.textContent = 'Confirm Character'
	confirmationButton.classList.add('character-confirmation-button')
	confirmationButtonDiv.appendChild(confirmationButton)
	document.getElementById('class-and-race-container').appendChild(confirmationButtonDiv)
	trainingHallsCommonRoom.west = 'locked'
	player.gold = 0
	player.skillPoints = 0

}
function wakeUp() {
	if (player.z == -2) {
		trainingHallsCommonRoom.descriptions.zoneExitsBool.west = 'locked'
		trainingHallsCommonRoom.descriptions.zoneExitsBool.south = 'locked'
		footsteps_of_player_home.descriptions.zoneExitsBool.north = 'locked'
		footsteps_of_player_home.descriptions.zoneExitsBool.south = 'locked'
		crossroads_shops_and_fields.descriptions.zoneExitsBool.north = 'locked'
		crossroads_shops_and_fields.descriptions.zoneExitsBool.south = 'locked'
		castle_gates_east.descriptions.zoneExitsBool.west = 'locked'
		castle_gates_e_inside.descriptions.zoneExitsBool.south = 'locked'
		castleCourtyardCrossInThePath1.descriptions.zoneExitsBool.north = 'locked'
		castleCourtyardCrossInThePath1.descriptions.zoneExitsBool.west = 'locked'
		galvadiaSinistralsGuildEntrance.descriptions.zoneExitsBool.southeast = 'locked'

		while (masterArea.firstChild) {
			masterArea.removeChild(masterArea.firstChild)
		}
		currentArea = playerHouse
		player.x = 0
		player.y = 4
		player.z = 0
		setTimeout(() => {
			areaCompiler(currentArea)
			updateScroll()
			gameDialogue(`You wake up inside your house.`)
		}, 1000)
	}
}

function advanceAndRetreatCheck() {
	let line1 = document.createElement('div')
	if (player.advancing) {
		customizeEachWord(`You are currently engaging your target and cannot perform another action for [`, 'white', line1)
		customizeEachWord(`${advanceTimer}`, 'yellow', line1)
		customizeEachWord(`] seconds`, 'white', line1)
		updateScroll()
		return true
	}
	if (player.retreating) {
		customizeEachWord(`You are currently retreating and cannot perform other another for [`, 'white', line1)
		customizeEachWord(`${retreatTimer}`, 'yellow', line1)
		customizeEachWord(`] seconds`, 'white', line1)
		updateScroll()
		return true
	}
}
//class list
//Berserker
//Fighter
//Knight
//Assassin
//Thief
//Shadowblade
//Martial Monk
//Mystic Monk
//Elemental Monk
//Ranger
//Mage
function playerAbility1() {
	switch (player.playerClass.name) {
		case 'Berserker':
			ripslashFunction()
			break;
		case 'Fighter':
			dualStrikeFunction()
			break;
		case 'Knight':
			valorStrikeFunction()
			break;
		case 'Assassin':
			ambushFunction()
			break;
		case 'Thief':
			venomBladeFunction()
			break;
		case 'Shadowblade':
			shadowsurgeFunction()
			break;
		case 'Martial Monk':
			catalystFunction()
			break;
		case 'Mystic Monk':
			fireSealFunction()
			break;
		case 'Elemental Monk':
			blazingFistFunction()
			break;
		case 'Ranger':
			piercingArrowFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.fireflames)
			break;
		case 'Cryo Mage':
			spellFunction(player.frostfreeze)
			break;
		case 'Lightning Magus':
			spellFunction(player.flashbolt)
			break;
		default:
		quickMessage(`nothing`)
	}
	updateMonsterBox()
}
function playerAbility1Shift() {
	switch (player.playerClass.name) {
		case 'Martial Monk':
			tempestFunction()
			break;
		case 'Mystic Monk':
			waterSealFunction()
			break;
		case 'Elemental Monk':
			tidalFistFunction()
			break;
		default:
		quickMessage(`nothing`)
	}
	updateMonsterBox()
}
function playerAbility1Alt() {
	switch (player.playerClass.name) {
		case 'Martial Monk':
			tempestFunction()
			break;
		case 'Mystic Monk':
			earthSealFunction()
			break;
		case 'Elemental Monk':
			lightningFistFunction()
			break;
		default:
		quickMessage(`nothing`)
	}
	updateMonsterBox()
}
function playerAbility1ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility2Shift() {
	switch (player.playerClass.name) {
		case 'Martial Monk':
			callOfWindFunctionCombat()
			break;
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility2Alt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility2ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility3Shift() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility3Alt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility3ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4() {
	switch (player.playerClass.name) {
		case 'Shadowblade':
			quickMessage('shadow nove used')
			shadowNovaFunction()
			break;
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4Shift() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4Alt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}

function playerAbility2() {
	switch (player.playerClass.name) {
		case 'Berserker':
			cycloneFunction()
			break;
		case 'Fighter':
			shredFunction()
			break;
		case 'Knight':
			shieldSlamFunction()
			break;
		case 'Assassin':
			backstabFunction()
			break;
		case 'Thief':
			contagionFunction()
			break;
		case 'Shadowblade':
			shadowDaggersFunction()
			break;
		case 'Martial Monk':
			callOfWindFunctionRanged()
			break;
		case 'Mystic Monk':
			mysticFistFunction()
			break;
		case 'Elemental Monk':
			elementalTempestFunction()
			break;
		case 'Ranger':
			rapidFireShotFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.inferno)
			break;
		case 'Cryo Mage':
			spellFunction(player.blizzard)
			break;
		case 'Lightning Magus':
			spellFunction(player.chainLightning)
			break;
		default:
		quickMessage(`nothing`)
	}
	updateMonsterBox()
}
function playerAbility3() {
	switch (player.playerClass.name) {
		case 'Berserker':
			cataclysmFunction()
			break;
		case 'Fighter':
			bladeBlitzFunction()
			break;
		case 'Knight':
			boomingMightFunction()
			break;
		case 'Assassin':
			guillotineFunction()
			break;
		case 'Thief':
			baneFunction()
			break;
		case 'Shadowblade':
			shadowVenomFunction()
			break;
		case 'Martial Monk':
			knuckleBlitzFunction()
			break;
		case 'Mystic Monk':
			unleashedPowerFunction()
			break;
		case 'Elemental Monk':
			transcendenceFunction()
			break;
		case 'Ranger':
			hydraArrowFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.meteor)
			break;
		case 'Cryo Mage':
			spellFunction(player.cryoclast)
			break;
		case 'Lightning Magus':
			spellFunction(player.gigavolt)
			break;
		default:
		quickMessage(`nothing`)
	}
	updateMonsterBox()
}

function playerNormalAttack() {
	switch (player.playerClass.name) {
		case 'Berserker':
			attack()
			break;
		case 'Fighter':
			attack()
			break;
		case 'Knight':
			attack()
			break;
		case 'Assassin':
			attack()
			break;
		case 'Thief':
			attack()
			break;
		case 'Shadowblade':
			attack()
			break;
		case 'Martial Monk':
			attack()
			break;
		case 'Mystic Monk':
			attack()
			break;
		case 'Elemental Monk':
			attack()
			break;
		case 'Ranger':
			attack()
			break;
		case 'Mage':
			target()
			break;
		default:
		quickMessage(`nothing`)
	}
	updateMonsterBox()
}

function playerNormalAttackShift() {
	switch (player.playerClass.name) {
		case 'Berserker':
			if (player.charge.level > 0) {
				chargeFunction()
				return
			}
			attack()
			break;
		case 'Fighter':
			if (player.charge.level > 0) {
				chargeFunction()
				return
			}
			attack()
			break;
		case 'Knight':
			if (player.charge.level > 0) {
				chargeFunction()
				return
			}
			attack()
			break;
		}
}

function warriorKeybinds() {}
function rogueKeybinds() {}
function rangerKeybinds() {}
function mageKeybinds() {}

document.addEventListener('keydown', numPadFunctionality)
function numPadFunctionality(event) {
	const isNumpadKey = event.location === 3
  	if (isNumpadKey && document.activeElement === commandLine) {
	  event.preventDefault();
	}
	if (isNumpadKey) {
		let eventKey = !isNaN(event.key) ? parseInt(event.key) : event.key
		handleAction(eventKey, event)
	}
}
function handleAction(action, event) {
	if (advanceAndRetreatCheck()) {return}
	if (event.altKey && event.shiftKey && action == '/') {playerAbility1ShiftAndAlt()}
	else if (event.shiftKey && action == '/') {playerAbility1Shift()} 
	else if (event.altKey && action == '/') {playerAbility1Alt()}
	else if (action == '/') {playerAbility1()} 

	else if (event.altKey && event.shiftKey && action == '*') {playerAbility2ShiftAndAlt()}
	else if (event.shiftKey && action == '*') {playerAbility2Shift()} 
	else if (event.altKey && action == '*') {playerAbility2Alt()} 
	else if (action == '*') {playerAbility2()} 

	else if (event.altKey && event.shiftKey && action == '-') {playerAbility3ShiftAndAlt()}
	else if (event.shiftKey && action == '-') {playerAbility3Shift()} 
	else if (event.altKey && action == '-') {playerAbility3Alt()} 
	else if (action == '-') {playerAbility3()} 

	else if (event.altKey && event.shiftKey && action == '+') {playerAbility4ShiftAndAlt()}
	else if (event.shiftKey && action == '+') {playerAbility4Shift()} 
	else if (event.altKey && action == '+') {playerAbility4Alt()} 
	else if (action == '+') {playerAbility4()} 

	else if (event.key == 'Clear') {playerNormalAttackShift()}

	switch (action) {
	case 7:
		if (!player.combat && !player.stasis) {
			handleInputs('nw')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('nw')
		} else if (player.stasis) {
			handleCombatStasisInputs('nw')
		} 
		break;
	case 8:
		if (!player.combat && !player.stasis) {
			handleInputs('n')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('n')
		} else if (player.stasis) {
			handleCombatStasisInputs('n')
		} 
		break;
	case 9:
		if (!player.combat && !player.stasis) {
			handleInputs('ne')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('ne')
		} else if (player.stasis) {
			handleCombatStasisInputs('ne')
		} 
		break;
	case 4:
		if (!player.combat && !player.stasis) {
			handleInputs('w')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('w')
		} else if (player.stasis) {
			handleCombatStasisInputs('w')
		} 
		break;
	case 5:
		if (!player.combat && !player.stasis) {
			handleInputs('a')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('a')
		} else if (player.stasis) {
			handleCombatStasisInputs('a')
		} 
	  	// playerNormalAttack()
	  	break
	case 6:
		if (!player.combat && !player.stasis) {
			handleInputs('e')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('e')
		} else if (player.stasis) {
			handleCombatStasisInputs('e')
		} 
		break;
	case 1:
		if (!player.combat && !player.stasis) {
			handleInputs('sw')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('sw')
		} else if (player.stasis) {
			handleCombatStasisInputs('sw')
		} 
		break;
	case 2:
		if (!player.combat && !player.stasis) {
			handleInputs('s')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('s')
		} else if (player.stasis) {
			handleCombatStasisInputs('s')
		} 
		break;
	case 3:
		if (!player.combat && !player.stasis) {
			handleInputs('se')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('se')
		} else if (player.stasis) {
			handleCombatStasisInputs('se')
		} 
		break;
	case 0:
		if (!player.combat && !player.stasis) {
			handleInputs('d')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('d')
		} else if (player.stasis) {
			handleCombatStasisInputs('d')
		} 
		break;
	case '.':
		if (!player.combat && !player.stasis) {
			handleInputs('u')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('u')
		} else if (player.stasis) {
			handleCombatStasisInputs('u')
		} 
		break;
	default:
		// Handle invalid key
		console.log('Invalid key');
	}
  }

function gameStart() {
	//INITIALIZE NPCS AND MONSTER BEHAVIOR
	// strayCat.npcBehavior()
	// annoyedSquire.npcBehavior()
	// villagerMalchus.npcBehavior()
	// villagerLinus.npcBehavior()
	villagerRissah.npcBehavior()
	deylani.npcBehavior()
	// villager1.npcBehavior()

	pushMonster.push(trainingDummy(currentArea))
	pushMonster.push(trainingDummy2(currentArea))
	pushMonster.push(trainingDummy3(currentArea))
	pushMonster.push(trainingDummy4(currentArea))
	pushMonster.push(trainingDummy5(currentArea))
	pushMonster.push(trainingDummy6(currentArea))
	pushMonster.push(trainingDummy7(currentArea))
	pushMonster.push(trainingDummy8(currentArea))
	pushMonster.push(trainingDummy9(currentArea))
	pushMonster.push(trainingDummy10(currentArea))

	player.stasis = false
	player.combat = false

	welcome()
	displayClassSelection()
	displayClassDetails()
	displayRaceSelection()
	displayRaceDetails()
	displayCharacterConfirmation()
	weaponGen(trainingShortsword())
	weaponGen(trainingShortsword())
	weaponGen(trainingTwoHandedSword())
	weaponGen(trainingBow())
	weaponGen(trainingDagger())
	weaponGen(trainingDagger())
	weaponGen(trainingShield())
	// weaponGen(stoutedMace())
	// weaponGen(stoutedMace())
	// weaponGen(mace())
	// weaponGen(mace())
	// weaponGen(gladius())
	// weaponGen(gladius())
	// weaponGen(crescentDagger())
	// weaponGen(crescentDagger())
	// weaponGen(fighterFists())
	// weaponGen(honedLongbow())
	// weaponGen(maul())
	// weaponGen(sledgehammer())
	// weaponGen(honedLongbow())
	// weaponGen(honedLongbow())
	// weaponGen(honedLongbow())
	// weaponGen(honedLongbow())
	// weaponGen(honedLongbow())
	// weaponGen(honedLongbow())
	// weaponGen(honedLongbow())
	// weaponGen(berserkBlade())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(copperOre())
	// questItemGen(lightHide())
	// questItemGen(lightHide())
	// questItemGen(lightHide())
	// questItemGen(lightHide())
	// questItemGen(lightHide())
	// questItemGen(lightHide())
	// questItemGen(thinFiber())
	// questItemGen(thinFiber())
	// questItemGen(thinFiber())
	// questItemGen(thinFiber())
	// questItemGen(thinFiber())
	// questItemGen(thinFiber())
	// questItemGen(brightYellowFlower())
	// questItemGen(sackOfGrain())
	// questItemGen(wormGuts())
	// foodGen(halfEatenFish())
	// foodGen(mudBall())
	pushItem[2].roomId = 'backpack'
	pushItem[3].roomId = 'backpack'
	pushItem[4].roomId = 'backpack'
	pushItem[5].roomId = 'backpack'
	pushItem[6].roomId = 'backpack'
	pushItem[7].roomId = 'backpack'
	pushItem[8].roomId = 'backpack'
	// pushItem[9].roomId = 'backpack'
	// pushItem[10].roomId = 'backpack'
	// pushItem[11].roomId = 'backpack'
	// pushItem[12].roomId = 'backpack'
	// pushItem[13].roomId = 'backpack'
	// pushItem[14].roomId = 'backpack'
	// pushItem[15].roomId = 'backpack'
	// pushItem[16].roomId = 'backpack'
	// pushItem[17].roomId = 'backpack'
	// pushItem[18].roomId = 'backpack'
	// pushItem[19].roomId = 'backpack'
	// pushItem[20].roomId = 'backpack'
	// pushItem[21].roomId = 'backpack'
	// pushItem[22].roomId = 'backpack'
	// pushItem[23].roomId = 'backpack'
	// pushItem[24].roomId = 'backpack'
	// pushItem[25].roomId = 'backpack'
	// pushItem[26].roomId = 'backpack'
	// pushItem[27].roomId = 'backpack'
	// pushItem[28].roomId = 'backpack'
	// pushItem[29].roomId = 'backpack'
	// pushItem[30].roomId = 'backpack'
	// pushItem[31].roomId = 'backpack'
	// pushItem[32].roomId = 'backpack'
	// pushItem[33].roomId = 'backpack'
	// pushItem[34].roomId = 'backpack'
	// pushItem[35].roomId = 'backpack'
	// pushItem[36].roomId = 'backpack'
	// pushItem[38].roomId = 'backpack'
	// pushItem[39].roomId = 'backpack'
	// pushItem[40].roomId = 'backpack'
	// pushItem[41].roomId = 'backpack'
	// pushItem[42].roomId = 'backpack'
	// pushItem[43].roomId = 'backpack'
	// pushItem[44].roomId = 'backpack'
	// pushItem[45].roomId = 'backpack'
	player.str = 1
	player.dex = 1
	player.agi = 1
	player.con = 1
	player.wis = 1
	player.int = 1
	player.twoHanded.level = 1
	player.bows.level = 1
	player.daggers.level = 1
	player.unarmed.level = 1
	player.oneHanded.level = 1
	player.sideStep.level = 0
	player.counterAttack.level = 0
	player.preemptiveStrike.level = 0
	player.heal = { ...heal }
	updateScroll()
	updatePlayerStats()
	player.gold = 1000
	player.attributePoints = 100
	player.skillPoints = 1000

	recall()
}
gameStart()
