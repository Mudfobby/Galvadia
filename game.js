// You stand in a large, open area surrounded by yellow fields. Numberous teachers are here instructing students and keeping an eye on the ones fighting in the fields.
// Some prospects sit here resting before going back in while others look nervously at the fields.

// The wide path into the fields is blotted with water, mud, and shreds of grass. A few prospects are hiding here, just around the corner and out of sight of monsters.

// By The Cliffside -> Along The Cliffside -> At The End Of The Cliffside

// By The Cliffside
// The forest glade, high on the cliffside to the east, casts a shadow over the eastern edge of the field. To climb the cliff
// would be impossible, unless of course you were athletic enough.

// Along The Cliffside
// The cracked rockface of the cliff has dotted the ground near the base with small boulders and piles of stone. Behind
// the stone you can barely make out what looks

///////////NPC AI MOVEMENT AREAS
let allWeaponSkillMultipliers = 0.15
let allWeaponSkillIncrements = 20
let allNpcsArray = []

let slugHost = {
	glooper: {
	},
	wormburner: {
	},
	adam: {
	},
	sloppy: {
	},
	scoopy: {
	},
	scampy: {
	},
}

let rouletteHost = {
	number: null,
	oddOrEven: null,
	playerBetAmount: null,
	winningAmount: null
}
function waitFunction(ms) {
return new Promise(resolve => {
	setTimeout(resolve, ms);
});
}

function shuffleArray(array) {
for (let i = array.length - 1; i > 0; i--) {
	// Generate a random index from 0 to i
	const j = Math.floor(Math.random() * (i + 1));
	// Swap the elements at indices i and j
	[array[i], array[j]] = [array[j], array[i]];
}
return array;
}
const slugs = ["glooper", "wormburner", "adam", "sloppy", "scoopy", "scampy"]

////////////GLOBALS AND SUPPORT FUNCTIONS ABOVE
//Slug racing
function playerLoseGold(amount) {
	player.gold -= amount
}
function playerGainGold(amount) {
	player.gold += amount
}
function playerGainGoldWithMessage(goldGained) {
	let line1 = lineFunc()
	player.gold += goldGained
	customizeEachWord(`You receive `, 'white', line1)
	customizeEachWord(`${goldGained} `, 'yellow', line1)
	customizeEachWord(`gold.`, 'white', line1)
}
function playerLoseGoldWithMessage(amount) {
	player.gold -= amount
}

async function initiateSnailRace(amount, secondCommand) {
	//slughost adds playerBet and playerSlug properties
	//playerBet is the amount of gold bet. Storing this for calculating prize money
	//playerSlug is self explanatory
	await dialogueWait(200)
	betHandler(amount, secondCommand)
	await dialogueWait(4000)
	slugRaceDialogue1()
	await dialogueWait(1000)
	slugRaceDialogue2()
	await dialogueWait(1000)
	slugRaceDialogue3()
	await dialogueWait(1000)
	slugRaceDialogue4()
	await dialogueWait(1000)
	slugRaceDialogue5()
	slugRacingBetHandler()
}

async function snailRacingHandler(amount, secondCommand) {
	let minPlayerGold = 100
	let maxBet = 100
	let minBet = 1
	if (!isBetValid(amount, secondCommand, minBet, maxBet, minPlayerGold, 'Snail Racing')) {return}
	playerLoseGold(amount)
	let validCommands = ['glooper', 'wormburner', 'adam', 'sloppy', 'scoopy', 'scampy'] //put the list of snail names in the array
	if (!validCommands.includes(secondCommand)) {
		console.log(secondCommand)
		quickMessage(`${secondCommand} is not a snail you can bet on.`)
		return
	} else {
		let line1 = lineFunc()
		let gameMasterDialogue = ''
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Game Master`, 'gameMaster', line1)
		customizeEachWord(`: ${gameMasterDialogue}`, 'white', line1)
		if (secondCommand == 'glooper') {
			customizeEachWord(`"${player.name} bets `, 'white', line1)
			customizeEachWord(`${amount} `, 'yellow', line1)
			customizeEachWord(`on Glooper, a tride and true pick! One of the oldest yet slimy with experience snails in the race!"`, 'white', line1)
		}
		else if (secondCommand == 'wormburner') {
			customizeEachWord(`"${player.name} bets `, 'white', line1)
			customizeEachWord(`${amount} `, 'yellow', line1)
			customizeEachWord(`on the beast slayer himself, Wormburner!"`, 'white', line1)
		}
		else if (secondCommand == 'adam') {
			customizeEachWord(`"${player.name} bets `, 'white', line1)
			customizeEachWord(`${amount} `, 'yellow', line1)
			customizeEachWord(`on Adam! He might just be the most depressed snail we've ever seen, but don't let that fool you! About every 6th race he fights back with a hateful vengence!"`, 'white', line1)
		}
		else if (secondCommand == 'sloppy') {
			customizeEachWord(`"${player.name} bets `, 'white', line1)
			customizeEachWord(`${amount} `, 'yellow', line1)
			customizeEachWord(`on Sloppy! Sloppy is one hell of a slopper. He'll slop all the other snails and then slop his way to the finish!"`, 'white', line1)
		}
		else if (secondCommand == 'scoopy') {
			customizeEachWord(`"${player.name} bets `, 'white', line1)
			customizeEachWord(`${amount} `, 'yellow', line1)
			customizeEachWord(`on Scoopy! When you need to soop the poop, who better to poop scoop with than Scoopy!"`, 'white', line1)
		}
		else if (secondCommand == 'scampy') {
			customizeEachWord(`"${player.name} bets `, 'white', line1)
			customizeEachWord(`${amount} `, 'yellow', line1)
			customizeEachWord(`on Scampy! If you wished you'd scamped instead of scooped, Scampy is your man!"`, 'white', line1)
		}
	}
	blankSpace()
	initiateSnailRace(amount, secondCommand)
	return
}

async function paperRockScissorsHandler(amount, secondCommand) {
	let minPlayerGold = 1
	let maxBet = 100
	let minBet = 1
	let winAmount = amount * 2
	let paperRockScissors = ['paper', 'rock', 'scissors']
	if (!isBetValid(amount, secondCommand, minBet, maxBet, minPlayerGold, 'Roulette')) {return}
	if (!paperRockScissors.includes(secondCommand)) {
		quickMessage(`You must say either paper, rock, or scissors.`)
		return
	}
	player.stasis = true
	let randomNumber = randomNumberRange(0, 2)
	let gameMastersChoice = paperRockScissors[randomNumber]
	let playerWinLoseOrPush
	if (secondCommand == 'paper' && gameMastersChoice == 'rock') {playerWinLoseOrPush = 'win'}
	if (secondCommand == 'paper' && gameMastersChoice == 'scissors') {playerWinLoseOrPush = 'lose'}
	if (secondCommand == 'rock' && gameMastersChoice == 'paper') {playerWinLoseOrPush = 'lose'}
	if (secondCommand == 'rock' && gameMastersChoice == 'scissors') {playerWinLoseOrPush = 'win'}
	if (secondCommand == 'scissors' && gameMastersChoice == 'rock') {playerWinLoseOrPush = 'lose'}
	if (secondCommand == 'scissors' && gameMastersChoice == 'paper') {playerWinLoseOrPush = 'win'}
	if (secondCommand == gameMastersChoice) {playerWinLoseOrPush = 'push'}
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	let line4 = lineFunc()
	let line5 = lineFunc()
	let line6 = lineFunc()
	let line7 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "You think you can beat me?"`, 'white', line1)
	blankSpace()
	await dialogueWait(2000)
	customizeEachWord(`Game Master`, 'gameMaster', line2)
	customizeEachWord(`: "Alright, let's go!"`, 'white', line2)
	blankSpace()
	await dialogueWait(1000)

	customizeEachWord(`Game Master`, 'gameMaster', line3)
	customizeEachWord(`: "Paper!"`, 'white', line3)
	blankSpace()
	await dialogueWait(1000)

	customizeEachWord(`Game Master`, 'gameMaster', line4)
	customizeEachWord(`: "Rock!"`, 'white', line4)
	blankSpace()
	await dialogueWait(1000)

	customizeEachWord(`Game Master`, 'gameMaster', line5)
	customizeEachWord(`: "Scissors!"`, 'white', line5)
	blankSpace()
	await dialogueWait(1000)

	customizeEachWord(`Game Master `, 'white', line6)
	customizeEachWord(`shows `, 'white', line6)
	customizeEachWord(`${gameMastersChoice}.`, 'white', line6)

	customizeEachWord(`You show `, 'white', line7)
	customizeEachWord(`${secondCommand}.`, 'white', line7)
	blankSpace()
	await dialogueWait(2000)
	if (playerWinLoseOrPush == 'win') {
		let line1 = lineFunc()
		customizeEachWord(`You won `, 'white', line1)
		customizeEachWord(`${winAmount} `, 'yellow', line1)
		customizeEachWord(`gold!`, 'white', line1)
		blankSpace()
		playerGainGold(winAmount)
	}
	if (playerWinLoseOrPush == 'lose') {
		let line1 = lineFunc()
		customizeEachWord(`You lose...`, 'white', line1)
		blankSpace()
		playerLoseGold(amount)
	}
	if (playerWinLoseOrPush == 'push') {
		let line1 = lineFunc()
		customizeEachWord(`Match ends in a draw!`, 'white', line1)
		blankSpace()
	}
}

async function rouletteHandler(amount, secondCommand) {
	let minPlayerGold = 1
	let maxBet = 100
	let minBet = 1
	if (!isBetValid(amount, secondCommand, minBet, maxBet, minPlayerGold, 'Roulette')) {return}
	if ((secondCommand < 1 || secondCommand > 40) && (secondCommand != 'odd' || secondCommand != 'even')) {
		quickMessage(`You must either pick a number between 1 and 40 or choose to bet on odd or even.`)
		return
	}
	playerLoseGold(amount)
	player.stasis = true
	let rouletteNumber = randomNumberRange(1, 40)
	let isOddOrEven
	let numberRange
	let playerBettingRange
	let doesBettingRangeMatch
	let doBettingWordsMatch
	let perfectMatch
	if (!isNaN(secondCommand)) {
		rouletteHost.numberOrWord = 'number'
		rouletteHost.winningAmount = amount * 3
		numberRange = rouletteNumber <= 10 ? '1 - 10' : rouletteNumber <= 20 ? '11 - 20' : rouletteNumber <= 30 ? '21 - 30' : '31 - 40'
		playerBettingRange = secondCommand <= 10 ? '1 - 10' : secondCommand <= 20 ? '11 - 20' : secondCommand <= 30 ? '21 - 30' : '31 - 40'
		doesBettingRangeMatch = numberRange == playerBettingRange ? true : false
		isOddOrEven = rouletteNumber % 2 == 0 ? 'even' : 'odd'
		if (rouletteNumber == secondCommand) {
			perfectMatch = true
			rouletteHost.winningAmount = amount * 5
		}
	} else if (isNaN(secondCommand)) {
		rouletteHost.numberOrWord = 'word'
		rouletteHost.winningAmount = amount * 2
		isOddOrEven = rouletteNumber % 2 == 0 ? 'even' : 'odd'
		doBettingWordsMatch = isOddOrEven == secondCommand ? true : false
		numberRange = rouletteNumber <= 10 ? '0 - 9' : rouletteNumber <= 20 ? '10 - 19' : rouletteNumber <= 30 ? '20 - 29' : '30 - 39'
	}
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	let line4 = lineFunc()
	let line5 = lineFunc()
	let line6 = lineFunc()
	let line7 = lineFunc()
	let line8 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "${player.name} bet `, 'white', line1)
	customizeEachWord(`${amount} `, 'yellow', line1)
	customizeEachWord(`gold pieces on ${secondCommand}!"`, 'white', line1)
	blankSpace()
	await dialogueWait(2000)
	customizeEachWord(`Game Master`, 'gameMaster', line2)
	customizeEachWord(`: "Everyone place your bets!"`, 'white', line2)
	blankSpace()
	await dialogueWait(2000)
	customizeEachWord(`Game Master`, 'gameMaster', line3)
	customizeEachWord(`: "Last chance for bets!"`, 'white', line3)
	blankSpace()
	await dialogueWait(2000)
	customizeEachWord(`The Game Master spins the roulette wheel..`, 'white', line4)
	blankSpace()
	await dialogueWait(2000)
	customizeEachWord(`The roulette wheel slowly spins down..`, 'white', line5)
	blankSpace()
	await dialogueWait(5000)
	customizeEachWord(`The roulette wheel lands on number `, 'white', line6)
	customizeEachWord(`${rouletteNumber} `, 'green', line6)
	customizeEachWord(`(${numberRange}) `, 'white', line6)
	customizeEachWord(`${capitalizeFirstLetter(isOddOrEven)}`, 'yellow', line6)
	customizeEachWord(`!`, 'white', line6)
	// blankSpace()
	// await dialogueWait(200)
	// customizeEachWord(`The winning number range is ${numberRange}!`, 'white', line7)
	blankSpace()
	await dialogueWait(200)
	if (perfectMatch) {
		let line1 = lineFunc()
		customizeEachWord(`You chose the winning number! You won `, 'white', line1)
		customizeEachWord(`${rouletteHost.winningAmount} `, 'yellow', line1)
		customizeEachWord(`gold pieces!`, 'white', line1)
		playerGainGold(rouletteHost.winningAmount)	
	} else if (doesBettingRangeMatch == true || doBettingWordsMatch == true) {
		let line1 = lineFunc()
		customizeEachWord(`You won `, 'white', line1)
		customizeEachWord(`${rouletteHost.winningAmount} `, 'yellow', line1)
		customizeEachWord(`gold pieces!`, 'white', line1)
		playerGainGold(rouletteHost.winningAmount)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You lost your bet of `, 'white', line1)
		customizeEachWord(`${amount} `, 'yellow', line1)
		customizeEachWord(`gold.`, 'white', line1)
	}
	blankSpace()
	player.stasis = false
}

async function bet(amount, secondCommand) {
	if (currentArea == amblersTavernGameRoom1) {snailRacingHandler(amount, secondCommand)}
	else if (currentArea == amblersTavernGameRoom2) {paperRockScissorsHandler(amount, secondCommand)}
	else if (currentArea == amblersTavernGamblingRoom1) {rouletteHandler(amount, secondCommand)}
	else if (currentArea == amblersTavern10) {}
	else if (currentArea == amblersTavern8) {}
	else if (currentArea == amblersTavern13) {}
	else if (currentArea == amblersTavern14) {}
	else if (currentArea == amblersTavern15) {}
	else {quickMessage(`You must be in a game room in order to place a bet.`)}
	

}

function isBetValid(playerBetAmount, secondCommand, minBet, maxBet, minPlayerGold, gameName) {
	if (playerBetAmount > player.gold) {
		quickMessage(`You don't have enough gold to bet that amount.`)
		return false
	}
	if (isNaN(playerBetAmount)) {
		quickMessage(`You must specify how much gold you want to bet first.`)
		return false
	}
	if (playerBetAmount <= 0) {
		quickMessage(`Your bet must be at least 1 gold piece.`)
		return false
	}
	if (!secondCommand) {
		quickMessage(`You must specify who or what you want to bet on.`)
		return false
	}
	if (playerBetAmount > maxBet) {
		quickMessage(`You cannot bet more than ${maxBet} gold.`)
		return false
	}
	if (playerBetAmount < minBet) {
		quickMessage(`You must bet more than ${minBet} gold to play ${gameName}`)
		return false
	}
	if (player.gold < minPlayerGold) {
		quickMessage(`You must have more than ${minPlayerGold} to play ${gameName}`)
		return false
	}
	return true
}

function betHandler(betAmount, slugBetOn) {
	slugHost.playerBet = betAmount
	slugHost.playerSlug = slugBetOn
	playerLoseGold(betAmount)
}

function slugRaceDialogue1() {
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "The race will begin in..."`, 'white', line1)
	blankSpace()
}
function slugRaceDialogue2() {
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "3."`, 'white', line1)
	blankSpace()
}
function slugRaceDialogue3() {
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "2."`, 'white', line1)
	blankSpace()
}
function slugRaceDialogue4() {
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "1."`, 'white', line1)
	blankSpace()
}
function slugRaceDialogue5() {
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`Game Master`, 'gameMaster', line1)
	customizeEachWord(`: "GO!"`, 'white', line1)
	blankSpace()
}

async function slugRacingBetHandler() {
	let main = document.getElementById('masterArea')
	let snailRacingContainer = document.createElement('section')

	let glooperContainer = document.createElement('section')
	let glooperName = document.createElement('article')
	let glooper = document.createElement('article')
	let glooperFinishText = document.createElement('article')
	glooperContainer.appendChild(glooperName)
	glooperContainer.appendChild(glooper)
	glooperContainer.appendChild(glooperFinishText)

	let wormburnerContainer = document.createElement('section')
	let wormburnerName = document.createElement('article')
	let wormburner = document.createElement('article')
	let wormburnerFinishText = document.createElement('article')

	wormburnerContainer.appendChild(wormburnerName)
	wormburnerContainer.appendChild(wormburner)
	wormburnerContainer.appendChild(wormburnerFinishText)

	let adamContainer = document.createElement('section')
	let adamName = document.createElement('article')
	let adam = document.createElement('article')
	let adamFinishText = document.createElement('article')

	adamContainer.appendChild(adamName)
	adamContainer.appendChild(adam)
	adamContainer.appendChild(adamFinishText)


	let sloppyContainer = document.createElement('section')
	let sloppyName = document.createElement('article')
	let sloppy = document.createElement('article')
	let sloppyFinishText = document.createElement('article')

	sloppyContainer.appendChild(sloppyName)
	sloppyContainer.appendChild(sloppy)
	sloppyContainer.appendChild(sloppyFinishText)


	let scoopyContainer = document.createElement('section')
	let scoopyName = document.createElement('article')
	let scoopy = document.createElement('article')
	let scoopyFinishText = document.createElement('article')

	scoopyContainer.appendChild(scoopyName)
	scoopyContainer.appendChild(scoopy)
	scoopyContainer.appendChild(scoopyFinishText)


	let scampyContainer = document.createElement('section')
	let scampyName = document.createElement('article')
	let scampy = document.createElement('article')
	let scampyFinishText = document.createElement('article')

	scampyContainer.appendChild(scampyName)
	scampyContainer.appendChild(scampy)
	scampyContainer.appendChild(scampyFinishText)

	snailRacingContainer.appendChild(glooperContainer)
	snailRacingContainer.appendChild(wormburnerContainer)
	snailRacingContainer.appendChild(adamContainer)
	snailRacingContainer.appendChild(sloppyContainer)
	snailRacingContainer.appendChild(scoopyContainer)
	snailRacingContainer.appendChild(scampyContainer)
	// snailRacingContainer.appendChild(firstPlace)
	// snailRacingContainer.appendChild(secondPlace)
	// snailRacingContainer.appendChild(thirdPlace)
	main.appendChild(snailRacingContainer)
	glooper.setAttribute('class', 'glooper')
	wormburner.setAttribute('class', 'wormburner')
	adam.setAttribute('class', 'adam')
	sloppy.setAttribute('class', 'sloppy')
	scoopy.setAttribute('class', 'scoopy')
	scampy.setAttribute('class', 'scampy')

	glooperName.setAttribute('class', 'glooperName')
	wormburnerName.setAttribute('class', 'wormburnerName')
	adamName.setAttribute('class', 'adamName')
	sloppyName.setAttribute('class', 'sloppyName')
	scoopyName.setAttribute('class', 'scoopyName')
	scampyName.setAttribute('class', 'scampyName')

	glooperName.textContent = `GLOOPER`
	wormburnerName.textContent = `WORMBURNER`
	adamName.textContent = `ADAM`
	sloppyName.textContent = `SLOPPY`
	scoopyName.textContent = `SCOOPY`
	scampyName.textContent = `SCAMPY`


	glooperContainer.setAttribute('class', 'glooperContainer')
	wormburnerContainer.setAttribute('class', 'wormburnerContainer')
	adamContainer.setAttribute('class', 'adamContainer')
	sloppyContainer.setAttribute('class', 'sloppyContainer')
	scoopyContainer.setAttribute('class', 'scoopyContainer')
	scampyContainer.setAttribute('class', 'scampyContainer')

	snailRacingContainer.setAttribute('class', 'snail-racing-container')
	updateScroll()
	let { playerBet } = slugHost
	let { playerSlug } = slugHost
	let slugWinningLineup = shuffleArray(slugs)
	let winnerSlug = slugWinningLineup[0]
	let secondPlaceSlug = slugWinningLineup[1]
	let thirdPlaceSlug = slugWinningLineup[2]
	let fourthPlaceSlug = slugWinningLineup[3]
	let fifthPlaceSlug = slugWinningLineup[4]
	let sixthPlaceSlug = slugWinningLineup[5]
	slugHost[winnerSlug].raceTime = 10000
	slugHost[winnerSlug].place = 'first'
	slugHost[secondPlaceSlug].raceTime = 10200
	slugHost[secondPlaceSlug].place = 'second'
	slugHost[thirdPlaceSlug].raceTime = 10400
	slugHost[thirdPlaceSlug].place = 'third'
	slugHost[fourthPlaceSlug].raceTime = 10600
	slugHost[fourthPlaceSlug].place = 'fourth'
	slugHost[fifthPlaceSlug].raceTime = 10800
	slugHost[fifthPlaceSlug].place = 'fifth'
	slugHost[sixthPlaceSlug].raceTime = 11000
	slugHost[sixthPlaceSlug].place = 'sixth'

	convertTimeToRaceHTML('glooper', glooper, glooperFinishText)
	convertTimeToRaceHTML('wormburner', wormburner, wormburnerFinishText)
	convertTimeToRaceHTML('adam', adam, adamFinishText)
	convertTimeToRaceHTML('sloppy', sloppy, sloppyFinishText)
	convertTimeToRaceHTML('scoopy', scoopy, scoopyFinishText)
	convertTimeToRaceHTML('scampy', scampy, scampyFinishText)

}

async function convertTimeToRaceHTML(slug, slugHTML, slugFinishText) {
	let capitalSlug = capitalizeFirstLetter(slug)
	let fluctuationArray = speedFluctuation(slugHost[slug].raceTime)
	let shuffledFluctuationArray = shuffleArray(fluctuationArray)
	slugHTML.innerHTML += `|START| `
	updateScroll()
	for (let i = 0; i < 10; i ++) {
		await waitFunction(shuffledFluctuationArray[i])
		slugHTML.innerHTML += `__@_/*  `
	}
	let firstPlace = document.createElement('article')
	let secondPlace = document.createElement('article')
	let thirdPlace = document.createElement('article')
	let fourthPlace = document.createElement('article')
	let fifthPlace = document.createElement('article')
	let sixthPlace = document.createElement('article')
	firstPlace.setAttribute('class', 'firstPlace')
	secondPlace.setAttribute('class', 'secondPlace')
	thirdPlace.setAttribute('class', 'thirdPlace')
	fourthPlace.setAttribute('class', 'fourthPlace')
	fifthPlace.setAttribute('class', 'fifthPlace')
	sixthPlace.setAttribute('class', 'sixthPlace')
	masterArea.appendChild(firstPlace)
	masterArea.appendChild(secondPlace)
	masterArea.appendChild(thirdPlace)
	masterArea.appendChild(fourthPlace)
	masterArea.appendChild(fifthPlace)
	masterArea.appendChild(sixthPlace)
	let line1 = lineFunc()
	if (slugHost[slug].place == 'first') {
		slugFinishText.textContent = `${capitalSlug} is the WINNER!`
		slugHTML.classList.add('winner')
		slugFinishText.classList.add('winner')
	}
	if (slugHost[slug].place == 'second') {
		slugFinishText.textContent = `${capitalSlug} gets 2nd place!`
		slugHTML.classList.add('second')
		slugFinishText.classList.add('second')
	}
	if (slugHost[slug].place == 'third') {
		slugFinishText.textContent = `${capitalSlug} comes in 3rd!`
		slugHTML.classList.add('third')
		slugFinishText.classList.add('third')
	}
	if (slugHost[slug].place == 'fourth') {
		slugFinishText.textContent = `${capitalSlug} trails behind in 4th!`
	}
	if (slugHost[slug].place == 'fifth') {
		slugFinishText.textContent = `${capitalSlug} slops his way to 5th..`
	}
	if (slugHost[slug].place == 'sixth') {
		slugFinishText.textContent = `${capitalSlug} really slugged it up and came in 6th....`
		findSnailWinner()

		// slugHost = {
		// 	glooper: {},
		// 	wormburner: {},
		// 	adam: {},
		// 	sloppy: {},
		// 	scoopy: {},
		// 	scampy: {},
		// }
	}
	updateScroll()
}

function speedFluctuation(time) {
	let totalTime = time //this is like 15000
	let timeIncrement = time / 10 // this would be 1500 if the above value is 15000
	let incrementArray = []
	for (let i = 0; i < 10; i++) {
		incrementArray.push(timeIncrement)
	}
	let counter = 0
	let sum = 0
	let incrementChange1 = randomNumberRange(100, 300)
	let incrementChange2 = randomNumberRange(100, 300)
	let incrementChange3 = randomNumberRange(100, 300)


	incrementArray.forEach((element, index) => {
	if (counter % 2 == 0) {
		incrementArray[index] += incrementChange1
	} else {
		incrementArray[index] -= incrementChange1
	}
		sum += element

	counter++
	})
 	incrementArray.forEach((element, index) => {
		if (counter % 2 == 0) {
  	incrementArray[index] += incrementChange2
	} else {
  	incrementArray[index] -= incrementChange2
	}
	counter++
  	})
  	incrementArray.forEach((element, index) => {
		if (counter % 2 == 0) {
  	incrementArray[index] += incrementChange3
	} else {
  incrementArray[index] -= incrementChange3
	}
	counter++
  	})
	console.log(sum, "SUM")
	let shuffledArray = shuffleArray(incrementArray)
	console.log(incrementArray)
	return incrementArray
}
// betHandler(100, 'scoopy')
// slugRacingBetHandler()

async function findSnailWinner() {
	let winnings = slugHost.playerBet
	let line1 = lineFunc()
	let line2 = lineFunc()
    for (const slug in slugHost) {
        if (slugHost.playerSlug == slug) {
            if (slugHost[slugHost.playerSlug].place == 'first') {
				winnings *= 3
				await dialogueWait(2000)
				blankSpace()
				customizeEachWord(`Game Master`, 'gameMaster', line1)
				customizeEachWord(`: "Congratulations your snail won first place!"`, 'white', line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`Game Master `, 'gameMaster', line2)
				customizeEachWord(`hands you your winnings.`, 'white', line2)
				blankSpace()
				playerGainGold(winnings)
				blankSpace()
			}
			if (slugHost[slugHost.playerSlug].place == 'second') {
				winnings *= 2
				await dialogueWait(2000)
				blankSpace()
				customizeEachWord(`Game Master`, 'gameMaster', line1)
				customizeEachWord(`: "Congratulations your snail came in second place!"`, 'white', line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`Game Master `, 'gameMaster', line2)
				customizeEachWord(`hands you the winnings.`, 'white', line2)
				blankSpace()
				playerGainGold(winnings)
				blankSpace()
			}
			if (slugHost[slugHost.playerSlug].place == 'third') {
				await dialogueWait(2000)
				blankSpace()
				customizeEachWord(`Game Master`, 'gameMaster', line1)
				customizeEachWord(`: "Well, at least you didn't lose anything!"`, 'white', line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`Game Master `, 'gameMaster', line2)
				customizeEachWord(`gives you your gold back.`, 'white', line2)
				blankSpace()
				playerGainGold(winnings)
				blankSpace()
			}
			if (slugHost[slugHost.playerSlug].place == 'fourth') {
				await dialogueWait(2000)
				blankSpace()
				customizeEachWord(`Game Master`, 'gameMaster', line1)
				customizeEachWord(`: "Better luck next time!"`, 'white', line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`You lost `, 'white', line2)
				customizeEachWord(`${winnings} `, 'yellow', line2)
				customizeEachWord(`gold.`, 'white', line2)
				blankSpace()
			}
			if (slugHost[slugHost.playerSlug].place == 'fifth') {
				await dialogueWait(2000)
				blankSpace()
				customizeEachWord(`Game Master`, 'gameMaster', line1)
				customizeEachWord(`: "Oh man, not your lucky day.."`, 'white', line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`You lost `, 'white', line2)
				customizeEachWord(`${winnings} `, 'yellow', line2)
				customizeEachWord(`gold.`, 'white', line2)
				blankSpace()
			}
			if (slugHost[slugHost.playerSlug].place == 'sixth') {
				winnings *= 2
				await dialogueWait(2000)
				blankSpace()
				customizeEachWord(`Game Master`, 'gameMaster', line1)
				customizeEachWord(`: "Not good, not good at all.. Your snail came in last. You have to pay double."`, 'white', line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`You lost `, 'white', line2)
				customizeEachWord(`${winnings} `, 'yellow', line2)
				customizeEachWord(`gold.`, 'white', line2)
				blankSpace()
				playerLoseGold(winnings)
				blankSpace()
			}
        }
    }
}






let gambler = {}

let NPCConversationIntervals = {

}
let bossTimeouts = {

}

let playerBuffIntervals = {

}

let castBarAnimationFrames = {
	
}
let selectedFish
let fishBiteTimer
let fishTopEnd
let fishBotEnd
let shiftKeyPressed = false;
document.addEventListener('keyup', function(event) {
	if (event.shiftKey) {
		shiftKeyPressed = false;
	}
});

const cooldownBar = document.querySelector('.bar-1')
let empowerPlayerTimeout
let playerBuffs = []
let catalystTimeout
let sinisterMarksTimeout
let piercingArrowTimeout
let piercingArrowInterval
let buff1Interval
let noMove = 'you cannot move in that direction'
let commandLine = document.getElementById('commandLine')
commandLine.focus()
let pushMonster = []
let roomEnemies = []
let directionMoved
let dialogueSpeed = 0
//classes
let yellow = 'yellow'
let red = 'red'
let blue = 'blue'
let orange = 'orange'
let green = 'green'
let purple = 'purple'
let white = 'white'
let brown = 'brown'
let pink = 'pink'
let black = 'black'
//HTML elements
//____________________________________________________++SWING VOCABULARY++__________________________________________
//expertise, swing, weapon, enemy, number damage
let blockedDamage
// let playerBlockedDamage

function blankSpace() {
	if (masterArea.lastChild != undefined && masterArea.lastChild.classList.contains('hide')) {
	} else {
		let space = document.createElement('div')
		masterArea.appendChild(space)
		space.textContent = 'SPACE'
		space.classList.add('hide')
	}
	updateScroll()
}



function expertise(weapon) {
	console.log('expertise ran')
	let playerExpertiseLevel
	let playerExpertiseAdjective
	if (weapon.type.oneHanded == true) {
		playerExpertiseLevel = player.oneHanded.level
	} else if (weapon.type.twoHanded == true) {
		playerExpertiseLevel = player.twoHanded.level
	} else if (weapon.type.unarmed == true) {
		playerExpertiseLevel = player.unarmed.level
	} else if (weapon.type.daggers == true) {
		playerExpertiseLevel = player.daggers.level
	}

	if (playerExpertiseLevel <= 4) {
		playerExpertiseAdjective = 'clumsily '
	} else if (playerExpertiseLevel <= 7) {
		playerExpertiseAdjective = 'novicely '
	}

	return playerExpertiseAdjective
}


function oneHandedSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		oneHandedMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(' and miss!', 'white', line1)
		blankSpace()
	} else {
		oneHandedHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}
function bowSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		bowMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`fire an arrow from your `, 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} `, 'white', line1) //at
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord('and miss!', 'white', line1)
		blankSpace()
	} else {
		bowHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`fire an arrow from your `, 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}

function daggerSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		daggerMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord('and miss!', 'white', line1)
		blankSpace()
	} else {
		daggerHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}
// weapon, enemy, damage, penName, playerSwingType, atIntoOnto
function twoHandedSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		twoHandedMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord('and miss!', 'white', line1)
		blankSpace()
	} else {
		blankSpace()
		twoHandedHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage. ', 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}
function unarmedSwing1(enemy, swingObject) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	if (!swingObject.doesSwingHit) {
		unarmedMissArray1[randomNumberRange(0, 4)].play()
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`swing `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1) //at
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(' and miss!', 'white', line1)
		blankSpace()
	} else {
		unarmedHitArray1[randomNumberRange(0, 4)].play()
		let damageColor = swingObject.critDamage > 0 ? 'red' : 'light-blue'
		blankSpace()
		customizeEachWord('You ', 'light-blue', line1)
		customizeEachWord(`${swingObject.penetrationVerb} `, 'white', line1)
		customizeEachWord('your ', 'white', line1)
		customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
		customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord('You hit for ', 'green', line2)
		customizeEachWord(`${swingObject.realTotalDamage} `, damageColor, line2)
		if (swingObject.penetrationType) {
			customizeEachWord(`${swingObject.penetrationType} `, swingObject.penetrationType, line2)
		}
		customizeEachWord('damage.', 'green', line2)
		customizeEachWord(` (Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		// blankSpace()
		console.log('TEST TEST TEST')
	}
		console.log(swingObject, 'WEAPON AT WEAPONSWING')
}

function words(wordOrWords, color) {
	const messageSpan = document.createElement('span')
	messageSpan.textContent = wordOrWords
	messageSpan.classList.add(color)
	return messageSpan
}

function quickMessage(message, classChange) {
	const messageDiv = document.createElement('div')
	messageDiv.appendChild(words(message, classChange))
	masterArea.appendChild(messageDiv)
	updateScroll()
}

const dialoguePlay1 = document.createElement('audio')
const dialoguePlay2 = document.createElement('audio')
const dialoguePlay3 = document.createElement('audio')
const dialoguePlay4 = document.createElement('audio')
const dialoguePlay5 = document.createElement('audio')
dialoguePlay1.setAttribute('src', './sounds/dialogue/galvadia_text_lufia1.mp3')
dialoguePlay2.setAttribute('src', './sounds/dialogue/galvadia_text_lufia1.mp3')
dialoguePlay3.setAttribute('src', './sounds/dialogue/galvadia_text_lufia1.mp3')
dialoguePlay4.setAttribute('src', './sounds/dialogue/galvadia_text_lufia1.mp3')
dialoguePlay5.setAttribute('src', './sounds/dialogue/galvadia_text_lufia1.mp3')
const dialogueArray = [dialoguePlay1, dialoguePlay2, dialoguePlay3, dialoguePlay4, dialoguePlay5]
// dialoguePlay.setAttribute('src', 'galvadia_text_lufia.mp3')
////////////////////////////////////////////////////////////SPELLS
const healPlay1 = document.createElement('audio')
healPlay1.setAttribute(`src`, './magic/')

const fireSpellConjure = document.createElement('audio')
const fireflamesPlay1 = document.createElement('audio')
const fireflamesPlay2 = document.createElement('audio')
const fireflamesPlay3 = document.createElement('audio')
const infernoPlay1 = document.createElement('audio')
const infernoPlay2 = document.createElement('audio')
const infernoPlay3 = document.createElement('audio')
const meteorPlay1 = document.createElement('audio')
const meteorPlay2 = document.createElement('audio')
const meteorPlay3 = document.createElement('audio')
const fireflamesArray = [fireflamesPlay1, fireflamesPlay2, fireflamesPlay3]
const infernoArray = [infernoPlay1, infernoPlay2, infernoPlay3]
const meteorArray = [meteorPlay1, meteorPlay2, meteorPlay3]
fireSpellConjure.setAttribute('src', './magic/fire/conjure/fire conjure.mp3')
fireflamesPlay1.setAttribute('src', './magic/fire/fireflames/fireflames.mp3')
fireflamesPlay2.setAttribute('src', './magic/fire/fireflames/fireflames higher.mp3')
fireflamesPlay3.setAttribute('src', './magic/fire/fireflames/fireflames lower.mp3')
infernoPlay1.setAttribute('src', './magic/fire/inferno/inferno.mp3')
infernoPlay2.setAttribute('src', './magic/fire/inferno/inferno higher.mp3')
infernoPlay3.setAttribute('src', './magic/fire/inferno/inferno lower.mp3')
meteorPlay1.setAttribute('src', './magic/fire/meteor/meteor.mp3')
meteorPlay2.setAttribute('src', './magic/fire/meteor/meteor higher.mp3')
meteorPlay3.setAttribute('src', './magic/fire/meteor/meteor lower.mp3')


const iceSpellConjure = document.createElement('audio')
const frostfreezePlay1 = document.createElement('audio')
const frostfreezePlay2 = document.createElement('audio')
const frostfreezePlay3 = document.createElement('audio')
const blizzardPlay1 = document.createElement('audio')
const blizzardPlay2 = document.createElement('audio')
const blizzardPlay3 = document.createElement('audio')
const cryoclastPlay1 = document.createElement('audio')
const cryoclastPlay2 = document.createElement('audio')
const cryoclastPlay3 = document.createElement('audio')
const frostfreezeArray = [frostfreezePlay1, frostfreezePlay2, frostfreezePlay3]
const blizzardArray = [blizzardPlay1, blizzardPlay2, blizzardPlay3]
const cryoclastArray = [cryoclastPlay1, cryoclastPlay2, cryoclastPlay3]
iceSpellConjure.setAttribute('src', './magic/ice/conjure/ice conjure.mp3')
frostfreezePlay1.setAttribute('src', './magic/ice/frostfreeze/frostfreeze.mp3')
frostfreezePlay2.setAttribute('src', './magic/ice/frostfreeze/frostfreeze higher.mp3')
frostfreezePlay3.setAttribute('src', './magic/ice/frostfreeze/frostfreeze lower.mp3')
blizzardPlay1.setAttribute('src', './magic/ice/blizzard/blizzard.mp3')
blizzardPlay2.setAttribute('src', './magic/ice/blizzard/blizzard higher.mp3')
blizzardPlay3.setAttribute('src', './magic/ice/blizzard/blizzard lower.mp3')
cryoclastPlay1.setAttribute('src', './magic/ice/cryoclast/cryoclast.mp3')
cryoclastPlay2.setAttribute('src', './magic/ice/cryoclast/cryoclast higher.mp3')
cryoclastPlay3.setAttribute('src', './magic/ice/cryoclast/cryoclast lower.mp3')


const lightningSpellConjure = document.createElement('audio')
const flashboltPlay1 = document.createElement('audio')
const flashboltPlay2 = document.createElement('audio')
const flashboltPlay3 = document.createElement('audio')
const chainLightningPlay1 = document.createElement('audio')
const chainLightningPlay2 = document.createElement('audio')
const chainLightningPlay3 = document.createElement('audio')
const gigavoltPlay1 = document.createElement('audio')
const gigavoltPlay2 = document.createElement('audio')
const gigavoltPlay3 = document.createElement('audio')
const flashboltArray = [flashboltPlay1, flashboltPlay2, flashboltPlay3]
const chainLightningArray = [chainLightningPlay1, chainLightningPlay2, chainLightningPlay3]
const gigavoltArray = [gigavoltPlay1, gigavoltPlay2, gigavoltPlay3]
lightningSpellConjure.setAttribute('src', './magic/lightning/conjure/lightning conjure.mp3')
flashboltPlay1.setAttribute('src', './magic/lightning/flashbolt/flashbolt.mp3')
flashboltPlay2.setAttribute('src', './magic/lightning/flashbolt/flashbolt higher.mp3')
flashboltPlay3.setAttribute('src', './magic/lightning/flashbolt/flashbolt lower.mp3')
chainLightningPlay1.setAttribute('src', './magic/lightning/chain lightning/chain lightning.mp3')
chainLightningPlay2.setAttribute('src', './magic/lightning/chain lightning/chain lightning higher.mp3')
chainLightningPlay3.setAttribute('src', './magic/lightning/chain lightning/chain lightning lower.mp3')
gigavoltPlay1.setAttribute('src', './magic/lightning/gigavolt/gigavolt.mp3')
gigavoltPlay2.setAttribute('src', './magic/lightning/gigavolt/gigavolt higher.mp3')
gigavoltPlay3.setAttribute('src', './magic/lightning/gigavolt/gigavolt lower.mp3')
////////////////////////////////////////////////////////////ABILITIES//////////////////////////////////////////////////////
//////////////BERSERKER
const ripslashPlay1 = document.createElement('audio')
const ripslashPlay2 = document.createElement('audio')
const ripslashPlay3 = document.createElement('audio')
const ripslashAudioArray = [ripslashPlay1, ripslashPlay2, ripslashPlay3]
ripslashPlay1.setAttribute('src', './swings/abilities/ripslash/ripslash.mp3')
ripslashPlay2.setAttribute('src', './swings/abilities/ripslash/ripslash higher.mp3')
ripslashPlay3.setAttribute('src', './swings/abilities/ripslash/ripslash lower.mp3')

const cyclonePlay1 = document.createElement('audio')
const cyclonePlay2 = document.createElement('audio')
const cyclonePlay3 = document.createElement('audio')
const cycloneAudioArray = [cyclonePlay1, cyclonePlay2, cyclonePlay3]
cyclonePlay1.setAttribute('src', './swings/abilities/cyclone/cyclone.mp3')
cyclonePlay2.setAttribute('src', './swings/abilities/cyclone/cyclone higher.mp3')
cyclonePlay3.setAttribute('src', './swings/abilities/cyclone/cyclone lower.mp3')

const cataclysmPlay1 = document.createElement('audio')
const cataclysmPlay2 = document.createElement('audio')
const cataclysmPlay3 = document.createElement('audio')
const cataclysmAudioArray = [cataclysmPlay1, cataclysmPlay2, cataclysmPlay3]
cataclysmPlay1.setAttribute('src', './swings/abilities/cataclysm/cataclysm.mp3')
cataclysmPlay2.setAttribute('src', './swings/abilities/cataclysm/cataclysm higher.mp3')
cataclysmPlay3.setAttribute('src', './swings/abilities/cataclysm/cataclysm lower.mp3')
/////////////FIGHTER
/////////////KNIGHT
/////////////AMBUSH
const ambushPlay1 = document.createElement('audio')
const ambushPlay2 = document.createElement('audio')
const ambushPlay3 = document.createElement('audio')
const ambushAudioArray = [ambushPlay1, ambushPlay2, ambushPlay3]
ambushPlay1.setAttribute('src', './swings/abilities/ambush/ambush.mp3')
ambushPlay2.setAttribute('src', './swings/abilities/ambush/ambush higher.mp3')
ambushPlay3.setAttribute('src', './swings/abilities/ambush/ambush lower.mp3')

const backstabPlay1 = document.createElement('audio')
const backstabPlay2 = document.createElement('audio')
const backstabPlay3 = document.createElement('audio')
const backstabAudioArray = [backstabPlay1, backstabPlay2, backstabPlay3]
backstabPlay1.setAttribute('src', './swings/abilities/backstab/backstab.mp3')
backstabPlay2.setAttribute('src', './swings/abilities/backstab/backstab higher.mp3')
backstabPlay3.setAttribute('src', './swings/abilities/backstab/backstab lower.mp3')

const guillotinePlay1 = document.createElement('audio')
const guillotinePlay2 = document.createElement('audio')
const guillotinePlay3 = document.createElement('audio')
const guillotineAudioArray = [guillotinePlay1, guillotinePlay2, guillotinePlay3]
guillotinePlay1.setAttribute('src', './swings/abilities/guillotine/guillotine.mp3')
guillotinePlay2.setAttribute('src', './swings/abilities/guillotine/guillotine higher.mp3')
guillotinePlay3.setAttribute('src', './swings/abilities/guillotine/guillotine lower.mp3')







const shortswordHitPlay1 = document.createElement('audio')
const shortswordHitPlay2 = document.createElement('audio')
const shortswordHitPlay3 = document.createElement('audio')
const shortswordHitPlay4 = document.createElement('audio')
const shortswordHitPlay5 = document.createElement('audio')
const oneHandedHitArray1 = [shortswordHitPlay1, shortswordHitPlay2, shortswordHitPlay3, shortswordHitPlay4, shortswordHitPlay5]

shortswordHitPlay1.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_1.wav')
shortswordHitPlay2.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_2.wav')
shortswordHitPlay3.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_3.wav')
shortswordHitPlay4.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_4.wav')
shortswordHitPlay5.setAttribute('src', './swings/one_handed_swords/shortsword/hit/shortsword_hit_5.wav')

const shortswordMissPlay1 = document.createElement('audio')
const shortswordMissPlay2 = document.createElement('audio')
const shortswordMissPlay3 = document.createElement('audio')
const shortswordMissPlay4 = document.createElement('audio')
const shortswordMissPlay5 = document.createElement('audio')
const oneHandedMissArray1 = [shortswordMissPlay1, shortswordMissPlay2, shortswordMissPlay3, shortswordMissPlay4, shortswordMissPlay5]

shortswordMissPlay1.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_1.wav')
shortswordMissPlay2.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_2.wav')
shortswordMissPlay3.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_3.wav')
shortswordMissPlay4.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_4.wav')
shortswordMissPlay5.setAttribute('src', './swings/one_handed_swords/shortsword/miss/shortsword_miss_5.wav')
////////////////////////////////////////////////////////////
const longswordHitPlay1 = document.createElement('audio')
const longswordHitPlay2 = document.createElement('audio')
const longswordHitPlay3 = document.createElement('audio')
const longswordHitPlay4 = document.createElement('audio')
const longswordHitPlay5 = document.createElement('audio')
const twoHandedHitArray1 = [longswordHitPlay1, longswordHitPlay2, longswordHitPlay3, longswordHitPlay4, longswordHitPlay5]

longswordHitPlay1.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_1.mp3')
longswordHitPlay2.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_2.mp3')
longswordHitPlay3.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_3.mp3')
longswordHitPlay4.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_4.mp3')
longswordHitPlay5.setAttribute('src', './swings/two_handed_swords/longsword/hit/longsword_hit_5.mp3')

const longswordMissPlay1 = document.createElement('audio')
const longswordMissPlay2 = document.createElement('audio')
const longswordMissPlay3 = document.createElement('audio')
const longswordMissPlay4 = document.createElement('audio')
const longswordMissPlay5 = document.createElement('audio')
const twoHandedMissArray1 = [longswordMissPlay1, longswordMissPlay2, longswordMissPlay3, longswordMissPlay4, longswordMissPlay5]

longswordMissPlay1.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_1.wav')
longswordMissPlay2.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_2.wav')
longswordMissPlay3.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_3.wav')
longswordMissPlay4.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_4.wav')
longswordMissPlay5.setAttribute('src', './swings/two_handed_swords/longsword/miss/longsword_miss_5.wav')
////////////////////////////////////////////////////////////
const shivHitPlay1 = document.createElement('audio')
const shivHitPlay2 = document.createElement('audio')
const shivHitPlay3 = document.createElement('audio')
const shivHitPlay4 = document.createElement('audio')
const shivHitPlay5 = document.createElement('audio')
const daggerHitArray1 = [shivHitPlay1, shivHitPlay2, shivHitPlay3, shivHitPlay4, shivHitPlay5]

shivHitPlay1.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_1.wav')
shivHitPlay2.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_2.wav')
shivHitPlay3.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_3.wav')
shivHitPlay4.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_4.wav')
shivHitPlay5.setAttribute('src', './swings/daggers/shiv/hit/shiv_hit_5.wav')

const shivMissPlay1 = document.createElement('audio')
const shivMissPlay2 = document.createElement('audio')
const shivMissPlay3 = document.createElement('audio')
const shivMissPlay4 = document.createElement('audio')
const shivMissPlay5 = document.createElement('audio')
const daggerMissArray1 = [shivMissPlay1, shivMissPlay2, shivMissPlay3, shivMissPlay4, shivMissPlay5]

shivMissPlay1.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_1.wav')
shivMissPlay2.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_2.wav')
shivMissPlay3.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_3.wav')
shivMissPlay4.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_4.wav')
shivMissPlay5.setAttribute('src', './swings/daggers/shiv/miss/shiv_miss_5.wav')
////////////////////////////////////////////////////////////
const shortbowHitPlay1 = document.createElement('audio')
const shortbowHitPlay2 = document.createElement('audio')
const shortbowHitPlay3 = document.createElement('audio')
const shortbowHitPlay4 = document.createElement('audio')
const shortbowHitPlay5 = document.createElement('audio')
const bowHitArray1 = [shortbowHitPlay1, shortbowHitPlay2, shortbowHitPlay3, shortbowHitPlay4, shortbowHitPlay5]

shortbowHitPlay1.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_1.wav')
shortbowHitPlay2.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_2.wav')
shortbowHitPlay3.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_3.wav')
shortbowHitPlay4.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_4.wav')
shortbowHitPlay5.setAttribute('src', './swings/bows/shortbow/hit/shortbow_hit_5.wav')

const shortbowMissPlay1 = document.createElement('audio')
const shortbowMissPlay2 = document.createElement('audio')
const shortbowMissPlay3 = document.createElement('audio')
const shortbowMissPlay4 = document.createElement('audio')
const shortbowMissPlay5 = document.createElement('audio')
const bowMissArray1 = [shortbowMissPlay1, shortbowMissPlay2, shortbowMissPlay3, shortbowMissPlay4, shortbowMissPlay5]

shortbowMissPlay1.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_1.wav')
shortbowMissPlay2.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_2.wav')
shortbowMissPlay3.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_3.wav')
shortbowMissPlay4.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_4.wav')
shortbowMissPlay5.setAttribute('src', './swings/bows/shortbow/miss/shortbow_miss_5.wav')
////////////////////////////////////////////////////////////
const unarmedHitPlay1 = document.createElement('audio')
const unarmedHitPlay2 = document.createElement('audio')
const unarmedHitPlay3 = document.createElement('audio')
const unarmedHitPlay4 = document.createElement('audio')
const unarmedHitPlay5 = document.createElement('audio')
const unarmedHitArray1 = [unarmedHitPlay1, unarmedHitPlay2, unarmedHitPlay3, unarmedHitPlay4, unarmedHitPlay5]

unarmedHitPlay1.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_1.wav')
unarmedHitPlay2.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_2.wav')
unarmedHitPlay3.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_3.wav')
unarmedHitPlay4.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_4.wav')
unarmedHitPlay5.setAttribute('src', './swings/fist/unarmed/hit/unarmed_hit_5.wav')

const unarmedMissPlay1 = document.createElement('audio')
const unarmedMissPlay2 = document.createElement('audio')
const unarmedMissPlay3 = document.createElement('audio')
const unarmedMissPlay4 = document.createElement('audio')
const unarmedMissPlay5 = document.createElement('audio')
const unarmedMissArray1 = [unarmedMissPlay1, unarmedMissPlay2, unarmedMissPlay3, unarmedMissPlay4, unarmedMissPlay5]

unarmedMissPlay1.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_1.wav')
unarmedMissPlay2.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_2.wav')
unarmedMissPlay3.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_3.wav')
unarmedMissPlay4.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_4.wav')
unarmedMissPlay5.setAttribute('src', './swings/fist/unarmed/miss/unarmed_miss_5.wav')
////////////////////////////////////////////////////////////
/////////////////////OPEN CHEST AND SACK SOUNDS///////////////////
const smallSackOpen = document.createElement('audio')
const smallChestOpen = document.createElement('audio')
const largeChestOpen = document.createElement('audio')
smallSackOpen.setAttribute('src', './sounds/only gold/small gold.mp3')
smallChestOpen.setAttribute('src', './sounds/chests/small chest.mp3')
largeChestOpen.setAttribute('src', './sounds/chests/large chest.mp3')
/////////////////////OPEN CHEST AND SACK SOUNDS///////////////////


/////////////////////////COOKING///////////////////////////////
const cookFoodSound = document.createElement('audio')
cookFoodSound.setAttribute('src', './sounds/cooking/food sizzle/food sizzle.mp3')
/////////////////////////COOKING///////////////////////////////

/////////////////////////POTION DRINKING///////////////////////////////
const drinkPotionSound = document.createElement('audio')
drinkPotionSound.setAttribute('src', './sounds/potions/drink potion/drink potion.mp3')
/////////////////////////POTION DRINKING///////////////////////////////

/////////////////////////BLACKSMITHING///////////////////////////////
const blacksmithHammerSound = document.createElement('audio')
const blacksmithHammerSound2 = document.createElement('audio')
blacksmithHammerSound.setAttribute('src', './sounds/ambient sounds/blacksmith/blacksmith hammer.mp3')
blacksmithHammerSound2.setAttribute('src', './sounds/ambient sounds/blacksmith/blacksmith hammer 2.mp3')
/////////////////////////BLACKSMITHING///////////////////////////////

/////////////////////////WAGON///////////////////////////////
const wagonWheelSound = document.createElement('audio')
const wagonWheelSound2 = document.createElement('audio')
wagonWheelSound.setAttribute('src', './sounds/ambient sounds/wagon/wagon wheel.mp3')
wagonWheelSound2.setAttribute('src', './sounds/ambient sounds/wagon/wagon wheel 2.mp3')
/////////////////////////WAGON///////////////////////////////

/////////////////////////FISHING///////////////////////////////
const fishSplash1 = document.createElement('audio')
const fishSplash2 = document.createElement('audio')
const fishSplash3 = document.createElement('audio')
const fishSplashArray = [fishSplash1, fishSplash2, fishSplash3]
fishSplash1.setAttribute('src', './sounds/fishing/fish splash/fish splash 1.mp3')
fishSplash2.setAttribute('src', './sounds/fishing/fish splash/fish splash 2.mp3')
fishSplash3.setAttribute('src', './sounds/fishing/fish splash/fish splash 3.mp3')
function playFishSplash() {
	let randomNumber = randomNumberRange(0, 2)
	fishSplashArray[randomNumber].play()
}

const bobberSplash1 = document.createElement('audio')
const bobberSplash2 = document.createElement('audio')
const bobberSplash3 = document.createElement('audio')
bobberSplash1.setAttribute('src', './sounds/fishing/bobber splash/bobber splash 1.mp3')
bobberSplash2.setAttribute('src', './sounds/fishing/bobber splash/bobber splash 2.mp3')
bobberSplash3.setAttribute('src', './sounds/fishing/bobber splash/bobber splash 3.mp3')
const bobberSplashArray = [bobberSplash1, bobberSplash2, bobberSplash3]
function playBobberSplash() {
	let randomNumber = randomNumberRange(0, 2)
	bobberSplashArray[randomNumber].play()
}

const fishCatch1 = document.createElement('audio')
const fishCatch2 = document.createElement('audio')
const fishCatch3 = document.createElement('audio')
fishCatch1.setAttribute('src', './sounds/fishing/fish catch/fish catch 1.mp3')
fishCatch2.setAttribute('src', './sounds/fishing/fish catch/fish catch 2.mp3')
fishCatch3.setAttribute('src', './sounds/fishing/fish catch/fish catch 3.mp3')
const fishCatchArray = [fishCatch1, fishCatch2, fishCatch3]
function playFishCatch() {
	let randomNumber = randomNumberRange(0, 2)
	fishCatchArray[randomNumber].play()
}

/////////////////////////FISHING///////////////////////////////



function dialogue(gameDialogue, textColor) {
	dialogueFinished = false
	let stopSound = false
	player.dialogueStasis = true
	const text = gameDialogue
	let timer
	let i = 0
	let textBox = document.createElement('span')
	if (textColor != undefined) {
		textBox.classList.add(textColor)
	} else {
		textBox.classList.add(textColor, 'light-blue')
	}
	setTimeout(() => {
		masterArea.appendChild(textBox)
		if (dialogueSpeed == 0 || dialogueSpeed == 'instant') {
			player.dialogueStasis = false
			let textNode = document.createTextNode(text)
			textBox.appendChild(textNode)
			updateScroll()
		} else {
			dialoguePlay.play()
			function dialogueInterval() {
				let textNode = document.createTextNode(text[i])
				// playSound()
				textBox.appendChild(textNode)
				updateScroll()
				i++

				if (i == text.length) {
					player.dialogueStasis = false
					stopSound = true
					if (stopSound == true) {
						dialoguePlay.pause()
					}
				}
				if (i >= text.length) {
					dialogueFinished = true
					clearInterval(timer)
				}
			}
			timer = setInterval(dialogueInterval, dialogueSpeed)
		}
	}, 200)
}
function npcDialogue(gameDialogue, textColor) {
	dialogueFinished = false
	let stopSound = false
	player.dialogueStasis = true
	const beginQuote = document.createElement('span')
	beginQuote.classList.add('white')
	beginQuote.textContent = '"'
	const endQuote = document.createElement('span')
	endQuote.classList.add('white')
	endQuote.textContent = '"'
	const text = gameDialogue
	let timer
	let i = 0
	let textBox = document.createElement('div')
	textBox.classList.add('npc-dialogue')
	if (textColor != undefined) {
		textBox.classList.add(textColor)
	} else {
		textBox.classList.add(textColor, 'orange')
	}
	setTimeout(() => {
		blankSpace()
		masterArea.appendChild(textBox)
		if (dialogueSpeed == 0 || dialogueSpeed == 'instant') {
			player.dialogueStasis = false
			let textNode = document.createTextNode(`${text}`)
			textBox.appendChild(beginQuote)
			textBox.appendChild(textNode)
			textBox.appendChild(endQuote)
			updateScroll()
		} else {
			dialoguePlay.play()
			textBox.appendChild(beginQuote)
			function dialogueInterval() {
				let textNode = document.createTextNode(text[i])
				// playSound()
				textBox.appendChild(textNode)
				updateScroll()
				i++

				if (i == text.length) {
					player.dialogueStasis = false
					stopSound = true
					if (stopSound == true) {
						dialoguePlay.pause()
						textBox.appendChild(endQuote)
					}
				}
				if (i >= text.length) {
					blankSpace()
					dialogueFinished = true
					clearInterval(timer)
				}
			}
			timer = setInterval(dialogueInterval, dialogueSpeed)
		}
	}, 0)
}

function gameDialogue(gameDialogue) {
	dialogueFinished = false
	player.dialogueStasis = true
	const text = gameDialogue
	let timer
	let i = 0
	let textBox = document.createElement('span')
	textBox.classList.add('game-dialogue')
	setTimeout(() => {
		blankSpace()
		masterArea.appendChild(textBox)
		if (dialogueSpeed == 0 || dialogueSpeed == 'instant') {
			player.dialogueStasis = false
			let textNode = document.createTextNode(text)
			textBox.appendChild(textNode)
			blankSpace()
			updateScroll()
		} else {
			function dialogueInterval() {
				let textNode = document.createTextNode(text[i])
				// playSound()
				textBox.appendChild(textNode)
				updateScroll()
				i++
				if (i == text.length) {
					player.dialogueStasis = false
				}
				if (i >= text.length) {
					dialogueFinished = true
					clearInterval(timer)
				}
			}
			timer = setInterval(dialogueInterval, dialogueSpeed)
		}
	}, 200)
}

function sellItemDialog(itemName, sellValue) {
	let line1 = document.createElement('div')
	blankSpace()
	customizeEachWord(`You sell your `, 'white', line1)
	customizeEachWord(`${itemName} `, 'green', line1)
	customizeEachWord(`for `, 'white', line1)
	customizeEachWord(`${sellValue} `, 'yellow', line1)
	customizeEachWord(`gold piece(s)`, 'white', line1)
	blankSpace()
}
function createDivElement(text, classNames = []) {
	const div = document.createElement('div');
	div.textContent = text;
	div.classList.add(...classNames);
	return div;
}
function weaponDescription(item) {
	const mainDiv = document.createElement('div');
	mainDiv.classList.add('item-description');

	//type
	let damageOrDefenseDiv = item.type.weapon ? 'Damage' : 'Armor'

	const itemNameDiv = createDivElement(item.name, ['item-description-name', item.color]);
	const typeDiv = createDivElement(`Type: ${item.type.skillUsed}`);
	const swingTypeDiv = createDivElement(`Swing Type: ${item.type.swingType}`) 
	const damageDiv = createDivElement(`${damageOrDefenseDiv}:`, ['row-flex'])
	let damageNumberDiv 
	if (item.type.weapon) {
		damageNumberDiv = createDivElement(`${item.botDamage} - ${item.topDamage}`, ['light-blue', 'small-left-margin']);
	}
	if (item.type.armor) {
		damageNumberDiv = createDivElement(`${item.mods.armor}`, ['light-blue', 'small-left-margin']);

	}
	const sellValueDiv = createDivElement('', ['row-flex']);
	const sellWordDiv = createDivElement('Value:');
	const sellNumberDiv = createDivElement(`${item.sellValue}`, ['yellow', 'small-left-margin']);

	damageDiv.appendChild(damageNumberDiv);
	sellValueDiv.appendChild(sellWordDiv);
	sellValueDiv.appendChild(sellNumberDiv);
	mainDiv.appendChild(itemNameDiv);
	mainDiv.appendChild(typeDiv);
	mainDiv.appendChild(swingTypeDiv);
	mainDiv.appendChild(damageDiv);
	masterArea.appendChild(mainDiv);
	if (item.mods) {
		const modsContainer = createDivElement()
		modsContainer.classList.add('simple-flex-column')
		const modHeader = createDivElement()
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		let wordsAndColors = []
		for (let mod in item.mods) {
			let modAbbreviation = mod
			if (mod == 'str') {mod = 'Strength'}
			if (mod == 'con') {mod = 'Constitution'}
			if (mod == 'dex') {mod = 'Dexterity'}
			if (mod == 'agi') {mod = 'Agility'}
			if (mod == 'int') {mod = 'Intelligence'}
			if (mod == 'wis') {mod = 'Wisdom'}
			if (mod == 'slashingPen') {mod = 'Slashing Penetration'}
			if (mod == 'piercingPen') {mod = 'Piercing Penetration'}
			if (mod == 'bluntPen') {mod = 'Blunt Penetration'}
			console.log(mod)
			console.log(modAbbreviation)
			console.log(item[mod])
			if (item.mods[modAbbreviation] > 0) {
			if (mod != 'armor' && !item.type.armor) {
				wordsAndColors.push({number: item.mods[modAbbreviation], word: mod, color: 'green'})
			}
		}
		}
		wordsAndColors.forEach(item => {
			let span = document.createElement('span')
			let numberSpan = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(span)
			mainSpan.appendChild(numberSpan)
			numberSpan.classList.add(item.color)
			span.textContent = capitalizeFirstLetter(item.word)
			numberSpan.textContent = ' ' +  '+' + item.number 
			
			modsContainer.appendChild(mainSpan)
		})
	}
	mainDiv.appendChild(sellValueDiv)
	if (item.requirements) {
		if (Object.keys(item.requirements).length != 0) {
		const modsContainer = createDivElement()
		const modHeader = document.createElement('span')
		modHeader.textContent = 'Requirements'
		modHeader.classList.add('red')
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		modsContainer.classList.add('simple-flex-column', 'requirements')

		let wordsAndColors = []
		for (let requirement in item.requirements) {
			let originalRequirement = requirement
			if (requirement == 'str') {requirement = 'Strength'}
			if (requirement == 'con') {requirement = 'Constitution'}
			if (requirement == 'dex') {requirement = 'Dexterity'}
			if (requirement == 'agi') {requirement = 'Agility'}
			if (requirement == 'int') {requirement = 'Intelligence'}
			if (requirement == 'wis') {requirement = 'Wisdom'}
			wordsAndColors.push({number: item.requirements[originalRequirement], word: requirement, color: 'yellow'})
		}
		wordsAndColors.forEach(item => {
			let wordSpan = document.createElement('span')
			let numberSpan = document.createElement('span')
			let openParenth = document.createElement('span')
			let closeParenth = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(wordSpan)
			mainSpan.appendChild(openParenth)
			mainSpan.appendChild(numberSpan)
			mainSpan.appendChild(closeParenth)
			wordSpan.textContent = item.word
			openParenth.textContent = ' ('
			numberSpan.classList.add(item.color)
			numberSpan.textContent = item.number
			closeParenth.textContent = ')'
			modsContainer.appendChild(mainSpan)
		})
	}

	}
	mainDiv.appendChild(createDivElement(item.description, ['item-flavor-text']));
	// mainDiv.appendChild(createDivElement(`Location: ${item.roomId}`))
}
function armorDescription(item) {
	quickMessage(`armor description ran`)
	const mainDiv = document.createElement('div');
	mainDiv.classList.add('item-description');
	function createDivElement(text, classNames = []) {
		const div = document.createElement('div');
		div.textContent = text;
		div.classList.add(...classNames);
		return div;
	}
	//weight
	let defense = 'Armor'

	const itemNameDiv = createDivElement(item.name, ['item-description-name', item.color]);
	const typeDiv = createDivElement(`Type: ${item.type.armorType}`);
	const defenseDiv = createDivElement(`${defense}:`, ['row-flex'])
	const weightDiv = createDivElement(`Weight: `, ['row-flex'])
	let armorNumberDiv
	let weightNumberDiv = createDivElement(`${item.mods.weight}`, ['light-blue', 'small-left-margin'])
	if (item.type.armor) {
		armorNumberDiv = createDivElement(`${item.mods.armor}`, ['light-blue', 'small-left-margin']);
	}
	const sellValueDiv = createDivElement('', ['row-flex']);
	const sellWordDiv = createDivElement('Value:', 'white');
	const sellNumberDiv = createDivElement(`${item.sellValue}`, ['yellow', 'small-left-margin']);

	defenseDiv.appendChild(armorNumberDiv);
	weightDiv.appendChild(weightNumberDiv);
	sellValueDiv.appendChild(sellWordDiv);
	sellValueDiv.appendChild(sellNumberDiv);

	mainDiv.appendChild(itemNameDiv);
	mainDiv.appendChild(createDivElement(item.description, ['item-flavor-text']));
	mainDiv.appendChild(typeDiv);
	mainDiv.appendChild(defenseDiv);
	mainDiv.appendChild(weightDiv);

	if (item.mods) {
		const modsContainer = createDivElement()
		modsContainer.classList.add('simple-flex-column')
		const modHeader = createDivElement()
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		let wordsAndColors = []
		for (let mod in item.mods) {
			let modAbbreviation = mod
			if (mod == 'str') {mod = 'Strength'}
			if (mod == 'con') {mod = 'Constitution'}
			if (mod == 'dex') {mod = 'Dexterity'}
			if (mod == 'agi') {mod = 'Agility'}
			if (mod == 'int') {mod = 'Intelligence'}
			if (mod == 'wis') {mod = 'Wisdom'}
			if (mod == 'slashingPen') {mod = 'Slashing Penetration'}
			if (mod == 'piercingPen') {mod = 'Piercing Penetration'}
			if (mod == 'bluntPen') {mod = 'Blunt Penetration'}
			console.log(mod)
			console.log(modAbbreviation)
			console.log(item[mod])
			if (item.mods[modAbbreviation] > 0) {
			if (mod != 'armor' && mod != 'weight') {
				wordsAndColors.push({number: item.mods[modAbbreviation], word: mod, color: 'green'})
			}
		}
		}
		wordsAndColors.forEach(item => {
			let span = document.createElement('span')
			let numberSpan = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(numberSpan)
			mainSpan.appendChild(span)
			numberSpan.classList.add(item.color)
			numberSpan.textContent = '+' + item.number + ' '
			span.textContent = item.word
			modsContainer.appendChild(mainSpan)
		})
	}

	if (item.requirements) {
		if (Object.keys(item.requirements).length != 0) {
		const modsContainer = createDivElement()
		const modHeader = document.createElement('span')
		modHeader.textContent = 'Requirements'
		modHeader.classList.add('red')
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		modsContainer.classList.add('simple-flex-column', 'requirements')

		let wordsAndColors = []
		for (let requirement in item.requirements) {
			let originalRequirement = requirement
			if (requirement == 'str') {requirement = 'Strength'}
			if (requirement == 'con') {requirement = 'Constitution'}
			if (requirement == 'dex') {requirement = 'Dexterity'}
			if (requirement == 'agi') {requirement = 'Agility'}
			if (requirement == 'int') {requirement = 'Intelligence'}
			if (requirement == 'wis') {requirement = 'Wisdom'}
			wordsAndColors.push({number: item.requirements[originalRequirement], word: requirement, color: 'yellow'})
		}
		wordsAndColors.forEach(item => {
			let wordSpan = document.createElement('span')
			let numberSpan = document.createElement('span')
			let openParenth = document.createElement('span')
			let closeParenth = document.createElement('span')
			let mainSpan = document.createElement('span')
			mainSpan.appendChild(wordSpan)
			mainSpan.appendChild(openParenth)
			mainSpan.appendChild(numberSpan)
			mainSpan.appendChild(closeParenth)
			wordSpan.textContent = item.word
			openParenth.textContent = ' ('
			numberSpan.classList.add(item.color)
			numberSpan.textContent = item.number
			closeParenth.textContent = ')'
			modsContainer.appendChild(mainSpan)
		})
	}
	}
	mainDiv.appendChild(sellValueDiv)
	masterArea.appendChild(mainDiv);
}


// function armorDescription(item) {
// 	const mainDiv = document.createElement('div')
// 	mainDiv.classList.add('item-description')
// 	// const locationDiv = document.createElement('div')
// 	// const locationNode = document.createTextNode(`Location: ${item.roomId}`)
// 	// locationDiv.appendChild(locationNode)
// 	const itemNameDiv = document.createElement('div')
// 	itemNameDiv.classList.add(item.color)
// 	itemNameDiv.classList.add('item-description-name')
// 	const itemNameNode = document.createTextNode(`${item.name}`)
// 	itemNameDiv.appendChild(itemNameNode)
// 	const itemDescriptionDiv = document.createElement('p')
// 	itemDescriptionDiv.classList.add('grey', 'italic')
// 	const itemDescriptionNode = document.createTextNode(`${item.description}`)
// 	itemDescriptionDiv.appendChild(itemDescriptionNode)
// 	mainDiv.appendChild(itemNameDiv)
// 	let itemValues = Object.values(item.mods)
// 	let itemKeys = Object.keys(item.mods)

// 	for (let i = 0; i < itemKeys.length; i++) {
// 		if (itemKeys[i] == 'armor') {
// 			itemKeys[i] = 'Armor'
// 			const armorDiv = document.createElement('div')
// 			const armorWordDiv = document.createElement('div')
// 			const armorNumberDiv = document.createElement('div')
// 			armorDiv.classList.add('row-flex')
// 			armorNumberDiv.classList.add('light-blue')
// 			armorNumberDiv.classList.add('small-left-margin')
// 			const armorWord = document.createTextNode(`Armor:`)
// 			const armorNumber = document.createTextNode(`${itemValues[i]}`)
// 			armorWordDiv.appendChild(armorWord)
// 			armorNumberDiv.appendChild(armorNumber)
// 			armorWordDiv.appendChild(armorWord)
// 			armorNumberDiv.appendChild(armorNumber)
// 			armorDiv.appendChild(armorWordDiv)
// 			armorDiv.appendChild(armorNumberDiv)
// 			mainDiv.appendChild(armorDiv)
// 			itemKeys.splice(itemKeys.indexOf(itemKeys[i]), 1)
// 		}
// 	}
// 	const modsContainer = document.createElement('div')
// 	modsContainer.classList.add('column-flex')
// 	const modHeader = document.createElement('div')
// 	modsContainer.appendChild(modHeader)
// 	const modText = document.createTextNode(`Stat Bonus`)
// 	modHeader.appendChild(modText)
// 	mainDiv.appendChild(modsContainer)
// 	for (let i = 0; i < itemKeys.length; i++) {
// 		let textDiv = document.createElement('div')
// 		if (itemKeys[i] == 'armor') {
// 		} else if (itemKeys[i] == 'str') {
// 			itemKeys[i] = 'Strength'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'dex') {
// 			itemKeys[i] = 'Dexterity'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'agi') {
// 			itemKeys[i] = 'Agility'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'con') {
// 			itemKeys[i] = 'Constitution'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'int') {
// 			itemKeys[i] = 'Intellect'
// 			textDiv.classList.add('green')
// 		} else if (itemKeys[i] == 'wis') {
// 			itemKeys[i] = 'Wisdom'
// 			textDiv.classList.add('green')
// 		} else {
// 			let textNode = document.createTextNode(`+${itemValues[i]} ${itemKeys[i]} `)
// 			textDiv.appendChild(textNode)
// 			modsContainer.appendChild(textDiv)
// 		}
// 	}
// 	const sellValueDiv = document.createElement('div')
// 	const sellWordDiv = document.createElement('div')
// 	const sellNumberDiv = document.createElement('div')
// 	sellNumberDiv.classList.add('small-left-margin')
// 	sellValueDiv.classList.add('row-flex')
// 	sellValueDiv.appendChild(sellWordDiv)
// 	sellValueDiv.appendChild(sellNumberDiv)

// 	const sellWordNode = document.createTextNode(`Value:`)
// 	const sellNumberNode = document.createTextNode(`${item.sellValue}`)

// 	sellWordDiv.appendChild(sellWordNode)
// 	sellNumberDiv.appendChild(sellNumberNode)

// 	sellNumberDiv.classList.add('yellow')
// 	mainDiv.appendChild(sellValueDiv)
// 	// mainDiv.appendChild(locationDiv)
// 	mainDiv.appendChild(itemDescriptionDiv)
// 	masterArea.appendChild(mainDiv)
// }

function allItemDescription(item) {
	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')
	masterArea.appendChild(mainDiv)
//description
	const itemNameDiv = document.createElement('div')
	const itemNameNode = document.createTextNode(`${item.name}`)
	itemNameDiv.classList.add(item.color)
	itemNameDiv.classList.add('item-description-name')
	itemNameDiv.appendChild(itemNameNode)
	mainDiv.appendChild(itemNameDiv)
	//slashingarmor
	if (item.description) {
		const itemDescriptionDiv = document.createElement('p')
		const itemDescriptionNode = document.createTextNode(`${item.description}`)
		itemDescriptionDiv.classList.add('grey', 'italic')
		itemDescriptionDiv.appendChild(itemDescriptionNode)
		mainDiv.appendChild(itemDescriptionDiv)
	}
	if (item.type?.skillUsed) {
		const itemTypeDiv = document.createElement('div')
		const itemTypeNode = document.createTextNode(`Weapon Skill: ${item.type.skillUsed}`)
		itemTypeDiv.appendChild(itemTypeNode)
		mainDiv.appendChild(itemTypeDiv)
	}
	if (item.type?.armorType) {
		const damageTypeDiv = document.createElement('div')
		const damageTypeNode = document.createTextNode(`Armor Type: ${item.type.armorType}`)
		damageTypeDiv.appendChild(damageTypeNode)
		mainDiv.appendChild(damageTypeDiv)
	}
	if (item.mods?.slashingArmor) {
		const slashingArmorDiv = document.createElement('div')
		const slashingArmorWordDiv = createDivElement(`Slashing Armor: `, ['row-flex'])
		const slashingArmorValueDiv = createDivElement((`${item.mods.slashingArmor}`), ['light-blue', 'small-left-margin'])
		slashingArmorWordDiv.appendChild(slashingArmorValueDiv)
		slashingArmorDiv.appendChild(slashingArmorWordDiv)
		mainDiv.appendChild(slashingArmorDiv)
		if (item?.blacksmithing?.slashingArmor) {
			let originalStat = item.mods.slashingArmor
			let enhancedStat = item.blacksmithing.slashingArmor
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			slashingArmorWordDiv.appendChild(openP)
			slashingArmorWordDiv.appendChild(modTotal)
			slashingArmorWordDiv.appendChild(enhancedModConcat)
			slashingArmorWordDiv.appendChild(enhancedModNumber)
			slashingArmorWordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.piercingArmor) {
		const piercingArmorDiv = document.createElement('div')
		const piercingArmorWordDiv = createDivElement(`Piercing Armor: `, ['row-flex'])
		const piercingArmorValueDiv = createDivElement((`${item.mods.piercingArmor}`), ['light-blue', 'small-left-margin'])
		piercingArmorWordDiv.appendChild(piercingArmorValueDiv)
		piercingArmorDiv.appendChild(piercingArmorWordDiv)
		mainDiv.appendChild(piercingArmorDiv)
		if (item?.blacksmithing?.piercingArmor) {
			let originalStat = item.mods.piercingArmor
			let enhancedStat = item.blacksmithing.piercingArmor
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			piercingArmorWordDiv.appendChild(openP)
			piercingArmorWordDiv.appendChild(modTotal)
			piercingArmorWordDiv.appendChild(enhancedModConcat)
			piercingArmorWordDiv.appendChild(enhancedModNumber)
			piercingArmorWordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.bluntArmor) {
		const bluntArmorDiv = document.createElement('div')
		const bluntArmorWordDiv = createDivElement(`Blunt Armor: `, ['row-flex'])
		const bluntArmorValueDiv = createDivElement((`${item.mods.bluntArmor}`), ['light-blue', 'small-left-margin'])
		bluntArmorWordDiv.appendChild(bluntArmorValueDiv)
		bluntArmorDiv.appendChild(bluntArmorWordDiv)
		mainDiv.appendChild(bluntArmorDiv)
		if (item?.blacksmithing?.bluntArmor) {
			let originalStat = item.mods.bluntArmor
			let enhancedStat = item.blacksmithing.bluntArmor
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			bluntArmorWordDiv.appendChild(openP)
			bluntArmorWordDiv.appendChild(modTotal)
			bluntArmorWordDiv.appendChild(enhancedModConcat)
			bluntArmorWordDiv.appendChild(enhancedModNumber)
			bluntArmorWordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.fireResist) {
		const fireResistDiv = document.createElement('div')
		const fireResistWordDiv = createDivElement(`Fire Resist: `, ['row-flex'])
		const fireResistValueDiv = createDivElement((`${item.mods.fireResist}`), ['light-blue', 'small-left-margin'])
		fireResistWordDiv.appendChild(fireResistValueDiv)
		fireResistDiv.appendChild(fireResistWordDiv)
		mainDiv.appendChild(fireResistDiv)
		if (item?.leatherworking?.fireResist) {
			let originalStat = item.mods.fireResist
			let enhancedStat = item.leatherworking.fireResist
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			fireResistWordDiv.appendChild(openP)
			fireResistWordDiv.appendChild(modTotal)
			fireResistWordDiv.appendChild(enhancedModConcat)
			fireResistWordDiv.appendChild(enhancedModNumber)
			fireResistWordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.iceResist) {
		const div = document.createElement('div')
		const wordDiv = createDivElement(`Ice Resist: `, ['row-flex'])
		const valueDiv = createDivElement((`${item.mods.iceResist}`), ['light-blue', 'small-left-margin'])
		wordDiv.appendChild(valueDiv)
		div.appendChild(wordDiv)
		mainDiv.appendChild(div)
		if (item?.leatherworking?.iceResist) {
			let originalStat = item.mods.iceResist
			let enhancedStat = item.leatherworking.iceResist
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			wordDiv.appendChild(openP)
			wordDiv.appendChild(modTotal)
			wordDiv.appendChild(enhancedModConcat)
			wordDiv.appendChild(enhancedModNumber)
			wordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.lightningResist) {
		const div = document.createElement('div')
		const wordDiv = createDivElement(`Lightning Resist: `, ['row-flex'])
		const valueDiv = createDivElement((`${item.mods.lightningResist}`), ['light-blue', 'small-left-margin'])
		wordDiv.appendChild(valueDiv)
		div.appendChild(wordDiv)
		mainDiv.appendChild(div)
		if (item?.leatherworking?.lightningResist) {
			let originalStat = item.mods.lightningResist
			let enhancedStat = item.leatherworking.lightningResist
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			wordDiv.appendChild(openP)
			wordDiv.appendChild(modTotal)
			wordDiv.appendChild(enhancedModConcat)
			wordDiv.appendChild(enhancedModNumber)
			wordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.waterResist) {
		const div = document.createElement('div')
		const wordDiv = createDivElement(`Water Resist: `, ['row-flex'])
		const valueDiv = createDivElement((`${item.mods.waterResist}`), ['light-blue', 'small-left-margin'])
		wordDiv.appendChild(valueDiv)
		div.appendChild(wordDiv)
		mainDiv.appendChild(div)
		if (item?.leatherworking?.waterResist) {
			let originalStat = item.mods.waterResist
			let enhancedStat = item.leatherworking.waterResist
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			wordDiv.appendChild(openP)
			wordDiv.appendChild(modTotal)
			wordDiv.appendChild(enhancedModConcat)
			wordDiv.appendChild(enhancedModNumber)
			wordDiv.appendChild(closeP)
		}
	}
	if (item.mods?.windResist) {
		const div = document.createElement('div')
		const wordDiv = createDivElement(`Wind Resist: `, ['row-flex'])
		const valueDiv = createDivElement((`${item.mods.windResist}`), ['light-blue', 'small-left-margin'])
		wordDiv.appendChild(valueDiv)
		div.appendChild(wordDiv)
		mainDiv.appendChild(div)
		if (item?.leatherworking?.windResist) {
			let originalStat = item.mods.windResist
			let enhancedStat = item.leatherworking.windResist
			let openP = createDivElement(`(`, ['small-left-margin'])
			let modTotal = createDivElement(`${originalStat - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+ `, ['row-flex', 'small-left-margin'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green', 'small-left-margin'])
			let closeP = createDivElement(`)`)
			wordDiv.appendChild(openP)
			wordDiv.appendChild(modTotal)
			wordDiv.appendChild(enhancedModConcat)
			wordDiv.appendChild(enhancedModNumber)
			wordDiv.appendChild(closeP)
		}
	}
	if (item.type?.damageType) {
		const damageTypeDiv = document.createElement('div')
		const damageTypeNode = document.createTextNode(`Damage Type: ${item.type.damageType}`)
		damageTypeDiv.appendChild(damageTypeNode)
		mainDiv.appendChild(damageTypeDiv)
	}
	if (item.type?.food) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Type: Food`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
		if (item.cookable) {
			const cookableDiv = document.createElement('div')
			const cookableNode = document.createTextNode(`Cookable: Yes`)
			cookableDiv.appendChild(cookableNode)
			mainDiv.appendChild(cookableDiv)
		} else {
			const cookableDiv = document.createElement('div')
			const cookableNode = document.createTextNode(`Cookable: No`)
			cookableDiv.appendChild(cookableNode)
			mainDiv.appendChild(cookableDiv)
		}
	}
	if (item.type?.quest) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Type: Quest Item/Sellable`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
	}
	if (item.type?.sell) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Use: Its only use is to be sold`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
	}
	if (item.type?.crafting) {
		const foodDiv = document.createElement('div')
		const foodNode = document.createTextNode(`Type: Crafting Material`)
		foodDiv.appendChild(foodNode)
		mainDiv.appendChild(foodDiv)
	}
	if (item?.buff) {
		if (item.buff?.healthBonus > 0) {
			const healthRecoveredDiv = createDivElement(`Health Recovery: `, ['row-flex'])
			const healthValueRecoveredNode = createDivElement(`${item.buff.healthBonus} `, ['light-blue', 'small-left-margin'])
			// const recoveredTextNode = createDivElement(`recovered per tick`, ['small-left-margin'])
			healthRecoveredDiv.appendChild(healthValueRecoveredNode)
			// healthRecoveredDiv.appendChild(recoveredTextNode)
			mainDiv.appendChild(healthRecoveredDiv)
		}
		if (item.buff?.manaBonus > 0) {
			const manaRecoveredDiv = createDivElement(`Mana Recovery: `, ['row-flex'])
			const manaValueRecoveredNode = createDivElement(`${item.buff.manaBonus} `, ['light-blue', 'small-left-margin'])
			// const recoveredTextNode = createDivElement(`recovered per tick`, ['small-left-margin'])
			manaRecoveredDiv.appendChild(manaValueRecoveredNode)
			// manaRecoveredDiv.appendChild(recoveredTextNode)
			mainDiv.appendChild(manaRecoveredDiv)
		}

	}
	if (item?.botDamage) {
		let damageWordDiv = createDivElement(`Damage: `, ['row-flex'])
		let highWordDiv = createDivElement(`High Damage: `, ['row-flex'])
		let lowWordDiv = createDivElement(`Low Damage: `, ['row-flex'])
		let damageValuesDiv = createDivElement(`${item.botDamage} - ${item.topDamage}`, ['light-blue', 'small-left-margin'])
		let highDamageValue = createDivElement(`${item.topDamage}`, ['light-blue', 'small-left-margin'])
		let lowDamageValue = createDivElement(`${item.botDamage}`, ['light-blue', 'small-left-margin'])
		damageWordDiv.appendChild(damageValuesDiv)
		highWordDiv.appendChild(highDamageValue)
		lowWordDiv.appendChild(lowDamageValue)
		mainDiv.appendChild(damageWordDiv)
		mainDiv.appendChild(highWordDiv)
		mainDiv.appendChild(lowWordDiv)
		if (item?.blacksmithing?.topDamage) {
			let enhancedStat = item.blacksmithing.topDamage
			highDamageValue = createDivElement(`${item.topDamage - enhancedStat}`, ['light-blue', 'small-left-margin'])
			let openP = createDivElement(`(`, ['small-left-margin'])
			let originalNumber = createDivElement(`${item.topDamage - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+`, ['row-flex'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green'])
			let closeP = createDivElement(`)`)
			highWordDiv.appendChild(openP)
			highWordDiv.appendChild(originalNumber)
			highWordDiv.appendChild(enhancedModConcat)
			highWordDiv.appendChild(enhancedModNumber)
			highWordDiv.appendChild(closeP)
		}
		if (item?.blacksmithing?.botDamage) {
			let enhancedStat = item.blacksmithing.botDamage
			highDamageValue = createDivElement(`${item.botDamage - enhancedStat}`, ['light-blue', 'small-left-margin'])
			let openP = createDivElement(`(`, ['small-left-margin'])
			let originalNumber = createDivElement(`${item.botDamage - enhancedStat}`, ['light-blue'])
			let enhancedModConcat = createDivElement(`+`, ['row-flex'])
			let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green'])
			let closeP = createDivElement(`)`)
			lowWordDiv.appendChild(openP)
			lowWordDiv.appendChild(originalNumber)
			lowWordDiv.appendChild(enhancedModConcat)
			lowWordDiv.appendChild(enhancedModNumber)
			lowWordDiv.appendChild(closeP)
		}
		// if (item?.leatherworking) {
		// 	let enhancedStat = item.leatherworking.botDamage
		// 	highDamageValue = createDivElement(`${item.botDamage - enhancedStat}`, ['light-blue', 'small-left-margin'])
		// 	let openP = createDivElement(`(`, ['small-left-margin'])
		// 	let originalNumber = createDivElement(`${item.botDamage - enhancedStat}`, ['light-blue'])
		// 	let enhancedModConcat = createDivElement(`+`, ['row-flex'])
		// 	let enhancedModNumber = createDivElement((`${enhancedStat}`), ['green'])
		// 	let closeP = createDivElement(`)`)
		// 	lowWordDiv.appendChild(openP)
		// 	lowWordDiv.appendChild(originalNumber)
		// 	lowWordDiv.appendChild(enhancedModConcat)
		// 	lowWordDiv.appendChild(enhancedModNumber)
		// 	lowWordDiv.appendChild(closeP)
		// }
	}

	if (item?.mods) {
		const modsContainer = createDivElement()
		const modHeader = document.createElement('span')
		modsContainer.appendChild(modHeader)
		mainDiv.appendChild(modsContainer)
		let wordsAndColors = []
		for (let mod in item.mods) {
			let modAbbreviation = mod
			if (mod == 'str') {mod = 'Strength: '}
			if (mod == 'con') {mod = 'Constitution: '}
			if (mod == 'dex') {mod = 'Dexterity: '}
			if (mod == 'agi') {mod = 'Agility: '}
			if (mod == 'int') {mod = 'Intelligence: '}
			if (mod == 'wis') {mod = 'Wisdom: '}
			if (mod == 'slashingPen') {mod = 'Slashing Penetration: '}
			if (mod == 'piercingPen') {mod = 'Piercing Penetration: '}
			if (mod == 'bluntPen') {mod = 'Blunt Penetration: '}
			if (mod == 'slashingArmor') {mod = 'Slashing Armor: '}
			if (mod == 'piercingArmor') {mod = 'Piercing Armor: '}
			if (mod == 'bluntArmor') {mod = 'Blunt Armor: '}
			if (mod == 'fireResist') {mod = 'Fire Resist: '}
			if (mod == 'iceResist') {mod = 'Ice Resist: '}
			if (mod == 'lightningResist') {mod = 'Lightning Resist: '}
			if (mod == 'iceResist') {mod = 'Ice Resist: '}
			if (mod == 'windResist') {mod = 'Wind Resist: '}
			if (mod == 'weight') {mod = 'Weight: '}
			if (item.mods[modAbbreviation] > 0) {
				if (mod != 'Slashing Armor: ' && mod != 'Piercing Armor: ' && mod != 'Blunt Armor: ' && mod != 'Weight: '
					&& mod != 'slashingRandom' && mod != 'piercingRandom' && mod != 'bluntRandom' && mod != 'Fire Resist: '
					&& mod != 'Ice Resist: ' && mod != 'Lightning Resist: ' && mod != 'Ice Resist: ' && mod != 'Wind Resist: '
				) {
					wordsAndColors.push({number: item.mods[modAbbreviation], word: mod, color: 'green'})
					modHeader.textContent = 'Bonuses'
					modsContainer.classList.add('simple-flex-column', 'requirements')
					modHeader.classList.add('green')
				}
			}
		}
		//requirements
		if (item?.requirements) {
			if (Object.keys(item.requirements).length != 0) {
			const modsContainer = createDivElement()
			const modHeader = document.createElement('span')
			modHeader.textContent = 'Requirements'
			modHeader.classList.add('red')
			modsContainer.appendChild(modHeader)
			mainDiv.appendChild(modsContainer)
			modsContainer.classList.add('simple-flex-column', 'requirements')
	
			let wordsAndColors = []
			for (let requirement in item.requirements) {
				let originalRequirement = requirement
				if (requirement == 'str') {requirement = 'Strength'}
				if (requirement == 'con') {requirement = 'Constitution'}
				if (requirement == 'dex') {requirement = 'Dexterity'}
				if (requirement == 'agi') {requirement = 'Agility'}
				if (requirement == 'int') {requirement = 'Intelligence'}
				if (requirement == 'wis') {requirement = 'Wisdom'}
				wordsAndColors.push({number: item.requirements[originalRequirement], word: requirement, color: 'yellow'})
			}
			wordsAndColors.forEach(item => {
				let wordSpan = document.createElement('span')
				let numberSpan = document.createElement('span')
				let openParenth = document.createElement('span')
				let closeParenth = document.createElement('span')
				let mainSpan = document.createElement('span')
				mainSpan.appendChild(wordSpan)
				mainSpan.appendChild(openParenth)
				mainSpan.appendChild(numberSpan)
				mainSpan.appendChild(closeParenth)
				wordSpan.textContent = item.word
				openParenth.textContent = ' ('
				numberSpan.classList.add(item.color)
				numberSpan.textContent = item.number
				closeParenth.textContent = ')'
				modsContainer.appendChild(mainSpan)
			})
		}
	}
		// wordsAndColors.forEach(numWordColor => {
		// 	let span = document.createElement('span')
		// 	let numberSpan = document.createElement('span')
		// 	let mainSpan = document.createElement('span')
		// 	mainSpan.appendChild(span)
		// 	mainSpan.appendChild(numberSpan)
		// 	numberSpan.classList.add(numWordColor.color)
		// 	span.textContent = capitalizeFirstLetter(numWordColor.word)
		// 	numberSpan.textContent = ' ' +  '+' + numWordColor.number
			
		// 	let bonusWord = numWordColor.word.toLowerCase()
		// 	let magicWeavingKeys = Object.keys(item.magicWeaving)
		// 	magicWeavingKeys.forEach(key => {
		// 		if (bonusWord.includes(key)) {
		// 			let enhancedStat = item.magicWeaving[key]
		// 			let originalStat = item.mods[key] - enhancedStat
		// 			let bonusNumbersSpan = document.createElement('span')
		// 			bonusNumbersSpan.textContent = ` (${originalStat} + ${enhancedStat})`
		// 			numberSpan.appendChild(bonusNumbersSpan)
		// 		}
		// 	})

		// 	modsContainer.appendChild(mainSpan)
		// })
	}
	if (item.mods?.weight) {
		const weightDiv = document.createElement('div')
		const weightWordDiv = createDivElement(`Weight: `, ['row-flex'])
		const weightValueDiv = createDivElement((`${item.mods.weight}`), ['light-blue', 'small-left-margin'])
		weightWordDiv.appendChild(weightValueDiv)
		weightDiv.appendChild(weightWordDiv)
		mainDiv.appendChild(weightDiv)
	}
	if (item?.sellValue) {
		const sellWordDiv = document.createElement('div')
		const sellWordNode = document.createTextNode(`Sell Value:`)
		const sellValueDiv = document.createElement('div')
		const sellNumberDiv = document.createElement('div')
		const sellNumberNode = document.createTextNode(`${item.sellValue}`)
		sellNumberDiv.classList.add('small-left-margin')
		sellValueDiv.classList.add('row-flex')
		sellValueDiv.appendChild(sellWordDiv)
		sellValueDiv.appendChild(sellNumberDiv)
		sellWordDiv.appendChild(sellWordNode)
		sellNumberDiv.appendChild(sellNumberNode)
		sellNumberDiv.classList.add('yellow')
		mainDiv.appendChild(sellValueDiv)
	}
	// if (item.description) {
	// 	const itemDescriptionDiv = document.createElement('p')
	// 	const itemDescriptionNode = document.createTextNode(`${item.description}`)
	// 	itemDescriptionDiv.classList.add('grey', 'italic')
	// 	itemDescriptionDiv.appendChild(itemDescriptionNode)
	// 	mainDiv.appendChild(itemDescriptionDiv)
	// }
	updateScroll()
}

function miscItemDescription(item) {
	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')
	const itemNameDiv = document.createElement('div')
	itemNameDiv.classList.add(item.color)
	itemNameDiv.classList.add('item-description-name')
	const itemNameNode = document.createTextNode(`${item.name}`)
	itemNameDiv.appendChild(itemNameNode)
	const itemDescriptionDiv = document.createElement('p')
	itemDescriptionDiv.classList.add('grey', 'italic')
	const itemDescriptionNode = document.createTextNode(`${item.description}`)
	itemDescriptionDiv.appendChild(itemDescriptionNode)

	const sellValueDiv = document.createElement('div')
	const sellWordDiv = document.createElement('div')
	const sellNumberDiv = document.createElement('div')
	sellNumberDiv.classList.add('small-left-margin')
	sellValueDiv.classList.add('row-flex')
	sellValueDiv.appendChild(sellWordDiv)
	sellValueDiv.appendChild(sellNumberDiv)

	const sellWordNode = document.createTextNode(`Value:`)
	const sellNumberNode = document.createTextNode(`${item.sellValue}`)

	sellWordDiv.appendChild(sellWordNode)
	sellNumberDiv.appendChild(sellNumberNode)

	sellNumberDiv.classList.add('yellow')

	mainDiv.appendChild(itemNameDiv)
	mainDiv.appendChild(sellValueDiv)
	mainDiv.appendChild(itemDescriptionDiv)
	masterArea.appendChild(mainDiv)
}

function npcDescription(npc) {
	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')
	const npcNameDiv = document.createElement('div')
	npcNameDiv.classList.add(npc.nameColor)
	npcNameDiv.classList.add('item-description-name')
	const npcNameNode = document.createTextNode(`${npc.name}`)
	npcNameDiv.appendChild(npcNameNode)
	const raceDiv = document.createElement('div')
	const raceNode = document.createTextNode(`Race: ${npc.race}`)
	raceDiv.appendChild(raceNode)
	const occupationDiv = document.createElement('div')
	const occupationNode = document.createTextNode(`Occupation: ${npc.occupation}`)
	occupationDiv.appendChild(occupationNode)
	const npcDescriptionDiv = document.createElement('p')
	npcDescriptionDiv.classList.add(npc.nameColor, 'italic')
	const npcDescriptionNode = document.createTextNode(`${npc.description}`)
	npcDescriptionDiv.appendChild(npcDescriptionNode)
	mainDiv.appendChild(npcNameDiv)
	mainDiv.appendChild(raceDiv)
	mainDiv.appendChild(occupationDiv)
	mainDiv.appendChild(npcDescriptionDiv)
	masterArea.appendChild(mainDiv)
}

function itemDescription(item) {
	allItemDescription(item)
	// console.log(item)
	// if (item.type.weapon) {
	// 	weaponDescription(item)
	// } else if (item.type.armor) {
	// 	armorDescription(item)
	// } else if (item.type.consumable) {
	// 	consumableDescription(item)
	// } else if (item.type.quest) {
	// 	miscItemDescription(item)
	// }
}

function enemyDescription(enemy, description) {
	let enemyHitChance =  calculateEnemyHitChance(enemy)
	let playerHitChance = calculatePlayerAccuracy() - calculateEnemyDodgeChance(enemy)

	const mainDiv = document.createElement('div')
	mainDiv.classList.add('item-description')

	const enemyNameDiv = document.createElement('div')
	const enemyNameNode = document.createTextNode(`${enemy.name}`)
	enemyNameDiv.classList.add('enemy-description-name', enemy.color)
	enemyNameDiv.appendChild(enemyNameNode)

	const enemyLevelDiv = document.createElement('div')
	const enemyLevelNode = document.createTextNode(`Level: ${enemy.level}`)
	enemyLevelDiv.appendChild(enemyLevelNode)

	const healthDiv = document.createElement('div')
	const healthNode = document.createTextNode(`Health: ${enemy.health}`)
	healthDiv.appendChild(healthNode)

	const attackPowerDiv = document.createElement('div')
	attackPowerDiv.classList.add('white')
	const attackPowerNode = document.createTextNode(`Attack Power: ${enemy.attackPower}`)
	attackPowerDiv.appendChild(attackPowerNode)

	const accuracyDiv = document.createElement('div')
	accuracyDiv.classList.add('white')
	const accuracyNode = document.createTextNode(`Accuracy: ${enemy.accuracy}`)
	accuracyDiv.appendChild(accuracyNode)

	const dodgeDiv = document.createElement('div')
	dodgeDiv.classList.add('white')
	const dodgeNode = document.createTextNode(`Dodge: ${enemy.dodge}`)
	dodgeDiv.appendChild(dodgeNode)

	const armorDiv = document.createElement('div')
	armorDiv.classList.add('white')
	const armorNode = document.createTextNode(`Armor: ${enemy.armor}`)
	armorDiv.appendChild(armorNode)

	const slashingArmorDiv = document.createElement('div')
	slashingArmorDiv.classList.add('white')
	const slashingArmorNode = document.createTextNode(`Slashing Armor: ${enemy.slashingArmor}`)
	slashingArmorDiv.appendChild(slashingArmorNode)

	const piercingArmorDiv = document.createElement('div')
	piercingArmorDiv.classList.add('white')
	const piercingArmorNode = document.createTextNode(`Piercing Armor: ${enemy.piercingArmor}`)
	piercingArmorDiv.appendChild(piercingArmorNode)

	const bluntArmorDiv = document.createElement('div')
	bluntArmorDiv.classList.add('white')
	const bluntArmorNode = document.createTextNode(`Blunt Armor: ${enemy.bluntArmor}`)
	bluntArmorDiv.appendChild(bluntArmorNode)

	const enemyHitChanceDiv = document.createElement('div')
	const enemyHitChanceNode = document.createTextNode(`Enemy chance to hit you: ${enemyHitChance}%`)
	enemyHitChanceDiv.appendChild(enemyHitChanceNode)

	const playerHitChanceDiv = document.createElement('div')
	const playerHitChanceNode = document.createTextNode(`Your chance to hit: ${playerHitChance}%`)
	playerHitChanceDiv.appendChild(playerHitChanceNode)

	const descriptionDiv = document.createElement('div')
	descriptionDiv.classList.add('grey', 'italic', 'enemy-description-description')
	const descriptionNode = document.createTextNode(description)
	descriptionDiv.appendChild(descriptionNode)

	mainDiv.appendChild(enemyNameDiv)
	mainDiv.appendChild(enemyLevelDiv)
	mainDiv.appendChild(healthDiv)
	mainDiv.appendChild(attackPowerDiv)
	mainDiv.appendChild(accuracyDiv)
	mainDiv.appendChild(dodgeDiv)
	mainDiv.appendChild(armorDiv)
	mainDiv.appendChild(slashingArmorDiv)
	mainDiv.appendChild(piercingArmorDiv)
	mainDiv.appendChild(bluntArmorDiv)
	mainDiv.appendChild(enemyHitChanceDiv)
	mainDiv.appendChild(playerHitChanceDiv)
	mainDiv.appendChild(descriptionDiv)
	masterArea.appendChild(mainDiv)
}

// function armorDescription(itemId, itemName, mods, description) {
// 	const mainDiv = document.createElement('div')
// 	mainDiv.classList.add('item-description')

// 	const messageP = document.createElement('div')
// 	messageP.appendChild(words(`Location: ${itemId}`))

// 	const messageP2 = document.createElement('div')
// 	messageP2.appendChild(words(`${itemName}`, 'darkGold'))

// 	const messageP3 = document.createElement('div')
// 	messageP3.appendChild(words(`Damage: ${botDamage} - ${topDamage}`))

// 	mainDiv.appendChild(messageP)
// 	mainDiv.appendChild(messageP2)
// 	mainDiv.appendChild(messageP3)

// 	let itemValues = Object.values(mods)
// 	let itemKeys = Object.keys(mods)
// 	for (let i = 0; i < itemKeys.length; i++) {
// 		if (itemValues[i] != 0) {
// 			if (itemKeys[i] == 'armor') {
// 				let textDiv = document.createElement('div')
// 				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
// 				textDiv.appendChild(textNode)
// 				mainDiv.appendChild(textDiv)
// 			} else {
// 				let textDiv = document.createElement('div')
// 				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
// 				textDiv.appendChild(textNode)
// 				mainDiv.appendChild(textDiv)
// 			}
// 		}
// 	}
// 	masterArea.appendChild(mainDiv)
// }
function shieldDescription(itemId, itemName, mods, description) {
	const messageP = document.createElement('div')
	messageP.appendChild(words(`_____________________________________________________________`))
	masterArea.appendChild(messageP)

	const messageP2 = document.createElement('div')
	messageP2.appendChild(words(`Location: ${itemId}`))
	masterArea.appendChild(messageP2)

	const messageP3 = document.createElement('div')
	messageP3.appendChild(words(`${itemName}`, 'darkGold'))
	masterArea.appendChild(messageP3)

	showItemDescription(mods)

	quickMessage(description, 'descriptions')
}
//____________________________________SWING VARIABLES AND FUNCTIONS TO INJECT_________________
function playerPenetrationNameFunc(penName) {
	const messageSpan = document.createElement('span')
	messageSpan.textContent = penName
	messageSpan.classList.add(white)
	return messageSpan
}

function damageOverTime() {
	let count = 0
	let tick = setInterval(() => {
		console.log(count)
		player.health--
		count++
		updatePlayerStats()
		if (count >= 5) {
			clearInterval(tick)
		}
	}, 1000)
}

function playerWeaponName(weapon) {
	let swingType = weapon.name.toLowerCase() + ' '
	const messageSpan = document.createElement('span')
	messageSpan.textContent = swingType
	messageSpan.classList.add('brown')
	return messageSpan
}
function enemyName(enemy) {
	//if enemy == enemy return 'at the' - if enemy == person return 'at'
	let enemyName = enemy
	const messageSpan = document.createElement('span')
	messageSpan.textContent = enemyName.toLowerCase() + ' '
	messageSpan.classList.add(red)
	return messageSpan
}
function damageNumber(damage) {
	let damageNumber = damage
	const messageSpan = document.createElement('span')
	messageSpan.textContent = damageNumber
	messageSpan.classList.add('yellow')
	return messageSpan
}
//area specific classes
let galvadianGreen = 'galvadian-green'
let castleGrey = 'castle-grey'
let dirtPath = 'dirt-path'
let town = 'town'
//

let descriptions = 'descriptions'
let masterArea = document.getElementById('masterArea')
let descName = document.getElementById('descName')
let zoneExits = document.getElementById('zoneExits')
let additional = document.getElementById('additional')
let enemys = document.getElementById('enemys')
let scrollable = document.getElementById('scrollable')
let allDirections = ['north', 'n', 'northeast', 'ne', 'east', 'e', 'southeast', 'se', 'south', 's', 'southwest', 'sw', 'west', 'w', 'northwest', 'nw', 'up', 'u', 'down', 'd']
let pushItem = []

let backpack = 'backpack'
let equipped = 'equipped'
let wielded = 'wielded'
let slot1 = 'right hand'
let slot2 = 'left hand'
let slot3 = 'head'
let slot4 = 'necklace'
let slot5 = 'shoulders'
let slot6 = 'chest'
let slot7 = 'back'
let slot8 = 'hands'
let slot9 = 'waist'
let slot10 = 'legs'
let slot11 = 'feet'
let slot12 = 'ring 1'
let slot13 = 'ring 2'
let slot14 = 'shield'
let empty = 'empty'
let armor = 'armor'
let shield = 'shield'
let sword = 'sword'
let bow = 'bow'
let drink = 'drink'
let oneSecond = 1
let twoSeconds = 2
let threeSeconds = 3
let fourSeconds = 4
// let swingTimer
let advanceTimer
let retreatTimer
let spellCastTimer
// let spellConjureTimer
// let spellChannelTimer
let trainedSkillName
let trainedSpellname
const regExp = /[a-zA-Z]/g
//player classes
const warrior = 'Warrior'
let cleaveCounter = 0

let futureArea
function futureAreaFunc(direction) {
	let futureX = currentArea.x
	let futureY = currentArea.y
	let futureZ = currentArea.z
	switch (direction) {
		case 'northwest':
		case 'nw':
			futureX += -1
			futureY += 1
			break
		case 'north':
		case 'n':
			futureY += 1
			break
		case 'northeast':
		case 'ne':
			futureX += 1
			futureY += 1
			break
		case 'east':
		case 'e':
			futureX += 1
			break
		case 'southeast':
		case 'se':
			futureX += 1
			futureY += -1
			break
		case 'south':
		case 's':
			futureY += -1
			break
		case 'southwest':
		case 'sw':
			futureX += -1
			futureY += -1
			break
		case 'west':
		case 'w':
			futureX += -1
			break
		case 'up':
		case 'u':
			futureZ += 1
			break
		case 'down':
		case 'd':
			futureZ += -1
			break
	}
	futureArea = allAreas.find(area => area.x == futureX && area.y == futureY && area.z == futureZ)
}

function questCheck() {
	if (currentArea.quests != undefined) {
		if (currentArea.quests.onEntry != undefined) {
			currentArea.quests.onEntry()
		}
	}
}

function pushItemByRoomId(roomIdCommand) {
	let roomIdItem = pushItem.find(item => item.roomId == roomIdCommand)
	if (roomIdItem != undefined) {
		return roomIdItem
	} else if (player.rightHand == empty) {
		return player.rightFist
	} else {
		return empty
	}
}
function pushItemByKeyword(secondCommand) {
	return pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand === keyword && roomId === currentArea.id))
}

function pushItemAllItemsInRoom() {
	let allItems = pushItem.filter(allItemsInRoom => allItemsInRoom.roomId == currentArea.id)
	if (allItems != undefined) {
		return allItems
	} else {
		return undefined
	}
}
function pushItemInBackpack() {
	return pushItem.filter(allItems => allItems.roomId == backpack)
}

function quest1Dialogue() {}

let spacer = `\u00A0`
let spacer5 = `\u00A0\u00A0\u00A0\u00A0\u00A0`
let spacer10 = `\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0` // spacer10 is 10 spaces long
let spacer20 = spacer10 + spacer10
let spacer30 = spacer20 + spacer10
let spacer40 = spacer20 + spacer20
let spacer50 = spacer40 + spacer10
let spacer100 = spacer50 + spacer50
let spacer200 = spacer100 + spacer100

//allows you to press enter to submit commands

let currentArea = {
	hostile: null,
	id: 0,
	x: 0,
	y: 0,
	npc: null,
	descriptions: {
		areaName: null,
		desc: null,
		zoneExits: null,
		zoneExitsBool: {
			north: null,
			northwest: null,
			west: null,
			southwest: null,
			south: null,
		},
	},
	interactables: {
		mushrooms: {
			pick: null,
			stomp: null,
			eat: null,
		},
	},
	enemys: {
		blob: {
			name: null,
			health: null,
			visual: null,
			spawnChance: null,
		},
	},
}
let previousArea
//STASIS
//game start
//swing
//rest
//spell cast
//spell target

//MODES?
//combat
//
//
//
commandLine.addEventListener('keypress', function (event) {
	if (event.keyCode === 13 && commandLine.value.length !== 0) {
		handleInputs(commandLine.value)
		event.preventDefault()
	}
})
//handleCombatStasisInputs
function handleInputs(commandLineInput) {
	const inputsLowerCase = commandLineInput.toLowerCase()
	const inputsSplitBySpace = inputsLowerCase.split(' ')
	let command = inputsSplitBySpace[0]
	const secondCommand = inputsSplitBySpace[1]
	let thirdCommand = inputsSplitBySpace[2]
	let fourthCommand = inputsSplitBySpace[3]
	for (let i = 4; i < inputsSplitBySpace.length; i++) {
		fourthCommand += inputsSplitBySpace[i]
	}
	const directionCheck = allDirections.find(noMove => noMove === command)

	commandLine.value = ''
	commandLine.focus()
	//IF IN DIALOGUE STASIS, CANNOT PERFORM ANY ACTION
	if (player.dialogueStasis) {return} 
	//COMMANDS THAT CAN BE USED IN EVERY STASIS EXCEPT DIALOGUE. THESE COMMANDS ARE FOR UI, INVENTORY,
	//CHECKING SKILLS, SPELLS, MENU STUFF, ETC.



	if (command == 'spells') {playerSpellsList()}
	else if (command == 'bet') {bet(secondCommand, thirdCommand)}
	else if (command == 'save') {saveGame(secondCommand)}
	else if (command == 'load') {retrieveSaveFile(secondCommand)}
	else if (command == 'skills') {playerSkillsList()}
	else if (command == 'abilities') {playerAbilitiesList()}
	else if (command == 'stats') {stats()}
	else if (command == 'experience' || command == 'exp') {exp()}
	else if (command == 'revive') {revive()}
	else if (command == 'help') {help(secondCommand)}
	else if (command == 'look' || command == 'l') {look(command, secondCommand, currentArea)}
	else if (command == 'examine' || command == 'ex') {examine(secondCommand, thirdCommand)}
	else if (command == 'inspect' || command == 'insp' || command == 'ins' || command == 'in') {inspect(secondCommand, thirdCommand)}
	else if (command == 'i' || command == 'inv' || command == 'inventory') {showInventory(player.inventory)}
	else if (command == 'clean') {clean()}
	else if (command == 'get' || command == 'g') {pickupItem(secondCommand, currentArea)}
	else if (command == 'drop') {dropItem(secondCommand, currentArea)}
	else if (command == 'pack' || command == 'p') {pack(secondCommand)}
	else if (command == 'unpack') {unpack(secondCommand, thirdCommand)}
	else if (command == 'swap') {swap()}
	else if (command == 'macro') {setMacro(secondCommand, thirdCommand)}

	else if (command == 'show') {show(secondCommand, thirdCommand)}
	else if (command == 'don' || command == 'wear' || command == 'equip') {donWearEquip(secondCommand)}
	else if (command == 'unequip' || command == 'remove') {unequipRemove(secondCommand)}
	else if (command == 'buy') {buyCommand(secondCommand, thirdCommand)}
	else if (command == 'sell') {sell(secondCommand, thirdCommand)}
	else if (command == 'train') {trainSkill(secondCommand, thirdCommand)}
	else if (command == 'learn') {learnSpell(secondCommand, thirdCommand)}
	else if (command == 'read') {read(secondCommand)}
	else if (command == 'god') {godMode(secondCommand)}
	else if (command == 'drink') {drinkPotion(secondCommand)}
	else if (command == 'kl') {displayKillList()}
	// if (player.stasis) {return}
	else if (command == 'fish') {fishFunction()}
	else if (command == 'open') {openObject(secondCommand)}
	else if (command == 'forge') {forge(secondCommand, thirdCommand, fourthCommand)}
	else if (command == 'tool') {tool(secondCommand, thirdCommand, fourthCommand)}
	else if (command == 'weave') {weave(secondCommand, thirdCommand, fourthCommand)}
	else if (command == 'increase' || command == 'inc') {increaseStat(secondCommand)}
	else if (command == 'speak' || command == 'talk') {speak(secondCommand)}
	else if (command == 'quest') {showQuest(secondCommand)}
	else if (command == 'offer') {offerQuest(secondCommand)}
	else if (command == 'cook') {cookFunction(secondCommand)}
	//BELOW ARE COMMANDS THAT CAN ONLY BE USED WHEN ADVANCING, RETREATING, OR ANY STASIS

	else if (advanceAndRetreatCheck()) {return}
	else if (actionWait()) {return}
	else if (directionCheck == command && player.combat) {
		quickMessage(`You cannot move while engaged in combat!`)
		return
	}
	else if (command == 'stealth' || command == 'hide') {stealthAbility()}
	else if (command == 'unhide') {unhide()}
	else if (command == 'unlock') {unlock(secondCommand)}
	else if (command == 'search') {search(secondCommand)}
	else if (command == 'pull') {pull(secondCommand)} //pull lever

	else if (command == 'push' || command == 'press') {pull(secondCommand)} //push wall, push tile, push brick

	else if (command == 'clear') {clear(secondCommand)} //clear grass, clear path, clear webs

	else if (command == 'turn' || command == 'rotate' || command == 'spin') {pull(secondCommand)} //turn, rotate, spin wheel

	else if (command == 'flip') {pull(secondCommand)} //flip a switch

	else if (command == 'climb' || command == 'scale') {pull(secondCommand)} //climb or scale a wall, ladder, etc

	else if (command == 'close' || command == 'shut') {pull(secondCommand)} //closing or shutting a door

	else if (command == 'touch') {pull(secondCommand)} //touch panel, touch plaque, touch runes

	else if (command == 'use') {pull(secondCommand)} //use bucket, use boat, use paddle, use axe

	else if (command == 'pick' || command == 'gather') {harvestFunction(secondCommand)}
	else if (command == 'mine') {mineFunction(secondCommand)}
	else if (command == 'eat') {eat(secondCommand)}
	else if (command == 'recall') {recall(secondCommand, thirdCommand, fourthCommand)}
	else if (command == '1') {useAbilityByNumber(command)}
	else if (command == '2') {useAbilityByNumber(command)}
	else if (command == '3') {useAbilityByNumber(command)}
	else if (command == '4') {useAbilityByNumber(command)}
	else if (command == '5') {useAbilityByNumber(command)}
	else if (command == '6') {useAbilityByNumber(command)}
	else if (command == '7') {useAbilityByNumber(command)}
	else if (command == '8') {useAbilityByNumber(command)}
	else if (command == '9') {useAbilityByNumber(command)}
	else if (command == '0') {useAbilityByNumber(command)}
	else if (command == 'cast') {spellFunction(secondCommand)}
	else if (command == 'target' || command == 't') {target(secondCommand, thirdCommand)}
	else if (command == 'rest') {restFunction()}
	else if (command == 'save') {save(secondCommand)}
	else if (command == 'load') {load(secondCommand)}
	else if (command == 'northwest' || command == 'nw') {moveDirection(command)}
	else if (command == 'north' || command == 'n') {moveDirection(command)}
	else if (command == 'northeast' || command == 'ne') {moveDirection(command)}
	else if (command == 'east' || command == 'e') {moveDirection(command)}
	else if (command == 'southeast' || command == 'se') {moveDirection(command)}
	else if (command == 'south' || command == 's') {moveDirection(command)}
	else if (command == 'southwest' || command == 'sw') {moveDirection(command)}
	else if (command == 'west' || command == 'w') {moveDirection(command)}
	else if (command == 'up' || command == 'u') {moveDirection(command)}
	else if (command == 'down' || command == 'd') {moveDirection(command)}
	else if (command == 'attack' || command == 'a') {attack(secondCommand, thirdCommand)}
	else if (command == 'advance' || command == 'ad') {advance(secondCommand)}
	else if (command == 'retreat' || command == 're') {retreat(secondCommand)}
	//CLASS ABILITIES THAT I MIGHT REMOVE FROM THIS ENTIRELY AND ONLY USED WITH THE NUMPAD
	else if (command == 'block') {}
	else if (command == 'taunt') {}
	else if (command == 'roll') {}
	else if (command == 'ripslash') {}
	else if (command == 'cyclone') {}
	else if (command == 'cataclysm' || command == 'cata') {}
	else if (command == 'dualstrike') {}
	else if (command == 'shred') {}
	else if (command == 'bladeblitz') {}
	else if (command == 'valorstrike') {}
	else if (command == 'shieldslam') {}
	else if (command == 'boomingmight') {}
	else if (command == 'ambush') {}
	else if (command == 'backstab') {}
	else if (command == 'guillotine') {}
	else if (command == 'catalyst') {}
	else if (command == 'tempest') {}
	else if (command == 'callofwind') {}
	else if (command == 'knuckleblitz') {}
	else if (command == 'fireseal') {}
	else if (command == 'waterseal') {}
	else if (command == 'earthseal') {}
	else if (command == 'mysticfist') {}
	else if (command == 'unleashedpower') {}
	else if (command == 'blazingfist') {}
	else if (command == 'riptidefist') {}
	else if (command == 'lightningfist') {}
	else if (command == 'piercingarrow') {}
	else if (command == 'rapidfirearrow') {}
	else if (command == 'hydraarrow') {}
	else if (command == 'charge') {}
	updatePlayerStats()
	updateScroll()
}

function handleCombatInputs(commandLineInput) {
	const inputsLowerCase = commandLineInput.toLowerCase()
	const inputsSplitBySpace = inputsLowerCase.split(' ')
	const command = inputsSplitBySpace[0]
	const secondCommand = inputsSplitBySpace[1]
	let thirdCommand = inputsSplitBySpace[2]
	let fourthCommand = inputsSplitBySpace[3]
	for (let i = 4; i < inputsSplitBySpace.length; i++) {
		fourthCommand += inputsSplitBySpace[i]
	}
	const directionCheck = allDirections.find(noMove => noMove === command)
	commandLine.value = ''
	commandLine.focus()
	if (advanceAndRetreatCheck()) {return}
		switch (command) {
			case 'roll':
				evasiveRollFunction()
				break;
			case 'taunt':
				tauntingShoutFunction()
				break;
			case 'spells':
				playerSpellsList()
			break;
			case 'skills':
				playerSkillsList()
				break;
			case 'abilities':
				playerAbilitiesList()
			break;
			case 'pick':
			case 'gather':
				harvestFunction(secondCommand)
				break;
			case 'mine':
				mineFunction(secondCommand)
				break;
			case 'cook':
				cookFunction(secondCommand)
				break;
			case 'revive':
				revive()
				break
			case 'help':
				help(secondCommand)
				break
			case 'block':
				block()
				break
			case 'charge':
				chargeFunction(secondCommand)
				break
			case 'cast':
				spellFunction(secondCommand)
				break
			case 'target':
			case 't':
				target(secondCommand, thirdCommand)
				break
			case 'ripslash':
				ripslashFunction(secondCommand, thirdCommand)
				break
			case 'dualstrike':
				dualStrikeFunction(secondCommand, thirdCommand)
				break
			case 'cata':
				cataclysmFunction(secondCommand, thirdCommand)
				break
			case 'cyclone':
				cycloneFunction(secondCommand, thirdCommand)
				break
			case 'bladeblitz':
				bladeBlitzFunction(secondCommand, thirdCommand)
				break
			case 'boomingmight':
				boomingMightFunction(secondCommand, thirdCommand)
				break
			case 'ambush':
				ambushFunction(secondCommand, thirdCommand)
				break
			case 'backstab':
				backstabFunction(secondCommand, thirdCommand)
				break
			case 'empoweringstrike':
				empoweringStrikeFunction(secondCommand, thirdCommand)
				break
			case 'catalyst':
				catalystFunction(secondCommand, thirdCommand)
				break
			case 'tempest':
				tempestFunction(secondCommand, thirdCommand)
				break
			case 'fireseal':
				fireSealFunction(secondCommand, thirdCommand)
				break
			case 'flamestrike':
				flameStrikeFunction(secondCommand, thirdCommand)
				break
			case 'waterseal':
				waterSealFunction(secondCommand, thirdCommand)
				break
			case 'wavefist':
				waveFistFunction(secondCommand, thirdCommand)
				break
			case 'blazingfist':
				blazingFistFunction(secondCommand, thirdCommand)
				break
			case 'riptide':
				riptideFistFunction(secondCommand, thirdCommand)
				break
			case 'piercingarrow':
				piercingArrowFunction(secondCommand, thirdCommand)
				break
			case 'hydraarrow':
				hydraArrowFunction(secondCommand, thirdCommand)
				break
			case 'aimedshot':
				aimedShotFunction(secondCommand, thirdCommand)
				break
			case 'bash':
				bashFunction()
				break
			case 'increase':
				increaseStat(secondCommand)
				break
			case 'unlock':
				unlock(secondCommand)
				break
			case 'pull':
				pull(secondCommand)
				break
			case 'eat':
				eat(secondCommand)
				break
			//combat functions
			case 'a':
			case 'attack':
				attack(secondCommand, thirdCommand)
				break
			case 'don':
			case 'wear':
			case 'equip':
				donWearEquip(secondCommand)
				break
			case 'unequip':
			case 'remove':
				unequipRemove(secondCommand)
				break
			case 'ad':
				attack(secondCommand, thirdCommand)
				break
			case 're':
			case 'retreat':
				retreat(secondCommand)
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, thirdCommand)
				break
			//normal functions
			case directionCheck:
				quickMessage('you cannot move while engaged in combat!')
				break
			case 'look':
			case 'l':
				look(command)
				break
			case 'examine':
			case 'ex':
				examine(secondCommand, thirdCommand)
				break
			case 'in':
			case 'ins':
			case 'insp':
			case 'inspect':
				inspect(secondCommand, thirdCommand)
				break
			case 'i':
			case 'inv':
			case 'show inventory':
				showInventory(player.inventory) //fix
				break
			case 'speak':
			case 'talk':
				speak(secondCommand)
				break
			case 'quest':
				showQuest(secondCommand)
				break
			case 'offer':
				offerQuest(secondCommand)
				break
			case 'show':
				show(secondCommand, thirdCommand)
				break
			case 'trade':
				trade(secondCommand)
				break
			case 'stats':
				stats()
				break
			case 'skills':
				skills()
				break
			case 'exp':
				exp()
				break
			case 'spawn':
				itemRoll()
				break
			case 'clean':
				clean()
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, thirdCommand)
				break
			case 'drop':
				dropItem(secondCommand, currentArea)
				break
			case 'pack':
			case 'p':
				pack(secondCommand)
				break
			case 'unpack':
				unpack(secondCommand, thirdCommand)
				break
			case 'swap':
				swap()
				break
			case 'recall':
				recall(secondCommand, thirdCommand, fourthCommand)
				break
			case 'dialogue':
				dialogueSpeedFunc(secondCommand)
				break
			case 'repeat':
				repeat(secondCommand)
				break
			default:
				invalidCommand(commandLineInput)
		}
	commandLine.value = ''
	commandLine.focus()
	updateScroll()
}

function handleCombatStasisInputs(commandLineInput) {
	const inputsLowerCase = commandLineInput.toLowerCase()
	const inputsSplitBySpace = inputsLowerCase.split(' ')
	const command = inputsSplitBySpace[0]
	const secondCommand = inputsSplitBySpace[1]
	let thirdCommand = inputsSplitBySpace[2]
	let fourthCommand = inputsSplitBySpace[3]
	for (let i = 4; i < inputsSplitBySpace.length; i++) {
		fourthCommand += inputsSplitBySpace[i]
	}
	if (player.dialogueStasis) {return} 
	commandLine.value = ''
	commandLine.focus()
	if (advanceAndRetreatCheck()) {return}		
		switch (command) {
			case 'roll':
				evasiveRollFunction()
				break;
			case 'taunt':
				tauntingShoutFunction()
				break;
			case 'spells':
				playerSpellsList()
			break;
			case 'skills':
				playerSkillsList()
				break;
			case 'abilities':
				playerAbilitiesList()
				break;
			case 'exp':
				exp()
				break;
			case 'stats':
				stats()
				break;
			case 'pick':
			case 'gather':
				harvestFunction(secondCommand)
				break;
			case 'mine':
				mineFunction(secondCommand)
				break;
			case 'cook':
				cookFunction(secondCommand)
				break;
			case 'revive':
				revive()
				break;
			case 'help':
				help(secondCommand)
				break
			case 'bash':
				bashFunction()
				break
			case 'ripslash':
				ripslashFunction(secondCommand, thirdCommand)
				break
			case 'cyclone':
				cycloneFunction(secondCommand, thirdCommand)
				break
			case 'bladeblitz':
				bladeBlitzFunction(secondCommand, thirdCommand)
				break
			case 'boomingmight':
				boomingMightFunction(secondCommand, thirdCommand)
				break
			case 'dualstrike':
				dualStrikeFunction(secondCommand, thirdCommand)
				break
			case 'cata':
				cataclysmFunction(secondCommand, thirdCommand)
				break
			case 'ambush':
				ambushFunction(secondCommand, thirdCommand)
				break
			case 'backstab':
				backstabFunction(secondCommand, thirdCommand)
				break
			case 'empoweringstrike':
				empoweringStrikeFunction(secondCommand, thirdCommand)
				break
			case 'catalyst':
				catalystFunction(secondCommand, thirdCommand)
				break
			case 'tempest':
				tempestFunction(secondCommand, thirdCommand)
				break
			case 'fireseal':
				fireSealFunction(secondCommand, thirdCommand)
				break
			case 'flamestrike':
				flameStrikeFunction(secondCommand, thirdCommand)
				break
			case 'waterseal':
				waterSealFunction(secondCommand, thirdCommand)
				break
			case 'wavefist':
				waveFistFunction(secondCommand, thirdCommand)
				break
			case 'blazingfist':
				blazingFistFunction(secondCommand, thirdCommand)
				break
			case 'riptide':
				riptideFistFunction(secondCommand, thirdCommand)
				break
			case 'piercingarrow':
				piercingArrowFunction(secondCommand, thirdCommand)
				break
			case 'hydraarrow':
				hydraArrowFunction(secondCommand, thirdCommand)
				break
			case 'aimedshot':
				aimedShotFunction(secondCommand, thirdCommand)
				break
			case 'increase':
				increaseStat(secondCommand)
				break
			case 'unlock':
				unlock(secondCommand)
				break
			case 'pull':
				pull(secondCommand)
				break
			case 'eat':
				eat(secondCommand)
				break
			case 'look':
			case 'l':
				look(command)
				break
			case 'examine':
			case 'ex':
				examine(secondCommand, thirdCommand)
				break
			case 'in':
			case 'ins':
			case 'insp':
			case 'inspect':
				inspect(secondCommand, thirdCommand)
				break
			case 'i':
			case 'inv':
				showInventory(player.inventory)
				break
			case 'clean':
				clean()
				break
			case 'get':
			case 'g':
				pickupItem(secondCommand, thirdCommand)
				break
			case 'drop':
				dropItem(secondCommand, thirdCommand)
				break
			case 'pack':
			case 'p':
				pack(secondCommand)
				break
			case 'unpack':
				unpack(secondCommand, thirdCommand)
				break
			case 'swap':
				swap()
				break
			case 'recall':
				recall(secondCommand, thirdCommand, fourthCommand)
				break
			case 'repeat':
				repeat(secondCommand)
				break
			default:
				actionWait()
		}
	commandLine.value = ''
	commandLine.focus()
	updateScroll()
}

function abvDirectionToFullDirection(command) {
	switch (command) {
		case 'nw':
			return 'northwest'
		case 'n':
			return 'north'
		case 'ne':
			return 'northeast'
		case 'e':
			return 'east'
		case 'se':
			return 'southeast'
		case 's':
			return 'south'
		case 'sw':
			return 'southwest'
		case 'w':
			return 'west'
		case 'u':
			return 'up'
		case 'd':
			return 'down'
		default:
			console.log(`Abv direction to full function did not work`)
	}
}

//Out of combat commands


function dialogueWait(milliseconds) {
	let randomNumber = randomNumberRange(0, 4)
	// let randomDialogueSound = dialogueArray[randomNumber]
    return new Promise(resolve => {
        player.dialogueStasis = true
        setTimeout(() => {
			// randomDialogueSound.play()
            player.dialogueStasis = false
            resolve()
        }, milliseconds)
    });
}
function wait(milliseconds) {
    return new Promise(resolve => {
        player.stasis = true
        setTimeout(() => {
            player.stasis = false
            resolve()
        }, milliseconds)
    });
}
function actionWait() {
	const line1 = lineFunc()
	let waitTime
	if (player.stasis) {
		if (player.swingTimer > 0) {
			waitTime = Math.floor(player.swingTimer * 10) / 10
			customizeEachWord(`You are exhausted and must wait before taking another swing [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		} else if (player.channelTimer > 0) {
			waitTime = Math.floor(player.channelTimer * 10) / 10
			customizeEachWord(`You are currently channeling a spell [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		} else if (player.conjureTimer > 0) {
			waitTime = Math.floor(player.conjureTimer * 10) / 10
			customizeEachWord(`You are exhausted and must wait before conjuring another spell [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		} else if (player.abilityTimer > 0) {
			waitTime = Math.floor(player.abilityTimer * 10) / 10
			customizeEachWord(`You must wait before doing anything else [`, 'white', line1)
			customizeEachWord(`${waitTime}`, 'yellow', line1)
			customizeEachWord(`]`, 'white', line1)
			return true
		}
		quickMessage(`Default must wait`)
		return true
	}
}

function save(secondCommand, thirdCommand) {
	// localStorage.setItem(secondCommand, JSON.stringify(player))
	// localStorage.setItem('tester', JSON.stringify(attack))
	// localStorage.setItem('vigorDescription', JSON.stringify(player.vigor.description))
	// localStorage.setItem('vigorGoldToUpgrade', JSON.stringify(player.vigor.goldToUpgrade))
	// localStorage.setItem('items', JSON.stringify(pushItem))
	// quickMessage(`Game saved under the name: ${secondCommand}`)
}

function load(secondCommand) {
	let loadPlayer = localStorage.getItem(secondCommand)
	let loadItems = localStorage.getItem('items')
	let loadVigorDescription = localStorage.getItem('vigorDescription')
	let loadAttack = localStorage.getItem('tester')
	console.log(loadAttack)
	console.log(JSON.parse(loadAttack))
	let loadVigorGoldToUpgrade = localStorage.getItem('vigorGoldToUpgrade')
	player = JSON.parse(loadPlayer)
	player.vigor.description = JSON.parse(loadVigorDescription)
	player.vigor.goldToUpgrade = JSON.parse(loadVigorGoldToUpgrade)
	pushItem = JSON.parse(loadItems)
	updateScroll()
	quickMessage(`Save file ${secondCommand} loaded`)
}

// Save game function



function godMode(secondCommand) {
	if (secondCommand == 'health') {
		player.godMods.con = 100
		updatePlayerStats()
		player.health = player.maxHealth
		updatePlayerStats()
		return
	}
	player.gold = 10000
	player.skillPoints = 1000
	player.attributePoints = 1000
	player.godMods.might = 1000
	player.godMods.adrenaline = 1000
	player.godMods.focus = 1000
	player.health = player.maxHealth
	player.godMods.dodging = 100
	player.godMods.accuracy = 1000
	player.godMods.str = 100
	player.godMods.dex = 100
	player.godMods.agi = 100
	player.godMods.charge = 1
	player.godMods.stealth = 1
	player.godMods.clearMind = 100
	player.godMods.magicDexterity = 100
	player.godMods.sorceryMastery = 1
	quickMessage(`God mode activated`)

	if (secondCommand == 'mana') {
		player.godMods.maxMana = 1000
		updatePlayerStats()
		player.mana = player.maxMana
		updatePlayerStats()
		return
	}
	if (secondCommand == 'weapon') {
		player.currentWeaponSkill.level = 20
		updatePlayerStats()
		return
	}
	if (secondCommand == '2') {
		player.level = 2
		player.experience = 15
		player.daggers.level = 2
		player.unarmed.level = 2
		player.bows.level = 2
		player.oneHanded.level = 2
		player.twoHanded.level = 2
		player.godMods.str = player.guild == 'Warrior' ? 2 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 2 : 
		player.godMods.dex = player.guild == 'Monk' ? 2 : 
		player.godMods.agi = player.guild == 'Ranger' ? 2 : 
		player.godMods.int = player.guild == 'Mage' ? 2 : 
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '3') {
		player.level = 3
		player.experience = 45
		player.daggers.level = 3
		player.unarmed.level = 3
		player.bows.level = 3
		player.oneHanded.level = 3
		player.twoHanded.level = 3
		player.godMods.str = player.guild == 'Warrior' ? 3 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 3 : 
		player.godMods.dex = player.guild == 'Monk' ? 3 : 
		player.godMods.agi = player.guild == 'Ranger' ? 3 : 
		player.godMods.int = player.guild == 'Mage' ? 3 : 
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '4') {
		player.level = 4
		player.experience = 100
		player.daggers.level = 4
		player.unarmed.level = 4
		player.bows.level = 4
		player.oneHanded.level = 4
		player.twoHanded.level = 4
		player.godMods.str = player.guild == 'Warrior' ? 4 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 4 : 
		player.godMods.dex = player.guild == 'Monk' ? 4 : 
		player.godMods.agi = player.guild == 'Ranger' ? 4 : 
		player.godMods.int = player.guild == 'Mage' ? 4 : 
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '5') {
		player.level = 5
		player.experience = 190
		player.daggers.level = 5
		player.unarmed.level = 5
		player.bows.level = 5
		player.oneHanded.level = 5
		player.twoHanded.level = 5
		player.godMods.str = player.guild == 'Warrior' ? 5 :
		player.godMods.dex = player.guild == 'Sinistral' ? 5 :
		player.godMods.dex = player.guild == 'Monk' ? 5 :
		player.godMods.agi = player.guild == 'Ranger' ? 5 :
		player.godMods.int = player.guild == 'Mage' ? 5 :
		player.godMods.con = 1
		updatePlayerStats()
		return
		}
	if (secondCommand == '6') {
		player.level = 6
		player.experience = 330
		player.daggers.level = 6
		player.unarmed.level = 6
		player.bows.level = 6
		player.oneHanded.level = 6
		player.twoHanded.level = 6
		player.godMods.str = player.guild == 'Warrior' ? 6 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 6 : 
		player.godMods.dex = player.guild == 'Monk' ? 6 : 
		player.godMods.agi = player.guild == 'Ranger' ? 6 : 
		player.godMods.int = player.guild == 'Mage' ? 6 : 
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '7') {
		player.level = 7
		player.experience = 522
		player.daggers.level = 7
		player.unarmed.level = 7
		player.bows.level = 7
		player.oneHanded.level = 7
		player.twoHanded.level = 7
		player.godMods.str = player.guild == 'Warrior' ? 7 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 7 : 
		player.godMods.dex = player.guild == 'Monk' ? 7 : 
		player.godMods.agi = player.guild == 'Ranger' ? 7 : 
		player.godMods.int = player.guild == 'Mage' ? 7 :
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '8') {
		player.level = 8
		player.experience = 797
		player.daggers.level = 8
		player.unarmed.level = 8
		player.bows.level = 8
		player.oneHanded.level = 8
		player.twoHanded.level = 8
		player.godMods.str = player.guild == 'Warrior' ? 8 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 8 : 
		player.godMods.dex = player.guild == 'Monk' ? 8 :
		player.godMods.agi = player.guild == 'Ranger' ? 8 : 
		player.godMods.int = player.guild == 'Mage' ? 8 : 
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '9') {
		player.level = 9
		player.experience = 1115
		player.daggers.level = 9
		player.unarmed.level = 9
		player.bows.level = 9
		player.oneHanded.level = 9
		player.twoHanded.level = 9
		player.godMods.str = player.guild == 'Warrior' ? 9 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 9 : 
		player.godMods.dex = player.guild == 'Monk' ? 9 : 
		player.godMods.agi = player.guild == 'Ranger' ? 9 : 
		player.godMods.int = player.guild == 'Mage' ? 9 : 
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (secondCommand == '10') {
		player.level = 10
		player.experience = 1474
		player.daggers.level = 10
		player.unarmed.level = 10
		player.bows.level = 10
		player.oneHanded.level = 10
		player.twoHanded.level = 10
		player.godMods.str = player.guild == 'Warrior' ? 10 : 
		player.godMods.dex = player.guild == 'Sinistral' ? 10 : 
		player.godMods.dex = player.guild == 'Monk' ? 10 : 
		player.godMods.agi = player.guild == 'Ranger' ? 10 : 
		player.godMods.int = player.guild == 'Mage' ? 10 :
		player.godMods.con = 1
		updatePlayerStats()
		return
	}
	if (!secondCommand) {
		player.level = 10
		player.experience = 1520
		player.godMods.daggers = 30
		player.godMods.unarmed = 30
		player.godMods.bows = 30
		player.godMods.oneHanded = 30
		player.godMods.twoHanded = 30
		player.godMods.stealth = 6
		player.godMods.con = 100
		player.godMods.str = 10
		player.godMods.dex = 10
		player.godMods.agi = 10
		player.godMods.int = 20
		updatePlayerStats()
		player.godMods.health = player.maxHealth
		updatePlayerStats()
		return
	}

	updatePlayerStats()
	
}

function combatCount(seconds) {
	// console.log(seconds, ' COMBAT COUNT IN SECONDS')
	player.stasis = true
	player.swingTimer = Math.round(seconds * 10) / 10
	// console.log(player.swingTimer, ' PLAYER SWING TIMER IN SECONDS')
	player.combatTicker = setInterval(() => {
		player.swingTimer -= 0.1
		player.swingTimer = Math.round(player.swingTimer * 10) / 10
		// seconds = Math.round(seconds * 10) / 10
		// console.log(player.swingTimer, ' COMBAT COUNT IN SECONDS')
		if (player.swingTimer <= 0) {
			// console.log(player.swingTimer, ' SHOULD BE LESS THAN OR = TO 0')
			player.swingTimer = player.currentWeaponSkill.speed
			player.stasis = false
			clearInterval(player.combatTicker)
		}
	}, 100)
}

function abilityCount(seconds) {
	quickMessage(`ability count initialized - ${seconds}`)
	player.stasis = true
	let abilityTicker = setInterval(() => {
		seconds = seconds - 0.1
		player.abilityTimer = Math.floor(seconds * 10) / 10
		seconds = Math.round(seconds * 10) / 10
		if (seconds <= 0) {
			player.abilityTimer = 0
			player.stasis = false
			clearInterval(abilityTicker)
		}
	}, 100)
}
function advanceCount(seconds) {
	player.stasis = true
	let advanceTicker = setInterval(() => {
		seconds = seconds - 0.1
		advanceTimer = Math.round(seconds * 10) / 10
		if (seconds <= 0) {
			advanceTimer = 0
			player.stasis = false
			clearInterval(advanceTicker)
		}
	}, 100)
}
function retreatCount(seconds) {
	player.stasis = true
	let retreatPenalty = player?.debuffs?.retreatTimer ? player.debuffs.retreatTimer : 0
	let retreatTicker = setInterval(() => {
		retreatTimer = Math.round((seconds + retreatPenalty) * 10) / 10
		seconds = seconds - 0.1
		if (seconds <= 0) {
			retreatTimer = 0
			player.stasis = false
			clearInterval(retreatTicker)
		}
	}, 100)
}
function spellConjureCount(spell) {
	player.conjureTimer = spell.conjureTime() / 1000
	let spellConjureTicker = setInterval(() => {
		player.conjureTimer = player.conjureTimer - 0.1
		if (player.conjureTimer <= 0) {
			player.conjureTimer = 0
			player.isConjuring = false
			spell.chambered = true
			let line1 = document.createElement('div')
			customizeEachWord(`${spell.name} `, spell.color, line1)
			customizeEachWord(`is ready to cast`, 'white', line1)
			clearInterval(spellConjureTicker)
		}
	}, 100)
}
function spellChannelCount(channelTime) {
	player.channelTimer = channelTime / 1000
	let spellChannelTicker = setInterval(() => {
		player.channelTimer = player.channelTimer - 0.1
		if (player.channelTimer <= 0) {
			player.channelTimer = 0
			clearInterval(spellChannelTicker)
		}
	}, 100)
}

//THIS FUNCTION ACCUMULATES MARKS ON THE PLAYER EACH TIME AN ATTACK IS MADE AND RESETS AFTER 
//	A SET AMOUNT OF TIME (5 SECONDS CURRENTLY IN THIS FUNCTION)

//CURRENTLY INACTIVE. USE THIS AS A TEMPLATE FOR A FUTURE RESOURCE
function rogueSinisterMarks() {
	function startTimeout() {
		sinisterMarksTimeout = setTimeout(() => {
			player.sinisterMarks = 0
			quickMessage(`SINISTER MARKS RESET`)
		}, 5000)
	}
	function resetTimeout() {
		clearTimeout(sinisterMarksTimeout)
		startTimeout()
	}
	if (player.playerClass.name == 'Thief') {
		player.sinisterMarks < 5 ? player.sinisterMarks += 1 : quickMessage(`max stacks reached`)
		resetTimeout()
	}
	quickMessage(`Sinister Marks - ${player.sinisterMarks}`)
}

//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++COMBAT FUNCTIONS++//////////////////////////////////////////////////
function tacticsBonus() {
	if (player.tactics.level > 0) {
		applyBuff(player.tactics.buff)
	}
}
function advance(secondCommand) {
	if (player.combat) {
		attack(secondCommand)
		return
	}
	console.log(secondCommand, ' second command')
	player.isStealthed = false
	let targetedMonster
	if (!isNaN(secondCommand)) {
		//targets enemy by number
		targetedMonster = roomEnemies[secondCommand - 1]
		console.log(1)
		console.log(targetedMonster, ' target by number')
	} else if (secondCommand) {
		//targets enemy by name
		targetedMonster = roomEnemies.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z && roomEnemies.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand)))
		console.log(2)
		console.log(targetedMonster, ' target by name')
	} else {
		targetedMonster = roomEnemies.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
		console.log(3)
		console.log(targetedMonster, ' default')
	}
	if (!targetedMonster) {
		targetedMonster = roomEnemies.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
		console.log(4)
		console.log(targetedMonster, ' default')
	}
	if (targetedMonster) {
		tacticsBonus()
		player.combat = true
		targetedMonster.combat = player.combat
		targetedMonster.hostile = true
		player.stasis = true
		player.advancing = true
		advanceCount(player.advanceTimer)
		const line1 = document.createElement('div')
		const line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You engage the `, 'white', line1)
		customizeEachWord(`${targetedMonster.name}`, targetedMonster.color, line1)
		customizeEachWord(`. Seconds until you can act`, 'white', line1)
		customizeEachWord(` [`, 'white', line1)
		customizeEachWord(`${player.advanceTimer}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
		setTimeout(() => {
			player.stasis = false
			player.advancing = false
		}, player.advanceTimer * 1000)
	} else {
		quickMessage('There must be a enemy in the room for you to advance')
	}
}

function retreat(secondCommand) {
	let direction = () => {
		if (secondCommand == 'nw') {
			return 'northwest'
		} else if (secondCommand == 'n') {
			return 'north'
		} else if (secondCommand == 'ne') {
			return 'northeast'
		} else if (secondCommand == 'e') {
			return 'east'
		} else if (secondCommand == 'se') {
			return 'southeast'
		} else if (secondCommand == 's') {
			return 'south'
		} else if (secondCommand == 'sw') {
			return 'southwest'
		} else if (secondCommand == 'w') {
			return 'west'
		} else if (secondCommand == 'u') {
			return 'up'
		} else if (secondCommand == 'd') {
			return 'down'
		} else {
			return secondCommand
		}
	}
	const retreatedDirection = allDirections.find(reDir => reDir == direction() && currentArea.descriptions.zoneExitsBool[reDir] == true)
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	let retreatPenalty = 0
	//use filter then foreach to do something to a group of enemys
	pushMonster.forEach(enemy => (enemy.combat = false)) //if this line works, delete the pushMonster.combat = player.combat below
	if (player.combat == false && secondCommand == undefined) {
		quickMessage(`You are not in combat therefore you cannot retreat`)
	} else if (player.combat == false && secondCommand != undefined) {
		retreatDirection(secondCommand)
	} else if (direction() == retreatedDirection && secondCommand !== undefined) {
		player.combat = false
		pushMonster.combat = player.combat //change this to find the enemys to change combat otherwise this is dead code
		player.stasis = true
		player.retreating = true
		retreatCount(player.retreatTimer)
		blankSpace()
		retreatDirection(secondCommand)
		customizeEachWord(`You disengage combat and retreat. `, 'white', line1)
		customizeEachWord(`Seconds until you can act [`, 'white', line1)
		customizeEachWord(`${player.retreatTimer.toFixed(1)}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
		setTimeout(() => {
			player.stasis = false
			player.retreating = false
		}, player.retreatTimer * 1000)
	} else {
		player.stasis = true
		player.retreating = true
		retreatCount(player.retreatTimer)
		blankSpace()
		customizeEachWord(`You disengage combat and retreat. `, 'white', line1)
		customizeEachWord(`Seconds until you can act [`, 'white', line1)
		customizeEachWord(`${player.retreatTimer.toFixed(1)}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
		setTimeout(() => {
			player.stasis = false
			player.retreating = false
		}, player.retreatTimer * 1000)
		player.combat = false
		pushMonster.combat = player.combat //change this to find the enemys to change combat otherwise this is dead code
	}
}
function combatCheck() {
	const enemyCombatCheck = pushMonster.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z && enemy.combat == true)
	if (enemyCombatCheck) {
		player.combat = true
	} else {
		player.combat = false
	}
}

//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DIRECTION AND MOVEMENT FUNCTIONS++//////////////////////////////////////////////////
function look(command, secondCommand) {
	if (secondCommand == 'nw' || secondCommand == 'northwest') {
		lookNorthwest('northwest')
	} else if (secondCommand == 'n' || secondCommand == 'north') {
		lookNorth('north')
	} else if (secondCommand == 'ne' || secondCommand == 'northeast') {
		lookNortheast('northeast')
	} else if (secondCommand == 'e' || secondCommand == 'east') {
		lookEast('east')
	} else if (secondCommand == 'se' || secondCommand == 'southeast') {
		lookSoutheast('southeast')
	} else if (secondCommand == 's' || secondCommand == 'south') {
		lookSouth('south')
	} else if (secondCommand == 'sw' || secondCommand == 'southwest') {
		lookSouthwest('southwest')
	} else if (secondCommand == 'w' || secondCommand == 'west') {
		lookWest('west')
	} else if (secondCommand == 'u' || secondCommand == 'up') {
		lookUp('up')
	} else if (secondCommand == 'd' || secondCommand == 'down') {
		lookDown('down')
	} else if (command === 'l' || command === 'look') {
		areaCompiler(currentArea)
		updateScroll()
	}
	blankSpace()
}

function lookNorthwest(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x - 1 && areaToLook.y == currentArea.y + 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookNorth(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.y == currentArea.y + 1 && areaToLook.x == currentArea.x && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookNortheast(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x + 1 && areaToLook.y == currentArea.y + 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookEast(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x + 1 && areaToLook.y == currentArea.y && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookSoutheast(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x + 1 && areaToLook.y == currentArea.y - 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookSouth(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.y == currentArea.y - 1 && areaToLook.x == currentArea.x && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookSouthwest(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x - 1 && areaToLook.y == currentArea.y - 1 && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookWest(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.x == currentArea.x - 1 && areaToLook.y == currentArea.y && areaToLook.z == player.z)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookUp(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.z == currentArea.z + 1 && areaToLook.x == currentArea.x && areaToLook.y == currentArea.y)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
function lookDown(secondCommand) {
	const area = allAreas.find(areaToLook => areaToLook.z == currentArea.z - 1 && areaToLook.x == currentArea.x && areaToLook.y == currentArea.y)
	if (area == undefined || !currentArea.descriptions.zoneExitsBool[secondCommand]) {
		quickMessage(`You cannot look in that direction`)
	} else {
		quickMessage(`Glancing to the ${secondCommand} you see...`)
		areaCompiler(area, 'grey', 'dark-red')
		updateScroll()
	}
}
// areaCompiler(currentArea)

const youMoveToThe = (input, area, classChange) => {
	//move direction block
	const masterArea = document.getElementById('masterArea')
	if (masterArea.childElementCount >= 500) {
		//This will remove elements at the top of the scroll page if they exceed or == 500
		let elementCount = masterArea.childElementCount - 500
		for (let i = 0; i < elementCount; i++) {
			masterArea.removeChild(masterArea.firstElementChild)
		}
	}
	const moveDiv = document.createElement('div')
	const moveNode = document.createTextNode(input)
	moveDiv.classList.add(classChange)

	moveDiv.appendChild(moveNode)
	masterArea.appendChild(moveDiv)

	questCheck()
	areaCompiler(area)
	onRoomEntry()
	updateScroll()
}

//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
//////////////////////////////////////////////////++HTML DISPLAY++//////////////////////////////////////////////////
const roomImages = {
	galvadia_town: "images/exteriors/main/galvadia_square/galvadia_square.jpg",
	galvadia_guild_square: "images/exteriors/main/galvadia_guild_square/galvadia_guild_square.jpg",
	galvadia_graveyard: "images/exteriors/graveyard/galvadia graveyard.png",
	galvadia_residential_east: "images/exteriors/town travel/galvadia/galvadia_residential_east.jpg",
	galvadia_exterior_north: "images/exteriors/castle walls/galvadia_exterior_north.jpg",
	galvadia_fields_north: "images/exteriors/landscapes/fields/galvadia fields/galvadia fields north.jpg",
	galvadia_training_fields: "images/exteriors/landscapes/fields/galvadia fields/galvadia training fields.jpg",
	galvadia_fields_west: "images/exteriors/landscapes/fields/galvadia fields/galvadia fields west.jpg",
	galvadia_fields_main: "images/exteriors/landscapes/fields/galvadia fields/galvadia fields main.jpg",
	galvadia_basement: "images/interiors/castle interiors/basement halls/basement halls.jpg",
	galvadia_egberts_room: "images/interiors/castle interiors/egbert's room/egbert's room.jpg",
	galvadia_training_halls_common_room: "images/interiors/castle interiors/common room/common room.jpg",
	galvadia_advanced_training_rooms: "images/interiors/castle interiors/advanced training rooms/advanced training rooms.jpg",
	galvadian_glade_center: "images/exteriors/landscapes/forests/galvadian glade center/galvadian glade center.jpg",
	galvadian_glade_entrance: "images/exteriors/landscapes/forests/galvadian glade entrance/galvadian glade entrance.jpg",
	kobold_cave_main: "images/interiors/cave interiors/kobold cave/kobold main/kobold main.jpg",
	kobold_cave_tunnels: "images/interiors/cave interiors/kobold cave/kobold tunnels/kobold tunnels.jpg",
	kobold_cave_chief_room: "images/interiors/cave interiors/kobold cave/kobold chief room/kobold chief room.jpg",
	the_shallows: "images/exteriors/landscapes/forests/the shallows/the shallows.jpg",
}
function changeRoomPicture(roomId) {
    let roomPictureDisplay = document.getElementById('room-picture');
    // Check if the room ID exists in the roomImages object
    if (roomId in roomImages) {
        roomPictureDisplay.src = roomImages[roomId];
    } else {
        // Default image if the room ID is not found
        roomPictureDisplay.src = "images/banner and misc/no_room.jpg"
    }
}
function updateNpcPicture() {
	let allNpcBoxes = document.querySelectorAll('.npc-box')
	let allNpcsInRoom = getAllNpcsInRoom()
	if (allNpcsInRoom.length === 0) {
		allNpcBoxes.forEach(box => {
			box.classList.add('hide')
		})
	} else {
		allNpcBoxes.forEach((box, index) => {
			if (index < allNpcsInRoom.length) {
				box.src = allNpcsInRoom[index].picture
				box.classList.remove('hide');
			} else {
				box.classList.add('hide');
			}
		});
	}
}
// function updateNpcPicture() {
// 	let allNpcBoxes = document.querySelectorAll('.npc-box')
// 	let allNpcsInRoom = getAllNpcsInRoom()
// 	if (allNpcsInRoom.length === 0) {
// 		//if no npcs are in the room, hides all NPC portrait windows
// 		allNpcBoxes.forEach(box => {
// 			box.classList.add('hide')
// 		})
// 	} else {
// 		//if there are 1 or more npcs, this
// 		allNpcBoxes.forEach((box, index) => {
// 			box.classList.add('hide')
// 			quickMessage(`adding hide class to ${index}`)
// 		})
// 		allNpcBoxes.forEach((box, index) => {
// 			if (index < allNpcsInRoom.length) {
// 				box.classList.remove('hide');
// 				box.src = allNpcsInRoom[index].picture
// 			} else {
// 				console.log(box)
// 				box.classList.add('hide');
// 				box.src = ""
// 			}
// 		});
// 	}
// }


// function updateNpcPicture() {
// 	let allNpcBoxes = document.querySelectorAll('.npc-box')
// 	let allNpcsInRoom = getAllNpcsInRoom()
// 	allNpcBoxes.forEach((box, index) => {
// 		box.src = ""
// 		box.classList.add('hide')
// 		box.classList.remove('hide')
// 		if (allNpcsInRoom[index]) {
// 			box.src = allNpcsInRoom[index].picture
// 		}
// 	})
// }
// function updateNpcPicture() {
// 	let allNpcBoxes = document.querySelectorAll('.npc-box');
// 	let allNpcsInRoom = getAllNpcsInRoom();

// 	if (allNpcsInRoom.length === 0) {
// 		allNpcBoxes.forEach(box => {
// 			box.classList.add('hide');
// 			box.src = ''; // Set the src to an empty string
// 		});
// 	} else {
// 		allNpcBoxes.forEach((box, index) => {
// 			if (index < allNpcsInRoom.length) {
// 				box.onload = function () {
// 					// Image loaded, now set the src
// 					box.src = allNpcsInRoom[index].picture;
// 					// Trigger a reflow to apply the transition
// 					void box.offsetWidth;
// 					// Fade in the element
// 					box.classList.remove()
// 				};
// 			} else {
// 				// Fade out the element before hiding
// 				box.classList.add('hide');
// 				box.src = '';
// 			}
// 		});
// 	}
// }

function displayArea(area, addClass) {
	let areaDescription = area.descriptions.desc
	let areaActionWord = area.descriptions.actionWord
	console.log(areaActionWord)
	// let areaDescriptionSplit = areaDescription.split(/\s|\./)
	let areaDescriptionSplit = areaDescription.split(' ')
	let slicedWordIndexArray = []
	let slicedWords = []
	changeRoomPicture(area.descriptions.zoneType)
	updateNpcPicture()
	// let roomPictureDisplay = document.getElementById('room-picture')
	// roomPictureDisplay.src = "images/forest.jpg"
	if (areaActionWord) {
			areaActionWord.forEach(keyword => {
				console.log(areaActionWord)
				console.log(keyword)
				slicedWordIndexArray.push(areaDescriptionSplit.indexOf(keyword))
				console.log(slicedWordIndexArray)
		})
		slicedWordIndexArray = slicedWordIndexArray.sort(function (a, b) {
			return a - b
		})
		for (let i = 0; i < slicedWordIndexArray.length; i++) {
			slicedWords.push(areaDescriptionSplit[slicedWordIndexArray[i]])
		}
		console.log(slicedWords)
		function compileDescription() {
			// let splitDirections = currentArea.descriptions.zoneExits.split()
			const areaMasterDiv = document.createElement('div')
			const areaNameDiv = document.createElement('div')
			const areaNameNode = document.createTextNode(area.descriptions.areaName)
			const areaDescDiv = document.createElement('div')
			areaDescDiv.classList.add('area-desc')

			const areaNestedExitsAndDirections = document.createElement('div')
			const areaExitsDiv = document.createElement('div')
			if (addClass) {areaExitsDiv.classList.add(addClass)}
			const areaExitsNode = document.createTextNode('Obvious Exits: ')
			const areaDirectionsDiv = document.createElement('div')
			// const areaDirectionsNode = document.createTextNode(area.descriptions.zoneExits)
			console.log(slicedWords)
			areaDescriptionSplit.forEach(word => {
				if (word != slicedWords[0] && 
					word != slicedWords[1] && 
					word != slicedWords[2] && 
					word != slicedWords[3] && 
					word != slicedWords[4] && 
					word != slicedWords[5] &&
					word != slicedWords[6] &&
					word != slicedWords[7] &&
					word != slicedWords[8] &&
					word != slicedWords[9] &&
					word != slicedWords[10] &&
					word != slicedWords[11] &&
					word != slicedWords[12] &&
					word != slicedWords[13]) {
					const areaDescSpan = document.createElement('span')
					if (addClass) {
						areaDescSpan.classList.add(addClass)
					}
					const areaDescNode = document.createTextNode(word + ' ') // new code
					areaDescSpan.appendChild(areaDescNode)
					areaDescDiv.appendChild(areaDescSpan)
				}
				for (let i = 0; i < slicedWords.length; i++) {
					if (word == slicedWords[i]) {
						console.log(word)
						console.log(slicedWords[i])
						let actionWordColor = area?.interactables?.[slicedWords[i]]?.color
						if (actionWordColor != undefined) {
							console.log('	not undefined')
							let areaDescSpan = document.createElement('span')
							let areaDescNode = document.createTextNode(slicedWords[i] + ' ')
							areaDescSpan.appendChild(areaDescNode)
							areaDescSpan.classList.add(actionWordColor())
							areaDescDiv.appendChild(areaDescSpan)
						}
					}
				}

				areaNameDiv.classList.add(area.descriptions.areaNameClass)
				areaNameDiv.classList.add('area-name')
				areaNestedExitsAndDirections.classList.add('nested-exits-directions')
				areaExitsDiv.classList.add('area-exits')
				areaDirectionsDiv.classList.add('area-directions')
				areaNameDiv.appendChild(areaNameNode)
				areaExitsDiv.appendChild(areaExitsNode)
				// areaDirectionsDiv.appendChild(areaDirectionsNode)
				areaNestedExitsAndDirections.appendChild(areaExitsDiv)
				areaNestedExitsAndDirections.appendChild(areaDirectionsDiv)
				areaMasterDiv.appendChild(areaNameDiv)
				areaMasterDiv.appendChild(areaDescDiv)
				areaMasterDiv.appendChild(areaNestedExitsAndDirections)
				masterArea.appendChild(areaMasterDiv)
			})
			let test = Object.entries(area.descriptions.zoneExitsBool)
			test.forEach(element => {
				if (element[1] == 'locked') {
					let directionSpan = document.createElement('span')
					directionSpan.classList.add('yellow')
					let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
					directionSpan.appendChild(directionNode)
					areaDirectionsDiv.appendChild(directionSpan)
				} else if (element[1] == 'blocked') {
					let directionSpan = document.createElement('span')
					directionSpan.classList.add('red')
					let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
					directionSpan.appendChild(directionNode)
					areaDirectionsDiv.appendChild(directionSpan)
				} else {
					let directionSpan = document.createElement('span')
					directionSpan.classList.add('area-directions')
					let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
					directionSpan.appendChild(directionNode)
					areaDirectionsDiv.appendChild(directionSpan)
				}
			})
		}
		compileDescription()
	} else {
		let splitDirections = area.descriptions.zoneExits.split(/\s|\./)
		const areaMasterDiv = document.createElement('div')
		const areaNameDiv = document.createElement('div')
		const areaNameNode = document.createTextNode(area.descriptions.areaName)
		const areaDescDiv = document.createElement('div')
		areaDescDiv.classList.add('area-desc')


		const areaNestedExitsAndDirections = document.createElement('div')
		const areaExitsDiv = document.createElement('div')
		const areaExitsNode = document.createTextNode('Obvious Exits: ')
		const areaDirectionsDiv = document.createElement('div')
		const areaDescNode = document.createTextNode(area.descriptions.desc)

		let test = Object.entries(area.descriptions.zoneExitsBool)
		test.forEach(element => {
			if (element[1] == 'locked') {
				let directionSpan = document.createElement('span')
				directionSpan.classList.add('yellow')
				let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
				directionSpan.appendChild(directionNode)
				areaDirectionsDiv.appendChild(directionSpan)
			} else if (element[1] == 'blocked') {
				let directionSpan = document.createElement('span')
				directionSpan.classList.add('red')
				let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
				directionSpan.appendChild(directionNode)
				areaDirectionsDiv.appendChild(directionSpan)
			} else {
				let directionSpan = document.createElement('span')
				directionSpan.classList.add('area-directions')
				let directionNode = document.createTextNode(capitalizeFirstLetter(element[0]) + ' ')
				directionSpan.appendChild(directionNode)
				areaDirectionsDiv.appendChild(directionSpan)
			}
		})

		// let directionSpan = document.createElement('span')
		// directionSpan.classList.add(colorDirections())
		// let directionNode = document.createTextNode(direction + ' ')
		// directionSpan.appendChild(directionNode)
		// areaDirectionsDiv.appendChild(directionSpan)
		areaNameDiv.classList.add(area.descriptions.areaNameClass)
		areaNameDiv.classList.add('area-name')
		areaDescDiv.classList.add('area-desc')
		areaNestedExitsAndDirections.classList.add('nested-exits-directions')
		areaExitsDiv.classList.add('area-exits')
		areaDirectionsDiv.classList.add('area-directions')
		areaNameDiv.appendChild(areaNameNode)
		areaDescDiv.appendChild(areaDescNode)
		areaExitsDiv.appendChild(areaExitsNode)
		areaNestedExitsAndDirections.appendChild(areaExitsDiv)
		areaNestedExitsAndDirections.appendChild(areaDirectionsDiv)

		areaMasterDiv.appendChild(areaNameDiv)
		areaMasterDiv.appendChild(areaDescDiv)
		areaMasterDiv.appendChild(areaNestedExitsAndDirections)
		masterArea.appendChild(areaMasterDiv)
		if (addClass != undefined) {
			areaNameDiv.classList.add('grey')
			areaDescDiv.classList.add('grey')
			areaExitsDiv.classList.add('grey')
			areaDirectionsDiv.classList.add('grey')
		}
	}
	updateMonsterBox()
}

function displayNpc(area, color) {
	const findNpc = area.npc
	if (findNpc[0] && findNpc[1] == undefined) {
		const peopleDiv = document.createElement('div')
		const peopleSpan = document.createElement('span')
		const peopleNode = document.createTextNode(`People:`)

		peopleDiv.classList.add('people-div')
		peopleSpan.classList.add('people-span')

		peopleSpan.appendChild(peopleNode)
		peopleDiv.appendChild(peopleSpan)
		masterArea.appendChild(peopleDiv)
		findNpc[0].displayName(peopleDiv)
	} else if (findNpc[1]) {
		const peopleDiv = document.createElement('div')
		const peopleSpan = document.createElement('span')
		const peopleNode = document.createTextNode(`People:`)

		peopleDiv.classList.add('people-div')
		peopleSpan.classList.add('people-span')

		peopleSpan.appendChild(peopleNode)
		peopleDiv.appendChild(peopleSpan)
		masterArea.appendChild(peopleDiv)
		findNpc[0].displayName(peopleDiv)
		findNpc.slice(1).forEach(npc => {
			let morePeopleDiv = document.createElement('div')
			let morePeopleSpan = document.createElement('span')
			morePeopleDiv.classList.add('extra-people')
			masterArea.appendChild(morePeopleDiv)
			morePeopleDiv.appendChild(morePeopleSpan)
			npc.displayName(morePeopleDiv)
		})
	}
}
function displayItems() {
	const findItem = pushItem.filter(({ roomId }) => roomId === currentArea.id)
	const findItemName = pushItem.filter(({ roomId }) => roomId === currentArea.id)
	if (findItem.length > 0) {
		const itemsDiv = document.createElement('div')
		const itemNames = findItemName.map(item => itemToNode(item))
		const itemsNode = document.createTextNode(`Items: `)
		itemsDiv.appendChild(itemsNode)
		itemNames.forEach(itemNode => {
			itemsDiv.appendChild(itemNode)
			itemNode.classList.add('item')
		})
		itemsDiv.classList.add('items')
		masterArea.appendChild(itemsDiv)
	}
}

function displayGold(area) {
	if (area.gold > 0) {
		const goldDiv = document.createElement('div')
		const goldNumberSpan = document.createElement('span')
		const goldNode = document.createTextNode(`Gold: `)
		const goldNumberNode = document.createTextNode(`${area.gold}`)
		goldNumberSpan.classList.add('yellow')
		goldDiv.appendChild(goldNode)
		goldNumberSpan.appendChild(goldNumberNode)
		goldDiv.appendChild(goldNumberSpan)
		masterArea.appendChild(goldDiv)
	}
}

function displayMonsters(area, color, enemyColor) {
	// let mappedArea = area != undefined ? area : currentArea
	// const enemyMapMe = pushMonster.filter(({ x, y, z }) => x == mappedArea.x && y == mappedArea.y && z == mappedArea.z)
	if (!coordinatesMatch(player, area)) {
		const mapEnemiesInNextRoom = getAllEnemiesInNextRoom(area)
		if (mapEnemiesInNextRoom.length > 0) {
			const enemyDiv = document.createElement('div')
			const enemyNames = mapEnemiesInNextRoom.map(enemy => enemyToNode(enemy, enemyColor))
			const enemysNode = document.createTextNode('Monsters: ')
			enemyDiv.appendChild(enemysNode)
			enemyNames.forEach(enemyNode => {
				enemyDiv.appendChild(enemyNode)
			})
			enemyDiv.classList.add(color)
			masterArea.appendChild(enemyDiv)
		}
		} else {
		const enemyMapMe = getAllEnemiesInRoom()
		if (enemyMapMe.length > 0) {
			const enemyDiv = document.createElement('div')
			const enemyNames = enemyMapMe.map(enemy => enemyToNode(enemy, enemyColor))
			const enemysNode = document.createTextNode('Monsters: ')
			enemyDiv.appendChild(enemysNode)
			enemyNames.forEach(enemyNode => {
				enemyDiv.appendChild(enemyNode)
			})
			enemyDiv.classList.add(color)
			masterArea.appendChild(enemyDiv)
		}
	}
}

function displayPlaceholder() {
	const placeholder = document.createElement('p')
	masterArea.appendChild(placeholder)
	masterArea.appendChild(placeholder)
}
//compiles functions to display the area, items, and enemys if they exist
function areaCompiler(area, color, enemyColor) {
	blankSpace()
	displayArea(area, color)
	displayNpc(area, color)
	displayItems(area, color)
	displayGold(area, color)
	displayMonsters(area, color, enemyColor)
	// displayPlaceholder()
}
function itemToNode(item) {
	let spanNode = document.createElement('span')
	spanNode.classList.add(item.color ? item.color : 'green')
	let newTextNode = document.createTextNode(`${item.name} `)
	spanNode.appendChild(newTextNode)
	return spanNode
}
function npcToNode(npc) {
	npc.displayName()
	// let spanNode = document.createElement('span')
	// spanNode.classList.add('npc')
	// let newTextNode = document.createTextNode(`${npc.displayName()} `)
	// spanNode.appendChild(newTextNode)
	// return spanNode
}
function npcItemsToNode(item) {
	let spanNode = document.createElement('span')
	let breakNode = document.createElement('br')
	let newTextNode = document.createTextNode(`${item.name} `)
	spanNode.appendChild(newTextNode)
	spanNode.appendChild(breakNode)
	return spanNode
}
function npcSkillsToNode(skill) {
	let spanNode = document.createElement('span')
	let breakNode = document.createElement('br')
	let newTextNode = document.createTextNode(`${skill} `)
	spanNode.appendChild(newTextNode)
	spanNode.appendChild(breakNode)
	return spanNode
}
function enemyToNode(enemy, enemyClass) {
	let enemySpanNode = document.createElement('span')
	enemySpanNode.classList.add(enemyClass ? enemyClass : enemy.color)
	enemySpanNode.classList.add('enemy-margin')
	let newTextNode = document.createTextNode(`${enemy.name} `)
	enemySpanNode.appendChild(newTextNode)
	return enemySpanNode
}

function stats() {
	let playerKeys = Object.keys(player)
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	let line3 = document.createElement('div')
	customizeEachWord(`SKILLS`, 'white', line1)
	customizeEachWord(`Skill Points: ${player.skillPoints}`, 'white', line2)
	customizeEachWord(`Attribute Points: ${player.attributePoints}`, 'white', line3)

	// quickMessage('STATS', 'yellow')
	// quickMessage(`You are currently a level -player.guildLevel- -insert guild rank- of the -insert guild name- guild`)
	// quickMessage(`You are currently world level ${player.level}`)
	// quickMessage(`You are x percent of the way to level x`)
	// quickMessage(`You have gained a total of ${player.experience} experience points in your adventures`)
	// quickMessage(`You have x skill points to spend`)
	// quickMessage(`You have x attribute points to spend`)
	// quickMessage(`Currently wielding ${player.rightHand == empty ? 'nothing' : 'a ' + player.rightHand} in your right hand and ${player.leftHand == empty ? 'nothing' : 'a ' + player.leftHand} in your left hand`)
	// quickMessage(`STR: ${player.str}`)
	// quickMessage(`DEX: ${player.dex}`)
	// quickMessage(`AGI: ${player.agi}`)
	// quickMessage(`INT: ${player.int}`)
	// quickMessage(`WIS: ${player.wis}`)
	// quickMessage(`CON: ${player.con}`)
	// quickMessage(`Max HP: ${player.maxHealth}`)
	// quickMessage(`Max MP: ${player.maxMana}`)
}

function spells() {
	let line1 = document.createElement('div')
	customizeEachWord(`Spells`, 'purple', line1)

	if (player.spells[0] != undefined) {
		player.spells.forEach(spell => {
			let line2 = document.createElement('div')
			customizeEachWord(`${spell.name} `, 'purple', line2)
			customizeEachWord(`${spell.level}`, 'white', line2)
		})
	}
}

function skills() {}
function exp() {
	let currentExp = player.experience
	let currentExpBracket = player.experienceNeededToLevel[player.level - 1]
	let nextExpBracket = player.experienceNeededToLevel[player.level]

	let bracketBase = nextExpBracket - currentExpBracket
	let newExpBase = currentExp - currentExpBracket
	let percentOfTheWayThere = parseInt((newExpBase / bracketBase) * 100).toFixed(2)
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	let line4 = lineFunc()
	let line5 = lineFunc()
	let line6 = lineFunc()
	let line7 = lineFunc()
	blankSpace()
	customizeEachWord(`You are a level `, 'white', line1)
	customizeEachWord(`${player.level} `, 'green', line1)
	customizeEachWord(`${player.race} `, 'white', line1)
	customizeEachWord(`${player.playerClass.name}`, player.playerClass.color, line1)
	customizeEachWord(`Your total experience gained is `, 'white', line2)
	customizeEachWord(`${player.experience}`, 'light-blue', line2)
	customizeEachWord(`You are `, 'white', line3)
	customizeEachWord(`${percentOfTheWayThere}`, 'light-blue', line3)
	customizeEachWord(`% of the way to level `, 'white', line3)
	customizeEachWord(`${player.level + 1}`, 'green', line3)

	customizeEachWord(`You have `, 'white', line5)
	customizeEachWord(`${player.skillPoints} `, 'light-blue', line5)
	customizeEachWord(`skill points`, 'white', line5)

	customizeEachWord(`You have `, 'white', line6)
	customizeEachWord(`${player.attributePoints} `, 'light-blue', line6)
	customizeEachWord(`attribute points`, 'white', line6)
}

function randomClassColor() {
	let allColorClasses = [
		'gray',
		'light-gray',
		'dark-gray',
		'yellow',
		'light-yellow',
		'dark-yellow',
		'green',
		'light-green',
		'dark-green',
		'orange',
		'light-orange',
		'dark-orange',
		'red',
		'light-red',
		'dark-red',
		'purple',
		'light-purple',
		'dark-purple',
		'blue',
		'light-blue',
		'dark-blue',
		'brown',
		'light-brown',
		'dark-brown',
	]
	let colorClassLength = allColorClasses.length
	let randomNumber = randomNumberRange(0, colorClassLength)
	return allColorClasses[randomNumber]
}

function experienceNeededToLevel() {
	return Math.floor(((100 * player.experience) / player.experienceNeededToLevel) * 100) / 100
}

function updateInventory() {
	const pushItemCheck = pushItem.filter(items => items.roomId == 'backpack')
	player.backpack = pushItemCheck.map(items => items.name)
	player.backpack.sort((a, b) => (a.name > b.name ? 1 : -1))
}
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ACTIONS++//////////////////////////////////////////////////

function dialogueSpeedFunc(speed) {
	dialogueSpeed = speed
}

function read(objectThatIsRead) {
	//for reading books, pages, signs, scrolls, etc
	if (objectThatIsRead == 'map') {
		let img = document.createElement('img')
		img.src = 'images/galvadia_minimap.png'
		img.style.height = '500px'
		img.style.width = '500px'
		masterArea.appendChild(img)
	}
	if (currentArea.descriptions[objectThatIsRead]) {
		// currentArea.descriptions.sign()
		currentArea.descriptions[objectThatIsRead]()
	} else if (!currentArea.descriptions.sign && objectThatIsRead == 'sign') {
		quickMessage(`You do not see a ${objectThatIsRead} to read`)
	} else if (objectThatIsRead == undefined) {
		quickMessage(`You must specify what you want to read`)
	} else if (objectThatIsRead != 'sign') {
		quickMessage(`You do not see a ${objectThatIsRead} to read`)
	}
	updateScroll()
}

////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS
////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS
function recall(playerX, playerY, playerZ) {
	player.combat = false
	pushMonster.forEach(enemy => {
		enemy.combat = false
	})
	// if (!playerX && !playerY && !playerZ && egbert.questSequence.fifteenth == true && player.level <= 10) {
	// }
	//Add the above conditional to allow the player to recall after completing the tutorial and if under level 10
	if (playerX == 'square') {
		currentArea = galvadiaTownSquare
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return	
	} 
	if (playerX == 'professions') {
		currentArea = amblersAlley1
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return	
	} 
	if (playerX == 'warrior') {
		currentArea = warriorsGuildBerserkersCommonRoom
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return	
	} 
	if (playerX == 'kobold') {
		currentArea = koboldCavesRoom1
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'graveyard') {
		currentArea = graveyard1
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'guild') {
		currentArea = galvadiaGuildSquare
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'glade') {
		currentArea = centralGlade
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (playerX == 'fields') {
		currentArea = fields9
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	} 
	if (!playerX && playerX != 0) {
		quickMessage(`RECALLED`)
		currentArea = trainingHallsCommonRoom
		player.x = currentArea.x
		player.y = currentArea.y
		player.z = currentArea.z
		quickMessage(`You chant the words of Recall in your head and immediately feel yourself being whisked through space!`)
		blankSpace()
		areaCompiler(currentArea)
		updateScroll()
		return
	}
	//parameters are the x, y values of the targeted room to recall to
	const recallRoom = allAreas.find(area => area.x == playerX && area.y == playerY && area.z == playerZ)
	if (recallRoom != undefined) {
		currentArea.isPlayerHere = false
		currentArea = recallRoom
	} else {
		quickMessage(`Room not found`)
	}
	player.combat = false
	player.x = recallRoom.x
	player.y = recallRoom.y
	player.z = recallRoom.z
	// newLocation()
	areaCompiler(recallRoom)
	updateScroll()
}
function revive() {
	if (player.isAlive) {
		quickMessage(`You are already alive!`)
		return
	}
	player.isAlive = true
	player.health = player.maxHealth - player.maxHealth + 1
	player.mana = player.maxMana - player.maxMana + 1
	player.gold = player.gold / 2
	updatePlayerStats()
	recall(-7, 4, 0)
}
async function unlock(secondCommand) {	
	let direction = () => {
		if (secondCommand == 'nw') {
			return 'northwest'
		} else if (secondCommand == 'n') {
			return 'north'
		} else if (secondCommand == 'ne') {
			return 'northeast'
		} else if (secondCommand == 'e') {
			return 'east'
		} else if (secondCommand == 'se') {
			return 'southeast'
		} else if (secondCommand == 's') {
			return 'south'
		} else if (secondCommand == 'sw') {
			return 'southwest'
		} else if (secondCommand == 'w') {
			return 'west'
		} else if (secondCommand == 'u') {
			return 'up'
		} else if (secondCommand == 'd') {
			return 'down'
		} else {
			return secondCommand
		}
	}
	let playerKey = pushItem.find(item => item.roomToUnlock == currentArea.descriptions.areaName && (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand'))
	let playerKeyIndex = pushItem.indexOf(playerKey)
	if (currentArea.descriptions.zoneExitsBool[direction()] == true || currentArea.descriptions.zoneExitsBool[direction()] == undefined) {
		quickMessage(`There is no locked door in that direction.`)
	} else if (currentArea.descriptions.zoneExitsBool[direction()] == 'locked') {
		if (playerKey == undefined) {
			quickMessage(`You do not have a key to unlock this door.`)
		} else if (playerKey != undefined) {
			currentArea.descriptions.zoneExitsBool[direction()] = true
			pushItem.splice(playerKeyIndex, 1)
			await dialogueWait(200)
			blankSpace()
			quickMessage(`You have unlocked the way to the ${direction()}.`)
			blankSpace()
			await dialogueWait(200)
			quickMessage(`The key disappears in a puff of smoke.`)
			blankSpace()
		} else {
			quickMessage(`Not a valid direction to unlock.`)
		}
	}
}

////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS
////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS////////////////GOD MODE FUNCTIONS

function clean() {
	for (let i = 0; i < pushItem.length; i++) {
		if (currentArea.id === pushItem[i].roomId) {
			pushItem.splice(i, 1)
			i--
		}
	}
	quickMessage('you clean the room')
}

function pickupItem(secondCommand, thirdCommand) {
	let allItems = pushItemAllItemsInRoom()
	let itemPickedUp = pushItemByKeyword(secondCommand)
	let line1 = document.createElement('div')
	const backpackObjects = pushItem.filter(items => items.roomId == 'backpack')
	if (secondCommand == 'all') {
		if (currentArea.gold <= 0 && allItems[0] == undefined) {
			blankSpace()
			customizeEachWord('There is nothing in the room for you to pick up', `white`, line1)
			blankSpace()
		} else if (currentArea.gold > 0 && allItems[0] !== undefined) {
			customizeEachWord(`You pick up all the items in the room and `, 'white', line1)
			blankSpace()
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s)`, 'white', line1)
			blankSpace()
			allItems.forEach(item => (item.roomId = 'backpack'))
			player.backpack = backpackObjects.map(items => items.name)
			player.gold = player.gold + currentArea.gold
			currentArea.gold = 0
		} else if (currentArea.gold > 0 && allItems[0] == undefined) {
			blankSpace()
			customizeEachWord(`You pick up `, 'white', line1)
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s). There are no items on the ground to pick up`, 'white', line1)
			blankSpace()
			player.gold = player.gold + currentArea.gold
			currentArea.gold = 0
		} else if (currentArea.gold <= 0 && allItems[0] !== undefined) {
			blankSpace()
			customizeEachWord(`You pick up all the items in the room and `, 'white', line1)
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s)`, 'white', line1)
			blankSpace()
			allItems.forEach(item => (item.roomId = 'backpack'))
			player.backpack = backpackObjects.map(items => items.name)
		}
	} else if (secondCommand !== 'all') {
		if (itemPickedUp) {
			blankSpace()
			customizeEachWord('You pick up a ', 'white', line1)
			customizeEachWord(`${itemPickedUp.name} `, `${itemPickedUp.color}`, line1)
			customizeEachWord(`and put it in your backpack`, `white`, line1)
			blankSpace()
			itemPickedUp.roomId = 'backpack'
			player.backpack = backpackObjects.map(items => items.name)
		} else if (secondCommand != 'gold' && itemPickedUp == undefined) {
			blankSpace()
			customizeEachWord(`There is no ${secondCommand} to pick up`, 'white', line1)
			blankSpace()
		}
		if (currentArea.gold > 0 && secondCommand == 'gold') {
			blankSpace()
			customizeEachWord(`You pick up `, 'white', line1)
			customizeEachWord(`${currentArea.gold} `, 'yellow', line1)
			customizeEachWord(`gold piece(s)`, 'white', line1)
			blankSpace()
			player.gold = player.gold + currentArea.gold
			currentArea.gold = 0
		}
	}
	updateInventory()
}

function dropItem(secondCommand) {
	let itemDropped = pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand === keyword && roomId === 'backpack'))
	let itemDroppedFromRightHand = pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand == keyword && roomId == 'right hand'))
	let itemDroppedFromLeftHand = pushItem.find(({ keywords, roomId }) => keywords.some(keyword => secondCommand == keyword && roomId == 'left hand'))
	let line1 = document.createElement('div')
	if (itemDropped != undefined) {
		customizeEachWord(`You drop your `, 'white', line1)
		customizeEachWord(`${itemDropped.name}`, `${itemDropped.color}`, line1)
		itemDropped.roomId = currentArea.id
	} else if (itemDroppedFromLeftHand != undefined) {
		customizeEachWord(`You drop your `, 'white', line1)
		customizeEachWord(`${itemDropped.name}`, `${itemDroppedFromLeftHand.color}`, line1)
		itemDroppedFromLeftHand.roomId = currentArea.id
		player.leftHand = empty
	} else if (itemDroppedFromRightHand != undefined) {
		customizeEachWord(`You drop your `, 'white', line1)
		customizeEachWord(`${itemDropped.name}`, `${itemDroppedFromRightHand.color}`, line1)
		itemDroppedFromRightHand.roomId = currentArea.id
		player.rightHand = empty
	} else {
		customizeEachWord(`You do not have a ${secondCommand} to drop`, 'white', line1)
	}
	updateInventory()
	updateCurrentWeaponSkill()
}
//PACK components
function packTwoHanded(twoHandedItem) {
	if (player.rightHand != empty || player.leftHand != empty) {
		let line1 = document.createElement('div')
		twoHandedItem.roomId = backpack
		player.rightHand = empty
		player.leftHand = empty
		// weaponOrShieldRemovePlayerAttribute(twoHandedItem)
		// weaponOrShieldAddPlayerAttribute(player.rightFist)
		// weaponOrShieldAddPlayerAttribute(player.leftFist)
		customizeEachWord(`You pack your `, 'white', line1)
		customizeEachWord(`${twoHandedItem.name}`, twoHandedItem.color, line1)
	}
}
function packRight(rightItem) {
	if (player.rightHand != empty) {
		let line1 = document.createElement('div')
		rightItem.roomId = backpack
		player.rightHand = empty
		// weaponOrShieldRemovePlayerAttribute(rightItem)
		// weaponOrShieldAddPlayerAttribute(player.rightFist)
		customizeEachWord(`You pack your `, 'white', line1)
		customizeEachWord(`${rightItem.name}`, rightItem.color, line1)
	} else {
		quickMessage(`You don't have anything in your right hand to pack`)
	}
}
function packLeft(leftItem) {
	if (player.leftHand != empty) {
		let line1 = document.createElement('div')
		leftItem.roomId = backpack
		player.leftHand = empty
		// weaponOrShieldRemovePlayerAttribute(leftItem)
		// weaponOrShieldAddPlayerAttribute(player.leftFist)
		customizeEachWord(`You pack your `, 'white', line1)
		customizeEachWord(`${leftItem.name}`, leftItem.color, line1)
	} else {
		quickMessage(`You don't have anything in your left hand to pack`)
	}
}

function updateWeaponIcons() {
	let playerWeaponRight = getWeapon1()
	let playerWeaponLeft = getWeapon2()
	let rightHandImage = document.querySelector('.right-hand-image')
	let leftHandImage = document.querySelector('.left-hand-image')
	//is two handed
	if (playerWeaponRight.type.twoHanded) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture}')`;
		rightHandImage.textContent = ''
		leftHandImage.style.backgroundImage = `url('${playerWeaponRight.picture}')`;
		leftHandImage.textContent = ''
		return
	}
	if (playerWeaponRight.type.fists) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture.right}')`;
		rightHandImage.textContent = ''
		leftHandImage.style.backgroundImage = `url('${playerWeaponRight.picture.left}')`;
		leftHandImage.textContent = ''
		return
	}
	if (playerWeaponRight.type.weapon) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture.right}')`;
		rightHandImage.textContent = ''
	}
	if (playerWeaponLeft.type.weapon) {
		leftHandImage.style.backgroundImage = `url('${playerWeaponLeft.picture.left}')`;
		leftHandImage.textContent = ''
	}
	if (playerWeaponRight.type.shield) {
		rightHandImage.style.backgroundImage = `url('${playerWeaponRight.picture}')`
		rightHandImage.textContent = ''
	}
	if (playerWeaponLeft.type.shield) {
		leftHandImage.style.backgroundImage = `url('${playerWeaponLeft.picture}')`
		leftHandImage.textContent = ''
	}
	//right item is not a weapon and is not a shield
	if ((!playerWeaponRight.type.weapon && !playerWeaponRight.type.shield)) {
		rightHandImage.style.backgroundImage = ''
		rightHandImage.textContent = playerWeaponRight.name
		rightHandImage.classList.add('green')
	}
	//left item is not a weapon and is not a shield
	if (!playerWeaponLeft.type.weapon && !playerWeaponLeft.type.shield) {
		leftHandImage.style.backgroundImage = ''
		leftHandImage.textContent = playerWeaponLeft.name
		leftHandImage.classList.add('green')
	}
	//empty hands, but class is either monk to display a fist or class is not a monk to display empty hands
	if (playerWeaponRight.name == 'Right Fist') {
		if (player.guild == 'Monk') {
			rightHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/right fist.png')`;
			rightHandImage.textContent = ''
		} else {
			rightHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/empty hand right.png')`;
			rightHandImage.textContent = ''
		}
	}
	if (playerWeaponLeft.name == 'Left Fist') {
		if (player.guild == 'Monk') {
			leftHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/left fist.png')`;
			leftHandImage.textContent = ''
		} else {
			leftHandImage.style.backgroundImage = `url('images/weapons/fist weapons/unarmed/empty hand left.png')`;
			leftHandImage.textContent = ''
		}
	}
}

function pack(secondCommand) {
	const selectedItemRight = pushItem.find(allItems => allItems.roomId == slot1)
	const selectedItemLeft = pushItem.find(allItems => allItems.roomId == slot2)
	//for packing away two handed item - only coded to have a roomId of 'right hand' / slot1
	const selectedItemTwoHandedBoolean = function () {
		if (selectedItemRight == undefined) {
			return undefined
		} else if (selectedItemRight.type.twoHanded || selectedItemRight.type.martialArts) {
			return true
		} else {
			return false
		}
	}
	const selectedItemTwoHandedBooleanLeft = function () {
		if (selectedItemLeft == undefined) {
			return undefined
		} else if (selectedItemLeft.type.twoHanded || selectedItemLeft.type.martialArts) {
			return true
		} else {
			return false
		}
	}
	if (secondCommand == 'right') {
		if (selectedItemTwoHandedBoolean() == true) {
			packTwoHanded(selectedItemRight)
		} else if (selectedItemTwoHandedBoolean() == false) {
			packRight(selectedItemRight)
			if (player.rightHand == empty && player.leftHand == empty) {
			}
		} else {
			quickMessage(`You have nothing in your right hand to pack.`)
		}
	}
	if (secondCommand == 'left') {
		if (selectedItemTwoHandedBooleanLeft() == true) {
			packTwoHanded(selectedItemLeft)
		} else if (selectedItemTwoHandedBooleanLeft() == false) {
			packLeft(selectedItemLeft)
			if (player.rightHand == empty && player.leftHand == empty) {
			}
		} else {
			quickMessage(`You have nothing in your left hand to pack.`)
		}
	}
	// updateCurrentWeaponSkill()
	// updateWeaponIcons()
	// updateInventory()
	// // updatePlayerStats()
	// updateEquipmentMods()
}
function testerer() {
	player.backpack.forEach(item => {
		player.backpack.forEach(bpItem => {
			item.name == bpItem && item.roomId == 'backpack'
		})
	})
}
//UNPACK components
function unpackTwoHanded(twoHandedItem) {
	if (twoHandedItem.type.twoHanded && player.rightHand == empty && player.leftHand == empty) {
		let line1 = document.createElement('div')
		twoHandedItem.roomId = slot1
		player.rightHand = twoHandedItem.name
		player.leftHand = twoHandedItem.name
		// weaponOrShieldAddPlayerAttribute(twoHandedItem)
		// weaponOrShieldRemovePlayerAttribute(player.rightFist)
		// weaponOrShieldRemovePlayerAttribute(player.leftFist)
		customizeEachWord(`You wield your `, 'white', line1)
		customizeEachWord(`${twoHandedItem.name} `, twoHandedItem.color, line1)
		customizeEachWord(`using both hands`, 'white', line1)
	} else if (player.rightHand != empty && player.leftHand != empty) {
		quickMessage(`Both hands must be free in order to wield a two handed weapon`)
	} else {
		quickMessage(`You cannot dual wield two handed weapons`)
	}
}
function unpackMartialArtsWeapon(martialArtsWeapon) {
	if (martialArtsWeapon.type.martialArts && player.rightHand == empty && player.leftHand == empty) {
		let line1 = document.createElement('div')
		martialArtsWeapon.roomId = slot1
		player.rightHand = martialArtsWeapon.name
		player.leftHand = martialArtsWeapon.name
		// weaponOrShieldAddPlayerAttribute(martialArtsWeapon)
		// weaponOrShieldRemovePlayerAttribute(player.rightFist)
		// weaponOrShieldRemovePlayerAttribute(player.leftFist)
		customizeEachWord(`You don your `, 'white', line1)
		customizeEachWord(`${martialArtsWeapon.name} `, martialArtsWeapon.color, line1)
	} else if (player.rightHand != empty && player.leftHand != empty) {
		quickMessage(`Both hands must be free in order to wield your ${martialArtsWeapon.name}`)
	} else {
		quickMessage(`You already have ${martialArtsWeapon.name} equipped on both hands`)
	}
}
function unpackOneHanded(oneHandedItem) {
	if (player.rightHand == empty) {
		let line1 = document.createElement('div')
		oneHandedItem.roomId = slot1
		player.rightHand = oneHandedItem.name
		// weaponOrShieldAddPlayerAttribute(oneHandedItem)
		// weaponOrShieldRemovePlayerAttribute(player.rightFist)
		player.stance = ''
		customizeEachWord(`You wield your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.name} `, oneHandedItem.color, line1)
		customizeEachWord(`in your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.roomId}`, 'white', line1)
	} else if (player.leftHand == empty && player.rightHand != empty) {
		let line1 = document.createElement('div')
		oneHandedItem.roomId = slot2
		player.leftHand = oneHandedItem.name
		// weaponOrShieldAddPlayerAttribute(oneHandedItem)
		// weaponOrShieldRemovePlayerAttribute(player.leftFist)
		player.stance = ''
		customizeEachWord(`You wield your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.name} `, oneHandedItem.color, line1)
		customizeEachWord(`in your `, 'white', line1)
		customizeEachWord(`${oneHandedItem.roomId}`, 'white', line1)
	} else if (player.rightHand != empty && player.leftHand != empty) {
		quickMessage(`You cannot unpack anything else with your hands full`)
	}
}
function unpackFail(selectedItem, secondCommand) {
	if (secondCommand == undefined) {
		quickMessage(`You must specify what you want to unpack`)
	} else if (selectedItem == undefined) {
		quickMessage(`You do not have a ${secondCommand} to unpack`)
	} else {
		quickMessage('unpackFail invoked, but nothing executed')
	}
}
//UNPACK function
function unpack(secondCommand, thirdCommand) {
	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack')
	allItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))
	const allSpecifiedItems = allItemsInBackpack.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	const selectedItem = isNaN(secondCommand) == false ? allItemsInBackpack[secondCommand] : allItemsInBackpack.find(({ keywords }) => keywords.some(keyword => secondCommand === keyword))
	if (requirementsMet(selectedItem) == false) {
		return
	}
	if (!isNaN(secondCommand) && thirdCommand) {
		quickMessage(`You must specify either the item slot number or the name of the item you want to unpack.`)
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] == undefined) {
		quickMessage(`You do not have an item in that slot to unpack`)
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] != undefined) {
		if (allItemsInBackpack[secondCommand - 1].type.twoHanded) {
			unpackTwoHanded(allItemsInBackpack[secondCommand - 1])
		} else if (allItemsInBackpack[secondCommand - 1].type.martialArts) {
			unpackMartialArtsWeapon(allItemsInBackpack[secondCommand - 1])
		} else {
			unpackOneHanded(allItemsInBackpack[secondCommand - 1])
		}
	} else if (isNaN(secondCommand) && isNaN(thirdCommand) && thirdCommand != undefined && allSpecifiedItems != undefined) {
		let twoKeywordItem = allSpecifiedItems.find(item => item.keywords.some(keyword => keyword == secondCommand + ' ' + thirdCommand))
		if (twoKeywordItem != undefined && twoKeywordItem.type.twoHanded) {
			unpackTwoHanded(twoKeywordItem)
		} else if (twoKeywordItem != undefined && twoKeywordItem.type.martialArts) {
			unpackMartialArtsWeapon(twoKeywordItem)
		} else if (twoKeywordItem != undefined) {
			console.log(twoKeywordItem, ' TWO KEYWORD ITEM')
			unpackOneHanded(twoKeywordItem)
		}
	} else if (isNaN(secondCommand) && !isNaN(thirdCommand) && allSpecifiedItems[thirdCommand - 1] == undefined) {
		quickMessage(`You do not have that number of ${secondCommand} to unpack.`)
	} else if (isNaN(secondCommand) && !isNaN(thirdCommand) && allSpecifiedItems[thirdCommand - 1] != undefined) {
		if (allSpecifiedItems[thirdCommand - 1].type.twoHanded) {
			unpackTwoHanded(allSpecifiedItems[thirdCommand - 1])
		}
		else if (allSpecifiedItems[thirdCommand - 1].type.martialArts) {
			unpackMartialArtsWeapon(allSpecifiedItems[thirdCommand - 1])
		} else {
			unpackOneHanded(allSpecifiedItems[thirdCommand - 1])
		}
	} else if (selectedItem != undefined) {
		if (selectedItem.type.twoHanded) {
			unpackTwoHanded(selectedItem)
		} else if (selectedItem.type.martialArts) {
			unpackMartialArtsWeapon(selectedItem)
		} else {
			unpackOneHanded(selectedItem)
		}
	} else {
		unpackFail(selectedItem, secondCommand)
	}
	updateCurrentWeaponSkill()
	updateWeaponIcons()
	updatePlayerStats()
	updateEquipmentMods()
	updateInventory()
}

function swap() {
	let line1 = lineFunc()
	let rightItem = getWeapon1()
	let leftItem = getWeapon2()
	let holdR = rightItem
	let holdL = leftItem
	if (rightItem.type.twoHanded) {
		quickMessage(`You cannot swap a two handed weapon`)
	} else if (rightItem.type.martialArts) {
		quickMessage(`You cannot swap martial arts weapons`)
	} else if (rightItem.type.unarmed && leftItem.type.unarmed) {
		quickMessage('You have nothing in your hands to swap!')
	} else if (rightItem.roomId == 'right hand' && !rightItem.type.unarmed && leftItem.roomId == 'left hand' && !leftItem.type.unarmed) {
		customizeEachWord(`You move your `, 'white', line1)
		customizeEachWord(`${rightItem.name} `, rightItem.color, line1)
		customizeEachWord(`to your left hand and your `, 'white', line1)
		customizeEachWord(`${leftItem.name} `, leftItem.color, line1)
		customizeEachWord(`to your right hand`, 'white', line1)

		rightItem.roomId = 'left hand'
		leftItem.roomId = 'right hand'
		player.rightHand = holdL.name
		player.leftHand = holdR.name
	} else if (rightItem.refName == 'rightFist') {
		let line1 = document.createElement('div')
		customizeEachWord(`You move your `, 'white', line1)
		customizeEachWord(`${player.leftHand} `, 'green', line1)
		customizeEachWord(`to your right hand`, 'white', line1)
		player.rightHand = player.leftHand
		leftItem.roomId = slot1
		player.leftHand = empty
	} else if (leftItem.refName == 'leftFist') {
		let line1 = document.createElement('div')
		customizeEachWord(`You move your `, 'white', line1)
		customizeEachWord(`${player.rightHand} `, 'green', line1)
		customizeEachWord(`to your left hand`, 'white', line1)
		player.leftHand = player.rightHand
		rightItem.roomId = slot2
		player.rightHand = empty
	} else {
		quickMessage(`None of these`)
	}
	updateWeaponIcons()
	updatePlayerStats()
}

async function cookFunction(secondCommand) {
	let foodItem = getAllItemsOnPerson().find(({ keywords }) => keywords.some(keyword => secondCommand == keyword))
	let doesFireExist = currentArea.descriptions.fire
	let line1 = lineFunc()
	blankSpace()
	if (!doesFireExist) {
		customizeEachWord(`You must be at a source of fire to cook food`, 'white', line1)
		return
	}
	if (!secondCommand) {
		customizeEachWord(`You must specify what you want to cook.`, 'white', line1)
		return
	}
	if (!foodItem) {
		customizeEachWord(`You do not have a ${secondCommand} to cook.`, 'white', line1)
		return
	}
	if (!foodItem.type.food) {
		customizeEachWord(`You can only cook food items.`, 'white', line1)
		return
	}
	if (!foodItem.cookable) {
		customizeEachWord(`This food is already in its edible state.`, 'white', line1)
		return
	}
	if (foodItem.cookable) {
		await dialogueWait(200)
		cookFoodSound.play()
		let cookedDish = foodItem.cookedVersion()
		pushItem.push(cookedDish)
		cookedDish.roomId = foodItem.roomId
		foodItem.roomId = 'backpack' 
		removeItemFromPerson(foodItem)
		cookedDish.cookPhrase()
		updatePlayerStats()
	}
	blankSpace()
}

function directionLevelCheck(levelCheckNumber) {
	if (player.level >= levelCheckNumber) {
		return true
	} else {
		return 'blocked'
	}
}

function mineFunction(secondCommand) {
	let rightItem = getWeapon1()
	let leftItem = getWeapon2()
	if (rightItem?.keywords.find(item => item == 'pickaxe') || leftItem?.keywords.find(item => item == 'pickaxe')) {
	let allVeinTypes = ['copper', 'iron', 'mithril', 'gold', 'silver', 'platinum', 'titanium']
	let areaVeinTypes = []
	for (let veinType in currentArea.interactables) {
		if (allVeinTypes.includes(veinType)) {
			areaVeinTypes.push(veinType)
		}
	}
	let doesCommandMatchAreaVein = areaVeinTypes.includes(secondCommand)
	if (!doesCommandMatchAreaVein) {
		quickMessage(`There is no vein of that type to mine here`)
		return
	}
	let areaInteractableObject = currentArea.interactables[secondCommand]
	if (areaInteractableObject.empty) {
		quickMessage(`This vein is empty`)
		return
	}

	areaInteractableObject.empty = true
	areaInteractableObject.respawn()
	switch (secondCommand) {
		case 'copper':
			blacksmithingMiningBonus(copperOre)
			break;
		case 'iron':
			blacksmithingMiningBonus(ironOre)
			break;
		case 'silver':
			blacksmithingMiningBonus(silverOre)
			break;
		case 'gold':
			blacksmithingMiningBonus(goldOre)
			break;
	}
	quickMessage(`You successfully mine some ore!`)
} else {
	quickMessage(`You must be wielding a pickaxe to mine ore`)
}
}

function herbalismHarvestBonus(herb) {
	for (let i = 0; i < Math.min(player.herbalism.level, 3); i++) {
		let randomNumber = randomNumberRange(1, 100)
		let chanceToReceiveBonus
		if (player.herbalism.level == 2) {chanceToReceiveBonus = 20}
		if (player.herbalism.level == 3) {chanceToReceiveBonus = 20}
		if (player.herbalism.level == 4) {chanceToReceiveBonus = 30}
		if (player.herbalism.level == 5) {chanceToReceiveBonus = 40}
		if (player.herbalism.level == 6) {chanceToReceiveBonus = 50}
		if (player.herbalism.level == 7) {chanceToReceiveBonus = 60}
		if (player.herbalism.level == 8) {chanceToReceiveBonus = 70}
		if (player.herbalism.level == 9) {chanceToReceiveBonus = 80}
		if (player.herbalism.level == 10) {chanceToReceiveBonus = 100}
		if (chanceToReceiveBonus >= randomNumber) {
			craftingMaterialGen(herb(currentArea))
		}
	}
	if (player.herbalism.level == 1) {
		craftingMaterialGen(herb(currentArea))
	}
}
function blacksmithingMiningBonus(ore) {
	for (let i = 0; i < Math.min(player.blacksmithing.level, 3); i++) {
		let randomNumber = randomNumberRange(1, 100)
		let chanceToReceiveBonus
		if (player.blacksmithing.level == 2) {chanceToReceiveBonus = 20}
		if (player.blacksmithing.level == 3) {chanceToReceiveBonus = 20}
		if (player.blacksmithing.level == 4) {chanceToReceiveBonus = 30}
		if (player.blacksmithing.level == 5) {chanceToReceiveBonus = 40}
		if (player.blacksmithing.level == 6) {chanceToReceiveBonus = 50}
		if (player.blacksmithing.level == 7) {chanceToReceiveBonus = 60}
		if (player.blacksmithing.level == 8) {chanceToReceiveBonus = 70}
		if (player.blacksmithing.level == 9) {chanceToReceiveBonus = 80}
		if (player.blacksmithing.level == 10) {chanceToReceiveBonus = 100}
		if (chanceToReceiveBonus >= randomNumber) {
			craftingMaterialGen(ore(currentArea))
		}
	}
	if (player.blacksmithing.level == 1) {
		craftingMaterialGen(ore(currentArea))
	}
}
function leatherworkingBonus() {}

async function harvestFunction(secondCommand) {
	let allPlantTypes = ['clover', 'orchid', 'lily', 'rose', 'ivy', 'sage', 'fern', 'daisy', 'thistle', 'lotus', 'poppy']
	let areaPlantTypes = []
	for (let plantType in currentArea.interactables) {
		if (allPlantTypes.includes(plantType)) {
			areaPlantTypes.push(plantType)
		}
	}
	if (!areaPlantTypes[0]) {
		quickMessage(`There are no plants here to harvest.`)
		return
	}
	let doesCommandMatchAreaPlant = areaPlantTypes.includes(secondCommand)
	console.log(doesCommandMatchAreaPlant, ' DOES COMMAND MATCH AREA PLANT')
	if (!doesCommandMatchAreaPlant) {
		quickMessage(`There is no plant of that type to gather here`)
		return
	}
	let areaInteractableObject = currentArea.interactables[secondCommand]
	if (areaInteractableObject.empty) {
		quickMessage(`This plant is bare`)
		return
	}
	let line1 = lineFunc()
	let plantName
	if (secondCommand == 'clover') {
		plantName = 'Clover'
		await dialogueWait(200)
		herbalismHarvestBonus(clover)
		areaInteractableObject.empty = true
		areaInteractableObject.respawn()
	} else if (secondCommand == 'orchid') {
		plantName = 'Orchid'
		await dialogueWait(200)
		herbalismHarvestBonus(orchid)
		areaInteractableObject.empty = true
		areaInteractableObject.respawn()
	}
	blankSpace()
	let aOrAn
	if (plantName[0] == 'A' || plantName[0] == 'E' || plantName[0] == 'I' || plantName[0] == 'O' || plantName[0] == 'U') {
		aOrAn = 'an'
	} else {
		aOrAn = 'a'
	}
	customizeEachWord(`You pick `, 'white', line1)
	customizeEachWord(`${aOrAn} `, 'white', line1)
	customizeEachWord(`${plantName} `, 'green', line1)
	customizeEachWord(`blossom.`, 'white', line1)
	blankSpace()
}

//
const invalidCommand = input => {
	const invalidCommandDiv = document.createElement('div')
	const invalidCommandNode = document.createTextNode(input + ' is not a proper command')
	invalidCommandDiv.classList.add('output-text')
	invalidCommandDiv.appendChild(invalidCommandNode)
	masterArea.appendChild(invalidCommandDiv)
}
//show skills-spells-items

//Inventory
const showInventory = () => {
	updateInventory()
	let leftRing = pushItem.find(item => item.roomId == 'left ring') != undefined ? pushItem.find(item => item.roomId == 'left ring') : 'white'
	let rightRing = pushItem.find(item => item.roomId == 'right ring') != undefined ? pushItem.find(item => item.roomId == 'right ring') : 'white'
	let leftHand = pushItem.find(item => item.roomId == 'left hand') != undefined ? pushItem.find(item => item.roomId == 'left hand') : 'white'
	let rightHand = pushItem.find(item => item.roomId == 'right hand') != undefined ? pushItem.find(item => item.roomId == 'right hand') : 'white'
	let head = pushItem.find(item => item.roomId == 'head') != undefined ? pushItem.find(item => item.roomId == 'head') : 'white'
	let necklace = pushItem.find(item => item.roomId == 'necklace') != undefined ? pushItem.find(item => item.roomId == 'necklace') : 'white'
	let shoulders = pushItem.find(item => item.roomId == 'shoulders') != undefined ? pushItem.find(item => item.roomId == 'shoulders') : 'white'
	let chest = pushItem.find(item => item.roomId == 'chest') != undefined ? pushItem.find(item => item.roomId == 'chest') : 'white'
	let back = pushItem.find(item => item.roomId == 'back') != undefined ? pushItem.find(item => item.roomId == 'back') : 'white'
	// let arms = pushItem.find(item => item.roomId == 'arms') != undefined ? pushItem.find(item => item.roomId == 'arms') : 'white'
	let hands = pushItem.find(item => item.roomId == 'hands') != undefined ? pushItem.find(item => item.roomId == 'hands') : 'white'
	let waist = pushItem.find(item => item.roomId == 'waist') != undefined ? pushItem.find(item => item.roomId == 'waist') : 'white'
	let legs = pushItem.find(item => item.roomId == 'legs') != undefined ? pushItem.find(item => item.roomId == 'legs') : 'white'
	let feet = pushItem.find(item => item.roomId == 'feet') != undefined ? pushItem.find(item => item.roomId == 'feet') : 'white'

	const equipmentAndBackpackContainer = document.createElement('div')
	const equipmentContainer = document.createElement('div')
	const equipmentHeading = document.createElement('h2')
	const equipmentHeadingTextNode = document.createTextNode('Equipment')
	const equipmentRowsContainer = document.createElement('div')
	const equipmentRow1 = document.createElement('div') //LH RH and rings
	const equipmentRow2 = document.createElement('div') // upper body
	const equipmentRow3 = document.createElement('div') // mid body
	const equipmentRow4 = document.createElement('div') // lower body
	const equipmentRow5 = document.createElement('div') // gold
	const equipmentSlotAndItemContainer1 = document.createElement('div')
	const equipmentSlotAndItemContainer2 = document.createElement('div')
	const equipmentSlotAndItemContainer3 = document.createElement('div')
	const equipmentSlotAndItemContainer4 = document.createElement('div')
	const equipmentSlotAndItemContainer5 = document.createElement('div')
	const equipmentSlotAndItemContainer6 = document.createElement('div')
	const equipmentSlotAndItemContainer7 = document.createElement('div')
	const equipmentSlotAndItemContainer8 = document.createElement('div')
	const equipmentSlotAndItemContainer9 = document.createElement('div')
	const equipmentSlotAndItemContainer10 = document.createElement('div')
	const equipmentSlotAndItemContainer11 = document.createElement('div')
	const equipmentSlotAndItemContainer12 = document.createElement('div')
	const equipmentSlotAndItemContainer13 = document.createElement('div')
	const equipmentSlotAndItemContainer14 = document.createElement('div')
	const equipmentSlotAndItemContainer15 = document.createElement('div') // just here in case I need to add another row
	//
	const LHRingSlotDiv = document.createElement('div')
	const LHRingItemDiv = document.createElement('div')
	const LHWeaponSlotDiv = document.createElement('div')
	const LHWeaponItemDiv = document.createElement('div')

	const RHRingSlotDiv = document.createElement('div')
	const RHRingItemDiv = document.createElement('div')

	const RHWeaponSlotDiv = document.createElement('div')
	const RHWeaponItemDiv = document.createElement('div')

	const headSlotDiv = document.createElement('div')
	const headItemDiv = document.createElement('div')

	const necklaceSlotDiv = document.createElement('div')
	const necklaceItemDiv = document.createElement('div')

	const shoulderSlotDiv = document.createElement('div')
	const shoulderItemDiv = document.createElement('div')

	const chestSlotDiv = document.createElement('div')
	const chestItemDiv = document.createElement('div')

	const backSlotDiv = document.createElement('div')
	const backItemDiv = document.createElement('div')

	// const armsSlotDiv = document.createElement('div')
	// const armsItemDiv = document.createElement('div')

	const handsSlotDiv = document.createElement('div')
	const handsItemDiv = document.createElement('div')

	const waistSlotDiv = document.createElement('div')
	const waistItemDiv = document.createElement('div')

	const legsSlotDiv = document.createElement('div')
	const legsItemDiv = document.createElement('div')

	const feetSlotDiv = document.createElement('div')
	const feetItemDiv = document.createElement('div')
	//
	const LHRingSlot = document.createTextNode(`Left Ring: `)
	const LHRingItem = document.createTextNode(`${player.leftHandRing}`)
	const RHRingSlot = document.createTextNode(`Right Ring: `)
	const RHRingItem = document.createTextNode(`${player.rightHandRing}`)
	const LHWeaponSlot = document.createTextNode('Left Hand: ')
	const LHWeaponItem = document.createTextNode(`${player.leftHand}`)
	const RHWeaponSlot = document.createTextNode('Right Hand: ')
	const RHWeaponItem = document.createTextNode(`${player.rightHand}`)
	const headSlot = document.createTextNode(`Head: `)
	const headItem = document.createTextNode(`${player.head}`)
	const necklaceSlot = document.createTextNode(`Necklace: `)
	const necklaceItem = document.createTextNode(`${player.necklace}`)
	const shoulderSlot = document.createTextNode(`Shoulders: `)
	const shoulderItem = document.createTextNode(`${player.shoulders}`)
	const chestSlot = document.createTextNode(`Chest: `)
	const chestItem = document.createTextNode(`${player.chest}`)
	const backSlot = document.createTextNode(`Back: `)
	const backItem = document.createTextNode(`${player.back}`)
	// const armsSlot = document.createTextNode(`Arms: `)
	// const armsItem = document.createTextNode(`${player.arms}`)
	const handsSlot = document.createTextNode(`Hands: `)
	const handsItem = document.createTextNode(`${player.hands}`)
	const waistSlot = document.createTextNode(`Waist: `)
	const waistItem = document.createTextNode(`${player.waist}`)
	const legsSlot = document.createTextNode(`Legs: `)
	const legsItem = document.createTextNode(`${player.legs}`)
	const feetSlot = document.createTextNode(`Feet: `)
	const feetItem = document.createTextNode(`${player.feet}`)
	const goldSlot = document.createTextNode(`Gold: `)
	const goldAmount = document.createTextNode(`${player.gold}`)

	/////////////////////////////////////////////////////////////////////////////////
	//EQ ROW 1
	//LEFT RING
	LHRingSlotDiv.appendChild(LHRingSlot)
	LHRingItemDiv.appendChild(LHRingItem)
	equipmentSlotAndItemContainer1.classList.add('slot-item-container')
	LHRingSlotDiv.classList.add('all-slots')
	LHRingItemDiv.classList.add(leftRing.color, 'inventory-item')
	//LEFT WEAPON

	LHWeaponSlotDiv.appendChild(LHWeaponSlot)
	LHWeaponItemDiv.appendChild(LHWeaponItem)
	equipmentSlotAndItemContainer2.classList.add('slot-item-container')
	LHWeaponSlotDiv.classList.add('all-slots')
	LHWeaponItemDiv.classList.add(leftHand.color, 'inventory-item')
	if (rightHand && rightHand.type && (rightHand.type.twoHanded || rightHand.type.martialArts)) {
		LHWeaponItemDiv.classList.add(rightHand.color)
	} else {
		LHWeaponItemDiv.classList.add(leftHand.color)
	}

	//RIGHT RING
	RHRingSlotDiv.appendChild(RHRingSlot)
	RHRingItemDiv.appendChild(RHRingItem)
	equipmentSlotAndItemContainer3.classList.add('slot-item-container-end')
	RHRingSlotDiv.classList.add('all-slots')
	RHRingItemDiv.classList.add(rightRing.color, 'inventory-item')
	//RIGHT WEAPON

	RHWeaponSlotDiv.appendChild(RHWeaponSlot)
	RHWeaponItemDiv.appendChild(RHWeaponItem)
	equipmentSlotAndItemContainer4.classList.add('slot-item-container-end')
	RHWeaponSlotDiv.classList.add('all-slots')
	RHWeaponItemDiv.classList.add(rightHand.color, 'inventory-item')
	//HEAD
	headSlotDiv.appendChild(headSlot)
	headItemDiv.appendChild(headItem)
	equipmentSlotAndItemContainer5.classList.add('slot-item-container')
	headSlotDiv.classList.add('all-slots')
	headItemDiv.classList.add(head.color, 'inventory-item')
	//NECKLACE
	necklaceSlotDiv.appendChild(necklaceSlot)
	necklaceItemDiv.appendChild(necklaceItem)
	equipmentSlotAndItemContainer6.classList.add('slot-item-container-middle')
	necklaceSlotDiv.classList.add('all-slots')
	necklaceItemDiv.classList.add(necklace.color, 'inventory-item')
	//SHOULDER
	shoulderSlotDiv.appendChild(shoulderSlot)
	shoulderItemDiv.appendChild(shoulderItem)
	equipmentSlotAndItemContainer7.classList.add('slot-item-container-end')
	shoulderSlotDiv.classList.add('all-slots')
	shoulderItemDiv.classList.add(shoulders.color, 'inventory-item')
	//CHEST
	chestSlotDiv.appendChild(chestSlot)
	chestItemDiv.appendChild(chestItem)
	equipmentSlotAndItemContainer8.classList.add('slot-item-container')
	chestSlotDiv.classList.add('all-slots')
	chestItemDiv.classList.add(chest.color, 'inventory-item')
	//BACK
	backSlotDiv.appendChild(backSlot)
	backItemDiv.appendChild(backItem)
	equipmentSlotAndItemContainer9.classList.add('slot-item-container-middle')
	backSlotDiv.classList.add('all-slots')
	backItemDiv.classList.add(back.color, 'inventory-item')
	//ARMS
	// armsSlotDiv.appendChild(armsSlot)
	// armsItemDiv.appendChild(armsItem)
	// equipmentSlotAndItemContainer10.classList.add('slot-item-container-end')
	// armsSlotDiv.classList.add('all-slots')
	// armsItemDiv.classList.add(arms.color, 'inventory-item')
	//HANDS
	handsSlotDiv.appendChild(handsSlot)
	handsItemDiv.appendChild(handsItem)
	equipmentSlotAndItemContainer11.classList.add('slot-item-container-end')
	handsSlotDiv.classList.add('all-slots')
	handsItemDiv.classList.add(hands.color, 'inventory-item')
	//WAIST
	waistSlotDiv.appendChild(waistSlot)
	waistItemDiv.appendChild(waistItem)
	equipmentSlotAndItemContainer12.classList.add('slot-item-container')
	waistSlotDiv.classList.add('all-slots')
	waistItemDiv.classList.add(waist.color, 'inventory-item')
	//LEGS
	legsSlotDiv.appendChild(legsSlot)
	legsItemDiv.appendChild(legsItem)
	equipmentSlotAndItemContainer13.classList.add('slot-item-container-middle')
	legsSlotDiv.classList.add('all-slots')
	legsItemDiv.classList.add(legs.color, 'inventory-item')
	//FEET
	feetSlotDiv.appendChild(feetSlot)
	feetItemDiv.appendChild(feetItem)
	equipmentSlotAndItemContainer14.classList.add('slot-item-container-end')
	feetSlotDiv.classList.add('all-slots')
	feetItemDiv.classList.add(feet.color, 'inventory-item')

	equipmentSlotAndItemContainer1.appendChild(LHRingSlotDiv)
	equipmentSlotAndItemContainer1.appendChild(LHRingItemDiv)
	equipmentSlotAndItemContainer2.appendChild(LHWeaponSlotDiv)
	equipmentSlotAndItemContainer2.appendChild(LHWeaponItemDiv)
	equipmentSlotAndItemContainer3.appendChild(RHWeaponSlotDiv)
	equipmentSlotAndItemContainer3.appendChild(RHWeaponItemDiv)
	equipmentSlotAndItemContainer4.appendChild(RHRingSlotDiv)
	equipmentSlotAndItemContainer4.appendChild(RHRingItemDiv)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer1)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer2)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer3)
	equipmentRow1.appendChild(equipmentSlotAndItemContainer4)
	//EQ ROW 2
	equipmentSlotAndItemContainer5.appendChild(headSlotDiv)
	equipmentSlotAndItemContainer5.appendChild(headItemDiv)
	equipmentSlotAndItemContainer6.appendChild(necklaceSlotDiv)
	equipmentSlotAndItemContainer6.appendChild(necklaceItemDiv)
	equipmentSlotAndItemContainer7.appendChild(shoulderSlotDiv)
	equipmentSlotAndItemContainer7.appendChild(shoulderItemDiv)
	equipmentRow2.appendChild(equipmentSlotAndItemContainer5)
	equipmentRow2.appendChild(equipmentSlotAndItemContainer6)
	equipmentRow2.appendChild(equipmentSlotAndItemContainer7)
	//EQ ROW 3
	equipmentSlotAndItemContainer8.appendChild(chestSlotDiv)
	equipmentSlotAndItemContainer8.appendChild(chestItemDiv)
	equipmentSlotAndItemContainer9.appendChild(backSlotDiv)
	equipmentSlotAndItemContainer9.appendChild(backItemDiv)
	// equipmentSlotAndItemContainer10.appendChild(armsSlotDiv)
	// equipmentSlotAndItemContainer10.appendChild(armsItemDiv)
	equipmentSlotAndItemContainer11.appendChild(handsSlotDiv)
	equipmentSlotAndItemContainer11.appendChild(handsItemDiv)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer8)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer9)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer10)
	equipmentRow3.appendChild(equipmentSlotAndItemContainer11)
	//EQ ROW 4
	equipmentSlotAndItemContainer12.appendChild(waistSlotDiv)
	equipmentSlotAndItemContainer12.appendChild(waistItemDiv)
	equipmentSlotAndItemContainer13.appendChild(legsSlotDiv)
	equipmentSlotAndItemContainer13.appendChild(legsItemDiv)
	equipmentSlotAndItemContainer14.appendChild(feetSlotDiv)
	equipmentSlotAndItemContainer14.appendChild(feetItemDiv)
	equipmentRow4.appendChild(equipmentSlotAndItemContainer12)
	equipmentRow4.appendChild(equipmentSlotAndItemContainer13)
	equipmentRow4.appendChild(equipmentSlotAndItemContainer14)
	//EQ ROW 5 - GOLD
	equipmentSlotAndItemContainer15.appendChild(goldSlot)
	equipmentSlotAndItemContainer15.appendChild(goldAmount)
	equipmentRow5.appendChild(equipmentSlotAndItemContainer15)
	//EQ row container (orange box)
	equipmentRowsContainer.appendChild(equipmentRow1)
	equipmentRowsContainer.appendChild(equipmentRow2)
	equipmentRowsContainer.appendChild(equipmentRow3)
	equipmentRowsContainer.appendChild(equipmentRow4)
	equipmentRowsContainer.appendChild(equipmentRow5)
	equipmentHeading.appendChild(equipmentHeadingTextNode)
	equipmentContainer.appendChild(equipmentHeading)
	equipmentContainer.appendChild(equipmentRowsContainer)
	equipmentAndBackpackContainer.appendChild(equipmentContainer)
	///////////////////////////////////////CLASSES/////////////////////////////////////////
	equipmentAndBackpackContainer.classList.add('equipment-and-backpack')
	equipmentContainer.classList.add('equipment-container')
	equipmentHeading.classList.add('equipment-heading')
	equipmentRowsContainer.classList.add('equipment-row-container')
	equipmentRow1.classList.add('equipment-row-1')
	equipmentRow2.classList.add('equipment-row-2')
	equipmentRow3.classList.add('equipment-row-3')
	equipmentRow4.classList.add('equipment-row-4')
	equipmentRow5.classList.add('gold-row')

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	const backpackContainer = document.createElement('div')
	const backpackHeading = document.createElement('h2')
	const backpackHeadingTextNode = document.createTextNode('Backpack')
	const backpackColumnsContainer = document.createElement('div')
	const backpackColumn1 = document.createElement('div')
	const backpackColumn2 = document.createElement('div')
	const backpackColumn3 = document.createElement('div')

	const backpackContents = pushItem.filter(item => item.roomId == 'backpack').sort((a, b) => (a.name > b.name ? 1 : -1))
	const backpack1Through20 = backpackContents.filter((item, index) => index <= 9 && item.roomId == 'backpack')
	const backpack21Through40 = backpackContents.filter((item, index) => index >= 10 && index <= 19 && item.roomId == 'backpack')
	const backpack41Through60 = backpackContents.filter((item, index) => index >= 20 && index <= 29 && item.roomId == 'backpack')

	if (backpack1Through20[0]) {
		backpack1Through20.forEach((item, i, arr) => {
			let slotNumber = i + 1
			const backpackSlotAndItemContainer1 = document.createElement('div')
			const slot1Div = document.createElement('div')
			const item1Div = document.createElement('div')

			item1Div.classList.add('backpack-item-name')
			const slot1 = document.createTextNode(`${slotNumber}. `)
			const item1 = document.createTextNode(`${item.name}`)

			slot1Div.appendChild(slot1)
			item1Div.appendChild(item1)

			item1Div.classList.add(item.color)

			backpackSlotAndItemContainer1.appendChild(slot1Div)
			backpackSlotAndItemContainer1.appendChild(item1Div)
			backpackColumn1.appendChild(backpackSlotAndItemContainer1) //
			backpackSlotAndItemContainer1.classList.add('backpack-slot-and-item-container')
		})
	}
	if (backpack21Through40[0]) {
		backpack21Through40.forEach((item, i, arr) => {
			let slotNumber = i + 11
			const backpackSlotAndItemContainer1 = document.createElement('div')
			const slot1Div = document.createElement('div')
			const item1Div = document.createElement('div')

			item1Div.classList.add('backpack-item-name')
			const slot1 = document.createTextNode(`${slotNumber}. `)
			const item1 = document.createTextNode(`${item.name}`)

			slot1Div.appendChild(slot1)
			item1Div.appendChild(item1)

			item1Div.classList.add(item.color)

			backpackSlotAndItemContainer1.appendChild(slot1Div)
			backpackSlotAndItemContainer1.appendChild(item1Div)
			backpackColumn2.appendChild(backpackSlotAndItemContainer1) //
			backpackSlotAndItemContainer1.classList.add('backpack-slot-and-item-container')
		})
	}
	if (backpack41Through60[0]) {
		backpack41Through60.forEach((item, i, arr) => {
			let slotNumber = i + 21
			const backpackSlotAndItemContainer1 = document.createElement('div')
			const slot1Div = document.createElement('div')
			const item1Div = document.createElement('div')

			item1Div.classList.add('backpack-item-name')
			const slot1 = document.createTextNode(`${slotNumber}. `)
			const item1 = document.createTextNode(`${item.name}`)

			slot1Div.appendChild(slot1)
			item1Div.appendChild(item1)

			item1Div.classList.add(item.color)

			backpackSlotAndItemContainer1.appendChild(slot1Div)
			backpackSlotAndItemContainer1.appendChild(item1Div)
			backpackColumn3.appendChild(backpackSlotAndItemContainer1) //
			backpackSlotAndItemContainer1.classList.add('backpack-slot-and-item-container')
		})
	}
	backpackContainer.appendChild(backpackHeading)
	backpackContainer.appendChild(backpackColumnsContainer)
	backpackColumnsContainer.appendChild(backpackColumn1)
	backpackColumnsContainer.appendChild(backpackColumn2)
	backpackColumnsContainer.appendChild(backpackColumn3)
	backpackColumn1.classList.add('backpack-column-1')
	backpackColumn2.classList.add('backpack-column-2')
	backpackColumn3.classList.add('backpack-column-3')

	backpackHeading.appendChild(backpackHeadingTextNode)
	equipmentAndBackpackContainer.appendChild(backpackContainer)
	masterArea.appendChild(equipmentAndBackpackContainer)

	// const backpackColumn2 = document.createElement('div')
	// const backpackColumn3 = document.createElement('div')

	// const backpackSlotAndItemContainer2 = document.createElement('div')
	// const backpackSlotAndItemContainer3 = document.createElement('div')
	// const backpackSlotAndItemContainer4 = document.createElement('div')
	// const backpackSlotAndItemContainer5 = document.createElement('div')
	// const backpackSlotAndItemContainer6 = document.createElement('div')
	// const backpackSlotAndItemContainer7 = document.createElement('div')
	// const backpackSlotAndItemContainer8 = document.createElement('div')
	// const backpackSlotAndItemContainer9 = document.createElement('div')
	// const backpackSlotAndItemContainer10 = document.createElement('div')
	// const backpackSlotAndItemContainer11 = document.createElement('div')
	// const backpackSlotAndItemContainer12 = document.createElement('div')
	// const backpackSlotAndItemContainer13 = document.createElement('div')
	// const backpackSlotAndItemContainer14 = document.createElement('div')
	// const backpackSlotAndItemContainer15 = document.createElement('div')
	// const backpackSlotAndItemContainer16 = document.createElement('div')
	// const backpackSlotAndItemContainer17 = document.createElement('div')
	// const backpackSlotAndItemContainer18 = document.createElement('div')
	// const backpackSlotAndItemContainer19 = document.createElement('div')
	// const backpackSlotAndItemContainer20 = document.createElement('div')
	// const backpackSlotAndItemContainer21 = document.createElement('div')
	// const backpackSlotAndItemContainer22 = document.createElement('div')
	// const backpackSlotAndItemContainer23 = document.createElement('div')
	// const backpackSlotAndItemContainer24 = document.createElement('div')
	// const backpackSlotAndItemContainer25 = document.createElement('div')
	// const backpackSlotAndItemContainer26 = document.createElement('div')
	// const backpackSlotAndItemContainer27 = document.createElement('div')
	// const backpackSlotAndItemContainer28 = document.createElement('div')
	// const backpackSlotAndItemContainer29 = document.createElement('div')
	// const backpackSlotAndItemContainer30 = document.createElement('div')

	// const slot2 = document.createTextNode(`2. `)
	// const item2 = document.createTextNode(`${player.backpack[1]}`)
	// const slot3 = document.createTextNode(`3. `)
	// const item3 = document.createTextNode(`${player.backpack[2]}`)
	// const slot4 = document.createTextNode(`4. `)
	// const item4 = document.createTextNode(`${player.backpack[3]}`)
	// const slot5 = document.createTextNode(`5. `)
	// const item5 = document.createTextNode(`${player.backpack[4]}`)
	// const slot6 = document.createTextNode(`6. `)
	// const item6 = document.createTextNode(`${player.backpack[5]}`)
	// const slot7 = document.createTextNode(`7. `)
	// const item7 = document.createTextNode(`${player.backpack[6]}`)
	// const slot8 = document.createTextNode(`8. `)
	// const item8 = document.createTextNode(`${player.backpack[7]}`)
	// const slot9 = document.createTextNode(`9. `)
	// const item9 = document.createTextNode(`${player.backpack[8]}`)
	// const slot10 = document.createTextNode(`10. `)
	// const item10 = document.createTextNode(`${player.backpack[9]}`)
	// const slot11 = document.createTextNode(`11. `)
	// const item11 = document.createTextNode(`${player.backpack[10]}`)
	// const slot12 = document.createTextNode(`12. `)
	// const item12 = document.createTextNode(`${player.backpack[11]}`)
	// const slot13 = document.createTextNode(`13. `)
	// const item13 = document.createTextNode(`${player.backpack[12]}`)
	// const slot14 = document.createTextNode(`14. `)
	// const item14 = document.createTextNode(`${player.backpack[13]}`)
	// const slot15 = document.createTextNode(`15. `)
	// const item15 = document.createTextNode(`${player.backpack[14]}`)
	// const slot16 = document.createTextNode(`16. `)
	// const item16 = document.createTextNode(`${player.backpack[15]}`)
	// const slot17 = document.createTextNode(`17. `)
	// const item17 = document.createTextNode(`${player.backpack[16]}`)
	// const slot18 = document.createTextNode(`18. `)
	// const item18 = document.createTextNode(`${player.backpack[17]}`)
	// const slot19 = document.createTextNode(`19. `)
	// const item19 = document.createTextNode(`${player.backpack[18]}`)
	// const slot20 = document.createTextNode(`20. `)
	// const item20 = document.createTextNode(`${player.backpack[19]}`)
	// const slot21 = document.createTextNode(`21. `)
	// const item21 = document.createTextNode(`${player.backpack[20]}`)
	// const slot22 = document.createTextNode(`22. `)
	// const item22 = document.createTextNode(`${player.backpack[21]}`)
	// const slot23 = document.createTextNode(`23. `)
	// const item23 = document.createTextNode(`${player.backpack[22]}`)
	// const slot24 = document.createTextNode(`24. `)
	// const item24 = document.createTextNode(`${player.backpack[23]}`)
	// const slot25 = document.createTextNode(`25. `)
	// const item25 = document.createTextNode(`${player.backpack[24]}`)
	// const slot26 = document.createTextNode(`26. `)
	// const item26 = document.createTextNode(`${player.backpack[25]}`)
	// const slot27 = document.createTextNode(`27. `)
	// const item27 = document.createTextNode(`${player.backpack[26]}`)
	// const slot28 = document.createTextNode(`28. `)
	// const item28 = document.createTextNode(`${player.backpack[27]}`)
	// const slot29 = document.createTextNode(`29. `)
	// const item29 = document.createTextNode(`${player.backpack[28]}`)
	// const slot30 = document.createTextNode(`30. `)
	// const item30 = document.createTextNode(`${player.backpack[29]}`)
	// const goldSlot = document.createTextNode(`Gold: `)
	// const goldAmount = document.createTextNode(`${player.gold}`)

	// backpackSlotAndItemContainer2.appendChild(slot2)
	// backpackSlotAndItemContainer2.appendChild(item2)
	// backpackSlotAndItemContainer3.appendChild(slot3)
	// backpackSlotAndItemContainer3.appendChild(item3)
	// backpackSlotAndItemContainer4.appendChild(slot4)
	// backpackSlotAndItemContainer4.appendChild(item4)
	// backpackSlotAndItemContainer5.appendChild(slot5)
	// backpackSlotAndItemContainer5.appendChild(item5)
	// backpackSlotAndItemContainer6.appendChild(slot6)
	// backpackSlotAndItemContainer6.appendChild(item6)
	// backpackSlotAndItemContainer7.appendChild(slot7)
	// backpackSlotAndItemContainer7.appendChild(item7)
	// backpackSlotAndItemContainer8.appendChild(slot8)
	// backpackSlotAndItemContainer8.appendChild(item8)
	// backpackSlotAndItemContainer9.appendChild(slot9)
	// backpackSlotAndItemContainer9.appendChild(item9)
	// backpackSlotAndItemContainer10.appendChild(slot10)
	// backpackSlotAndItemContainer10.appendChild(item10)
	// backpackSlotAndItemContainer11.appendChild(slot11)
	// backpackSlotAndItemContainer11.appendChild(item11)
	// backpackSlotAndItemContainer12.appendChild(slot12)
	// backpackSlotAndItemContainer12.appendChild(item12)
	// backpackSlotAndItemContainer13.appendChild(slot13)
	// backpackSlotAndItemContainer13.appendChild(item13)
	// backpackSlotAndItemContainer14.appendChild(slot14)
	// backpackSlotAndItemContainer14.appendChild(item14)
	// backpackSlotAndItemContainer15.appendChild(slot15)
	// backpackSlotAndItemContainer15.appendChild(item15)
	// backpackSlotAndItemContainer16.appendChild(slot16)
	// backpackSlotAndItemContainer16.appendChild(item16)
	// backpackSlotAndItemContainer17.appendChild(slot17)
	// backpackSlotAndItemContainer17.appendChild(item17)
	// backpackSlotAndItemContainer18.appendChild(slot18)
	// backpackSlotAndItemContainer18.appendChild(item18)
	// backpackSlotAndItemContainer19.appendChild(slot19)
	// backpackSlotAndItemContainer19.appendChild(item19)
	// backpackSlotAndItemContainer20.appendChild(slot20)
	// backpackSlotAndItemContainer20.appendChild(item20)
	// backpackSlotAndItemContainer21.appendChild(slot21)
	// backpackSlotAndItemContainer21.appendChild(item21)
	// backpackSlotAndItemContainer22.appendChild(slot22)
	// backpackSlotAndItemContainer22.appendChild(item22)
	// backpackSlotAndItemContainer23.appendChild(slot23)
	// backpackSlotAndItemContainer23.appendChild(item23)
	// backpackSlotAndItemContainer24.appendChild(slot24)
	// backpackSlotAndItemContainer24.appendChild(item24)
	// backpackSlotAndItemContainer25.appendChild(slot25)
	// backpackSlotAndItemContainer25.appendChild(item25)
	// backpackSlotAndItemContainer26.appendChild(slot26)
	// backpackSlotAndItemContainer26.appendChild(item26)
	// backpackSlotAndItemContainer27.appendChild(slot27)
	// backpackSlotAndItemContainer27.appendChild(item27)
	// backpackSlotAndItemContainer28.appendChild(slot28)
	// backpackSlotAndItemContainer28.appendChild(item28)
	// backpackSlotAndItemContainer29.appendChild(slot29)
	// backpackSlotAndItemContainer29.appendChild(item29)
	// backpackSlotAndItemContainer30.appendChild(slot30)
	// backpackSlotAndItemContainer30.appendChild(item30)

	// backpackColumn1.appendChild(backpackSlotAndItemContainer2)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer3)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer4)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer5)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer6)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer7)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer8)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer9)
	// backpackColumn1.appendChild(backpackSlotAndItemContainer10)

	// backpackColumn2.appendChild(backpackSlotAndItemContainer11)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer12)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer13)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer14)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer15)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer16)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer17)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer18)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer19)
	// backpackColumn2.appendChild(backpackSlotAndItemContainer20)

	// backpackColumn3.appendChild(backpackSlotAndItemContainer21)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer22)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer23)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer24)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer25)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer26)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer27)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer28)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer29)
	// backpackColumn3.appendChild(backpackSlotAndItemContainer30)

	// backpackColumnsContainer.appendChild(backpackColumn2)
	// backpackColumnsContainer.appendChild(backpackColumn3)

	//CLASSES ADDED
	// backpackSlotAndItemContainer2.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer3.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer4.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer5.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer6.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer7.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer8.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer9.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer10.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer11.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer12.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer13.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer14.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer15.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer16.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer17.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer18.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer19.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer20.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer21.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer22.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer23.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer24.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer25.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer26.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer27.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer28.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer29.classList.add('backpack-slot-and-item-container')
	// backpackSlotAndItemContainer30.classList.add('backpack-slot-and-item-container')
	backpackContainer.classList.add('backpack-container')
	backpackHeading.classList.add('backpack-heading')
	backpackColumnsContainer.classList.add('backpack-columns-container')
	// backpackColumn2.classList.add('backpack-column-2')
	// backpackColumn3.classList.add('backpack-column-3')
}


function isPlayerConjuring() {
	let line1 = lineFunc()
	if (player.conjuring) {
		customizeEachWord(`You cannot attack while conjuring a spell without the appropriate skill!`, 'white', line1)
		return true
	} else { 
		return false
	}
}
function doesEnemyExist() {
	let line1 = lineFunc()
	let doesEnemyExist = pushMonster.find(enemy => coordinatesMatch(player, enemy))
	if (!player.isAlive) {
		quickMessage(`You are dead! You must revive before being able to do anything else.`)
		return
	}
	if (doesEnemyExist) {return true}
	if (!doesEnemyExist) {
		customizeEachWord(`There is no enemy for you to attack`, 'white', line1)
		return false
	}
}
function doesValidTargetExist(enemy) {
	let line1 = lineFunc()
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let isPlayerInCombat = 	allEnemiesInRoom.some(enemy => enemy.combat)
	//if player does not have a bow equipped or is in stealth + enemy is not in combat
	if (!rangeCheck() && !isPlayerInCombat) {
		customizeEachWord(`You must be in combat with the enemy to attack it!`, 'white', line1)
		return false
	} else if (!rangeCheck() && isPlayerInCombat) {
		// customizeEachWord(`Player is melee, valid target exists`, 'white', line1)
		return true
	} else if (rangeCheck() && allEnemiesInRoom[0]) {
		// quickMessage(`Player is ranged, valid target exists`, 'white', line1)
		return true
	} else {
		customizeEachWord(`There must be an enemy in the room for you to attack it!`, 'white', line1)
	}
}
function rangeCheck() {
	if (player.currentWeaponSkill.refName == 'bows' || player.isStealthed) {return true}
	else {return false}
}
function currentRightHandWeapon() {
	return pushItem.find(item => item.roomId == 'right hand') == undefined ? player.rightFist : pushItem.find(item => item.roomId == 'right hand')
}
function currentLeftHandWeapon() {
	return pushItem.find(item => item.roomId == 'left hand') == undefined ? player.leftFist : pushItem.find(item => item.roomId == 'left hand')
}

function testWeaponObject() {
	let weapon = {
		rightWeapon: {},
		rightPenType: 'slashing',
		rightRawDamage: 20,

		leftWeapon: {},
		leftPenType: 'piercing',
		leftRawDamage: 10,

	}
}

function singleOrDualSwing(rightItem, leftItem) {
	let weaponsObject = {
		right: {
			totalDamage: 0
		},
		left: {
			totalDamage: 0
		},
	}

	if (rightItem.refName == 'rightFist' && leftItem.refName == 'leftFist') {
		// quickMessage(`Unarmed x2`)
		weaponsObject.right.weapon = rightItem
		weaponsObject.left.weapon = leftItem
	}
	else if (rightItem.type.weapon && !rightItem.type.unarmed && leftItem.type.weapon && !leftItem.type.unarmed) {
		// quickMessage(`Dual wield swing with weapons`)
		weaponsObject.right.weapon = rightItem
		weaponsObject.left.weapon = leftItem
	}
	else if ((rightItem.refName == 'rightFist' || !rightItem.type.weapon) && (leftItem.type.weapon && !leftItem.type.unarmed)) {
		// quickMessage(`LEFT only weapon swing - no fist should swing here`)
		weaponsObject.left.weapon = leftItem
		weaponsObject.doesPlayerCleave = doesPlayerCleave(weaponsObject)
	} else if ((leftItem.refName == 'leftFist' || !leftItem.type.weapon) && (rightItem.type.weapon && !rightItem.type.unarmed)) {
		// quickMessage(`RIGHT only weapon swing - no fist should swing here`)
		weaponsObject.right.weapon = rightItem
		weaponsObject.doesPlayerCleave = doesPlayerCleave(weaponsObject)
	} else if (!rightItem.type.weapon && leftItem.refName == 'leftFist') {
		// quickMessage(`Right hand has a non-weapon item, only left unarmed swing should happen`)
		weaponsObject.left.weapon = leftItem
	} else if (!leftItem.type.weapon && rightItem.refName == 'rightFist') {
		// quickMessage(`Left hand has a non-weapon item, only right unarmed swing should happen`)
		weaponsObject.right.weapon = rightItem
	} else if (!leftItem.type.weapon && !rightItem.type.weapon) {
		// quickMessage(`You cannot attack with those items in your hands!`)
		return false
	}
	calculateNumberOfStrikes(weaponsObject)
	return weaponsObject

}
function doesPlayerCleave() {
	if (player.currentWeaponSkill.refName != 'twoHanded' || 
		player.currentWeaponSkill.refName != 'oneHanded' ||
		player.cleave.level == 0
		) {
		return false
	} else {
		return true
	}
}

function calculateCleaveTargets(targetEnemy, allEnemies) {
	let mainTarget = targetEnemy
	let allEnemiesInCombat = allEnemies
	allEnemiesInCombat.splice(allEnemiesInCombat.indexOf(mainTarget), 1)
	let cleaveTargets = []
	for (let i = 0; i < player.cleave.level; i++) {
		if (allEnemiesInCombat[i]) {
			cleaveTargets.push(allEnemiesInCombat[i])
		}
	}
	if (cleaveTargets[0]) {
		return cleaveTargets
	} else {
		return []
	}
}

function sneakAttack(enemy) {
	stealthBreak()
	resourceGained(backstab, 5, 'maxAdrenaline')
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`You jump out in a `, 'white', line1)
	customizeEachWord(`Sneak attack`, 'orange', line1)
	customizeEachWord(`!`, 'white', line1)
	player.isStealthed = false
	player.combat = true
	enemy.combat = true
}


function updatePlayerMight() {
	if (player.might < player.maxMight)
		player.might++
}
function updatePlayerAdrenaline() {

}
function updatePlayerFocus() {

}

function increasePlayerResource() {
	switch (player.playerClass) {
		case 'Warrior':
			updatePlayerMight()
		case 'Thief':
			updatePlayerAdrenaline()
		case 'Monk':
			updatePlayerFocus()
		case 'Ranger':
		case 'Mage':
	}
}
	// weaponsObject { THIS IS WHAT THE WEAPONSOBJECT LOOKS LIKE
	// 	right: {
	// 		rawDamage:
	// 		penetrationType:
	// 		swingType:
	// 		totalDamage:
	// 		blockedDamage:
	//		verb:
	//		preposition:
	// 	}
	// 	left: {
	// 		rawDamage:
	// 		penetrationType:
	// 		swingType:
	// 		totalDamage:
	// 		blockedDamage:
	//		verb:
	//		preposition:
	// 	}
	// }
// function perceptionCheck(obstacle) {
// 	let playerLevel = player.level
// 	let playerPerception = player.perception.effectiveness()
// 	let playerTotalPerception = playerLevel + playerPerception
// 	return playerTotalPerception >= obstacle
// }

function strengthCheck(check) {
	if (player.str >= check) {
		return true
	} else {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel as though you aren't strong enough to do this.`, 'white', line1)
		blankSpace()
		return false
	}
}
function dexterityCheck(check) {
	if (player.dex >= check) {
		return true
	} else {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel as though you aren't deft enough to do this.`, 'white', line1)
		blankSpace()
		return false
	}
}
function agilityCheck(check) {
	if (player.agi >= check) {
		return true
	} else {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel as though you aren't agile enough to do this.`, 'white', line1)
		blankSpace()
		return false
	}
}
function wisdomCheck(check) {
	if (player.wis >= check) {
		return true
	} else {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel as though you aren't wise enough to understand this.`, 'white', line1)
		blankSpace()
		return false
	}
}
function intelligenceCheck(check) {
	if (player.int >= check) {
		return true
	} else {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel as though you aren't intelligent enough to harvest this.`, 'white', line1)
		blankSpace()
		return false
	}
}
function constitutionCheck(check) {
	if (player.con >= check) {
		return true
	} else {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel as though you aren't tough enough to harvest this.`, 'white', line1)
		blankSpace()
		return false
	}
}

function calculateCritDamage(rightOrLeftObject) {
	let damage = 0
	let roll = randomNumberRange(1, 100)
	if (player.headshot.level > 0) {
		if (player.headshot.procChance() >= roll) {
			damage = (rightOrLeftObject.baseDamage * player.headshot.percentBonus()) - rightOrLeftObject.baseDamage
			quickMessage(`HEADSHOT: ${damage} bonus`)
		}
	}
	if (player.backstabbing.level > 0) {
		if (player.backstabbing.procChance() >= roll) {
			damage = (rightOrLeftObject.baseDamage * player.backstabbing.percentBonus()) - rightOrLeftObject.baseDamage
			quickMessage(`BACKSTAB: ${damage} bonus`)
		}
	}
	if (player.brutalBlows.level > 0) {
		if (player.brutalBlows.procChance() >= roll) {
			damage = (rightOrLeftObject.baseDamage * player.brutalBlows.percentBonus()) - rightOrLeftObject.baseDamage
			quickMessage(`BRUTAL BLOW: ${damage} bonus`)
		}
	}
	return Math.ceil(damage)
}




function attackGodMode(secondCommand, thirdCommand) {
	//FAIL CHECKS BELOW
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let allEnemiesInCombat = getAllEnemiesInCombat()
	let enemiesGettingHit = []
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	enemiesGettingHit.push(targetEnemy)
	// if (actionWait()) {return}
	// if (!doesEnemyExist()) {return} 
	if (!doesValidTargetExist(targetEnemy)) {return}
	if (isPlayerConjuring()) {return}
	let playerWeaponRight = currentRightHandWeapon()
	let playerWeaponLeft = currentLeftHandWeapon()
	let weaponsObject = singleOrDualSwing(playerWeaponRight, playerWeaponLeft)
	let weaponSkillSpeed = player.currentWeaponSkill.speed
	let cleaveTargets = calculateCleaveTargets(targetEnemy, allEnemiesInCombat)
	enemiesGettingHit = enemiesGettingHit.concat(cleaveTargets)
	handleAttack(enemiesGettingHit, weaponsObject)
	// combatCount(weaponSkillSpeed)
	updatePlayerStats()
	updateMonsterBox()
	updateScroll()
}
function attack(secondCommand, thirdCommand) {
	//FAIL CHECKS BELOW
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let allEnemiesInCombat = getAllEnemiesInCombat()
	let enemiesGettingHit = []
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	enemiesGettingHit.push(targetEnemy)
	if (actionWait()) {return}
	// if (!doesEnemyExist()) {return} 
	if (!doesValidTargetExist(targetEnemy)) {return}
	if (isPlayerConjuring()) {return}
	let playerWeaponRight = currentRightHandWeapon()
	let playerWeaponLeft = currentLeftHandWeapon()
	let weaponsObject = singleOrDualSwing(playerWeaponRight, playerWeaponLeft)
	let weaponSkillSpeed = player.currentWeaponSkill.speed
	let cleaveTargets = calculateCleaveTargets(targetEnemy, allEnemiesInCombat)
	enemiesGettingHit = enemiesGettingHit.concat(cleaveTargets)
	handleAttack(enemiesGettingHit, weaponsObject)
	combatCount(weaponSkillSpeed)
	updatePlayerStats()
	updateMonsterBox()
	updateScroll()
}
function handleAttack(enemy, weaponsObject) {
	handleRightAttack(enemy, weaponsObject)
	handleLeftAttack(enemy, weaponsObject)
}
function handleRightAttack(enemy, weaponsObject) {
	console.log(weaponsObject, ' WEAPONS OBJECT')
	let rightObject = weaponsObject.right
	if (rightObject.weapon) {
		enemy.forEach(enemy => {
		if (enemy.health <= 0) {return}
		for (let i = 0; i < rightObject.numberOfExtraStrikes + 1; i++) {
			if (enemy.health <= 0) {return}
			rightObject.doesSwingHit = calculateHitOrMiss(enemy)
			if (!rightObject.doesSwingHit) {
				rightObject.penetrationVerb = calculatePenetrationVerb(rightObject)
				rightObject.preposition = atIntoOnto(rightObject)
				displaySwing(enemy, rightObject)
				// return
			}
			if (rightObject.doesSwingHit) {
			rightObject.classOnHitDisplay = {}
			rightObject.playerBuffOnHit = {}
			rightObject.weaponEnchantment = {}
			rightObject.weaponHealingEnchantment = {}

			rightObject.penetrationVerb = calculatePenetrationVerb(rightObject)
			rightObject.preposition = atIntoOnto(rightObject)
			rightObject.penetrationType = calculatePenetrationType(enemy, rightObject)
			rightObject.baseDamage = baseAttackDamageRight() //Raw base damage
			rightObject.critDamage = calculateCritDamage(rightObject)
			rightObject.totalDamage = calculateDamageWithBonusesAndAfterEnemyMitigation(enemy, rightObject) //base damage after enemy mitigation
			// rightObject.blockedDamage = rightObject.baseDamage - rightObject.totalDamage
			rightObject.blockedDamage = rightObject.damagePreMitigation - rightObject.totalDamage
			rightObject.buffDamage = calculateBuffDamage(enemy, rightObject)
			rightObject.weaponEnchantmentDamage = calculateWeaponEnchantmentDamage(enemy, rightObject)
			rightObject.weaponEnchantmentHeal = calculateWeaponEnchantmentHeal(rightObject)
			rightObject.onHitDamage = calculateOnHitDamage(enemy, rightObject) //0, 10, 15
			rightObject.doesPlayerStun = calculateStunningBlow()
			rightObject.realTotalDamage = rightObject.totalDamage + rightObject.onHitDamage + rightObject.buffDamage
			rightObject.damageToApplyToEnemy = Math.ceil(rightObject.totalDamage + rightObject.onHitDamage + rightObject.buffDamage + rightObject.weaponEnchantmentDamage)
			displaySwing(enemy, rightObject)
			applyDamageToEnemy(enemy, rightObject.damageToApplyToEnemy)
			calculateClassAdditionalEffects(enemy)
			gainClassResourceOnAttack(rightObject.doesSwingHit)
			// applyBuffForReal(rightObject)
			applyOnHitSkillBuffs(rightObject)
			applyStunningBlow(enemy, rightObject)
			console.log(rightObject)
			}
		}
	})
	} 
}
function handleLeftAttack(enemy, weaponsObject) {
	let leftObject = weaponsObject.left
	if (leftObject.weapon) {
		enemy.forEach(enemy => {
			if (enemy.health <= 0) {return}
			for (let i = 0; i < leftObject.numberOfExtraStrikes + 1; i++) {
				if (enemy.health <= 0) {return}
				leftObject.doesSwingHit = calculateHitOrMiss(enemy)
				if (!leftObject.doesSwingHit) {
					leftObject.penetrationVerb = calculatePenetrationVerb(leftObject)
					leftObject.preposition = atIntoOnto(leftObject)
					displaySwing(enemy, leftObject)
					// return
				}
				if (leftObject.doesSwingHit) {
				leftObject.classOnHitDisplay = {}
				leftObject.playerBuffOnHit = {}
				leftObject.weaponEnchantment = {}
				leftObject.weaponHealingEnchantment = {}
	
				leftObject.penetrationVerb = calculatePenetrationVerb(leftObject)
				leftObject.preposition = atIntoOnto(leftObject)
				leftObject.penetrationType = calculatePenetrationType(enemy, leftObject)
				leftObject.baseDamage = baseAttackDamageLeft() //Raw base damage
				leftObject.critDamage = calculateCritDamage(leftObject)
				leftObject.totalDamage = calculateDamageWithBonusesAndAfterEnemyMitigation(enemy, leftObject) //base damage after enemy mitigation
				// leftObject.blockedDamage = leftObject.baseDamage - leftObject.totalDamage
				leftObject.blockedDamage = leftObject.damagePreMitigation - leftObject.totalDamage
	
				leftObject.buffDamage = calculateBuffDamage(enemy, leftObject)
				leftObject.weaponEnchantmentDamage = calculateWeaponEnchantmentDamage(enemy, leftObject)
				leftObject.weaponEnchantmentHeal = calculateWeaponEnchantmentHeal(leftObject)
				leftObject.onHitDamage = calculateOnHitDamage(enemy, leftObject) //0, 10, 15
				leftObject.doesPlayerStun = calculateStunningBlow()

				leftObject.realTotalDamage = leftObject.totalDamage + leftObject.onHitDamage + leftObject.buffDamage
				leftObject.damageToApplyToEnemy = Math.ceil(leftObject.totalDamage + leftObject.onHitDamage + leftObject.buffDamage + leftObject.weaponEnchantmentDamage)
				displaySwing(enemy, leftObject)
				applyDamageToEnemy(enemy, leftObject.damageToApplyToEnemy)
				calculateClassAdditionalEffects(enemy)
				gainClassResourceOnAttack(leftObject.doesSwingHit)
				// applyBuffForReal(leftObject)
				applyOnHitSkillBuffs(leftObject)
				applyStunningBlow(enemy, leftObject)
				console.log(leftObject)
			}
		}
	})
	}
}

// function studySpell(secondCommand, thirdCommand) {
// 	let npcSpellIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
// 	let masterSpell = this.spellsOffered[npcSpellIndex]
// 	let npcSpellMaxLevel = masterSpell != undefined ? this.spellsMaxLevel[masterSpell.refName] : undefined
// 	let playerSpell = player[masterSpell.refName]
// 	let playerGold = player.gold
// 	let playerPoints = player.skillPoints
// 	let goldCost = playerSpell != undefined ? playerSpell.goldToUpgrade() : masterSpell.goldToUpgrade()
// 	let pointsCost = playerSpell != undefined ? playerSpell.pointsToUpgrade() : masterSpell.pointsToUpgrade()

// 	let line1 = document.createElement('div')
// 	console.log('JOCH SKILSL RAN')
// 	if (player.guild != 'Mage') {
// 	if (masterSpell == undefined) {
// 		customizeEachWord(`That skill is not one of the choices`, 'white', line1)
// 	} else if (playerGold < goldCost) {
// 		quickMessage(`You do not have enough gold to learn this spell!`)
// 	} else if (playerPoints < pointsCost) {
// 		quickMessage(`You do not have enough ability points to learn this spell!`)
// 	} else if (playerSpell == undefined && masterSpell != undefined) {
// 		player[masterSpell.refName].level++
// 		customizeEachWord(`You have learned the `, 'white', line1)
// 		customizeEachWord(`${masterSpell.refName} `, masterSpell.color, line1)
// 		customizeEachWord(`spell!`, 'white', line1)
// 		player.gold -= goldCost
// 		player.skillPoints -= pointsCost
// 	} else if (playerSpell.level < npcSpellMaxLevel) {
// 		player[masterSpell.refName].level++
// 		customizeEachWord(`You have furthered your knowledge of the `, 'white', line1)
// 		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
// 		customizeEachWord(`spell! You have increased its level to `, 'white', line1)
// 		customizeEachWord(`${playerSpell.level}`, `light-blue`, line1)
// 		player.gold -= goldCost
// 		player.skillPoints -= pointsCost
// 	} else {
// 		customizeEachWord(`${this.name} `, this.nameColor, line1)
// 		customizeEachWord(`cannot teach you any more of the `, 'white', line1)
// 		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
// 		customizeEachWord(`spell`, 'white', line1)
// 	}
// } else {
// 	quickMessage(`You must be a Mage Initiate to learn from Scylla`)
// }
// }

function calculateTotalDamage(swingObject) {
	let {onHitDamage, damageAfterMitigation} = swingObject
	if (!onHitDamage) {
		onHitDamage = 0
	}
	return damageAfterMitigation + onHitDamage
}

function unarmedProficiencyCheck() {
	return player.unarmed.level > 0
}

function applyStunningBlow(enemy, weaponObject) {
	if (!weaponObject.doesPlayerStun) {return}
	enemy.isStunned = true
	enemy.capturedAttackTimer = enemy.attackTimer
	// player.stunningBlows.flavorText(enemy)
	if (enemy.stunDuration) {
		clearTimeout(enemy.stunDuration)
	}
	clearTimeout(enemy.attackTimerInterval)
	enemy.stunDuration = setTimeout(() => {
		if (enemy.health > 0) {
			quickMessage(`Enemy is no longer stunned`)
		}
		enemy.isStunned = false
		if (!enemy.isBehaviorRunning) {
			enemy.enemyBehavior()
		}
	}, player.stunningBlows.stunningBlowsDuration())
}

function displayOnHitBonusSwing(enemy, swingObject) {
	if (enemy.debuffs) {
		for (const debuff in enemy.debuffs) {
			console.log(enemy.debuffs[debuff])
			if (enemy.debuffs[debuff].flavorText) {
				enemy.debuffs[debuff].flavorText(enemy, swingObject)
			}
		}
	}
}

function baseWeightDamage() {
	//using player.mods.weight because player.weight factors in strength which removes weight from player.weight
	let playerWeight = player.weight
	let baseDamage = playerWeight * 0.5
	return Math.ceil(baseDamage)
}

function baseAttackDamageRight() {
	// THIS FUNCTION CALCULATES THE PLAYER'S BASE ATTACK DAMAGE FOR THE RIGHT WEAPON
	const playerWeapon = player.currentWeaponRight();
	if (!playerWeapon) {return 0}
	if (playerWeapon.type.shield) {return playerWeapon.mods.armor}
	const { attackPower, botMultiplier, topMultiplier } = player[playerWeapon.skillUsed]
	const { botDamage, topDamage } = playerWeapon;
	const lowDamage = Math.ceil(attackPower * (botMultiplier * botDamage));
	const highDamage = Math.ceil(attackPower * (topMultiplier * topDamage));
	const baseDamage = Math.max(0, randomNumberRange(lowDamage, highDamage))
	console.log(lowDamage, 'LOW DAMAGE - RIGHT')
	console.log(highDamage, 'HIGH DAMAGE - RIGHT', highDamage / player.currentWeaponSkill.speed, ' HIGH DPS - RIGHT')
	console.log(baseDamage, 'CHOSEN DAMAGE - RIGHT')
	console.log(baseDamage / player.currentWeaponSkill.speed, ' DPS - RIGHT')
	return baseDamage
}

function baseAttackDamageLeft() {
	// THIS FUNCTION CALCULATES THE PLAYER'S BASE ATTACK DAMAGE FOR THE RIGHT WEAPON
	const playerWeapon = player.currentWeaponLeft();
	if (!playerWeapon) {return 0}
	if (playerWeapon.type.shield) {return playerWeapon.mods.armor}
	const { attackPower, botMultiplier, topMultiplier } = player[playerWeapon.skillUsed]
	const { botDamage, topDamage } = playerWeapon;
	const lowDamage = Math.ceil(attackPower * (botMultiplier * botDamage));
	const highDamage = Math.ceil(attackPower * (topMultiplier * topDamage));
	const baseDamage = Math.max(0, randomNumberRange(lowDamage, highDamage))
	console.log(lowDamage, ' LOW DAMAGE - LEFT')
	console.log(highDamage, ' HIGH DAMAGE - LEFT', highDamage / player.currentWeaponSkill.speed, ' HIGH DPS - LEFT')
	console.log(baseDamage, 'CHOSEN DAMAGE - LEFT')
	console.log(baseDamage / player.currentWeaponSkill.speed, ' DPS - LEFT')
	return baseDamage
}


function calculateNumberOfStrikes(rightOrLeft) {
	let numberOfExtraStrikes = 0
	if (player.multipleStrikes.level > 0) {
		let multipleStrikesNumber = player.multipleStrikes.extraStrikesNumber()
		let multipleStrikeChance = player.multipleStrikes.extraStrikesChance()
		if (rightOrLeft.right.weapon && rightOrLeft.left.weapon) {
			multipleStrikeChance = multipleStrikeChance / 2
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.right.numberOfExtraStrikes = numberOfExtraStrikes
			numberOfExtraStrikes = 0
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.left.numberOfExtraStrikes = numberOfExtraStrikes
			return
		}
		if (rightOrLeft.right.weapon) {
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.right.numberOfExtraStrikes = numberOfExtraStrikes
			return
		}
		if (rightOrLeft.left.weapon) {
			for (let i = 0; i < multipleStrikesNumber; i++) {
				let roll = randomNumberRange(1, 100)
				if (roll <= multipleStrikeChance) {
					numberOfExtraStrikes++
				} 
			}
			rightOrLeft.left.numberOfExtraStrikes = numberOfExtraStrikes
		}
	}
	if (player.extraStrike.level > 0) {
		numberOfExtraStrikes += player.extraStrike.nthStrike()
	}
	if (player.doubleDraw.level > 0) {
		if (player.doubleDraw.counter == player.doubleDraw.nthStrike()) {
			numberOfExtraStrikes++
			player.doubleDraw.counter = 0
		} else {
			player.doubleDraw.counter++
		}
	}
	rightOrLeft.right.numberOfExtraStrikes = numberOfExtraStrikes
	rightOrLeft.left.numberOfExtraStrikes = numberOfExtraStrikes
	// console.log(extraStrikeChance, ' CHANCE OF GETTING AN EXTRA STRIKE')
	// return numberOfExtraStrikes
}


function calculateHitOrMiss(enemy) {
	let hitChance = calculatePlayerAccuracy() - calculateEnemyDodgeChance(enemy)
	let randomRoll = randomNumberRange(1, 100)
	console.log(hitChance, ' PLAYER HIT CHANCE')
	if (hitChance >= randomRoll) {
		increasePlayerResource()
		return true
	} else if (hitChance < randomRoll) {
		return false
	} else {
		quickMessage(`HIT CHANCE IS BUGGED ENEMY PROBABLY HAS FUCKY DODGE STAT`)
		return true
	}
}
function calculateRawAttackDamage(rightOrLeft) {
	if (rightOrLeft.doesSwingHit) {
		const topDamage = Math.ceil(parseFloat((player.currentWeaponSkill.attackPower * (player.currentWeaponSkill.topMultiplier * rightOrLeft.weapon.topDamage))))
		const botDamage = Math.ceil(parseFloat((player.currentWeaponSkill.attackPower * (player.currentWeaponSkill.botMultiplier * rightOrLeft.weapon.botDamage))))
		return randomNumberRange(botDamage, topDamage)
	} else {
		return 0
	}
}



function calculatePenetrationVerb(rightOrLeft) {
	let penetrationTypes = []
	if (rightOrLeft.weapon.mods.hasOwnProperty('slashingPen')) {penetrationTypes.push('slashingPen')}
	if (rightOrLeft.weapon.mods.hasOwnProperty('piercingPen')) {penetrationTypes.push('piercingPen')}
	if (rightOrLeft.weapon.mods.hasOwnProperty('bluntPen')) {penetrationTypes.push('bluntPen')}
	let penetrationIndex = randomNumberRange(0, penetrationTypes.length - 1)
	let penType = penetrationTypes[penetrationIndex]
	if (rightOrLeft.weapon.type.bow) {
		return 'fire'
	}
	switch (penType) {
		case 'slashingPen':
			return 'swing'
		case 'piercingPen':
			return 'thrust'
		case 'bluntPen':
			return  'slam'
		default:
			console.log(`DEFAULT: UNDEFINED PENETRATION TYPE`)
			return undefined
	}
}
function calculatePenetrationType(enemy, rightOrLeft) {
	if (enemy.armor > 0) {return undefined}
	switch (rightOrLeft.penetrationVerb) {
		case 'swing':
			return 'slashing'
		case 'thrust':
			return 'piercing'
		case 'fire':
			return 'piercing'
		case 'slam':
			return  'blunt'
		default:
			console.log(`DEFAULT: UNDEFINED PENETRATION TYPE`)
			return undefined
	}
}
function calculateMagicDamageWithResist(damage, magicResist, playerPenetration) {
	let playerPen = !playerPenetration ? 0 : playerPenetration
	let enemyMagicResist = !magicResist ? 0 : magicResist - playerPen < 0 ? 0 : magicResist - playerPen
	console.log(playerPen, ' PLAYER PEN')
	console.log(enemyMagicResist, ' ENEMY MAGIC RESIST')
 	// let damageAfterResist = Math.ceil(damage * (1 - enemyMagicResist / (enemyMagicResist + 60)))
	let damageAfterResist = Math.ceil((damage - enemyMagicResist) * (1000 / (1000 + enemyMagicResist)) <= 0 ? 0 : (damage - enemyMagicResist) * (1000 / (1000 + enemyMagicResist)))
	console.log(damageAfterResist, ' DAMAGE AFTER RESIST')
	return damageAfterResist
}
function calculateMagicDamage(enemy, spell, numberOfEnemiesToSplit) {
	console.log(spell, 'SPELL')
	let element = spell.element
	let resistType
	let playerPen
	if (element == 'fire') {
		resistType = 'fireResist'
		playerPen = 'firePen'
	}
	if (element == 'water') {
		resistType = 'waterResist'
		playerPen = 'waterPen'

	}
	if (element == 'earth') {
		resistType = 'earthResist'
		playerPen = 'earthPen'

	}
	if (element == 'ice') {
		resistType = 'iceResist'
		playerPen = 'icePen'

	}
	if (element == 'wind') {
		resistType = 'windResist'
		playerPen = 'windPen'

	}
	if (element == 'lightning') {
		resistType = 'lightningResist'
		playerPen = 'lightningPen'

	}
	if (element == 'shadow') {
		resistType = 'shadowResist'
		playerPen = 'shadowPen'

	}
	if (element == 'poison') {
		resistType = 'poisonResist'
		playerPen = 'poisonPen'
	}
	let playerMagicPenetration = player[playerPen] ? player[playerPen] : 0
	let enemyMagicResist = enemy[resistType] ? enemy[resistType] : 0
	let totalEnemyResist = enemyMagicResist - playerMagicPenetration < 0 ? 0 : enemyMagicResist - playerMagicPenetration
	console.log(playerMagicPenetration, ' PLAYER MAGIC PENETRATION')
	console.log(enemyMagicResist, ' ENEMY MAGIC RESIST')
	console.log(totalEnemyResist, ' ENEMY MAGIC RESIST AFTER SUBRACTING PLAYER PENETRATION')
	let damageObject = {
		damageBeforeMagicResist: 0,
		damageAfterMagicResist: 0,
		damageResisted: 0,
		penetrationType: element,
	}
	damageObject.damageBeforeMagicResist = spell.damage(enemy)
	console.log(damageObject.damageBeforeMagicResist)
	if (numberOfEnemiesToSplit && numberOfEnemiesToSplit > 1) {
		damageObject.damageBeforeMagicResist /= numberOfEnemiesToSplit
	}
	console.log(damageObject.damageBeforeMagicResist)
	damageObject.damageAfterMagicResist = Math.ceil((damageObject.damageBeforeMagicResist - totalEnemyResist) * (1000 / (1000 + totalEnemyResist)) <= 0 ? 0 : (damageObject.damageBeforeMagicResist - totalEnemyResist) * (1000 / (1000 + totalEnemyResist)))
	damageObject.damageResisted = Math.ceil(damageObject.damageBeforeMagicResist - damageObject.damageAfterMagicResist)
	
	console.log(damageObject, 'MAGIC DAMAGE OBJECT')

	return damageObject
}



function calculateDamageWithBonusesAndAfterEnemyMitigation(enemy, rightOrLeft) {
	if (!rightOrLeft.doesSwingHit) {
		rightOrLeft.totalDamage = 0
		return
	}
	let damageBeforeMitigation = rightOrLeft.baseDamage + rightOrLeft.critDamage
	rightOrLeft.damagePreMitigation = damageBeforeMitigation
	if (enemy.armor > 0) {
		const damageAfterMitigation = damageBeforeMitigation * (1000 / (1000 + enemy.armor)) <= 0 ? 0 : Math.floor(damageBeforeMitigation * (1000 / (1000 + enemy.armor)))
		return damageAfterMitigation
	} else if (enemy.armor == 0) {
		let slashingPiercingOrBlunt = rightOrLeft.penetrationType == 'slashing' ? 'slashingPen' : rightOrLeft.penetrationType == 'piercing' ? 'piercingPen' : 'bluntPen'
		let enemyArmor = rightOrLeft.penetrationType == 'slashing' ? enemy.slashingArmor : rightOrLeft.penetrationType == 'piercing' ? enemy.piercingArmor : enemy.bluntArmor
		let armorAfterPen = enemyArmor - player[slashingPiercingOrBlunt] <= 0 ? 0 : enemyArmor - player[slashingPiercingOrBlunt]
		const damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
		return Math.floor(damageAfterMitigation)
	}
}
function calculateAbilityDamageAgainstEnemyArmor(enemy, damage, penetrationType) {
	let abilityDamage = damage
	if (enemy.armor > 0) {
		const damageAfterMitigation = abilityDamage * (1000 / (1000 + enemy.armor)) <= 0 ? 0 : Math.floor(abilityDamage * (1000 / (1000 + enemy.armor)))
		return Math.ceil(damageAfterMitigation)
	} else if (enemy.armor == 0) {
		let enemyArmor = penetrationType == 'slashingPen' ? enemy.slashingArmor : penetrationType == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
		let armorAfterPen = enemyArmor - player[penetrationType] <= 0 ? 0 : enemyArmor - player[penetrationType]
		const damageAfterMitigation = (abilityDamage - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (abilityDamage - armorAfterPen) * (1000 / (1000 + armorAfterPen))
		return Math.ceil(damageAfterMitigation)
	}
}
function calculatePenetrationRoll() {
	let weapon1 = getWeapon1()
	let weapon2 = getWeapon2()
	let weaponUsed = weapon1 && weapon2 ? weapon1 : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	let penetrationTypes = []
	if (weaponUsed.mods.hasOwnProperty('slashingPen')) {penetrationTypes.push('slashingPen')}
	if (weaponUsed.mods.hasOwnProperty('piercingPen')) {penetrationTypes.push('piercingPen')}
	if (weaponUsed.mods.hasOwnProperty('bluntPen')) {penetrationTypes.push('bluntPen')}
	let penetrationIndex = randomNumberRange(0, penetrationTypes.length - 1)
	let penType = penetrationTypes[penetrationIndex]
	return penType
}


function calculateBonusDamage(enemy) {
	let stealthBonus = 0
	let bleedBonus = 0
	if (player.isStealthed) {
		stealthBonus = player.stealth.damageBonus()
	}
	// if (enemy.debuff) {
	// 	if (enemy.debuff.bleed) {
	// 		bleedBonus = enemy.debuff.bleed.damageBonus()
	// 	}
	// }
	let totalBonus = stealthBonus + bleedBonus
	return totalBonus
}

function calculateBlockedDamage (rightOrLeft) {
	return rightOrLeft.baseDamage - rightOrLeft.totalDamage
}
function atIntoOnto(rightOrLeft) {
	if (!rightOrLeft.doesSwingHit || rightOrLeft.weapon.type.bow) {
		return 'at the'
	}
	if (rightOrLeft.penetrationVerb == 'swing') {
		return 'at the'
	} else if (rightOrLeft.penetrationVerb == 'thrust') {
		return 'into the'
	} else if (rightOrLeft.penetrationVerb == 'slam') {
		return 'into the'
	} 
}

function applyDamageToEnemy(enemy, damage) {
	if (enemy.health > 0 && player.health > 0 && damage) {
		enemy.health = enemy.health - damage
		if (enemy.health <= 0) {
			// grantBonusOnEnemyDeath(ability)
			enemy.death(enemy)
		}
	}
	updateMonsterBox()
}

function weaponSkillMaxLevel(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 10}
	if (player.level < 20) {return 20}
	if (player.level < 30) {return 30}
	if (player.level < 40) {return 40}
}

function skillMaxLevel5(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 5}
	if (player.level < 20) {return 10}
	if (player.level < 30) {return 15}
	if (player.level < 40) {return 20}
}

function skillMaxLevel4(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 4}
	if (player.level < 20) {return 8}
	if (player.level < 30) {return 12}
	if (player.level < 40) {return 16}
	if (player.level < 50) {return 20}
}
function skillMaxLevel3(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 3}
	if (player.level < 20) {return 6}
	if (player.level < 30) {return 9}
	if (player.level < 40) {return 12}
	if (player.level < 50) {return 15}
}
function skillMaxLevel2(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 2}
	if (player.level < 20) {return 4}
	if (player.level < 30) {return 6}
	if (player.level < 40) {return 8}
	if (player.level < 50) {return 10}
}
function skillMaxLevel1(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 1}
	if (player.level < 20) {return 2}
	if (player.level < 30) {return 3}
	if (player.level < 40) {return 4}
	if (player.level < 50) {return 5}
}
function skillCleaveMaxLevel(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level < 10) {return 1}
	if (player.level < 20) {return 2}
	if (player.level < 30) {return 3}
}
function skillExtraStrikeMaxLevel(skillOrSpell) {
	if (skillOrSpell.level == skillOrSpell.maxLevel) {return skillOrSpell.maxLevel}
	if (player.level >= 20 && player.level < 30) {return 1}
	if (player.level >= 30) {return 2}
}


function calculatePlayerAccuracy() {
	return player.currentWeaponSkill.accuracy + player.level + 75
}
function calculateEnemyDodgeChance(enemy) {
	return enemyDodgeChance = enemy.dodge + enemy.level
}


function updateRoomEnemies(enemy) {
	pushMonster.forEach((pushedEnemy, index) => {
		if (coordinatesMatch(pushedEnemy, player)) {
			if (roomEnemies.indexOf(pushedEnemy) == -1) {
				roomEnemies.push(pushedEnemy);
			}
		}
		if (!coordinatesMatch(pushedEnemy, player)) {
			// Check if the enemy is already in the roomEnemies array
			const index = roomEnemies.indexOf(pushedEnemy);
			if (index !== -1) {
				// Remove the enemy from the array if it exists
				roomEnemies.splice(index, 1);
			}
		}	
	});
}

function getAllEnemiesInCombat() {
	return roomEnemies.filter(enemy => coordinatesMatch(enemy, player) && enemy.combat)
}
// function getAllEnemiesInRoom() {
// 	let allEnemies = pushMonster.filter(enemy => coordinatesMatch(enemy, player))
// 	allEnemies.reverse()
// 	return allEnemies
// }

function getAllEnemiesInRoom() {
	// Filter enemies in the room
	let allEnemies = roomEnemies
	return allEnemies
}

function getAllEnemiesInNextRoom(area) {
	//this is for looking in a direction
	let allEnemies = pushMonster.filter(enemy => enemy.x == area.x && enemy.y == area.y && enemy.z == area.z)
	return allEnemies
}

function getAllNpcsInRoom() {
	return currentArea.npc
}

function findEnemyInCombatByNumber(secondCommand) {
	let enemyByNumber = getAllEnemiesInCombat()
	return enemyByNumber[secondCommand - 1]
}


function findEnemyInCombatByName(secondCommand) {
	const enemyByName = getAllEnemiesInCombat().find(({ keywords }) => keywords.some(x => x == secondCommand))
	return enemyByName
}

function targetCombatEnemy(secondCommand, thirdCommand) {
	let allEnemiesInCombatArray = getAllEnemiesInCombat()
	let enemyByFirst = allEnemiesInCombatArray[0]
	let enemyByName = findEnemyInCombatByName(secondCommand)
	let enemyByNumber = findEnemyInCombatByNumber(secondCommand)
	//attack 3 goblin
	//attack goblin 3
	if (typeof(secondCommand) == 'object') {
		return secondCommand
	}
	if ((secondCommand && thirdCommand) && (!isNaN(secondCommand) || !isNaN(thirdCommand)) && enemyByName != undefined) {
		let allEnemiesWithSameName = getAllEnemiesInCombat().filter(({ keywords }) => keywords.some(x => x == secondCommand))
		let chosenNumber = !isNaN(secondCommand) ? secondCommand : !isNaN(thirdCommand) ? thirdCommand : undefined
		let chosenEnemy = allEnemiesWithSameName[chosenNumber - 1]
		if (chosenEnemy != undefined) {
			return chosenEnemy
		} else {
			return enemyByFirst
		}
	}
	if (secondCommand == undefined) { return enemyByFirst }
	if (secondCommand != undefined && enemyByName == undefined && enemyByNumber == undefined) { return enemyByFirst}
	if (!isNaN(secondCommand) && enemyByNumber != undefined) { //Finds enemy by number. Returns first enemy in the room if enemy by number is undefined
		return enemyByNumber
	}
	if (enemyByName == undefined) {
		return enemyByFirst
	} else if (enemyByName != undefined) {
		return enemyByName
	}
	return enemyByFirst

}
//MELEE TARGETING
//TARGET ENEMIES NOT IN COMBAT
function targetFirstEnemy(secondCommand, thirdCommand) {
	//if player is ranged, target based on that
	let allEnemiesInRoom = getAllEnemiesInRoom()
	if (!secondCommand) {
		return allEnemiesInRoom[0]
	}
	
}
function targetAnyEnemy(secondCommand, thirdCommand) {
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let allCombatEnemiesInRoom = getAllEnemiesInCombat()
	let enemyByFirst = rangeCheck() ? allEnemiesInRoom[0] : allCombatEnemiesInRoom[0]
	let enemyByName = getAnyEnemyByName(secondCommand)
	let enemyByNumber = getAnyEnemyByNumber(secondCommand)
	if ((secondCommand && thirdCommand) && (!isNaN(secondCommand) || !isNaN(thirdCommand)) && enemyByName != undefined) {
		let allEnemiesWithSameName = getAllEnemiesInRoom().filter(({ keywords }) => keywords.some(x => x == secondCommand))
		let chosenNumber = !isNaN(secondCommand) ? secondCommand : !isNaN(thirdCommand) ? thirdCommand : undefined
		let chosenEnemy = allEnemiesWithSameName[chosenNumber - 1]
		if (chosenEnemy != undefined) {
			return chosenEnemy
		} else {
			return enemyByFirst
		}
	}
	if (secondCommand == undefined) { 
		return enemyByFirst 
	}
	if (secondCommand != undefined && enemyByName == undefined && enemyByNumber == undefined) { 
		return enemyByFirst
	}
	if (!isNaN(secondCommand) && enemyByNumber != undefined && enemyByNumber.combat == true) { //Finds enemy by number. Returns first enemy in the room if enemy by number is undefined
		return enemyByNumber
	}
	if (enemyByName == undefined) {
		return enemyByFirst
	} else if (enemyByName != undefined) {
		return enemyByName
	}
	return enemyByFirst

}

function getAnyEnemyByName(secondCommand) {
	const enemyByName = getAllEnemiesInRoom().find(({ keywords }) => keywords.some(x => x == secondCommand))
	return enemyByName
}
function getAnyEnemyByNumber(secondCommand) {
	let enemyByNumber = getAllEnemiesInRoom()
	return enemyByNumber[secondCommand - 1]
}
function getAnyEnemyByFirst() {
	const allMonstersInRoom = getAllEnemiesInRoom()
	const firstMonster = allMonstersInRoom[0]
	return firstMonster
}

function getWeapon1() {
	let weapon1 = pushItem.find(item => item.roomId == 'right hand') //take out from && on if problems occur
	if (weapon1) {
		return weapon1
	} else {
		return player.rightFist
	}
}

function getWeapon2() {
	let weapon2 = pushItem.find(item => item.roomId == 'left hand') //take out from && on if problems occur
	if (weapon2 != undefined) {
		return weapon2
	} else {
		return player.leftFist
	}
}
//might not need to ever use this function
function weaponAndArmorModsCombiner() {
	const allMods = []
	let allEquippedArmor = pushItem.filter(item => isNaN(item.roomId) && item.roomId != backpack)
	allEquippedArmor.forEach(({ mods }) => {
		if (mods != undefined) {
			allMods.push(mods)
		}
	})
	const mergeMods = allMods.reduce((modObj, mod) => {
		for (const [modName, modValue] of Object.entries(mod)) {
			if (!modObj[modName]) {
				modObj[modName] = 0
			}
			modObj[modName] += modValue
		}
		return modObj
	}, {})
	return mergeMods
}
let penetrationArray = []



// function damageCalculator(playerWeapon, targetedMonster, wasPlayerStealthed) {
// 	if (targetedMonster != undefined) {
// 		let monsterLevel = targetedMonster.level
// 		let monsterArmor = targetedMonster.armor
// 		let playerLevel = player.level
// 		let playerWeaponSkill = player.currentWeaponSkill
// 		let penNames = []
// 		let penTypes = []
// 		let ifNoPenTypes = []
// 		let enemyPenTypes = []
// 		let penRoll = []
// 		let ifNoPenRoll = []
// 		let enemyPenRoll = []
// 		let weaponSlashingPen = playerWeapon.mods.slashingPen
// 		let weaponPiercingPen = playerWeapon.mods.piercingPen
// 		let weaponBluntPen = playerWeapon.mods.bluntPen
// 		let attackPower = function () {
// 			let attackPower = 0
// 			if (playerWeapon.skillUsed == 'oneHanded') {
// 				attackPower = player.oneHanded.attackPower
// 			} else if (playerWeapon.skillUsed == 'twoHanded') {
// 				attackPower =  player.twoHanded.attackPower
// 			} else if (playerWeapon.skillUsed == 'unarmed') {
// 				attackPower =  player.unarmed.attackPower
// 			} else if (playerWeapon.skillUsed == 'daggers') {
// 				attackPower =  player.daggers.attackPower
// 			} else if (playerWeapon.skillUsed == 'bows') {
// 				attackPower =  player.bows.attackPower
// 			}
// 			// if (wasPlayerStealthed) {
// 			// 	attackPower += player.stealth.bonusDamage()
// 			// }
// 			return attackPower
// 		}

// 		//need to change this targetedMonster to match the actual attack target in the attack function

// 		let isPenetration
// 		function findPenetration() {
// 			if (targetedMonster.armor == 0) {
// 				isPenetration = true
// 				if (weaponSlashingPen != 0) {
// 					penTypes.push(weaponSlashingPen)
// 					penNames.push('slashing ')
// 					enemyPenTypes.push(targetedMonster.slashingArmor)
// 				}
// 				if (weaponPiercingPen != 0) {
// 					penTypes.push(weaponPiercingPen)
// 					penNames.push('piercing ')
// 					enemyPenTypes.push(targetedMonster.piercingArmor)
// 				}
// 				if (weaponBluntPen != 0) {
// 					penTypes.push(weaponBluntPen)
// 					penNames.push('blunt ')
// 					enemyPenTypes.push(targetedMonster.bluntArmor)
// 				}
// 			}
// 		}
// 		function ifNoPenetration() {
// 			if (targetedMonster.armor != 0) {
// 				isPenetration = false
// 				if (weaponSlashingPen != 0) {
// 					ifNoPenTypes.push(weaponSlashingPen)
// 					penNames.push('slashing ')
// 				}
// 				if (weaponPiercingPen != 0) {
// 					ifNoPenTypes.push(weaponPiercingPen)
// 					penNames.push('piercing ')
// 				}
// 				if (weaponBluntPen != 0) {
// 					ifNoPenTypes.push(weaponBluntPen)
// 					penNames.push('blunt ')
// 				}
// 				console.log(ifNoPenTypes, ' IF NO PEN TYPES')
// 			}
// 		}
// 		ifNoPenetration()
// 		findPenetration()
// 		let arrayNumber = () => Math.floor(Math.random() * penTypes.length)
// 		let arrayNumberNoPenTypes = () => Math.floor(Math.random() * ifNoPenTypes.length)
// 		let rolled = arrayNumber()
// 		let noPenRolled = arrayNumberNoPenTypes()
// 		penRoll = penTypes[rolled]
// 		ifNoPenRoll = ifNoPenTypes[noPenRolled]
// 		if (isPenetration == true) {
// 			penetrationArray.push(penNames[rolled])
// 		} else if (isPenetration == false) {
// 			penetrationArray.push(penNames[noPenRolled])
// 		}
// 		console.log(penNames, ' PEN NAMES ------------------------------------------')
// 		function penRolled() {
// 			if (penRoll != undefined) {
// 				console.log('PENROLL IS DEFINED - PENETRATION SHOULD HAPPEN')
// 				if (penRoll == weaponSlashingPen) {
// 					playerPenetrationName = 'slashing '
// 				} else if (penRoll == weaponPiercingPen) {
// 					playerPenetrationName = 'piercing '
// 				} else if (penRoll == weaponBluntPen) {
// 					playerPenetrationName = 'blunt '
// 				} else {
// 					playerPenetrationName = 'unarmed ' //only for unarmed so that atIntoOnto will return 'into the '
// 				}
// 			} else if (ifNoPenRoll != undefined) {
// 				console.log('PENROLL IS NOT DEFINED - NO PENETRATION SHOULD BE CALCULATED')
// 				if (ifNoPenRoll == weaponSlashingPen) {
// 					playerPenetrationName = 'slashing '
// 				} else if (ifNoPenRoll == weaponPiercingPen) {
// 					playerPenetrationName = 'piercing '
// 				} else if (ifNoPenRoll == weaponBluntPen) {
// 					playerPenetrationName = 'blunt '
// 				} else {
// 					playerPenetrationName = 'unarmed ' //only for unarmed so that atIntoOnto will return 'into the '
// 				}
// 			}
// 		}
// 		penRolled()
// 		enemyPenRoll = enemyPenTypes[rolled]
// 		let hitRoll = Math.floor(Math.random() * 100) + 1
// 		let hitChance = playerAbilityHitChance(targetedMonster)
// 		function additionalBonusDamage() {
// 			let stealthDamage = player.isStealthed == true ? player.stealth.level * 5 : 0
// 			let total = stealthDamage
// 			return total
// 		}
// 		let bonusDamage = additionalBonusDamage()
// 		console.log(hitChance, ' PLAYER HIT CHANCE ------------------------------------------------')
// 		console.log(player[playerWeaponSkill], ' PLAYER WEAPON SKILL --------------------')
// 		//MONSTER HAS FLAT ARMOR
// 		if (hitChance == true && targetedMonster.armor != 0) {
// 			if (targetedMonster != undefined && playerWeapon != undefined) {
// 				if (monsterArmor == 1) {
// 					monsterArmor = 0
// 				}
// 				let botDamage = attackPower() * (playerWeaponSkill.botMultiplier * playerWeapon.botDamage)
// 				let topDamage = attackPower() * (playerWeaponSkill.topMultiplier * playerWeapon.topDamage)
// 				console.log(botDamage, 'BOT DAMAGE')
// 				console.log(topDamage, 'TOP DAMAGE')
// 				botDamage = botDamage >= 0 ? botDamage : 0
// 				topDamage = topDamage >= 0 ? topDamage : 0
// 				let rawDamage = randomNumberRange(botDamage, topDamage) + bonusDamage
// 				let squaredTweak = isNaN(Math.sqrt(monsterLevel - playerLevel)) ? 0 : Math.sqrt(monsterLevel - playerLevel)
// 				let finalDamage = rawDamage * (100 / (100 + monsterArmor)) - squaredTweak <= 0 ? 0 : Math.floor(rawDamage * (100 / (100 + monsterArmor)) - squaredTweak)
// 				blockedDamage = Math.floor(rawDamage - finalDamage)
// 				console.log(botDamage, ' bot damage')
// 				console.log(topDamage, ' top damage')
// 				console.log(rawDamage, ' raw damage')
// 				console.log(squaredTweak, ' squared tweak')
// 				console.log(finalDamage, ' final damage')
// 				return finalDamage
// 			}
// 			//MONSTER HAS PENETRATION ARMOR TYPES
// 		} else if (hitChance == true && penTypes[0] != undefined) {
// 			console.log(hitChance, 'HITCHANCE')
// 			console.log(hitRoll, 'HITROLL')
// 			if (targetedMonster != undefined && playerWeapon != undefined) {
// 				let enemyArmorType
// 				;(() => {
// 					if (playerPenetrationName == 'slashing ') {
// 						enemyArmorType = 'slashingArmor'
// 					}
// 					if (playerPenetrationName == 'piercing ') {
// 						enemyArmorType = 'piercingArmor'
// 					}
// 					if (playerPenetrationName == 'blunt ') {
// 						enemyArmorType = 'bluntArmor'
// 					}
// 				})()
// 				let botDamage = attackPower() * playerWeaponSkill.botMultiplier * playerWeapon.botDamage
// 				let topDamage = attackPower() * playerWeaponSkill.topMultiplier * playerWeapon.topDamage

// 				botDamage = botDamage >= 0 ? botDamage : 0
// 				topDamage = topDamage >= 0 ? topDamage : 0

// 				let rawDamage = randomNumberRange(botDamage, topDamage) + bonusDamage				
// 				let squaredTweak = isNaN(Math.sqrt(monsterLevel - playerLevel)) ? 0 : Math.sqrt(monsterLevel - playerLevel)
// 				let finalDamage = rawDamage * (100 / (100 + monsterArmor)) - squaredTweak <= 0 ? 0 : Math.floor(rawDamage * (100 / (100 + monsterArmor)) - squaredTweak)
// 				blockedDamage = rawDamage - damageAfterArmor
// 				console.log(botDamage, ' bot damage')
// 				console.log(topDamage, ' top damage')
// 				console.log(rawDamage, ' raw damage')
// 				console.log(squaredTweak, ' squared tweak')
// 				console.log(finalDamage, ' final damage')
// 				return finalDamage
// 			}
// 		} else if (hitChance == false) {
// 			console.log(hitChance, 'HITCHANCE')
// 			console.log(hitRoll, 'HITROLL')
// 			return 'miss'
// 		} else {
// 			console.log('UNDEFINED')
// 			return undefined
// 		}
// 	}
// }

function slashingCalculation(weaponSlashing, enemySlashingArmor) {
	if (playerWeapon.slashingPen != 0 && targetedMonster.slashingArmor != 0) {
		slashing = true
	}
}
function piercingCalculation(enemyPiercingArmor) {
	if (playerWeapon.piercingPen != 0 && targetedMonster.piercingArmor != 0) {
		piercing = true
	}
}
function bluntCalculation(enemyBluntArmor) {
	if (playerWeapon.bluntPen != 0 && targetedMonster.bluntArmor != 0) {
		blunt = true
	}
}

//races
//Human
//Elf
//Half-Elf
//Halfling
//Dwarf
//Half-Giant
function goldUpgradeCostLow(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 25}
	if (skillSpellAbility.level <= 10) {return 50}
	if (skillSpellAbility.level <= 15) {return 100}
	if (skillSpellAbility.level >= 16) {return 150}
}
function skillUpgradeCostLow(skillSpellAbility) {
	if (skillSpellAbility.level <= 5) {return 2}
	if (skillSpellAbility.level <= 10) {return 5}
	if (skillSpellAbility.level <= 15) {return 8}
	if (skillSpellAbility.level >= 16) {return 12}
}

function goldUpgradeCost1(skillSpellAbility) {
	if (skillSpellAbility.level <= 4) {return 10 * (skillSpellAbility.level + 1)}
	if (skillSpellAbility.level <= 9) {return 25 * (skillSpellAbility.level + 1)}
	if (skillSpellAbility.level <= 14) {return 50 * (skillSpellAbility.level + 1)}
	if (skillSpellAbility.level >= 19) {return 125 * (skillSpellAbility.level + 1)}
}
function skillUpgradeCost1(skillSpellAbility) {
	if (skillSpellAbility.level <= 4) {return 1 + (skillSpellAbility.level * 1)}
	if (skillSpellAbility.level <= 9) {return 2 + (skillSpellAbility.level * 2)}
	if (skillSpellAbility.level <= 14) {return 3 + (skillSpellAbility.level * 3)}
	if (skillSpellAbility.level >= 19) {return 4 + (skillSpellAbility.level + 4)}
}

function goldUpgradeCost2(skillSpellAbility) {
	if (skillSpellAbility.level <= 4) {return 20 * (skillSpellAbility.level + 1)}
	if (skillSpellAbility.level <= 9) {return 45 * (skillSpellAbility.level + 1)}
	if (skillSpellAbility.level <= 14) {return 90 * (skillSpellAbility.level + 1)}
	if (skillSpellAbility.level <= 19) {return 195 * (skillSpellAbility.level + 1)}
}
function skillUpgradeCost2(skillSpellAbility) {
	if (skillSpellAbility.level <= 4) {return 5 + (skillSpellAbility.level * 1)}
	if (skillSpellAbility.level <= 9) {return 5 + (skillSpellAbility.level * 2)}
	if (skillSpellAbility.level <= 14) {return 5 + (skillSpellAbility.level * 3)}
	if (skillSpellAbility.level <= 19) {return 5 + (skillSpellAbility.level * 4)}
}


function abilityGoldUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level <= 3) {return 125}
	if (skillSpellAbility.level <= 5) {return 250}
	if (skillSpellAbility.level <= 7) {return 375}
	if (skillSpellAbility.level >= 8) {return 500}
}
function abilityUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level <= 3) {return 20}
	if (skillSpellAbility.level <= 5) {return 30}
	if (skillSpellAbility.level <= 7) {return 40}
	if (skillSpellAbility.level >= 8) {return 50}
}

function spellGoldUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level == 0) {return 50}
	if (skillSpellAbility.level == 1) {return 100}
	if (skillSpellAbility.level == 2) {return 200}
	if (skillSpellAbility.level == 3) {return 300}
	if (skillSpellAbility.level == 4) {return 400}
	if (skillSpellAbility.level == 5) {return 650}
	if (skillSpellAbility.level == 6) {return 900}
	if (skillSpellAbility.level == 7) {return 1250}
	if (skillSpellAbility.level == 8) {return 1500}
	if (skillSpellAbility.level >= 9) {return 2000}
}
function spellUpgradeCost(skillSpellAbility) {
	if (skillSpellAbility.level < 10) {return 10 * skillSpellAbility.level}
}



function enemyKillExperience(enemy, baseLevel) {
	// let enemyLevelMod = enemy.level * enemy.level
	// let enemyLevelMod = (enemy.level - baseLevel) * 0.1
	let baseExperience = enemy.baseExperience
	// let experienceLevelBonus = baseExperience * enemyLevelMod
	// console.log(enemyLevelMod)
	// console.log(baseExperience)
	// console.log(experienceLevelBonus)
	if (enemy.level - player.level >= 5) {baseExperience *= 1.25}
	if (enemy.level - player.level == 4) {baseExperience *= 1.20}
	if (enemy.level - player.level == 3) {baseExperience *= 1.15}
	if (enemy.level - player.level == 2) {baseExperience *= 1.1}
	if (enemy.level - player.level == 1) {baseExperience *= 1.05}
	if (enemy.level - player.level == 0) {baseExperience *= 1.00}
	if (enemy.level - player.level == -1) {baseExperience *= 0.9}
	if (enemy.level - player.level == -2) {baseExperience *= 0.8}
	if (enemy.level - player.level == -3) {baseExperience *= 0.7}
	if (enemy.level - player.level == -4) {baseExperience *= 0.6}
	if (enemy.level - player.level == -5) {baseExperience *= 0.5}
	if (enemy.level - player.level == -6) {baseExperience *= 0.4}
	if (enemy.level - player.level == -7) {baseExperience *= 0.3}
	if (enemy.level - player.level == -8) {baseExperience *= 0.2}
	if (enemy.level - player.level <= -9) {baseExperience *= 0.1}
	// baseExperience += experienceLevelBonus
	return Math.floor(baseExperience)
}

function levelUp() {
	updatePlayerStats()
}

function playerLevelFunc() {
	updatePlayerStats()
	let playerCurrentLevel = player.level
	const levelThresholds = player.experienceNeededToLevel
	for (let level = 1; level <= levelThresholds.length; level++) {
		if (player.experience < levelThresholds[level]) {
			player.level = level;
			// player.experienceNeededToLevel = level === 1 ? 10 : levelThresholds[level - 1] - levelThresholds[level - 2];
			break;
		}
	}
	// if (player.level == 10) {
	// 	warriorsGuildGroundLevelInterior222222.npc.push(velthash)
	// 	mageGuild_Room2.npc.push(olivandra)
	// 	monksGuildRoom1.npc.push(sitoria)
	// 	rangersGuildRoom1.npc.push(tilwin)
	// 	sinistralsGuild_Room2.npc.push(zell)
	// }
	if (playerCurrentLevel != player.level) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	let line4 = document.createElement('div')
	let attributePointsIncrease
	if (player.level <= 5) {
		attributePointsIncrease = 2
	} else if (player.level <= 10) {
		attributePointsIncrease = 3
	} else if (player.level <= 15) {
		attributePointsIncrease = 4
	} else if (player.level >= 16) {
		attributePointsIncrease = 5
	}
	let skillPointsIncrease = player.level * 4 > 20 ? 20 : player.level * 4
	//player level events
	if (player.level == 10) {
		activateLevel10Event()
	}
	blankSpace()
	customizeEachWord(`You are now level `, 'white', line1)
	customizeEachWord(`${player.level}`, 'green', line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`You have gained `, 'white', line2)
	customizeEachWord(`${attributePointsIncrease} `, 'green', line2)
	customizeEachWord(`attribute `, 'light-blue', line2)
	customizeEachWord(`point(s)!`, 'white', line2)
	customizeEachWord(`You have gained `, 'white', line4)
	customizeEachWord(`${skillPointsIncrease} `, 'green', line4)
	customizeEachWord(`skill `, 'light-blue', line4)
	customizeEachWord(`point(s)!`, 'white', line4)
	blankSpace()
	abilityLearnedOnLevelUp()
	player.attributePoints += attributePointsIncrease
	player.skillPoints += skillPointsIncrease
	updatePlayerStats()
	}
}
function activateLevel10Event() {
	npcAddToRoom(fieldsTrainer, warriorsGuildOfficeHallVelthash)
	// warriorsGuildOfficeHallVelthash.npc.push(fieldsTrainer)
}

function abilityLearnedOnLevelUp() {
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	if (player.playerClass.name == 'Berserker') {
		if (player.level == 3) {
			player.skillMods.ripslash = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Ripslash`, player.ripslash.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.cyclone = 1
			player.skillMods.bleed = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Cyclone`, player.cyclone.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.cataclysm = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Cataclysm`, player.ripslash.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Fighter') {
		if (player.level == 3) {
			player.skillMods.dualStrike = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Dual Strike`, player.dualStrike.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.bladeBlitz = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Blade Blitz`, player.bladeBlitz.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.shred = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shred`, player.shred.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Knight') {
		if (player.level == 3) {
			player.skillMods.valorStrike = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Valor Strike`, player.valorStrike.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.shieldSlam = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shield Slam`, player.shieldSlam.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.boomingMight = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Booming Might`, player.boomingMight.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Assassin') {
		if (player.level == 3) {
			player.skillMods.ambush = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Ambush`, player.ambush.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.backstab = 1
			player.skillMods.sinisterMark = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Backstab`, player.backstab.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.guillotine = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Guillotine`, player.guillotine.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Thief') {
		if (player.level == 3) {
			player.skillMods.venomBlade = 1
			player.skillMods.poison = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Venom Blade`, player.venomBlade.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.contagion = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Contagion`, player.contagion.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.bane = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Bane`, player.bane.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Shadowblade') {
		if (player.level == 3) {
			player.skillMods.shadowDaggers = 1
			player.skillMods.shadowMark = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shadow Daggers`, player.shadowDaggers.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.shadowsurge = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shadowsurge`, player.shadowsurge.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.shadowVenom = 1
			player.skillMods.shadowNova = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Shadow Venom`, player.shadowVenom.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Martial Monk') {
		if (player.level == 3) {
			player.skillMods.catalyst = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Catalyst`, player.catalyst.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 3) {
			player.skillMods.tempest = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Tempest`, player.tempest.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.callOfWind = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Call Of Wind`, player.tempest.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.knuckleBlitz = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`KnuckleBlitz`, player.tempest.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		// if (player.level == 5) {
		// 	player.guillotine.level = 1
		// 	customizeEachWord(`You have learned the ability `, 'white', line1)
		// 	customizeEachWord(`Guillotine`, player.guillotine.color, line1)
		// 	customizeEachWord(`!`, 'white', line1)
		// }
	}
	if (player.playerClass.name == 'Mystic Monk') {
		if (player.level == 3) {
			player.skillMods.fireSeal = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Fire Seal`, player.fireSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.waterSeal = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Water Seal`, player.waterSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.earthSeal = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Earth Seal`, player.earthSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.mysticFist = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Mystic Fist`, player.earthSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.unleashedPower = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Unleashed Power`, player.earthSeal.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Elemental Monk') {
		if (player.level == 3) {
			player.skillMods.blazingFist = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Flaming Palm Strike`, player.blazingFist.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.tidalFist = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Tidal Fist`, player.tidalFist.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.quakeFist = 1
			player.skillMods.lightningFist = 1
			player.skillMods.elementalTempest = 1
			player.skillMods.transcendence = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Quake Fist`, player.quakeFist.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Ranger') {
		if (player.level == 3) {
			player.skillMods.piercingArrow = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Piercing Arrow`, player.piercingArrow.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 4) {
			player.skillMods.rapidFireShot = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Rapid Fire Shot`, player.rapidFireShot.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.hydraArrow = 1
			customizeEachWord(`You have learned the ability `, 'white', line1)
			customizeEachWord(`Hydra Arrow`, player.hydraArrow.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Pyromancer') {
		if (player.level == 2) {
			player.skillMods.barrier = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Magic Shield`, player.barrier.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.inferno = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Inferno`, player.inferno.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 6) {
			player.skillMods.meteor = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Meteor`, player.meteor.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Cryo Mage') {
		if (player.level == 2) {
			player.skillMods.barrier = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Magic Shield`, player.barrier.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.blizzard = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Blizzard`, player.blizzard.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 6) {
			player.skillMods.cryoclast = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Cryoclast`, player.cryoclast.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
	if (player.playerClass.name == 'Lightning Magus') {
		if (player.level == 2) {
			player.skillMods.barrier = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Magic Shield`, player.barrier.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 5) {
			player.skillMods.chainLightning = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Chain Lightning`, player.chainLightning.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
		if (player.level == 6) {
			player.skillMods.gigavolt = 1
			customizeEachWord(`You have learned the spell `, 'white', line1)
			customizeEachWord(`Gigavolt`, player.gigavolt.color, line1)
			customizeEachWord(`!`, 'white', line1)
		}
	}
}

function buffTallyModValue(player, stat) {
    let total = 0;
    
    // Loop through all buffs on the player
    for (let buff in player.buffs) {
        if (player.buffs[buff].mods && player.buffs[buff].mods[stat]) {
            total += player.buffs[buff].mods[stat];
        }
    }

    return total;
}

function buffGetValues() {
	let playerBuffs = Object.keys(player.buffs)
	for (const buffName of player.buffs) {
		if (player.buffs[buffName]?.mods) {
			quickMessage()
		}
	}
}

function calculateStat(playerObject, stat) {
		return (playerObject?.skillMods?.[stat] ?? 0) +
		(playerObject?.baseStats?.[stat] ?? 0) +
		(playerObject?.equipmentMods?.[stat] ?? 0) +
		// (playerObject?.buffMods?.[stat] ?? 0) +
		buffTallyModValue(player, stat) +
		(playerObject?.debuffMods?.[stat] ?? 0) +
		(playerObject?.godMods?.[stat] ?? 0);
}
function calculateBonusStat(playerObject, stat) {
		return (playerObject?.skillMods?.[stat] ?? 0) +
		(playerObject?.equipmentMods?.[stat] ?? 0) +
		// (playerObject?.buffMods?.[stat] ?? 0) +
		buffTallyModValue(player, stat) +
		(playerObject?.debuffMods?.[stat] ?? 0) +
		(playerObject?.godMods?.[stat] ?? 0);
}

//!player.questLog.egbert
//player.questLog.egbert = {}
//player.questLog.egbert.questStage = stage

function questChangeStage(questGiver, stage) {
	questGiver.questStage = stage
	// if (!player.questLog[questGiver.refName]) {
	// 	player.questLog[questGiver.refName] = {}
	// 	player.questLog[questGiver.refName].stage = stage
	// } else {
	// 	player.questLog[questGiver.refName].stage = stage
	// }
}
function dialogueChangeStage(questGiver, stage) {
	questGiver.dialogueStage = stage
}


// function npcAddLocationToPlayerObject(npc, area) {
// 	if (!player.npcLocations[npc.refName]) {
// 		player.npcLocations[npc.refName] = {}
// 		player.npcLocations[npc.refName] = area
// 	} else {
// 		player.npcLocations[npc.refName] = area
// 	}
// }

function npcUpdateLocation(npc, area) {
    // Ensure the tracker has an entry for this NPC
    if (!player.npcLocationTracker[npc.refName]) {
        player.npcLocationTracker[npc.refName] = {};
    }

    // Update the NPC's location and store the NPC object
    player.npcLocationTracker[npc.refName].location = area.descriptions.areaName
    player.npcLocationTracker[npc.refName].npcRefName = npc.refName
	if (npc.questStage) player.npcLocationTracker[npc.refName].questStage = npc.questStage
}
function loadNpcsIntoAreas() {
	npcClearAllBehavior()
    for (const npcInTracker in player.npcLocationTracker) {
		console.log(npcInTracker, ' NPC IN TRACKER')
        const npcData = player.npcLocationTracker[npcInTracker];
        const areaName = npcData.location;
		const refName = npcData.npcRefName
		for (const npcInArray of allNpcsArray) {
			if (npcInArray.refName == refName) {
				// clearInterval(npcInArray.behaviorInterval)
				let areaToPushNpcTo
				if (npcInArray.areas) {
					//has area pack -- free roaming npcs
					let areaToRemoveNpcFrom = npcInArray.areas.find(area => area.npc.find(npc => npc.refName == npcInArray.refName))
					let npcToRemoveIndex = areaToRemoveNpcFrom.npc.indexOf(npcInArray)
					areaToRemoveNpcFrom.npc.splice(npcToRemoveIndex, 1)
				} else {
					//doesn't have area pack -- static npcs
					// areaToPushNpcTo = allAreas.find(area => area?.descriptions?.areaName == areaName)
				}
				areaToPushNpcTo = allAreas.find(area => area?.descriptions?.areaName == areaName)
				npcRemoveFromTheirCurrentRoom(npcInArray)
				npcAddToRoom(areaToPushNpcTo, npcInArray)
				npcStartSelectNpcBehavior(npcInArray)
			}
		}
    }
	for (const npcInStorage in player.npcQuestStageStorage) {
		let foundNpc = allNpcsArray.find(npc => npc.refName == npcInStorage)
		foundNpc.questStage = player.npcQuestStageStorage[npcInStorage]
	}
}

function npcClearAllBehavior() {
	allNpcsArray.forEach(npc => {
		clearInterval(npc.behaviorInterval)
	})
}
function npcStartAllBehavior() {
	//Starts behavior intervals of all npcs. Might not want to use this if
	//i'm going to have some npcs not have their behavior running until certain events
	//like npcs in other towns probably shouldn't be moving since the player won't encounter
	//them for many hours
	allNpcsArray.forEach(npc => npc.npcBehavior?.())
}
function npcStartSelectNpcBehavior(npc) {
	npc.npcBehavior()
}

let player = {
	npcLocationTracker: {},
	npcQuestStageStorage: {},
	gameStages: {
		tutorial: {
			stage1: true,
			isComplete: false,
			tutorialEventsRan: false,
			gameEvent: function() {
				let npcArray = [till, sylas, gaelwyn, krista, lessa]
				npcArray.forEach(npc => {
					console.log(npc)
					npc.isBehaviorOn = false
					npcRemoveFromRoomPack(npc, npc.areas)
					npcAddToRoom(trainingHallsCombatHalls1, npc)
				})
			},
		},
		gameStart: {
		},
	},
	questLog: {},
	npcLocations: {},
	isAlive: true,
	level: 1,
	id: 'player1',
	skillMods: {},
	godMods: {},
	baseStats: {},
	equipmentMods: {},
	buffMods: {},
	debuffMods: {
		retreatTimer: 0,
		advanceTimer: 0
	},
	buffs: {},
	debuffs: {},
	health: 0,
	mana: 0,
	sinisterMarks: 0,
	might: 5,
	focus: 20,
	magicResist: {
		fire: 0,
		ice: 0,
		lightning: 0,
		wind: 0,
		water: 0,
	},
	sealCounter: {
	},
	isAbilityQueued: false,
	adrenaline: 50,
	maxAdrenaline: 50,
	magicShield: 0,
	fireProficiency: 1.0,
	iceProficiency: 1.0,
	lightningProficiency: 1.0,
	arcaneKnowledge: 0,
	firePen: 0,
	waterPen: 0,
	earthPen: 0,
	icePen: 0,
	windPen: 0,
	lightningPen: 0,
	shadowPen: 0,
	poisonPen: 0,
	playerClass: {},
	race: '',
	experience: 0,
	experienceNeededToLevel: [
		0, 15, 45, 100, 180, 285, 415, 570, 750, 955, 1190, 1455, 1750, 2075, 2430, 2815, 3240,
		3705, 4210, 4755, 5355, 6010, 6705, 7440, 8205, 9015, 9870, 10770, 11715, 12705, 13740, 
		14815, 15860, 16875, 17860,
	],
	attributePoints: 0,
	skillPoints: 0,
	roomId: 1,
	x: 0,
	y: 0,
	z: -2,
	s: '',
	special: '',
	name: '',
	mount: false,
	currentWeaponSkill: [],
	combat: [],
	stasis: [],
	swingTimer: 0,
	channelTimer: 0,
	conjureTimer: 0,
	abilityTimer: 0,
	warriorAbilityQueue: false,
	//stasis - combat, dialogue, advancing stasis, spell cast
	stance: 'normal',
	//inventory and equipment
	gold: 0,
	backpack: [],
	rightHand: empty,
	leftHand: empty,
	leftHandRing: empty,
	rightHandRing: empty,
	head: empty,
	necklace: empty,
	shoulders: empty,
	chest: empty,
	back: empty,
	// arms: empty,
	hands: empty,
	waist: empty,
	legs: empty,
	feet: empty,
	killList: {},
	buildUpThenRelease: [],
	hidden: false,
	isStealthed: false,
	spellsConjuredMax: 2,
	spellsConjured: 0,
	conjuredSpells: [], //this is replaced by spellsConjured - delete when magic functions are fixed
	spellsConjured: [],
	chargeEffect: false,
	spells: [],
	skills: {},
	rightFist: {
		//change object name to rightHand
		get level() {
			return calculateStat(player, this.refName)
		},
		id: 'fist1',
		roomId: 'right hand',
		name: 'Right Fist',
		picture: "images/weapons/fist weapons/empty hand right.png",
		refName: 'rightFist',
		keywords: ['right fist'],
		color: 'green',
		skillUsed: 'unarmed',
		botDamage: 1,
		topDamage: 3,
		speed: 3,
		accuracy: 4,
		mods: {
			str: 0,
			dex: 0,
			agi: 0,
			bluntPen: 0,
		},
		type: {
			weapon: true,
			unarmed: true,
		},
		enchantment: [],
		desc: () => {
			quickMessage('You have a fairly soft right hand', 'descriptions')
		},
		swing: (enemy, weapon) => unarmedSwing1(enemy, weapon),
		miss: (enemy, weapon) => unarmedSwing1(enemy, weapon),
		addToPlayer: function() {
			player[this.refName] = {}
			copyGettersAndSetters(player[this.refName], this)
		},
	},
	leftFist: {
		//change object name to leftHand
		get level() {
			return calculateStat(player, this.refName)
		},
		id: 'fist2',
		roomId: 'left hand',
		name: 'Left Fist',
		picture: "images/weapons/fist weapons/empty hand left.png",
		refName: 'leftFist',
		keywords: ['left fist'],
		color: 'green',
		skillUsed: 'unarmed',
		botDamage: 1,
		topDamage: 3,
		speed: 3,
		accuracy: 4,
		mods: {
			str: 0,
			dex: 0,
			agi: 0,
			bluntPen: 0,
		},
		type: {
			weapon: true,
			unarmed: true,
		},
		enchantment: [],
		desc: () => {
			quickMessage('You have a fairly soft right hand', 'descriptions')
		},
		swing: (enemy, weapon) => unarmedSwing1(enemy, weapon),
		miss: (enemy, weapon) => unarmedSwing1(enemy, weapon),
		addToPlayer: function() {
			player[this.refName] = {}
			copyGettersAndSetters(player[this.refName], this)
		},
	},
	get str() {
		return calculateStat(this, 'str')
	},
	get dex() {
		return calculateStat(this, 'dex')
	},	
	get agi() {
		return calculateStat(this, 'agi')
	},	
	get int() {
		return calculateStat(this, 'int')
	},
	get wis() {
		return calculateStat(this, 'wis')
	},
	get mys() {
		return calculateStat(this, 'mys')
	},
	get con() {
		return calculateStat(this, 'con')
	},
	get dodge() {
		return calculateStat(this, 'dodge') + player.dodging.rating() + (player.agi * 3) - player.burden
	},
	get accuracy() {
		return calculateStat(this, 'accuracy') - player.burden
	},
	get slashingPen() {
		return calculateStat(this, 'slashingPen') + player.slashingExpertise.amount()
	},
	get piercingPen() {
		return calculateStat(this, 'piercingPen') + player.piercingExpertise.amount()
	},
	get bluntPen() {
		return calculateStat(this, 'bluntPen') + player.bluntExpertise.amount()
	},
	get slashingArmor() {
		return calculateStat(this, 'slashingArmor') + player.toughness.rating()
	},
	get piercingArmor() {
		return calculateStat(this, 'piercingArmor') + player.toughness.rating()
	},
	get bluntArmor() {
		return calculateStat(this, 'bluntArmor') + player.toughness.rating()
	},
	get fireResist() {
		return calculateStat(this, 'fireResist') // add something like + magic resist skill
	},
	get iceResist() {
		return calculateStat(this, 'iceResist') // add something like + magic resist skill
	},
	get lightningResist() {
		return calculateStat(this, 'lightningResist') // add something like + magic resist skill
	},
	get waterResist() {
		return calculateStat(this, 'waterResist') // add something like + magic resist skill
	},
	get windResist() {
		return calculateStat(this, 'windResist') // add something like + magic resist skill
	},
	get burden() {
		return Math.max(calculateStat(this, 'weight') - (player.str * 5), 0)
	},
	get weight() {
		return calculateStat(this, 'weight')
	},
	get spellPower() {
		let isSpellWeaponValid = (player.currentWeaponRight()?.mods?.spellPower ?? 0) * (player.spellWeapons?.bonus() ?? 0);
		let spellWeaponBonus = Math.max(0, isSpellWeaponValid || 0)
		let baseSpellpowerCalculation = Math.ceil((player.int * 2) + player.wis + spellWeaponBonus)
		console.log(spellWeaponBonus)
		console.log(baseSpellpowerCalculation)
		return calculateStat(this, 'spellPower') + baseSpellpowerCalculation
	},
	get mysticPower() {
		let isMysticWeaponValid =(player.currentWeaponRight()?.mods?.mysticPower ?? 0) * (player.spellWeapons?.bonus() ?? 0);
		let mysticWeaponBonus = Math.max(0, isMysticWeaponValid || 0)
		let baseMysticPowerCalculation = Math.ceil((player.mys * 2) + player.wis + mysticWeaponBonus)
		return calculateStat(this, 'mysticPower') + baseMysticPowerCalculation
	},
	get maxHealth() {
		let perLevelBonus = player.baseStats.healthPerLevel * player.level
		let perCONBonus = (player.baseStats.healthPerCON + player.vigor.level) * player.con
		return calculateStat(this, 'maxHealth') + perLevelBonus + perCONBonus
	},
	get maxMana() {
		let perLevelBonus = player.baseStats.manaPerLevel * player.level
		let perWISBonus = (player.baseStats.manaPerWIS + player.devotion.level) * player.wis
		return calculateStat(this, 'maxMana') + perLevelBonus + perWISBonus
	},
	get sinisterMarksMax() {
		return calculateStat(this, 'sinisterMarksMax')
	},
	get maxMight() {
		return calculateStat(this, 'maxMight')
	},
	get maxFocus() {
		return calculateStat(this, 'maxFocus')
	},
	///////////////////////////////////////

	///////////////////////////////////////

	currentWeaponRight: function() {
		//returns player.rightFist because rightFist does not exist in the pushItem array
		if (player.rightHand == 'empty') {
			return player.rightFist
		} else {
			return pushItem.find(item => item.roomId == 'right hand')
		}
	},
	currentWeaponLeft: function() {
		//Can only throw left punch if trained in unarmed
		if (player.leftHand == 'empty') {
			return player.leftFist
		}
		return pushItem.find(item => item.roomId == 'left hand')
	},
	get advanceTimer() {
		return calculateStat(this, 'advanceTimer')
	},
	get retreatTimer() {
		return calculateStat(this, 'retreatTimer')
	},

	currentRightHandWeapon: () => (pushItem.find(item => item.roomId == 'right hand') == undefined ? player.rightFist : pushItem.find(item => item.roomId == 'right hand')),
	currentLeftHandWeapon: () => (pushItem.find(item => item.roomId == 'left hand') == undefined ? player.leftFist : pushItem.find(item => item.roomId == 'left hand')),

}

//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////
//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////
//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////
//////////////////////////////////////////////////////////SKILLS START//////////////////////////////////

const perception = {
	get level() {
		return calculateStat()
	},
	name: 'Perception',
	refName: 'perception',
	type: 'skill',
	color: 'skill',
	check: function(obstacle) {
		let playerLevel = player.level
		let playerPerception = player.perception.level
		let playerTotalPerception = playerLevel + playerPerception
		return playerTotalPerception >= obstacle
	},
	goldToUpgrade: function () {
		return goldUpgradeCostLow(player.perception)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCostLow(player.perception)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
perception.addToPlayer()

const rest = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Rest',
	type: 'skill',
	refName: 'rest',
	color: 'skill',
	restTimer: 10000,
	description: 'The rest ability allows you to recover health and mana. The higher the level, the more health and mana you recover. Raising the constitution and wisdom attribute will also increase the amount of health and mana you recover while resting. You can use the rest ability by using the REST command',
	healthBonus: 0,
	manaBonus: 0,
	maxLevel: 20,
	healthPerTick: function() {
		let baseRecovery = player.con
		let restSkillLevel = this.level
		let skillModifier = 1.5
		if (player.guild == "Warrior") {}
		if (player.guild == "Sinistral") {}
		if (player.guild == "Monk") {}
		if (player.guild == "Ranger") {}
		if (player.guild == "Mage") {
			baseRecovery = 1
			skillModifier = 1
			restSkillLevel /= 2
		}
		let amountRecovered = Math.ceil(baseRecovery + (restSkillLevel * skillModifier) * restSkillLevel)
		return amountRecovered
	},
	manaPerTick: function() {
		let baseRecovery = player.wis
		let restSkillLevel = this.level
		let skillModifier = 1.5
		if (player.guild != "Mage") {
			baseRecovery = 1
			skillModifier = 1
			restSkillLevel /= 2
		}
		let amountRecovered = Math.ceil(baseRecovery + (restSkillLevel * skillModifier) * restSkillLevel)
		return amountRecovered
	},
	goldToUpgrade: function () {
		return goldUpgradeCostLow(player.rest)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCostLow(player.rest)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
rest.addToPlayer()

const slashingExpertise = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Slashing Weapons Expertise',
	refName: 'slashingExpertise',
	type: 'skill',
	color: `green`,
	maxLevel: 20,
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}	
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.slashingExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.slashingExpertise)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
slashingExpertise.addToPlayer()

const piercingExpertise = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Piercing Weapons Expertise',
	refName: 'piercingExpertise',
	type: 'skill',
	color: `green`,
	maxLevel: 20,
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}	
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.piercingExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.piercingExpertise)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
piercingExpertise.addToPlayer()

const bluntExpertise = {	
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Blunt Weapons Expertise',
	refName: 'bluntExpertise',
	type: 'skill',
	color: 'green',
	maxLevel: 20,
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.bluntExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.bluntExpertise)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
bluntExpertise.addToPlayer()

const firePenetration = {	
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Fire Penetration',
	refName: 'firePenetration',
	type: 'skill',
	color: 'green',
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.firePenetration)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.firePenetration)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
firePenetration.addToPlayer()

const icePenetration = {	
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Ice Penetration',
	refName: 'icePenetration',
	type: 'skill',
	color: 'green',
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.icePenetration)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.icePenetration)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
icePenetration.addToPlayer()

const lightningPenetration = {	
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Lightning Penetration',
	refName: 'lightningPenetration',
	type: 'skill',
	color: 'green',
	amount: function() {
		//As this skill levels beyond 5, 10, 15, the increase in expertise ramps up
		if (this.level < 5) {
			return this.level * 2
		} else if (this.level < 10) {
			return this.level * 3
		} else if (this.level < 15) {
			return this.level * 4
		} else {
			return this.level * 5
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.lightningPenetration)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.lightningPenetration)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
lightningPenetration.addToPlayer()

const weakSpot = {	
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Weak Spot',
	refName: 'weakSpot',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	chance: function() {
		if (player.weakSpot.level == 1) {return 5}
		if (player.weakSpot.level == 2) {return 10}
		if (player.weakSpot.level == 3) {return 15}
		if (player.weakSpot.level == 4) {return 20}
		if (player.weakSpot.level >= 5) {return 25}
	},
	debuff: {
		//armor reduction debuff applied to the enemy
		name: 'Weak Spot',
		refName: 'weakSpot',
		modifiedStats: ['piercingArmor'],
		get piercingArmor() { 
			if (player.weakSpot.level == 1) { return -5 }
			if (player.weakSpot.level == 2) { return -5 }
			if (player.weakSpot.level == 3) { return -5 }
			if (player.weakSpot.level == 4) { return -5 }
			if (player.weakSpot.level == 5) { return -5 }
			if (player.weakSpot.level == 6) { return -7 }
			if (player.weakSpot.level == 7) { return -10 }
			if (player.weakSpot.level == 8) { return -13 }
			if (player.weakSpot.level == 9) { return -15 }
			if (player.weakSpot.level >= 10) { return -20 }
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return player.weakSpot.level
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.weakSpot)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.weakSpot)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Weak Spot gives you the ability to find a weak spot in the enemy's armor. Upon landing a regular attack, you have a ${this.chance}% chance of reducing the enemy's piercing armor by 5 for each application.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
weakSpot.addToPlayer()


const vigor = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Vigor',
	refName: 'vigor',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	healthMultiplier: function() {
		if (player.vigor.level == 1) { return 0.2}
		if (player.vigor.level == 2) { return 0.4}
		if (player.vigor.level == 3) { return 0.6}
		if (player.vigor.level == 4) { return 0.8}
		if (player.vigor.level == 5) { return 1.0}
		if (player.vigor.level == 6) { return 1.2}
		if (player.vigor.level == 7) { return 1.4}
		if (player.vigor.level == 8) { return 1.6}
		if (player.vigor.level == 9) { return 1.8}
		if (player.vigor.level >= 10) { return 2.0}
		else {return 0}	
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.vigor)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.vigor)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Vigor`, this.color, line1)
		customizeEachWord(`: Increases the effectiveness of Constitution by gaining more hit points per point of Constitution. This effect is retroactive and you will gain extra health for the Constitution you currently have.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
vigor.addToPlayer()

const devotion = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Devotion',
	refName: 'devotion',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	manaMultiplier: function() {
		if (player.devotion.level == 1) { return 0.1}
		if (player.devotion.level == 2) { return 0.2}
		if (player.devotion.level == 3) { return 0.3}
		if (player.devotion.level == 4) { return 0.4}
		if (player.devotion.level == 5) { return 0.5}
		if (player.devotion.level == 6) { return 0.6}
		if (player.devotion.level == 7) { return 0.7}
		if (player.devotion.level == 8) { return 0.8}
		if (player.devotion.level == 9) { return 0.9}
		if (player.devotion.level >= 10) { return 1.0}
		else {return 0}
	},	
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.devotion)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.devotion)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Devotion`, this.color, line1)
		customizeEachWord(`: Increases the effectiveness of Wisdom by gaining more mana per point of Wisdom. This effect is retroactive, and you will gain extra mana for the Wisdom you currently have.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
devotion.addToPlayer()

const cleave = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Cleave',
	type: 'skill',
	refName: 'cleave',
	color: 'green',
	maxLevel: 3,
	extraTargets: function() {
		if (player.cleave.level == 1) {return 1}
		if (player.cleave.level == 2) {return 2}
		if (player.cleave.level >= 3) {return 3}
	},
	goldToUpgrade: function () {
		if (player.cleave.level == 0) {return 500}
		if (player.cleave.level == 1) {return 1000}
		if (player.cleave.level >= 2) {return 2000}	
	},
	pointsToUpgrade: function () {
		if (player.cleave.level == 0) {return 20}
		if (player.cleave.level == 1) {return 40}
		if (player.cleave.level >= 2) {return 60}		
	},
	description: function() {
		let line1 = lineFunc()
		customizeEachWord(`Cleave allows you to hit an additional enemy each swing. The number of additional targets hit is equal to this skills level.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
cleave.addToPlayer()

const multipleStrikes = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Multiple Strikes',
	refName: 'multipleStrikes',
	type: 'skill',
	color: 'skill',
	maxLevel: 5,
	extraStrikesNumber: function() {
		if (player.multipleStrikes.level == 0) {return 0}
		if (player.multipleStrikes.level == 1) {return 1}
		if (player.multipleStrikes.level == 2) {return 1}
		if (player.multipleStrikes.level == 3) {return 2}
		if (player.multipleStrikes.level == 4) {return 2}
		if (player.multipleStrikes.level >= 5) {return 3}
	},
	extraStrikesChance: function() {
		if (player.multipleStrikes.level == 0) {return 0}
		if (player.multipleStrikes.level == 1) {return 10}
		if (player.multipleStrikes.level == 2) {return 20}
		if (player.multipleStrikes.level == 3) {return 20}
		if (player.multipleStrikes.level == 4) {return 30}
		if (player.multipleStrikes.level >= 5) {return 40}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.multipleStrikes)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.multipleStrikes)
	},
	description: function() {
		let line1 = lineFunc()
		customizeEachWord(`Multiple Strikes gives you a chance to land multiple strikes on a single target. This ability currently grants you a ${this.extraStrikesChance()}% chance to land an extra strike on an enemy. This effect can trigger ${this.extraStrikesNumber()} times.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
multipleStrikes.addToPlayer()

const doubleDraw = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Double Draw',
	refName: 'doubleDraw',
	type: 'skill',
	color: 'green',
	counter: 0,
	maxLevel: 6,
	nthStrike: function() {
		if (player.doubleDraw.level == 1) {return 7}
		if (player.doubleDraw.level == 2) {return 6}
		if (player.doubleDraw.level == 3) {return 5}
		if (player.doubleDraw.level == 4) {return 4}
		if (player.doubleDraw.level == 5) {return 3} 
		if (player.doubleDraw.level >= 6) {return 2} 
	},
	goldToUpgrade: function () {
		if (player.doubleDraw.level == 0) {return 200}
		if (player.doubleDraw.level == 1) {return 500}
		if (player.doubleDraw.level == 2) {return 1000}
		if (player.doubleDraw.level == 3) {return 1500}
		if (player.doubleDraw.level == 4) {return 2000}		
		if (player.doubleDraw.level >= 5) {return 3000}		
	},
	pointsToUpgrade: function () {
		if (player.doubleDraw.level == 0) {return 20}
		if (player.doubleDraw.level == 1) {return 30}
		if (player.doubleDraw.level == 2) {return 40}
		if (player.doubleDraw.level == 3) {return 50}
		if (player.doubleDraw.level == 4) {return 60}	
		if (player.doubleDraw.level >= 5) {return 100}	
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Every nth regular attack, a Ranger will draw 2 arrows instead of 1 when firing their next shot.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
doubleDraw.addToPlayer()
const extraStrike = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Extra Strike',
	refName: 'extraStrike',
	type: 'skill',
	color: 'green',
	nthStrike: function() {
		if (this.level == 1) {return 1}
		if (this.level >= 2) {return 2}
	},
	goldToUpgrade: function () {
		if (player.extraStrike.level == 0) {return 1000}
		if (player.extraStrike.level >= 1) {return 5000}
		// if (player.doubleDraw.level >= 2) {return 10000}
	},
	pointsToUpgrade: function () {
		if (player.extraStrike.level == 0) {return 50}
		if (player.extraStrike.level >= 1) {return 100}
		// if (player.doubleDraw.level >= 2) {return 100}	
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Automatically grants a Monk an extra regular attack, for each fist, on every swing. Each level of this skill grants one extra attack.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
extraStrike.addToPlayer()

const stunningBlows = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Stunning Blows',
	refName: 'stunningBlows',
	type: 'skill',
	color: 'skill',
	maxLevel: 9,
	flavorText: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You stun the ${enemy.name} for `, 'red', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${player.stunningBlows.stunningBlowsDuration() / 1000}`, 'yellow', line1)
		customizeEachWord(`] `, 'white', line1)
		customizeEachWord(`seconds!`, 'red', line1)
	},
	chanceToStun: function() {
		if (player.stunningBlows.level == 1) { return 10 }
		if (player.stunningBlows.level == 2) { return 15 }
		if (player.stunningBlows.level == 3) { return 15 }
		if (player.stunningBlows.level == 4) { return 20 }
		if (player.stunningBlows.level == 5) { return 20 }
		if (player.stunningBlows.level == 6) { return 25 }
		if (player.stunningBlows.level == 7) { return 25 }
		if (player.stunningBlows.level >= 8) { return 30 }
		else {return 0}
	},
	stunningBlowsDuration: function() {
		if (player.stunningBlows.level == 1) { return 3000}
		if (player.stunningBlows.level == 2) { return 3000}
		if (player.stunningBlows.level == 3) { return 3500}
		if (player.stunningBlows.level == 4) { return 3500}
		if (player.stunningBlows.level == 5) { return 4000}
		if (player.stunningBlows.level == 6) { return 4000}
		if (player.stunningBlows.level == 7) { return 4500}
		if (player.stunningBlows.level == 8) { return 4500}
		if (player.stunningBlows.level >= 9) { return 5000}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.stunningBlows)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.stunningBlows)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Grants the chance to stun an enemy for a duration after successfully landing a regular attack. You currently have a ${this.chanceToStun()}% chance to stun for ${this.stunningBlowsDuration() / 1000} seconds.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
stunningBlows.addToPlayer()
const precision = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Precision Strikes',
	refName: 'precision',
	type: 'skill',
	color: 'skill',
	maxLevel: 20,
	update: function() {
		player.unarmed.botMultiplier += 0.05
		player.oneHanded.botMultiplier += 0.05
		player.twoHanded.botMultiplier += 0.05
		player.daggers.botMultiplier += 0.05
		player.bows.botMultiplier += 0.05
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.precision)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.precision)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Precision hones in your weapon skill allowing your attacks to land more flush. This will increase the bottom end value of your damage roll.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
precision.addToPlayer()
const warcraft = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Warcraft',
	refName: 'warcraft',
	type: 'skill',
	color: 'skill',
	maxLevel: 20,
	update: function() {
		player.unarmed.topMultiplier += 0.05
		player.oneHanded.topMultiplier += 0.05
		player.twoHanded.topMultiplier += 0.05
		player.daggers.topMultiplier += 0.05
		player.bows.topMultiplier += 0.05
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.warcraft)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.warcraft)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Warcraft hones in your weapon skill, allowing you to hit enemies harder. This will increase the top end value of your damage roll.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
warcraft.addToPlayer()

const stealth = {
		get level() {
		return calculateStat(player, this.refName)
	},
	type: 'ability',
	name: 'Stealth',
	refName: 'stealth',
	color: 'sinistral-color',
	maxLevel: 10,
	cooldown: function() {
		if (player.stealth.level <= 1) {return 2}
		if (player.stealth.level == 2) {return 2}
		if (player.stealth.level == 3) {return 2}
		if (player.stealth.level == 4) {return 2}
		if (player.stealth.level == 5) {return 2}
		if (player.stealth.level == 6) {return 2}
		if (player.stealth.level == 7) {return 2}
		if (player.stealth.level >= 8) {return 2}
	},
	buff: {
		name: 'Stealth Break',
		refName: 'stealthBreak',
		stacks: 1,
		get dodge() {
			if (player.stealth.level <= 1) { return 10 }
			if (player.stealth.level == 2) { return 15 }
			if (player.stealth.level == 3) { return 20 }
			if (player.stealth.level == 4) { return 25 }
			if (player.stealth.level == 5) { return 30 }
			if (player.stealth.level == 6) { return 35 }
			if (player.stealth.level == 7) { return 40 }
			if (player.stealth.level == 8) { return 40 }
			if (player.stealth.level >= 9) { return 50 }
		},
		get duration() {
			if (player.stealth.level <= 1) { return 11000 }
			if (player.stealth.level == 2) { return 12000 }
			if (player.stealth.level == 3) { return 13000 }
			if (player.stealth.level == 4) { return 14000 }
			if (player.stealth.level == 5) { return 15000 }
			if (player.stealth.level == 6) { return 16000 }
			if (player.stealth.level == 7) { return 17000 }
			if (player.stealth.level == 8) { return 18000 }
			if (player.stealth.level == 9) { return 19000 }
			if (player.stealth.level >= 10) { return 20000 }
		},
		maxStacks: function() {
			return 1
		},
	},
	damageBonus: function() {
		if (!player.isStealthed) {return 0}
		let damageBonus = 0
		if (player.stealth.level <= 1) {damageBonus = 0.25} 
		if (player.stealth.level == 2) {damageBonus = 0.50} 
		if (player.stealth.level == 3) {damageBonus = 0.75} 
		if (player.stealth.level == 4) {damageBonus = 1.0} 
		if (player.stealth.level == 5) {damageBonus = 1.25}
		if (player.stealth.level == 6) {damageBonus = 1.50}
		if (player.stealth.level == 7) {damageBonus = 1.75}
		if (player.stealth.level == 8) {damageBonus = 2.0}
		if (player.stealth.level == 9) {damageBonus = 2.25}
		if (player.stealth.level >= 10) {damageBonus = 2.50}
		damage = player.currentWeaponSkill.attackPower * damageBonus
		return Math.ceil(damage)
	},
	stealthSwing: function(enemy, swingObject) {
		let line1 = lineFunc()
		let line2 = lineFunc()
			if (!swingObject.doesSwingHit) {
				daggerMissArray1[randomNumberRange(0, 4)].play()
				blankSpace()
				customizeEachWord(`You ${swingObject.swingType} `, 'white', line1)
				customizeEachWord(`your `, 'white', line1)
				customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
				customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`and miss!`, 'white', line1)
				blankSpace()
			} else {
				daggerHitArray1[randomNumberRange(0, 4)].play()
				blankSpace()
				customizeEachWord(`You ${swingObject.swingType} `, 'white', line1)
				customizeEachWord(`your `, 'white', line1)
				customizeEachWord(`${swingObject.weapon.name} `, swingObject.weapon.color, line1)
				customizeEachWord(`${swingObject.preposition} the `, 'white', line1)
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`Sneak Attack `, this.color, line2)
				customizeEachWord(`hits for `, 'green', line2)
				customizeEachWord(`${swingObject.realTotalDamage} `, 'light-blue', line2)
				if (swingObject.penText) {
					customizeEachWord(`${swingObject.penText} `, swingObject.penText, line2)
				}				
				customizeEachWord(`damage. `, 'green', line2)
				customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
				customizeEachWord(`${swingObject.blockedDamage}`, 'light-blue', line2)
				customizeEachWord(`)`, 'white', line2)
				blankSpace()
			}
	},
	flavorTextStealthBreak: function() {
		let line1 = lineFunc()
		customizeEachWord(`Shadows follow you into combat, increasing your dodging capabilities.`, `grey`, line1)
	},
	stealthCheck: function(enemy) {
		let playerStealthRating = (player.stealth.level + player.level) * 2
		let enemyDiscoverRating = enemy.level
		let discoverChance = 100 - (playerStealthRating - enemyDiscoverRating) < 0 ? 0 : 100 - (playerStealthRating - enemyDiscoverRating)
		console.log(discoverChance, ' This is the percentage chance that the player will be discovered in stealth from an enemy')
		return discoverChance
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.stealth)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.stealth)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Stealth allows you to hide using the HIDE command. It is an essential part of the Sinistral's aresenal. Using a regular attack while stealthed will perform a Sneak Attack, instantly engaging you with the enemy while dealing bonus damage. When you break stealth with any attack or ability, you will gain a bonus to dodge for a short duration. While hidden, enemies cannot see you, though enemies do have a chance to discover you if your skill level isn't high enough.
		
		Training Stealth will increase the damage of Sneak Attack, increase its dodge bonus, increase the dodge bonus duration, and reduce the time it takes to be able to act after stealthing.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
stealth.addToPlayer()

const block = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Block',
	refName: 'block',
	type: 'skill',
	cooldown: 0,
	blockAmount: function () {
		return this.level * 2 + player.con + player.agi
	},
	blockChance: 100,
	blockRoll: function () {
		if (this.level == 0) {return false}
		if (randomNumberRange(1, 100) <= this.blockChance) {return true} 
		else {return false}
	},
	color: 'skill',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
block.addToPlayer()

const dodging = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Dodging',
	refName: 'dodging',
	type: 'skill',
	color: 'green',
	maxLevel: 20,
	rating: function() {
		if (player.dodging.level == 1) {return 2}
		if (player.dodging.level == 2) {return 4}
		if (player.dodging.level == 3) {return 6}
		if (player.dodging.level == 4) {return 8}
		if (player.dodging.level == 5) {return 10}
		if (player.dodging.level == 6) {return 13}
		if (player.dodging.level == 7) {return 16}
		if (player.dodging.level == 8) {return 19}
		if (player.dodging.level == 9) {return 21}
		if (player.dodging.level == 10) {return 24}
		if (player.dodging.level == 11) {return 28}
		if (player.dodging.level == 12) {return 32}
		if (player.dodging.level == 13) {return 36}
		if (player.dodging.level == 14) {return 40}
		if (player.dodging.level == 15) {return 45}
		if (player.dodging.level == 16) {return 50}
		if (player.dodging.level == 17) {return 55}
		if (player.dodging.level == 18) {return 60}
		if (player.dodging.level == 19) {return 65}
		if (player.dodging.level >= 20) {return 70}
		else {return 0}
	},

	goldToUpgrade: function () {
		return goldUpgradeCost1(player.dodging)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.dodging)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Passively increases your chance to dodge physical attacks.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
dodging.addToPlayer()
const supremeDodging = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Supreme Dodging',
	refName: 'supremeDodging',
	maxLevel: 10,
	buff: {
		name: 'Supreme Dodging',
		refName: 'supremeDodging',
		duration: 10000,
		stacks: 1,
		get dodge() {
			if (player.supremeDodging.level == 1) {return 1}
			if (player.supremeDodging.level == 2) {return 2}
			if (player.supremeDodging.level == 3) {return 3}
			if (player.supremeDodging.level == 4) {return 4}
			if (player.supremeDodging.level == 5) {return 5}
			if (player.supremeDodging.level == 6) {return 6}
			if (player.supremeDodging.level == 7) {return 7}
			if (player.supremeDodging.level == 8) {return 8}
			if (player.supremeDodging.level == 9) {return 9}
			if (player.supremeDodging.level >= 10) {return 10}
		},
		maxStacks: function() {
			return player.supremeDodging.level + 4
		}
	},
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.supremeDodging)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.supremeDodging)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each successful attack increases your chance to dodge by ${player.supremeDodging.buff.dodge} per stack.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
supremeDodging.addToPlayer()
const toughness = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Toughness',
	refName: 'toughness',
	maxLevel: 10,
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Toughness is the measure of your natural defenses. Raising this will increase your base armor.`, 'white', line1)
		blankSpace()
	},
	rating: function() {
		if (player.toughness.level == 1) {return 1}
		if (player.toughness.level == 2) {return 2}
		if (player.toughness.level == 3) {return 5}
		if (player.toughness.level == 4) {return 7}
		if (player.toughness.level == 5) {return 10}
		if (player.toughness.level == 6) {return 13}
		if (player.toughness.level == 7) {return 16}
		if (player.toughness.level == 8) {return 19}
		if (player.toughness.level == 9) {return 22}
		if (player.toughness.level == 10) {return 25}
		else {
			return 0
		}
	},
	type: 'skill',
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.toughness)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.toughness)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
toughness.addToPlayer()

const sideStep = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Side Step',
	refName: 'sideStep',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	calculate: function(enemy) {
		let chance = (player.sideStep.level * 10) - enemy.level
		let roll = randomNumberRange(1, 100)
		if (chance >= roll) {
			return true
		} else {
			return false
		}
	},
	flavorText: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You side-step the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`as it tries to advance you!`, 'white', line1)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.sideStep)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.sideStep)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
sideStep.addToPlayer()
const quickshot = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Quickshot',
	refName: 'quickshot',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	calculate: function(enemy) {
		let chance = (this.level * 10) - enemy.level
		let roll = randomNumberRange(1, 100)
		if (chance >= roll) {
			return true
		} else {
			return false
		}
	},
	strike: function(enemy) {
		//chance to dodgestrike is 10% per level - the enemy's level
		let baseChance = player.quickshot.level * 10
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToQuickshot = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToQuickshot, 'side step strike chance')
		console.log(roll, ' side step strike roll')
		if (chanceToQuickshot >= roll) {
			//dodgestrike only strikes once and with a single weapon
			//damage is base attack damage of right weapon if applicable, left weapon if right weapon isn't available
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
			bowHitArray1[randomNumberRange(0, 4)].play()
			this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
			applyDamageToEnemy(enemy, damageAfterMitigation)

		} else {
			//no dodgestrike happens
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`As you `, 'white', line1)
		customizeEachWord(`side-step `, 'green', line1)
		customizeEachWord(`its advance, you fire an arrow into the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Quickshot is a Ranger skill that gives you the chance to fire a single arrow (for regular attack damage) at an enemy after side-stepping its advance. This skill can only be used if Sidestep is at least level 1.`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.quickshot)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.quickshot)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
quickshot.addToPlayer()

const dodgeStrike = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Dodge Strike',
	refName: 'dodgeStrike',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	strike: function(enemy) {
		let baseChance = player.dodgeStrike.level * 10
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToDodgeStrike = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToDodgeStrike, 'dodgestrike chance')
		console.log(roll, ' dodgestrike roll')
		if (chanceToDodgeStrike >= roll) {
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
			daggerHitArray1[randomNumberRange(0, 4)].play()
			this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
			applyDamageToEnemy(enemy, damageAfterMitigation)

		} else {
			//no dodgestrike happens
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You deliver a `, 'white', line1)
		customizeEachWord(`Dodgestrike `, 'green', line1)
		customizeEachWord(`to the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`as you dodge its attack!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.dodgeStrike)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.dodgeStrike)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
dodgeStrike.addToPlayer()
const preemptiveStrike = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Preemptive Strike',
	refName: 'preemptiveStrike',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	strike: function(enemy) {
		let baseChance = player.preemptiveStrike.level * 2
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToPreemptiveStrike = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToPreemptiveStrike, 'preemptive strike chance')
		console.log(roll, ' preemptive strike roll')
		if (chanceToPreemptiveStrike >= roll) {
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
				unarmedHitArray1[randomNumberRange(0, 4)].play()
				this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
				applyDamageToEnemy(enemy, damageAfterMitigation)
		} else {
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You predict the `, 'white', line1)
		customizeEachWord(`${enemy.name}'s `, enemy.color, line1)
		customizeEachWord(`attack, landing a `, 'white', line1)
		customizeEachWord(`Preemptive Strike `, 'green', line1)
		customizeEachWord(`first!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.preemptiveStrike)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.preemptiveStrike)
	},
	description: function() {
		let line1 = lineFunc()
		customizeEachWord(`Preemptive Strike `, this.color, line1)
		customizeEachWord(`grants you the ability to strike and enemy just before they land their attack on you. The chance to execute a Preemptive Strike is based on the skills level at 10% each level. The enemy's level is also taken into consideration at -1% chance per enemy's level.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
preemptiveStrike.addToPlayer()

const lockpicking = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Lockpicking',
	refName: 'lockpicking',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	chance: function(enemy) {
		
	},
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
lockpicking.addToPlayer()

const smokeBomb = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Smoke Bomb',
	refName: 'smokeBomb',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	resourceName: 'adrenaline',
	resourceCost: 20,
	maxLevel: 1,
	flavorText: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You conjure a cloud of smoke and disappear from combat!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return 1000
	},
	pointsToUpgrade: function () {
		return 30
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
smokeBomb.addToPlayer()
const mindsEye = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Mind's Eye`,
	refName: 'mindsEye',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 2,
	goldToUpgrade: function () {
		return 250
	},
	pointsToUpgrade: function () {
		return 100
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
mindsEye.addToPlayer()

const arcaneKnowledge = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Arcane Knowledge`,
	refName: 'arcaneKnowledge',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.arcaneKnowledge)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.arcaneKnowledge)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
arcaneKnowledge.addToPlayer()

const mysticismMastery = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Mysticism Mastery`,
	refName: 'mysticismMastery',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	reduction: function() {
		if (player.mysticismMastery.level == 1) {return 0.05}
		if (player.mysticismMastery.level == 2) {return 0.10}
		if (player.mysticismMastery.level == 3) {return 0.15}
		if (player.mysticismMastery.level == 4) {return 0.20}
		if (player.mysticismMastery.level == 5) {return 0.25}
		if (player.mysticismMastery.level == 6) {return 0.30}
		if (player.mysticismMastery.level == 7) {return 0.35}
		if (player.mysticismMastery.level == 8) {return 0.40}
		if (player.mysticismMastery.level == 9) {return 0.45}
		if (player.mysticismMastery.level >= 10) {return 0.50}
		else {return 1}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.mysticismMastery)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.mysticismMastery)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
mysticismMastery.addToPlayer()
const sorceryMastery = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Sorcery Mastery`,
	refName: 'sorceryMastery',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	reduction: function() {
		if (player.sorceryMastery.level == 1) {return 0.05}
		if (player.sorceryMastery.level == 2) {return 0.10}
		if (player.sorceryMastery.level == 3) {return 0.15}
		if (player.sorceryMastery.level == 4) {return 0.20}
		if (player.sorceryMastery.level == 5) {return 0.25}
		if (player.sorceryMastery.level == 6) {return 0.30}
		if (player.sorceryMastery.level == 7) {return 0.35}
		if (player.sorceryMastery.level == 8) {return 0.40}
		if (player.sorceryMastery.level == 9) {return 0.45}
		if (player.sorceryMastery.level == 10) {return 0.50}
		else {return 1}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.sorceryMastery)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.sorceryMastery)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
sorceryMastery.addToPlayer()
const clearMind = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: `Clear Mind`,
	refName: 'clearMind',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	reduction: function() {
		if (player.clearMind.level >= 100) {return 4000}
		if (player.clearMind.level == 1) {return 200}
		if (player.clearMind.level == 2) {return 400}
		if (player.clearMind.level == 3) {return 600}
		if (player.clearMind.level == 4) {return 800}
		if (player.clearMind.level == 5) {return 1000}
		if (player.clearMind.level == 6) {return 1200}
		if (player.clearMind.level == 7) {return 1400}
		if (player.clearMind.level == 8) {return 1600}
		if (player.clearMind.level == 9) {return 1800}
		if (player.clearMind.level >= 10) {return 2000}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.clearMind)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.clearMind)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
clearMind.addToPlayer()

const spellWeapons = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Spell Weapons`,
	refName: 'spellWeapons',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	bonus: function() {
		if (player.spellWeapons.level == 1) {return 0.1}
		if (player.spellWeapons.level == 2) {return 0.2}
		if (player.spellWeapons.level == 3) {return 0.3}
		if (player.spellWeapons.level == 4) {return 0.4}
		if (player.spellWeapons.level == 5) {return 0.5}
		if (player.spellWeapons.level == 6) {return 0.6}
		if (player.spellWeapons.level == 7) {return 0.7}
		if (player.spellWeapons.level == 8) {return 0.8}
		if (player.spellWeapons.level == 9) {return 0.9}
		if (player.spellWeapons.level == 10) {return 1.0}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.spellWeapons)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.spellWeapons)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
spellWeapons.addToPlayer()


const magicDexterity = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Magic Dexterity`,
	refName: 'magicDexterity',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	reduction: function() {
		if (player.magicDexterity.level >= 100) {return 4000}
		if (player.magicDexterity.level == 1) {return 200}
		if (player.magicDexterity.level == 2) {return 400}
		if (player.magicDexterity.level == 3) {return 600}
		if (player.magicDexterity.level == 4) {return 800}
		if (player.magicDexterity.level == 5) {return 1000}
		if (player.magicDexterity.level == 6) {return 1200}
		if (player.magicDexterity.level == 7) {return 1400}
		if (player.magicDexterity.level == 8) {return 1600}
		if (player.magicDexterity.level == 9) {return 1800}
		if (player.magicDexterity.level >= 10) {return 2000}
		else {return 0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.magicDexterity)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.magicDexterity)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
magicDexterity.addToPlayer()

const barrier = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Barrier`,
	refName: 'barrier',
	type: 'restorative',
	cooldown: 0,
	color: 'green',
	conjureBarColor: 'defensive-spell',
	chambered: false,
	maxLevel: 10,
	resourceName: 'mana', 
	conjureTime: function() {
		let baseConjureTime = 6000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.barrier.level == 0) {spellLevelReduction = 0}
		if (player.barrier.level == 1) {spellLevelReduction = 200}
		if (player.barrier.level == 2) {spellLevelReduction = 400}
		if (player.barrier.level == 3) {spellLevelReduction = 700}
		if (player.barrier.level == 4) {spellLevelReduction = 1000}
		if (player.barrier.level >= 5) {spellLevelReduction = 1500}
		//6000, 1000, 
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 6000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.barrier.level == 0) {spellLevelReduction = 0}
		if (player.barrier.level == 1) {spellLevelReduction = 200}
		if (player.barrier.level == 2) {spellLevelReduction = 400}
		if (player.barrier.level == 3) {spellLevelReduction = 700}
		if (player.barrier.level == 4) {spellLevelReduction = 1000}
		if (player.barrier.level >= 5) {spellLevelReduction = 1500}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	maxShield: function() {
		let baseAmount = player.mysticPower
		let skillBonus
		if (player.barrier.level == 0) {skillBonus = 1}
		if (player.barrier.level == 1) {skillBonus = 1.2}
		if (player.barrier.level == 2) {skillBonus = 1.4}
		if (player.barrier.level == 3) {skillBonus = 1.6}
		if (player.barrier.level == 4) {skillBonus = 1.8}
		if (player.barrier.level == 5) {skillBonus = 2.0}
		if (player.barrier.level == 6) {skillBonus = 2.2}
		if (player.barrier.level == 7) {skillBonus = 2.4}
		if (player.barrier.level == 8) {skillBonus = 2.6}
		if (player.barrier.level == 9) {skillBonus = 2.8}
		if (player.barrier.level >= 10) {skillBonus = 3.0}
		let shieldTotal = baseAmount * skillBonus
		return Math.ceil(shieldTotal)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.barrier)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.barrier)
	},
	cast: function() {
		this.chambered = false
		applyMagicShieldToPlayer()
	},
	castAudio: function() {

	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (shieldAmount) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You hold your hands out in front of you. A light blue glow surrounds your body.`, 'white', line1)		
		customizeEachWord(`You place a `, 'white', line2)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`on yourself absorbing the next `, 'white', line2)
		customizeEachWord(`${shieldAmount} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()

	},
	description: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Barrier creates a protective shield around you, absorbing damage from magic and physical attacks. Damage will be applied to barrier before being applied to your health.
			This spell utilizes Mysticpower rather than Spellpower.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
barrier.addToPlayer()


const battleRage = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Battle Rage`,
	refName: 'battleRage',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	activate: function() {
		applyBuff(player.battleRage.buff)
	},
	buff: {
		name: 'Battle Rage',
		refName: 'battleRage',
		get attackPower() {
			if (player.battleRage.level == 1) {return 1}
			if (player.battleRage.level == 2) {return 1}
			if (player.battleRage.level == 3) {return 2}
			if (player.battleRage.level == 4) {return 2}
			if (player.battleRage.level == 5) {return 3}
			if (player.battleRage.level == 6) {return 3}
			if (player.battleRage.level == 7) {return 4}
			if (player.battleRage.level == 8) {return 4}
			if (player.battleRage.level == 9) {return 5}
			if (player.battleRage.level >= 10) {return 5}
			else {return 0}
		},
		duration: 10000,
		stacks: 1,
		maxStacks: function() {
			if (player.battleRage.level == 1) {return 3}
			if (player.battleRage.level == 2) {return 4}
			if (player.battleRage.level == 3) {return 4}
			if (player.battleRage.level == 4) {return 5}
			if (player.battleRage.level == 5) {return 5}
			if (player.battleRage.level == 6) {return 6}
			if (player.battleRage.level == 7) {return 6}
			if (player.battleRage.level == 8) {return 7}
			if (player.battleRage.level == 9) {return 7}
			if (player.battleRage.level >= 10) {return 8}
			else {return 0}
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.battleRage)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.battleRage)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each hit you take from an enemy's offensive attack increases your offense capabilities. Attack Power increased by ${player.battleRage.buff.attackPower} and stacks up to ${player.battleRage.buff.maxStacks()} times.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
battleRage.addToPlayer()
const resilience = { //DEFENSE RAISED BY LANDING ATTACKS
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Resilience`,
	refName: 'resilience',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Resilience',
		refName: 'resilience',
		duration: 10000,
		stacks: 1,
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		maxStacks: function() {
			if (player.resilience.level == 1) {return 1}
			if (player.resilience.level == 2) {return 2}
			if (player.resilience.level == 3) {return 3}
			if (player.resilience.level == 4) {return 4}
			if (player.resilience.level == 5) {return 5}
			if (player.resilience.level == 6) {return 6}
			if (player.resilience.level == 7) {return 7}
			if (player.resilience.level == 8) {return 8}
			if (player.resilience.level == 9) {return 9}
			if (player.resilience.level >= 10) {return 10}
		}

	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.resilience)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.resilience)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each regular attack you land increases your defenses. All armor types increased by ${player.resilience.attackPower} and stacks up to ${player.resilience.maxStacks()} times.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
resilience.addToPlayer()

const hardenedSkin = {//DEFENSE RAISED BY TAKING HITS
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Hardened Skin',
	refName: 'hardenedSkin',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	activate: function() {
		applyBuff(buff)
	},
	buff: {
		name: 'Hardened Skin',
		refName: 'hardenedSkin',
		duration: 10000,
		get slashingArmor() {
			if (player.hardenedSkin.level == 1) {return 1}
			if (player.hardenedSkin.level == 2) {return 2}
			if (player.hardenedSkin.level == 3) {return 3}
			if (player.hardenedSkin.level == 4) {return 4}
			if (player.hardenedSkin.level >= 5) {return 5}
		},
		get slashingArmor() {
			if (player.hardenedSkin.level == 1) {return 1}
			if (player.hardenedSkin.level == 2) {return 2}
			if (player.hardenedSkin.level == 3) {return 3}
			if (player.hardenedSkin.level == 4) {return 4}
			if (player.hardenedSkin.level >= 5) {return 5}
		},		
		get slashingArmor() {
			if (player.hardenedSkin.level == 1) {return 1}
			if (player.hardenedSkin.level == 2) {return 2}
			if (player.hardenedSkin.level == 3) {return 3}
			if (player.hardenedSkin.level == 4) {return 4}
			if (player.hardenedSkin.level >= 5) {return 5}
		},		
		stacks: 1,
		maxStacks: function() {
			return 5
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.hardenedSkin)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.hardenedSkin)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
hardenedSkin.addToPlayer()
const knightsResolve = {//WEIGHT ADDS ATTACK POWER
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Knight's Resolve`,
	refName: 'knightsResolve',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	bonusDamage: function() {
		if (this.level == 1) {return player.weight * 0.1}
		if (this.level == 2) {return player.weight * 0.2}
		if (this.level == 3) {return player.weight * 0.3}
		if (this.level == 4) {return player.weight * 0.4}
		if (this.level == 5) {return player.weight * 0.5}
		if (this.level == 6) {return player.weight * 0.6}
		if (this.level == 7) {return player.weight * 0.7}
		if (this.level == 8) {return player.weight * 0.8}
		if (this.level == 9) {return player.weight * 0.9}
		if (this.level >= 10) {return player.weight * 1.0}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.knightsResolve)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.knightsResolve)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Knight's Resolve `, this.color, line1)
		customizeEachWord(`grants knights additional damage based on their weight. This skill takes into consideration the Knight's weight before it is mitigated by Strength and other factors.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
knightsResolve.addToPlayer()
const blacksmithing = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: `Blacksmithing`,
	refName: 'blacksmithing',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.blacksmithing)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.blacksmithing)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Blacksmithing allows you to enhance your weapons and armor with ores. Applying ore to a weapon will enhance its top end damage while applying ore to a piece of armor will increase a specified armor type. Higher level blacksmithing is required to both mine and utilize higher level ores. Increasing the level of Blacksmithing will also give a higher possibility of receiving more than one ore when mining.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
blacksmithing.addToPlayer()
const herbalism = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Herbalism`,
	refName: 'herbalism',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.herbalism)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.herbalism)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Herbalism allows you to enhance your weapons and armor with magical plant fibers. Applying magic fibers to a weapon or piece of armor will increase a specified magical property already on that item. Higher level herbalism is required to harvest and apply higher level magic fibers to equipment. Increasing the level of Herbalism will also give a higher possibility of receiving more than one flower/herb when harvesting.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
herbalism.addToPlayer()
const leatherworking = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Leatherworking`,
	refName: 'leatherworking',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.leatherworking)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.leatherworking)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Leatherworking allows you to enhance your weapons and armor with magic animal hide. Applying magic hide to a weapon will increase the low end damage while applying magic hide to armor will decrease its weight. Higher level leatherworking is required to skin animals and apply higher level hides to equipment. Increasing the level of Leatherworking will also give a higher possibility of receiving more than one hide when skinning.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
leatherworking.addToPlayer()
const fishing = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: `Fishing`,
	refName: 'fishing',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.fishing)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.fishing)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Fishing allows you to go fishing. Increasing its level will help you catch fish faster.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
fishing.addToPlayer()

const evasiveRoll = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Evasive Roll`,
	refName: 'evasiveRoll',
	resourceName: 'focus',
	maxLevel: 1,
	get resourceCost() {
		if (this.level >= 1) {return 20}
	},
	cooldown: 0,
	type: 'skill',
	color: 'ranger-color',
	goldToUpgrade: function () {
		return 1000
	},
	pointsToUpgrade: function () {
		return 40
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
evasiveRoll.addToPlayer()
const athletics = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Athletics`,
	refName: 'athletics',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Each level of this skill counts toward rolls that require STR, DEX, or AGI. Level 1 would count as 1 STR, DEX, or AGI. Level 5 would count as 5 STR, DEX, or AGI, etc.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
athletics.addToPlayer()
const ridingSkill = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Riding Skill`,
	refName: 'ridingSkill',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Allows for better handling of mounts. The higher your skill is, the higher the level of mounts you can ride.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
ridingSkill.addToPlayer()

const tauntingShout = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Taunting Shout`,
	refName: 'tauntingShout',
	cooldown: 0,
	resourceName: 'might',
	resourceCost: 1,
	maxLevel: 1,
	type: 'skill',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return 250
	},
	pointsToUpgrade: function () {
		return 20
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Taunts every enemy in the room, forcing them to instantly engage combat with you.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
tauntingShout.addToPlayer()

const berserking = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Berserking`,
	refName: 'berserking',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	goldToUpgrade: function () {
		return 9999
	},
	pointsToUpgrade: function () {
		return 9999
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Crit skill for Warriors.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
berserking.addToPlayer()
const headshot = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Headshot`,
	refName: 'headshot',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	procChance: function() {
		return player.headshot.level * 4
	},
	percentBonus: function() {
		return 1.75
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.headshot)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.headshot)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Headshot `, 'green', line1)
		customizeEachWord(`gives you a percent chance to land a headshot on the target dealing 75% bonus damage. Your current chance to land a headshot is ${player.headshot.procChance()} `, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
headshot.addToPlayer()
const backstabbing = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Backstabbing`,
	refName: 'backstabbing',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	procChance: function() {
		return player.backstabbing.level * 5
	},
	percentBonus: function() {
		return 1.5
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.backstabbing)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.backstabbing)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Gives you a chance to perform a Backstabbing attack instead of a regular attack. This currently has a chance of ${player.backstabbing.procChance()}% chance to deal ${player.backstabbing.percentBonus}x damage.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
backstabbing.addToPlayer()

const brutalBlows = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Brutal Blows`,
	refName: 'brutalBlows',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	procChance: function() {
		return player.brutalBlows.level * 3
	},
	percentBonus: function() {
		return 2.0
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.brutalBlows)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.brutalBlows)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Brutal Blows gives you a chance to land a devastating attack that deals ${player.brutalBlows.percenBonus()}x damage at a chance of ${player.brutalBlows.procChance()}%`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
brutalBlows.addToPlayer()

const thrillOfTheKill = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Thrill Of The Kill',
	refName: 'thrillOfTheKill',
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Thrill Of The Kill',
		refName: 'thrillOfTheKill',
		enemy: undefined,
		percentRecovered: function() {
			if (player.thrillOfTheKill.level == 1) {return 0.01}
			if (player.thrillOfTheKill.level == 2) {return 0.02}
			if (player.thrillOfTheKill.level == 3) {return 0.03}
			if (player.thrillOfTheKill.level == 4) {return 0.04}
			if (player.thrillOfTheKill.level == 5) {return 0.05}
			if (player.thrillOfTheKill.level == 6) {return 0.06}
			if (player.thrillOfTheKill.level == 7) {return 0.07}
			if (player.thrillOfTheKill.level == 8) {return 0.08}
			if (player.thrillOfTheKill.level == 9) {return 0.09}
			if (player.thrillOfTheKill.level >= 10) {return 0.10}
			else {return 0}
		},
		heal: function(enemy) {
			let healAmount
			let enemyHealthPercent = Math.ceil(player.thrillOfTheKill.buff.enemy.maxHealth * player.thrillOfTheKill.buff.percentRecovered())
			if (player.thrillOfTheKill.level >= 1) {
				healAmount = enemyHealthPercent
			}
			return healAmount
		},
		flavorText: function(healAmount) {
			let line1 = lineFunc()
			customizeEachWord(`You heal for `, 'green', line1)
			customizeEachWord(`${healAmount} `, 'light-blue', line1)
			customizeEachWord(`hit point(s).`, 'green', line1)
			blankSpace()
		},
		duration: 10000,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
	},
	heal: function() {
		return 10
	},
	activate: function(enemy) {
		player.thrillOfTheKill.buff.enemy = enemy
		applyBuff(player.thrillOfTheKill.buff)

	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.thrillOfTheKill)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.thrillOfTheKill)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You feel invigorated after last kill. Your regular attacks heal you for ${player.thrillOfTheKill.buff.percentRecovered()} of the enemy's health that you most recently killed.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
thrillOfTheKill.addToPlayer()

const counterAttack = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Counter Attack',
	refName: 'counterAttack',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	strike: function(enemy) {
		let baseChance = player.counterAttack.level * 3
		let enemyLevelNegation = player.level - enemy.level < 0 ? player.level - enemy.level : 0
		let chanceToCounter = baseChance + enemyLevelNegation
		let roll = randomNumberRange(1, 100)
		console.log(chanceToCounter, 'side step strike chance')
		console.log(roll, ' side step strike roll')
		if (chanceToCounter >= roll) {
			let damageBeforeMitigation = getWeapon1() ? baseAttackDamageRight() : getWeapon2() ? baseAttackDamageLeft() : undefined
			let playerPenetration = calculatePenetrationRoll()
			let enemyArmor = playerPenetration == 'slashingPen' ? enemy.slashingArmor : playerPenetration == 'piercingPen' ? enemy.piercingArmor : enemy.bluntArmor
			let armorAfterPen = enemyArmor - player[playerPenetration] <= 0 ? 0 : enemyArmor - player[playerPenetration]
			let damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))
			let blockedDamage = damageBeforeMitigation - damageAfterMitigation
			let penetrationFlavorText = playerPenetration == 'slashingPen' ? 'slashing' : playerPenetration == 'piercingPen' ? 'piercing' : 'blunt'
			console.log(damageAfterMitigation, ' DAMAGE')
			if (!damageAfterMitigation) {return}
				oneHandedHitArray1[randomNumberRange(0, 4)].play()
				this.flavorText(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText)
				applyDamageToEnemy(enemy, damageAfterMitigation)
		} else {
		}
	},
	flavorText: function(enemy, damageAfterMitigation, blockedDamage, penetrationFlavorText) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You spot an opening in the `, 'white', line1)
		customizeEachWord(`${enemy.name}'s `, enemy.color, line1)
		customizeEachWord(`defense, and you land a `, 'white', line1)
		customizeEachWord(`Counter Attack`, 'green', line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damageAfterMitigation} `, 'light-blue', line2)
		customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${blockedDamage}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.counterAttack)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.counterAttack)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
counterAttack.addToPlayer()
const fleetFooted = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Fleet Footed`,
	refName: 'fleetFooted',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 5,
	reduction: function() {
		let reductionTime = 0
		if (this.level == 0) {reductionTime = 0}
		if (this.level == 1) {reductionTime = 0.1}
		if (this.level == 2) {reductionTime = 0.2}
		if (this.level == 3) {reductionTime = 0.3}
		if (this.level == 4) {reductionTime = 0.4}
		if (this.level >= 5) {reductionTime = 0.5}
		return reductionTime
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.slashingExpertise)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.slashingExpertise)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Reduces the time penalty of retreating. Each level of Fleet Footed reduces the time you can become active after retreating by .1 second(s).`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
fleetFooted.addToPlayer()
const initiation = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Initiation`,
	refName: 'initiation',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	maxLevel: 5,
	reduction: function() {
		let reductionTime = 0
		if (this.level == 0) {reductionTime = 0}
		if (this.level == 1) {reductionTime = 0.2}
		if (this.level == 2) {reductionTime = 0.4}
		if (this.level == 3) {reductionTime = 0.6}
		if (this.level == 4) {reductionTime = 0.8}
		if (this.level >= 5) {reductionTime = 1.0}
		return reductionTime
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.initiation)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.initiation)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Reduces the time it takes to perform a regular attack after advancing the enemy. Each level of Initiation reduces the time you can become active after advancing an enemy by .2 second(s).`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
initiation.addToPlayer()
const vigilance = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Vigilance`,
	refName: 'vigilance',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Vigilance',
		refName: 'vigilance',
		get dodge() {
			if (player.vigilance.level == 1) {return 5}
			if (player.vigilance.level == 2) {return 5}
			if (player.vigilance.level == 3) {return 10}
			if (player.vigilance.level == 4) {return 10}
			if (player.vigilance.level == 5) {return 15}
			if (player.vigilance.level == 6) {return 15}
			if (player.vigilance.level == 7) {return 20}
			if (player.vigilance.level == 8) {return 20}
			if (player.vigilance.level == 9) {return 25}
			if (player.vigilance.level >= 10) {return 25}
		},
		get agi() {
			if (player.vigilance.level == 1) {return 0}
			if (player.vigilance.level == 2) {return 2}
			if (player.vigilance.level == 3) {return 2}
			if (player.vigilance.level == 4) {return 4}
			if (player.vigilance.level == 5) {return 4}
			if (player.vigilance.level == 6) {return 6}
			if (player.vigilance.level == 7) {return 6}
			if (player.vigilance.level == 8) {return 8}
			if (player.vigilance.level == 9) {return 8}
			if (player.vigilance.level >= 10) {return 10}
		},
		duration: 10000,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.vigilance)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.vigilance)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Grants a bonus after retreating.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
vigilance.addToPlayer()
const tactics = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Tactics`,
	refName: 'tactics',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	buff: {
		name: 'Tactics',
		refName: 'tactics',
		get slashingArmor() {
			if (player.tactics.level == 1) {return 1}
			if (player.tactics.level == 2) {return 2}
			if (player.tactics.level == 3) {return 3}
			if (player.tactics.level == 4) {return 4}
			if (player.tactics.level == 5) {return 5}
			if (player.tactics.level == 6) {return 6}
			if (player.tactics.level == 7) {return 7}
			if (player.tactics.level == 8) {return 8}
			if (player.tactics.level == 9) {return 9}
			if (player.tactics.level >= 10) {return 10}
			else {return 0}
		},
		get piercingArmor() {
			if (player.tactics.level == 1) {return 1}
			if (player.tactics.level == 2) {return 2}
			if (player.tactics.level == 3) {return 3}
			if (player.tactics.level == 4) {return 4}
			if (player.tactics.level == 5) {return 5}
			if (player.tactics.level == 6) {return 6}
			if (player.tactics.level == 7) {return 7}
			if (player.tactics.level == 8) {return 8}
			if (player.tactics.level == 9) {return 9}
			if (player.tactics.level >= 10) {return 10}
			else {return 0}
		},
		get bluntArmor() {
			if (player.tactics.level == 1) {return 1}
			if (player.tactics.level == 2) {return 2}
			if (player.tactics.level == 3) {return 3}
			if (player.tactics.level == 4) {return 4}
			if (player.tactics.level == 5) {return 5}
			if (player.tactics.level == 6) {return 6}
			if (player.tactics.level == 7) {return 7}
			if (player.tactics.level == 8) {return 8}
			if (player.tactics.level == 9) {return 9}
			if (player.tactics.level >= 10) {return 10}
			else {return 0}
		},
		get str() {
			if (player.tactics.level == 1) {return 0}
			if (player.tactics.level == 2) {return 0}
			if (player.tactics.level == 3) {return 0}
			if (player.tactics.level == 4) {return 0}
			if (player.tactics.level == 5) {return 0}
			if (player.tactics.level == 6) {return 1}
			if (player.tactics.level == 7) {return 2}
			if (player.tactics.level == 8) {return 3}
			if (player.tactics.level == 9) {return 4}
			if (player.tactics.level >= 10) {return 5}
			else {return 0}
		},
		duration: function() {
			if (player.tactics.level == 1) {return 10000}
			if (player.tactics.level == 2) {return 11000}
			if (player.tactics.level == 3) {return 12000}
			if (player.tactics.level == 4) {return 13000}
			if (player.tactics.level == 5) {return 14000}
			if (player.tactics.level == 6) {return 15000}
			if (player.tactics.level == 7) {return 16000}
			if (player.tactics.level == 8) {return 17000}
			if (player.tactics.level == 9) {return 18000}
			if (player.tactics.level >= 10) {return 20000}
		},
		stacks: 1,
		maxStacks: function() {
			return 1
		},
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.tactics)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.tactics)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Grants an armor bonus for a short duration after using the advance command to initiate combat.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
tactics.addToPlayer()
const fistsOfFury = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Fists of Fury`,
	refName: 'fistsOfFury',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	update: function() {
		//Goblin Fist
		//Ogre Fist
		//Titan Fist
		//Dragon Fist
		//God Fist
		if (this.level == 1) {player.rightFist.topDamage += 2}
		if (this.level == 1) {player.leftFist.topDamage += 2}
		if (this.level == 2) {player.rightFist.topDamage += 3}
		if (this.level == 2) {player.leftFist.topDamage += 3}
		if (this.level == 3) {player.rightFist.topDamage += 4}
		if (this.level == 3) {player.leftFist.topDamage += 4}
		if (this.level == 4) {player.rightFist.topDamage += 5}
		if (this.level == 4) {player.leftFist.topDamage += 5}
		if (this.level == 5) {player.rightFist.topDamage += 6}
		if (this.level == 5) {player.leftFist.topDamage += 6}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.fistsOfFury)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.fistsOfFury)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`A skill for Monks who would rather use their fists in combat rather than rely on weapons. Fists of Fury increases the top damage value of both your fists.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
fistsOfFury.addToPlayer()
const fistsOfPrecision = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Fists of Precision`,
	refName: 'fistsOfPrecision',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	update: function() {
		//Goblin Fist
		//Ogre Fist
		//Titan Fist
		//Dragon Fist
		//God Fist
		if (this.level == 1) {player.rightFist.botDamage += 2}
		if (this.level == 1) {player.leftFist.botDamage += 2}
		if (this.level == 2) {player.rightFist.botDamage += 3}
		if (this.level == 2) {player.leftFist.botDamage += 3}
		if (this.level == 3) {player.rightFist.botDamage += 4}
		if (this.level == 3) {player.leftFist.botDamage += 4}
		if (this.level == 4) {player.rightFist.botDamage += 5}
		if (this.level == 4) {player.leftFist.botDamage += 5}
		if (this.level == 5) {player.rightFist.botDamage += 6}
		if (this.level == 5) {player.leftFist.botDamage += 6}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.fistsOfPrecision)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.fistsOfPrecision)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`A skill for Monks who would rather use their fists in combat rather than rely on weapons. Fists of Calm increases the bottom damage value of both your fists.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
fistsOfPrecision.addToPlayer()

const wayOfTheFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: `Way Of The Fist`,
	refName: 'wayOfTheFist',
	cooldown: 0,
	type: 'skill',
	color: 'green',
	update: function() {
		let attackPowerIncrease = 0
		let bluntPenIncrease = 0
		if (player.wayOfTheFist.level == 1) {attackPowerIncrease = 1}
		if (player.wayOfTheFist.level == 1) {bluntPenIncrease = 0}
		if (player.wayOfTheFist.level == 2) {attackPowerIncrease = 2}
		if (player.wayOfTheFist.level == 2) {bluntPenIncrease = 3}
		if (player.wayOfTheFist.level == 3) {attackPowerIncrease = 3}
		if (player.wayOfTheFist.level == 3) {bluntPenIncrease = 3}
		if (player.wayOfTheFist.level == 4) {attackPowerIncrease = 5}
		if (player.wayOfTheFist.level == 4) {bluntPenIncrease = 5}
		if (player.wayOfTheFist.level == 5) {attackPowerIncrease = 6}
		if (player.wayOfTheFist.level == 5) {bluntPenIncrease = 6}
		if (player.wayOfTheFist.level == 6) {attackPowerIncrease = 7}
		if (player.wayOfTheFist.level == 6) {bluntPenIncrease = 7}
		if (player.wayOfTheFist.level == 7) {attackPowerIncrease = 9}
		if (player.wayOfTheFist.level == 7) {bluntPenIncrease = 9}
		if (player.wayOfTheFist.level == 8) {attackPowerIncrease = 10}
		if (player.wayOfTheFist.level == 8) {bluntPenIncrease = 10}
		if (player.wayOfTheFist.level == 9) {attackPowerIncrease = 11}
		if (player.wayOfTheFist.level == 9) {bluntPenIncrease = 11}
		if (player.wayOfTheFist.level >= 10) {attackPowerIncrease = 15}
		if (player.wayOfTheFist.level >= 10) {bluntPenIncrease = 15}
		// player.unarmed.botMultiplier += increaseAmount
		player.rightFist.mods.attackPower = attackPowerIncrease
		player.leftFist.mods.attackPower = attackPowerIncrease
		player.rightFist.mods.bluntPen = bluntPenIncrease
		player.leftFist.mods.bluntPen = bluntPenIncrease
		console.log(attackPowerIncrease)
		console.log(player.rightFist.mods)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.wayOfTheFist)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.wayOfTheFist)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Increases your attack power while not wielding any weapons. This is for Monks who choose to use their fists rather than rely on weapons in combat. Way Of The Fist also increases your Blunt Penetration.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
wayOfTheFist.addToPlayer()
const bleed = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Bleed',
	refName: 'bleed',
	color: 'green',
	stacks: 0,
	duration: 15000,
	damage: function(enemy, swingObject) {
		let damage = swingObject.totalDamage
		let totalDamage = Math.ceil(damage * (enemy.debuffs.bleed.stacks * 0.1))
		console.log(totalDamage, ' BLEED BONUS DAMAGE')
		return Math.ceil(totalDamage)
		// return 0.1 * this.stacks
		//change to increment by 10% per stack
	},
	bonusModifier: function() {
		if (this.level == 0) {return 0}
		if (this.level == 1) {return 0.20}
		if (this.level == 2) {return 0.25}
		if (this.level == 3) {return 0.30}
		if (this.level == 4) {return 0.35}
		if (this.level == 5) {return 0.40}
		if (this.level == 6) {return 0.45}
		if (this.level == 7) {return 0.50}
		if (this.level == 8) {return 0.55}
		if (this.level == 9) {return 0.60}
		if (this.level >= 10) {return 0.65}
	},
	maxStacks: function() {
		return 5
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.bleed)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.bleed)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Bleed is a debuff applied to enemies by certain Warrior skills. Each stack of bleed on the target increases the damage dealt to it by all warrior abilities and regular attacks by ${player.bleed.bonusModifier() * 100}%. Damage is increased further for each stack on the target.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
bleed.addToPlayer()
const burn = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Burn',
	refName: 'burn',
	color: 'green',
	stacks: 0,
	duration: 15000,
	bonusModifier: function() {
		if (this.level == 1) {return 0.20}
		if (this.level == 2) {return 0.25}
		if (this.level == 3) {return 0.30}
		if (this.level == 4) {return 0.35}
		if (this.level == 5) {return 0.40}
		if (this.level == 6) {return 0.45}
		if (this.level == 7) {return 0.50}
		if (this.level == 8) {return 0.55}
		if (this.level == 9) {return 0.60}
		if (this.level >= 10) {return 0.65}
		else {return 0}
	},
	maxStacks: function() {
		return this.level + 2
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Burn is a debuff applied by certain fire spells. Each stack of burn increases the damage of all fire spells against the target by ${player.burn.bonusModifier()}% per stack.`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.burn)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.burn)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
burn.addToPlayer()
const frostbite = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Frostbite',
	refName: 'frostbite',
	color: 'green',
	stacks: 0,
	duration: 15000,
	bonusModifier: function() {
		if (this.level == 1) {return 0.20}
		if (this.level == 2) {return 0.25}
		if (this.level == 3) {return 0.30}
		if (this.level == 4) {return 0.35}
		if (this.level == 5) {return 0.40}
		if (this.level == 6) {return 0.45}
		if (this.level == 7) {return 0.50}
		if (this.level == 8) {return 0.55}
		if (this.level == 9) {return 0.60}
		if (this.level >= 10) {return 0.65}
		else {return 0}
	},
	maxStacks: function() {
		return this.level + 2
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Burn is a debuff applied by certain fire spells. Each stack of burn increases the damage of all fire spells against the target by ${player.burn.bonusModifier()}% per stack.`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.frostbite)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.frostbite)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
frostbite.addToPlayer()
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////
//////////////////////////////////////SKILLS SKILLS SKILLS SKILLS////////////////////////////////////////

//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
//////////////////////////////////////ABILITIES ABILITIES ABILITIES//////////////////////////////////////
const charge = {
	//Ideas: Can hit and engage multiple enemies at once
	//
		get level() {
		return calculateStat(player, this.refName)
	},
	maxLevel: 5,
	name: 'Charge',
	refName: 'charge',
	type: 'ability',
	color: 'warrior-color',
	activate: function() {
		let debuffTime
		if (player.charge.level == 1) {debuffTime = 10000}
	},
	buff: {
		name: 'Charge',
		refName: 'charge',
		get slashingArmor() {
			if (player.level == 1) {return -10}
			if (player.level == 2) {return -8}
			if (player.level == 3) {return -6}
			if (player.level == 4) {return -4}
			if (player.level >= 5) {return 0}
		},
		get piercingArmor() {
			if (player.level == 1) {return -10}
			if (player.level == 2) {return -8}
			if (player.level == 3) {return -6}
			if (player.level == 4) {return -4}
			if (player.level >= 5) {return 0}	
		},
		get bluntArmor() {
			if (player.level == 1) {return -10}
			if (player.level == 2) {return -8}
			if (player.level == 3) {return -6}
			if (player.level == 4) {return -4}
			if (player.level >= 5) {return 0}		
		},
		stacks: 1,
		duration: 10000,
		maxStacks: function() {
			return 1
		}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.charge)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.charge)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Charge `, 'green', line1)
		customizeEachWord(`allows you to instantly engage combat while simulataneously performing a regular attack on your target. This is a reckless attack, leaving you vulnerable for a short time after charging by decreasing the value of all armor types. Training this ability to higher levels will reduce the armor penalty.`, 'white', line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
charge.addToPlayer()

const ripslash = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Ripslash',
	refName: 'ripslash',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 6000,
	cooldown: 6000,
	windUp: 6,
	numberOfSwings: function() {
		if (this.level == 1) { return 1 }
		if (this.level == 2) { return 1 }
		if (this.level == 3) { return 1 }
		if (this.level == 4) { return 1 }
		if (this.level == 5) { return 2 }
		if (this.level == 6) { return 2 }
		if (this.level == 7) { return 2 }
		if (this.level == 8) { return 2 }
		if (this.level == 9) { return 2 }
		if (this.level >= 10) { return 3 }
		else {return 1 }
	},
	resourceCost: 1,
	resourceName: 'might',
	weaponTypesUsed: ['oneHanded', 'twoHanded'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0 }
		if (this.level == 2) { levelModifier = 1.2 }
		if (this.level == 3) { levelModifier = 1.4 }
		if (this.level == 4) { levelModifier = 1.6 }
		if (this.level == 5) { levelModifier = 1.6 }
		if (this.level == 6) { levelModifier = 1.8 }
		if (this.level == 7) { levelModifier = 2.0 }
		if (this.level == 8) { levelModifier = 2.2 }
		if (this.level == 9) { levelModifier = 2.5 }
		if (this.level >= 10) { levelModifier = 2.5 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You step forward, arcing your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`upward, ripping into the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		ripslashAudioArray[randomNumberRange(0, 2)].play()
	},
		flavorTextMiss: function(enemy, weapon) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You step forward, arcing your `, 'white', line2)
			customizeEachWord(`${weapon.name} `, `${weapon.color}`, line2)
			customizeEachWord(`toward the `, 'white', line2)
			customizeEachWord(`${enemy.name}`, enemy.color, line2)
			customizeEachWord(`, but you narrowly `, 'white', line2)
			customizeEachWord(`miss`, 'red', line2)
			customizeEachWord(`!`, 'white', line2)
			blankSpace()
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Ripslash deals single target damage, increasing with each skill level. Ripslash gains an additional swing at skill levels 5 and 10.`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.ripslash)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.ripslash)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
ripslash.addToPlayer()

const cyclone = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Cyclone',
	refName: 'cyclone',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 6000,
	cooldown: 6000,
	windUp: 6,
	numberOfTargets: function() {
		if (this.level == 1) { return 2}
		if (this.level == 2) { return 2}
		if (this.level == 3) { return 2}
		if (this.level == 4) { return 3}
		if (this.level == 5) { return 3}
		if (this.level == 6) { return 3}
		if (this.level == 7) { return 4}
		if (this.level == 8) { return 4}
		if (this.level == 9) { return 4}
		if (this.level >= 10) { return 5}
	},
	resourceName: 'might',
	resourceCost: 2,
	weaponTypesUsed: ['oneHanded', 'twoHanded'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let levelModifier
		if (this.level == 1) { levelModifier = 1.25 }
		if (this.level == 2) { levelModifier = 1.40 }
		if (this.level == 3) { levelModifier = 1.55 }
		if (this.level == 4) { levelModifier = 1.55 }
		if (this.level == 5) { levelModifier = 1.70 }
		if (this.level == 6) { levelModifier = 1.85 }
		if (this.level == 7) { levelModifier = 1.85 }
		if (this.level == 8) { levelModifier = 2.0 }
		if (this.level == 9) { levelModifier = 2.15 }
		if (this.level >= 10) { levelModifier = 2.30 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		return Math.ceil(totalDamage)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		customizeEachWord(`Your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`eviscerates the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		cycloneAudioArray[randomNumberRange(0, 2)].play()
	},
	flavorText2: function(weapon) {
		let line1 = lineFunc()
		customizeEachWord(`Dashing at the enemy, you spin into a `, 'white', line1)
		customizeEachWord(`cyclone `, this.color, line1)
		customizeEachWord(`of fury!`, 'white', line1)

	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Your `, 'white', line2)
		customizeEachWord(`${weapon.name} `, weapon.color, line2)
		customizeEachWord(`whirls past the `, 'white', line2)
		customizeEachWord(`${enemy.name} `, enemy.color, line2)
		customizeEachWord(`and you `, 'white', line2)
		customizeEachWord(`miss`, 'red', line2)
		customizeEachWord(`!`, 'white', line2)
		blankSpace()
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.cyclone)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.cyclone)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
cyclone.addToPlayer()

const cataclysm = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Cataclysm',
	refName: 'cataclysm',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 6000,
	cooldown: 6000,
	windUp: 6,
	resourceName: 'might',
	resourceCost: 3, //player.maxMight is what this should be when not testing things
	weaponTypesUsed: ['oneHanded', 'twoHanded'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() * 1.5
		let levelModifier
		if (this.level == 1) { levelModifier = 1.7 }
		if (this.level == 2) { levelModifier = 1.9 }
		//level 3 now hits 2 times
		if (this.level == 3) { levelModifier = 2.1 }
		if (this.level == 4) { levelModifier = 2.3 }
		//level 5 now hits 3 times
		if (this.level == 5) { levelModifier = 2.5 }
		if (this.level == 6) { levelModifier = 2.7 }
		if (this.level == 7) { levelModifier = 2.9 }
		if (this.level == 8) { levelModifier = 3.1 }
		if (this.level == 9) { levelModifier = 3.3 }
		if (this.level >= 10) { levelModifier = 3.5 }
		let basePlusLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, basePlusLevelDamage)
		let totalDamage = basePlusLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' CATACLYSM BASE DAMAGE')
		console.log(basePlusLevelDamage, ' CATACLYSM BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Cataclysm',
		refName: 'cataclysm',
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		get slashingArmor() {
			if (player.cataclysm.level == 1) {return -10}
			if (player.cataclysm.level == 2) {return -20}
			if (player.cataclysm.level == 3) {return -30}
			if (player.cataclysm.level == 4) {return -40}
			if (player.cataclysm.level >= 5) {return -50}
		},
		get piercingArmor() {
			if (player.cataclysm.level == 1) {return -10}
			if (player.cataclysm.level == 2) {return -20}
			if (player.cataclysm.level == 3) {return -30}
			if (player.cataclysm.level == 4) {return -40}
			if (player.cataclysm.level >= 5) {return -50}
		},
		get bluntArmor() {
			if (player.cataclysm.level == 1) {return -10}
			if (player.cataclysm.level == 2) {return -20}
			if (player.cataclysm.level == 3) {return -30}
			if (player.cataclysm.level == 4) {return -40}
			if (player.cataclysm.level >= 5) {return -50}
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap high into the air, crashing down with your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		cataclysmAudioArray[randomNumberRange(0, 2)].play()
	},
	flavorTextMiss: function(enemy, weapon) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
	blankSpace()
	customizeEachWord(`You leap high into the air, crashing down with your `, 'white', line1)
	customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
	customizeEachWord(`, but you `, 'white', line1)
	customizeEachWord(`miss`, 'red', line1)
	customizeEachWord(`!`, 'white', line1)
	blankSpace()
	},
	specialEffect: function(enemy, damage, penetrationType, damageBlocked) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
	blankSpace()
	customizeEachWord(`The shockwave from `, `warrior-ability-text-color`, line1)
	customizeEachWord(`${this.name} `, this.color, line1)
	customizeEachWord(`blasts the `, `warrior-ability-text-color`, line1)
	customizeEachWord(`${enemy.name}`, enemy.color, line1)
	customizeEachWord(`!`, `warrior-ability-text-color`, line1)
	customizeEachWord(`${this.name} `, this.color, line2)
	customizeEachWord(`hits for `, `warrior-ability-text-color`, line2)
	customizeEachWord(`${damage} `, `light-blue`, line2)
	customizeEachWord(`${penetrationType} `, penetrationType, line2)
	customizeEachWord(`damage! `, `white`, line2)
	customizeEachWord(`(Enemy's armor blocks `, `white`, line2)
	customizeEachWord(`${damageBlocked}`, `light-blue`, line2)
	customizeEachWord(`)`, `white`, line2)
	blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.cataclysm)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.cataclysm)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
cataclysm.addToPlayer()

const dualStrike = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Dual Strike',
	refName: 'dualStrike',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 8000,
	cooldown: 8000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 1,
	weaponTypesUsed: ['oneHanded', 'daggers'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.75 }
		if (this.level == 2) { levelModifier = 2.25 }
		if (this.level == 3) { levelModifier = 2.75 }
		if (this.level == 4) { levelModifier = 3.25 }
		if (this.level == 5) { levelModifier = 3.75 }
		if (this.level == 6) { levelModifier = 4.25 }
		if (this.level == 7) { levelModifier = 4.75 }
		if (this.level == 8) { levelModifier = 5.25 }
		if (this.level == 9) { levelModifier = 5.50 }
		if (this.level >= 10) { levelModifier = 5.75 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	buff: {
		name: 'Fury',
		refName: 'fury',
		duration: 20000,
		attackPower: 0,
		mods: {
			attackPower: 2000,
			weight: 10,
		},
		stacks: 1,
		maxStacks: function() {
			return 3
		}
	},
	// debuff: {
	// 	name: 'Fury',
	// 	refName: 'fury',
	// 	duration: 30000,
	// 	stacks: 0,
	// 	maxStacks: function() {
	// 		return 3
	// 	},
	// 	get bonusModifier() {
	// 		//50% bonus damage to regular attack at all levels
	// 		return 0.5
	// 	}
	// },
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You lunge forward, pluging your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[0].name} `, `${weapon[0].color}`, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[1].name} `, `${weapon[1].color}`, line1)
		customizeEachWord(`into the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You attempt a `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`attack on the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`, but your attack goes wide and you `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.dualStrike)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.dualStrike)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
dualStrike.addToPlayer()

const shred = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Shred',
	refName: 'shred',
	type: 'ability',
	color: 'warrior-color',
	cooldown: 10000,
	cooldownSet: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 1,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5 }
		if (this.level == 2) { levelModifier = 1.7 }
		if (this.level == 3) { levelModifier = 1.9 }
		if (this.level == 4) { levelModifier = 1.9 }
		if (this.level == 5) { levelModifier = 2.1 }
		if (this.level == 6) { levelModifier = 2.1 }
		if (this.level == 7) { levelModifier = 2.1 }
		if (this.level == 8) { levelModifier = 2.3 }
		if (this.level == 9) { levelModifier = 2.3 }
		if (this.level >= 10) { levelModifier = 2.5 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' Fury Strike BASE DAMAGE')
		console.log(baseAndLevelDamage, ' Fury Strike BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Fury',
		refName: 'fury',
		stacks: 0,
		duration: 20000,
		maxStacks: function() {
			return 3
		},
	},
	// debuff: {
	// 	name: 'Shred',
	// 	refName: 'shred',
	// 	modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
	// 	slashingArmor: -5,
	// 	piercingArmor: -5,
	// 	bluntArmor: -5,
	// 	stacks: 1,
	// 	duration: 20000,
	// 	maxStacks: function() {
	// 		return 5
	// 	},
	// },
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You aim your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[0].name} `, weapon[0].color, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[1].name} `, weapon[1].color, line1)
		customizeEachWord(`carefully, swinging at the weakest spots in the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(` armor!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},	
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You attempt to `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`, but your attack goes wide and you `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shred)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shred)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shred.addToPlayer()

const bladeBlitz = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Blade Blitz',
	refName: 'bladeBlitz',
	type: 'ability',
	color: 'warrior-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	numberOfSwings: function() {
		if (player?.buffs?.fury) {
			return player.buffs.fury.stacks
		} else {
			return 1
		}
	},
	resourceName: 'might',
	resourceCost: function() {
		return 3
	},
	weaponTypesUsed: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5 }
		if (this.level == 2) { levelModifier = 1.7 }
		if (this.level == 3) { levelModifier = 1.9 }
		if (this.level == 4) { levelModifier = 1.9 }
		if (this.level == 5) { levelModifier = 2.1 }
		if (this.level == 6) { levelModifier = 2.1 }
		if (this.level == 7) { levelModifier = 2.1 }
		if (this.level == 8) { levelModifier = 2.3 }
		if (this.level == 9) { levelModifier = 2.3 }
		if (this.level >= 10) { levelModifier = 2.5 }
		let baseAndLevelDamage = (baseDamage * levelModifier)
		let bleedBonusDamage = calculateBleedBonus(enemy, baseAndLevelDamage)
		let totalDamage = baseAndLevelDamage + bleedBonusDamage
		console.log(baseDamage, ' RIPSLASH BASE DAMAGE')
		console.log(baseAndLevelDamage, ' RIPSLASH BASE + LEVEL DAMAGE')
		console.log(bleedBonusDamage, ' BLEED BONUS DAMAGE (ONLY THE BLEED PERCENTAGE -- NOT ADDED TO ANY BASE DAMAGE)')
		console.log(totalDamage, ' TOTAL DAMAGE')
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You swing furiously with your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon[0].name} `, weapon[0].color, line1)
		customizeEachWord(`and `, 'warrior-color', line1)
		customizeEachWord(`${weapon[1].name} `, weapon[1].color, line1)
		customizeEachWord(`in a blur of blades, eviscerating the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},	
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`swing at the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`goes wide and you `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	numberOfHits: function(weapon1, weapon2) {
		let minimumHits
		let maximumHits
		let totalHits
		if (weapon1 != undefined && weapon2 != undefined) {
			minimumHits = 2
			maximumHits = 3 + player.bladeBlitz.level
		}
		 else if (weapon2 == undefined && weapon1 != undefined) {
			minimumHits = 1
			maximumHits = 2

		} else if (weapon1 == undefined && weapon2 != undefined) {
			minimumHits = 1
			maximumHits = 2
		}
		totalHits = randomNumberRange(minimumHits, maximumHits)
		quickMessage(`Minimum Hits: ${minimumHits}`)
		quickMessage(`Maximum Hits: ${maximumHits}`)
		quickMessage(`Number of Hits: ${totalHits}`)
		return totalHits
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.bladeBlitz)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.bladeBlitz)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
bladeBlitz.addToPlayer()

const valorStrike = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Valor Strike',
	refName: 'valorStrike',
	type: 'ability',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 1,
	weaponTypesUsed: ['shields', 'oneHanded'],
	valorBonus: function() {
		if (this.level == 1) {return 1.10}
		if (this.level == 2) {return 1.15}
		if (this.level == 3) {return 1.20}
		if (this.level == 4) {return 1.25}
		if (this.level == 5) {return 1.30}
		if (this.level == 6) {return 1.35}
		if (this.level == 7) {return 1.40}
		if (this.level == 8) {return 1.45}
		if (this.level == 9) {return 1.50}
		if (this.level >= 10) {return 1.55}
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight()
		let levelModifier
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.1}
		if (this.level == 3) { levelModifier = 1.2}
		if (this.level == 4) { levelModifier = 1.3}
		if (this.level == 5) { levelModifier = 1.4}
		if (this.level == 6) { levelModifier = 1.5}
		if (this.level == 7) { levelModifier = 1.6}
		if (this.level == 8) { levelModifier = 1.7}
		if (this.level == 9) { levelModifier = 1.8}
		if (this.level >= 10) { levelModifier = 1.9}
		let bonusModifier = this.valorBonus()
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage * bonusModifier
		return Math.ceil(totalDamage)
	},
	buff: {
		name: 'Valor',
		refName: 'valor',
		duration: 30000,
		stacks: 1,
		maxStacks: function() {
			return player.valorStrike.level + 5
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You manifest your Valor into your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon.name}`, weapon.color, line1)
		customizeEachWord(`, striking the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`with a vengence!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You swing your sword at the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`with your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`but `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.valorStrike)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.valorStrike)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
valorStrike.addToPlayer()

const shieldSlam = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Shield Slam',
	refName: 'shieldSlam',
	type: 'ability',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 2,
	numberOfTargets: function() {
		return this.level + 1
	},
	weaponTypesUsed: ['shields'],
	damage: function () {
		let baseAttackDamage = baseAttackDamageRight()
		let baseWeightDamage = baseWeightDamage()
		let baseDamage = baseAttackDamage + baseWeightDamage
		let levelModifier
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.25}
		if (this.level == 3) { levelModifier = 1.50}
		if (this.level == 4) { levelModifier = 1.75}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.25}
		if (this.level == 7) { levelModifier = 2.50}
		if (this.level == 8) { levelModifier = 2.75}
		if (this.level == 9) { levelModifier = 3.0}
		if (this.level >= 10) { levelModifier = 3.25}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Shield Slam',
		refName: 'shieldSlam',
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		get slashingArmor() {
			if (player.shieldSlam.level == 1) {return -5}
			if (player.shieldSlam.level == 2) {return -10}
			if (player.shieldSlam.level == 3) {return -15}
			if (player.shieldSlam.level == 4) {return -20}
			if (player.shieldSlam.level >= 5) {return -25}
		},
		get piercingArmor() {
			if (player.shieldSlam.level == 1) {return -5}
			if (player.shieldSlam.level == 2) {return -10}
			if (player.shieldSlam.level == 3) {return -15}
			if (player.shieldSlam.level == 4) {return -20}
			if (player.shieldSlam.level >= 5) {return -25}
		},
		get bluntArmor() {
			if (player.shieldSlam.level == 1) {return -5}
			if (player.shieldSlam.level == 2) {return -10}
			if (player.shieldSlam.level == 3) {return -15}
			if (player.shieldSlam.level == 4) {return -20}
			if (player.shieldSlam.level >= 5) {return -25}
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, shield, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${shield.name} `, shield.color, line1)
		customizeEachWord(`slams into the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1 )
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorText2: function(shield) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You swing your shield in a wide arc, slamming your `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${shield.name} `, shield.color, line1)
		customizeEachWord(`into the enemy!`, `warrior-ability-text-color`, line1)

	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You swing your shield in a wide arc at the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shieldSlam)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shieldSlam)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Shield Slam deals damage and lowers the armor of all penetration types of the enemy. The number of targets hit is equal to this skill's level. Shield Slam gains bonus damage based on your weight and armor.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shieldSlam.addToPlayer()

const boomingMight = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Booming Might',
	refName: 'boomingMight',
	type: 'ability',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 2,
	resourceName: 'might',
	resourceCost: 3,
	weaponTypesUsed: ['oneHanded', 'shields'],
	buff: {
		name: 'Valor',
		refName: 'valor',
		duration: 30000,
		stacks: 0,
		maxStacks: function() {
			return player.valorStrike.level + 5
		},
		type: 'debuff',
	},
	damage: function () {
		let baseAttackDamage = baseAttackDamageRight()
		let weightDamage = baseWeightDamage()
		let baseDamage = baseAttackDamage + weightDamage
		let levelModifier
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.25}
		if (this.level == 3) { levelModifier = 1.50}
		if (this.level == 4) { levelModifier = 1.75}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.25}
		if (this.level == 7) { levelModifier = 2.50}
		if (this.level == 8) { levelModifier = 2.75}
		if (this.level == 9) { levelModifier = 3.0}
		if (this.level >= 10) { levelModifier = 3.25}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage 
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		blankSpace()
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You hurl a shockwave of `, `warrior-ability-text-color`, line1)
		customizeEachWord(`Might `, `warrior-color`, line1)
		customizeEachWord(`, blasting the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorText2: function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`Throwing back your arms with a mighty yell, you unleash a `, `warrior-ability-text-color`, line2)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`!`, `warrior-ability-text-color`, line2)
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`The shockwave goes hurling toward the `, `warrior-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, `warrior-ability-text-color`, line1)
		customizeEachWord(`misses`, 'red', line1)
		customizeEachWord(`!`, `warrior-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	color: 'warrior-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.boomingMight)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.boomingMight)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
boomingMight.addToPlayer()

//AMBUSH ADDITIONAL EFFECTS IDEAS
//To supplement burst damage/burst effectiveness, could add a debuff to enemy that reduce's accuracy
const ambush = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Ambush',
	refName: 'ambush',
	cooldown: 5000,
	cooldownSet: 5000,
	resourceName: 'adrenaline',
	resourceCost: 20,
	weaponTypesUsed: ['daggers'],
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 2.0,
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelModifier
		if (this.level == 1) { levelModifier = 2.0}
		if (this.level == 2) { levelModifier = 2.3}
		if (this.level == 3) { levelModifier = 2.6}
		if (this.level == 4) { levelModifier = 2.9}
		if (this.level == 5) { levelModifier = 3.2}
		if (this.level == 6) { levelModifier = 3.5}
		if (this.level == 7) { levelModifier = 3.8}
		if (this.level == 8) { levelModifier = 4.1}
		if (this.level == 9) { levelModifier = 4.4}
		if (this.level >= 10) { levelModifier = 4.7}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Ambush while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap from the shadows, `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`ambushing the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`, plunging your `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon[0].name} `, weapon[0].color, line1)
		customizeEachWord(`deep into its spine!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		ambushAudioArray[randomNumberRange(0, 2)].play()
	},
	flavorTextSpecial: function() {
		let line1 = lineFunc()
		customizeEachWord(`The kill was so deft, you were completely unheard, and you immediately leap back into the shadows.`, 'grey', line1)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`In an attempt to `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, you miscalculate and `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
		daggerMissArray1[randomNumberRange(0, 4)].play()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.ambush)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.ambush)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
ambush.addToPlayer()

const backstab = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Backstab',
	refName: 'backstab',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 10,
	weaponTypesUsed: ['daggers'],
	rightWeaponTypes: ['daggers'],
	leftWeaponTypes: ['daggers'],
	damage: function () {
		let baseDamage = baseAttackDamageRight()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.5}
		if (this.level == 2) { levelModifier = 2.0}
		if (this.level == 3) { levelModifier = 2.5}
		if (this.level == 4) { levelModifier = 3.0}
		if (this.level == 5) { levelModifier = 3.5}
		if (this.level == 6) { levelModifier = 4.0}
		if (this.level == 7) { levelModifier = 4.5}
		if (this.level == 8) { levelModifier = 5.0}
		if (this.level == 9) { levelModifier = 5.5}
		if (this.level >= 10) { levelModifier = 6.0}
		let baseAndLevelDamage = baseDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform backstab while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	debuff: {
		name: 'Sinister Mark',
		refName: 'sinisterMark',
		stacks: 0,
		modifiedStats: ['slashingArmor', 'piercingArmor', 'bluntArmor'],
		maxLevel: 10,
		get slashingArmor() {
			if (player.sinisterMark.level == 1) {return -2}
			if (player.sinisterMark.level == 2) {return -4}
			if (player.sinisterMark.level == 3) {return -6}
			if (player.sinisterMark.level == 4) {return -8}
			if (player.sinisterMark.level == 5) {return -10}
			if (player.sinisterMark.level == 6) {return -12}
			if (player.sinisterMark.level == 7) {return -14}
			if (player.sinisterMark.level == 8) {return -16}
			if (player.sinisterMark.level == 9) {return -18}
			if (player.sinisterMark.level >= 10) {return -20}
			else {return 0}
		},
		get piercingArmor() {
			if (player.sinisterMark.level == 1) {return -2}
			if (player.sinisterMark.level == 2) {return -4}
			if (player.sinisterMark.level == 3) {return -6}
			if (player.sinisterMark.level == 4) {return -8}
			if (player.sinisterMark.level == 5) {return -10}
			if (player.sinisterMark.level == 6) {return -12}
			if (player.sinisterMark.level == 7) {return -14}
			if (player.sinisterMark.level == 8) {return -16}
			if (player.sinisterMark.level == 9) {return -18}
			if (player.sinisterMark.level >= 10) {return -20}
			else {return 0}
		},		
		get bluntArmor() {
			if (player.sinisterMark.level == 1) {return -2}
			if (player.sinisterMark.level == 2) {return -4}
			if (player.sinisterMark.level == 3) {return -6}
			if (player.sinisterMark.level == 4) {return -8}
			if (player.sinisterMark.level == 5) {return -10}
			if (player.sinisterMark.level == 6) {return -12}
			if (player.sinisterMark.level == 7) {return -14}
			if (player.sinisterMark.level == 8) {return -16}
			if (player.sinisterMark.level == 9) {return -18}
			if (player.sinisterMark.level >= 10) {return -20}
			else {return 0}
		},		
		maxStacks: function() {
			return player.backstab.level + 1
		},
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slip behind the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and sink your `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		backstabAudioArray[randomNumberRange(0, 2)].play()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
		daggerMissArray1[randomNumberRange(0, 4)].play()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.backstab)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.backstab)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Backstab deals single target damage based on your right hand weapon. It also applies a Sinister Mark to the target lowering its slashing, piercing, and blunt armor types by a small amount. This effect stacks to an amount equal to Backstab's level + 1.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
backstab.addToPlayer()

const guillotine = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Guillotine',
	refName: 'guillotine',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 10,
	weaponTypesUsed: ['daggers'],
	rightWeaponTypes: ['daggers'],
	leftWeaponTypes: ['daggers'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let bonusEnemyMissingHealthModifier = ((enemy.maxHealth - enemy.health) / enemy.maxHealth) + 1
		let baseDamageAndBonusDamage = baseDamage * bonusEnemyMissingHealthModifier
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.25}
		if (this.level == 3) { levelModifier = 1.50}
		if (this.level == 4) { levelModifier = 1.75}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.25}
		if (this.level == 7) { levelModifier = 2.50}
		if (this.level == 8) { levelModifier = 2.75}
		if (this.level == 9) { levelModifier = 3.25}
		if (this.level >= 10) { levelModifier = 3.5}
		let baseAndLevelDamage = baseDamageAndBonusDamage * levelModifier
		let totalDamage = baseAndLevelDamage
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Guillotine while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You blink forward at the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`slashing with your `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`across its throat!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
		guillotineAudioArray[randomNumberRange(0, 2)].play()
	},
	flavorTextAdrenalineGain: function() {
		let line1 = lineFunc()
		customizeEachWord(`Guillotine `, this.color, line1)
		customizeEachWord(`consumes the Sinister Marks on the target before it dies granting you Adrenaline!`, `sinistral-ability-text-color`, line1)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You blink forward at the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
		daggerMissArray1[randomNumberRange(0, 4)].play()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.guillotine)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.guillotine)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
guillotine.addToPlayer()

const venomBlade = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Venom Blade',
	refName: 'venomBlade',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 15,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		//5 and 5 = 10
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft())
		let bonusModifier = enemy.debuffs?.poison ? (enemy.debuffs?.poison.stacks * 0.1) + 1 : 1
		console.log(bonusModifier, ' VENOMBLADE BONUS DAMAGE FROM ENEMY POISON STACKS')
		let bonusDamage = baseDamage * bonusModifier
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.05}
		if (this.level == 3) { levelModifier = 1.1}
		if (this.level == 4) { levelModifier = 1.15}
		if (this.level == 5) { levelModifier = 1.20}
		if (this.level == 6) { levelModifier = 1.25}
		if (this.level == 7) { levelModifier = 1.30}
		if (this.level == 8) { levelModifier = 1.35}
		if (this.level == 9) { levelModifier = 1.40}
		if (this.level >= 10) { levelModifier = 1.45}
		let totalDamage = (bonusDamage) * levelModifier
		return Math.ceil(totalDamage)
	},
	// debuff: {
	// 	name: 'Poison',
	// 	refName: 'poison',
	// 	stacks: 0,
	// 	damage: function(swingObject) {
	// 		return 0
	// 	},
	// 	maxStacks: function() {
	// 		return 5
	// 	},
	// },
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You lacerate the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`with your venom coated `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You swing your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`at the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to lacerate it with `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.venomBlade)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.venomBlade)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
venomBlade.addToPlayer()

const contagion = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Contagion',
	refName: 'contagion',
	cooldown: 2000,
	cooldownSet: 2000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 5,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.0}
		if (this.level == 2) { levelModifier = 1.2}
		if (this.level == 3) { levelModifier = 1.4}
		if (this.level == 4) { levelModifier = 1.6}
		if (this.level == 5) { levelModifier = 1.8}
		if (this.level == 6) { levelModifier = 2.0}
		if (this.level == 7) { levelModifier = 2.2}
		if (this.level == 8) { levelModifier = 2.4}
		if (this.level == 9) { levelModifier = 2.6}
		if (this.level >= 10) { levelModifier = 2.8}
		let totalDamage = baseDamage * levelModifier
		return Math.ceil(totalDamage)
	},
	buff: {
		name: 'Poison',
		refName: 'poison',
		resistType: 'poisonResist',
		penType: 'poisonPen',
		duration: 30000,
		stacks: 0,
		damage: function(enemy) {
			quickMessage(`Contagion.buff.damage is being triggered`)
			let totalDamage = baseAttackDamageRight() + 100
			if (enemy.debuffs) {
				if (enemy.debuffs.shadowMark) {
					let stacks = enemy.debuffs.shadowMark.stacks
					totalDamage = totalDamage * stacks
				}
			}
			return totalDamage
		},
		maxStacks: function() {
			return 20
		},
		flavorText: function(enemy, damage) {
			let line1 = lineFunc()
			customizeEachWord(`You hit for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`poison damage.`, 'poison', line1)
		},
		type: 'mark',
		color: 'poison',
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Contagion while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You stab the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`with your off-hand `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`injecting it with `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`!`, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, ) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You stab at the `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to infect it with `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`, but you `, 'sinistral-ability-text-color', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'sinistral-ability-text-color', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.contagion)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.contagion)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
contagion.addToPlayer()

const bane = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Bane',
	refName: 'bane',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy) {
		let poisonStacks = enemy.debuffs?.poison?.stacks ? (enemy.debuffs.poison.stacks * 0.1) + 1 : 0
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft())
		let baseAndBonusDamage = baseDamage * poisonStacks
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.25}
		if (this.level == 2) { levelModifier = 1.75}
		if (this.level == 3) { levelModifier = 2.25}
		if (this.level == 4) { levelModifier = 2.75}
		if (this.level == 5) { levelModifier = 3.25}
		if (this.level == 6) { levelModifier = 3.5}
		if (this.level == 7) { levelModifier = 2.8}
		if (this.level == 8) { levelModifier = 3.1}
		if (this.level == 9) { levelModifier = 3.4}
		if (this.level >= 10) { levelModifier = 3.7}
		//Percent Bonus Damage currently set to 20% bonus damage per stack
		let totalDamage = baseAndBonusDamage * levelModifier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap onto the back of the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`sinking your `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back! Your blade siphons the poison from the enemy, draining its life force!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You leap at the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to strike it with `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name}`, this.color, line1)
		customizeEachWord(`, but you narrowly `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.bane)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.bane)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
bane.addToPlayer()

const shadowDaggers = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Shadow Daggers',
	refName: 'shadowDaggers',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	numberOfHits: function() {
		return 2 + this.level
	},
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let levelModifier = 1
		if (this.level == 1) { levelModifier = 1.2}
		if (this.level == 2) { levelModifier = 1.4}
		if (this.level == 3) { levelModifier = 1.6}
		if (this.level == 4) { levelModifier = 1.8}
		if (this.level == 5) { levelModifier = 2.0}
		if (this.level == 6) { levelModifier = 2.2}
		if (this.level == 7) { levelModifier = 2.4}
		if (this.level == 8) { levelModifier = 2.6}
		if (this.level == 9) { levelModifier = 2.8}
		if (this.level >= 10) { levelModifier = 3.0}
		//Percent Bonus Damage currently set to 20% bonus damage per stack
		let totalDamage = baseDamage * levelModifier
		return Math.ceil(totalDamage)	
	},
	debuff: {

	}
		// {
		// 	name: 'Reduced Accuracy',
		// 	refName: 'reducedAccuracy',
		// 	modifiedStats: ['accuracy'],
		// 	accuracy: -7,
		// 	duration: 20000,
		// 	stacks: 0,
		// 	maxStacks: function() {
		// 		return player.shadowDaggers.level
		// 	},
		// },
		// {
		// 	name: 'Reduced Defense',
		// 	refName: 'reducedDefense',
		// 	modifiedStats: ['slashingArmor'],
		// 	slashingArmor: -10,
		// 	duration: 20000,
		// 	stacks: 0,
		// 	maxStacks: function() {
		// 		return player.shadowDaggers.level
		// 	},
		// },
		// {
		// 	name: 'Reduced Dodge',
		// 	refName: 'reducedDodge',
		// 	modifiedStats: ['dodge'],
		// 	dodge: -10,
		// 	duration: 20000,
		// 	stacks: 0,
		// 	maxStacks: function() {
		// 		return player.shadowDaggers.level
		// 	},
		// }
	,
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked, index) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let tellPlayerWhatDebuffGotApplied = ['accuracy', 'dodge', 'armor']
		blankSpace()
		customizeEachWord(`You throw a dagger at the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`hitting it and reducing its ${tellPlayerWhatDebuffGotApplied[index]}!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You throw a `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`Shadow Dagger `, this.color, line1)
		customizeEachWord(`at the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`but `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowDaggers)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowDaggers)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shadowDaggers.addToPlayer()


const shadowNova = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Shadow Nova',
	refName: 'shadowNova',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let bonusDamageModifier = 1
		if (player?.buffs?.shadowbane) {
			if (player.buffs.shadowbane.stacks <= 1) {bonusDamageModifier = 1.0}
			if (player.buffs.shadowbane.stacks == 2) {bonusDamageModifier = 1.1}
			if (player.buffs.shadowbane.stacks == 3) {bonusDamageModifier = 1.25}
			if (player.buffs.shadowbane.stacks == 4) {bonusDamageModifier = 1.45}
			if (player.buffs.shadowbane.stacks == 5) {bonusDamageModifier = 1.70}
			if (player.buffs.shadowbane.stacks == 6) {bonusDamageModifier = 2.0}
			if (player.buffs.shadowbane.stacks == 7) {bonusDamageModifier = 2.35}
			if (player.buffs.shadowbane.stacks == 8) {bonusDamageModifier = 2.75}
			if (player.buffs.shadowbane.stacks == 9) {bonusDamageModifier = 3.25}
			if (player.buffs.shadowbane.stacks >= 10) {bonusDamageModifier = 4.0}
			console.log(bonusDamageModifier, ' damage modifier based on stacks')
		}
		let totalDamage = baseDamage * bonusDamageModifier
		return Math.ceil(totalDamage)
	},
	regularDamage: function(enemy) {
		//base regular damage is combined weapon damage
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let totalDamage = 0
		//Calculate damage for shadowsurge
		let bonusDamageMod = enemy.debuffs?.shadowMark?.stacks ? enemy.debuffs.shadowMark.stacks : 0
		let bonusDamageTotal = (baseDamage * 1.20) * bonusDamageMod
		totalDamage = baseDamage + bonusDamageTotal
		return Math.ceil(totalDamage)
	}, 
	buff: {
		name: 'Shadowbane',
		refName: 'shadowbane',
		duration: 30000,
		stacks: 0,
		dodge: 10,
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You strike the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`with both daggers, releasing its stored energy and blasting it with `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			customizeEachWord(`!`, `sinistral-ability-text-color` , line1)
			customizeEachWord(`${this.name} `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`shadow `, 'shadow', line2)
			customizeEachWord(`damage.`, `green`, line2)
			customizeEachWord(` (Enemy resists `, `white`, line2)
			customizeEachWord(`${damageBlocked}`, `light-blue`, line2)
			customizeEachWord(`)`, `white`, line2)
			blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, doesPlayerShadowStep) {
		let line1 = lineFunc()
			blankSpace()
			customizeEachWord(`You dive at the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`with your daggers `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`but `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`miss`, 'red', line1)
			customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
			blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowNova)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowNova)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shadowNova.addToPlayer()

const catalyst = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Catalyst',
	refName: 'catalyst',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	multiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 9,
	sequence: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	duration: 10000,
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let penetrationType = calculatePenetrationRoll()
		let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
		// damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
		// damageBlocked = baseDamage - damageAfterArmor
		let quickJabLevelMultiplier
		let colossusPunchLevelMultiplier
		let gigasUppercutLevelMultiplier
		let atmaShockLevelMultiplier
		let quickJabDebuff = {
			name: `Quick Jab's Blind and Hinderance`,
			refName: 'quickJab',
			modifiedStats: ['dodge', 'accuracy'],
			duration: 15000,
			dodge: -5,
			accuracy: -5,
		}

		let colossusPunchDebuff = {
			name: 'Colossus Punch: Blunt Armor Debuff',
			refName: 'colossusPunchDebuff',
			modifiedStats: ['bluntArmor'],
			duration: 15000,
			bluntArmor: -5
		}
		//////////////////////////////////////////////////////////////////////////
		const multipliers = [
			{ quickJab: 1.1, colossusPunch: 1.3, gigasUppercut: 1.5, atmaShock: 1.75, quickJabDodgeDebuff: -5, quickJabAccuracyDebuff: -5, colossusPunchDebuff: -2 },
			{ quickJab: 1.2, colossusPunch: 1.4, gigasUppercut: 1.6, atmaShock: 1.85, quickJabDodgeDebuff: -8, quickJabAccuracyDebuff: -8, colossusPunchDebuff: -5 },
			{ quickJab: 1.3, colossusPunch: 1.5, gigasUppercut: 1.7, atmaShock: 1.95, quickJabDodgeDebuff: -12, quickJabAccuracyDebuff: -12, colossusPunchDebuff: -7 },
			{ quickJab: 1.4, colossusPunch: 1.6, gigasUppercut: 1.8, atmaShock: 2.05, quickJabDodgeDebuff: -16, quickJabAccuracyDebuff: -16, colossusPunchDebuff: -10 },
			{ quickJab: 1.5, colossusPunch: 1.7, gigasUppercut: 1.9, atmaShock: 2.15, quickJabDodgeDebuff: -20, quickJabAccuracyDebuff: -20, colossusPunchDebuff: -12 },
			{ quickJab: 1.6, colossusPunch: 1.8, gigasUppercut: 2.0, atmaShock: 2.25, quickJabDodgeDebuff: -25, quickJabAccuracyDebuff: -25, colossusPunchDebuff: -15 },
			{ quickJab: 1.7, colossusPunch: 1.9, gigasUppercut: 2.1, atmaShock: 2.35, quickJabDodgeDebuff: -30, quickJabAccuracyDebuff: -30, colossusPunchDebuff: -17 },
			{ quickJab: 1.8, colossusPunch: 2.0, gigasUppercut: 2.2, atmaShock: 2.45, quickJabDodgeDebuff: -35, quickJabAccuracyDebuff: -35, colossusPunchDebuff: -20 },
			{ quickJab: 1.9, colossusPunch: 2.1, gigasUppercut: 2.3, atmaShock: 2.55, quickJabDodgeDebuff: -40, quickJabAccuracyDebuff: -40, colossusPunchDebuff: -22 },
			{ quickJab: 2.0, colossusPunch: 2.2, gigasUppercut: 2.4, atmaShock: 2.1, quickJabDodgeDebuff: -50, quickJabAccuracyDebuff: -50, colossusPunchDebuff: -25 }
		];

		// Determine the player's level (capped at 10)
		const level = Math.min(player.catalyst.level, 10) - 1;
		
		// Set the multipliers from the lookup table
		quickJabLevelMultiplier = multipliers[level].quickJab;
		colossusPunchLevelMultiplier = multipliers[level].colossusPunch;
		gigasUppercutLevelMultiplier = multipliers[level].gigasUppercut;
		atmaShockLevelMultiplier = multipliers[level].atmaShock;
		quickJabDebuff.dodge = multipliers[level].quickJabDodgeDebuff
		quickJabDebuff.accuracy = multipliers[level].quickJabAccuracyDebuff
		colossusPunchDebuff.bluntArmor = multipliers[level].colossusPunchDebuff
		console.log(quickJabDebuff)
		console.log(colossusPunchDebuff)
/////////////////////////////////////////////////////////////////////////////
		let quickJabBaseDamage = Math.ceil(baseDamage * quickJabLevelMultiplier)
		let quickJabDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, quickJabBaseDamage, penetrationType)
		let quickJabDamageBlocked = quickJabBaseDamage - quickJabDamageAfterMitigation
		console.log(quickJabBaseDamage)
		console.log(quickJabDamageAfterMitigation)
		console.log(quickJabDamageBlocked)

		let colossusPunchBaseDamage = Math.ceil(baseDamage * colossusPunchLevelMultiplier)
		let colossusPunchDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, colossusPunchBaseDamage, penetrationType)
		let colossusPunchDamageBlocked = colossusPunchBaseDamage - colossusPunchDamageAfterMitigation

		let gigasUppercutBaseDamage = Math.ceil(baseDamage * gigasUppercutLevelMultiplier)
		let gigasUppercutDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, gigasUppercutBaseDamage, penetrationType)
		let gigasUppercutDamageBlocked = gigasUppercutBaseDamage - gigasUppercutDamageAfterMitigation

		let atmaShockBaseDamage = Math.ceil(baseDamage * atmaShockLevelMultiplier)
		let atmaShockDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, atmaShockBaseDamage, penetrationType)
		let atmaShockDamageBlocked = atmaShockBaseDamage - atmaShockDamageAfterMitigation

		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		//single -> double strength -> 2 - 3 successive attacks -> Strong AOE
		let sequence = this.sequence
		let colossusPunch = player.colossusPunch
		let hydraStrike = player.hydraStrike
		let gigasUppercut = player.gigasUppercut
		let atmaShock = player.atmaShock



		if (sequence == 0 || sequence == 5) {
			this.sequence = 1
			player.sequence = 1
			blankSpace()
			customizeEachWord(`You land a stiff jab on the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`! `, `monk-ability-text-color`, line1)
			customizeEachWord(`You knock it off balance lowering its dodge and accuracy!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Quick Jab `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${quickJabDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${quickJabDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, quickJabDamageAfterMitigation)
			applyDebuff(enemy, quickJabDebuff)
		} 
		else if (sequence == 1 && colossusPunch.level > 0) {
			this.sequence = 2
			player.sequence = 2
			customizeEachWord(`You follow up with a `, `monk-ability-text-color`, line1)
			customizeEachWord(`Colossus Punch`, `monk-ability-text-color`, line1)
			customizeEachWord(`, smashing into the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`and lowering its armor!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Colossus Punch `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${colossusPunchDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${colossusPunchDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, colossusPunchDamageAfterMitigation)
			applyDebuff(enemy, colossusPunchDebuff)
		}
		else if (sequence == 2 && hydraStrike.level > 0) {
			this.sequence = 3
			player.sequence = 3
			for (let i = 0; i < 3; i++) {
				let hydraStrikeBaseDamage = Math.ceil((baseAttackDamageLeft() + baseAttackDamageRight()) * 1.5)
				let hydraStrikeDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, hydraStrikeBaseDamage, penetrationType)
				let hydraStrikeBlockedDamage = hydraStrikeBaseDamage - hydraStrikeDamageAfterMitigation	
				if (enemy.health > 0) {
					let line1 = lineFunc()
					let line2 = lineFunc()
					let line3 = lineFunc()
					customizeEachWord(`You punch with blinding speed, pummeling the `, `monk-ability-text-color`, line1)
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`with `, `monk-ability-text-color`, line1)
					customizeEachWord(`Hydra Strike`, `monk-ability-text-color`, line1)
					customizeEachWord(`!`, `monk-ability-text-color`, line1)
					customizeEachWord(`Hydra Strike `, this.color, line2)
					customizeEachWord(`hits for `, 'green', line2)
					customizeEachWord(`${hydraStrikeDamageAfterMitigation} `, 'light-blue', line2)
					customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
					customizeEachWord(`damage. `, 'green', line2)
					customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
					customizeEachWord(`${hydraStrikeBlockedDamage}`, 'light-blue', line2)
					customizeEachWord(`)`, 'white', line2)
					blankSpace()
					applyDamageToEnemy(enemy, hydraStrikeDamageAfterMitigation)
				}
			}
		}
		else if (sequence == 3 && gigasUppercut.level > 0) {
			//this.sequence = 0 stops Atma Shock from happening
			this.sequence = 4
			player.sequence = 4
			customizeEachWord(`You dip down and blink forward with a `, `monk-ability-text-color`, line1)
			customizeEachWord(`Gigas Uppercut `, `monk-ability-text-color`, line1)
			customizeEachWord(`pulverizing the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Gigas Uppercut `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${gigasUppercutDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${gigasUppercutDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, gigasUppercutDamageAfterMitigation)
		}
		else if (sequence == 4 && atmaShock.level > 0) {
			let getEnemiesInCombat = getAllEnemiesInCombat()
			this.sequence = 5
			player.sequence = 5
			getEnemiesInCombat.forEach(enemy => {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let line3 = lineFunc()
				customizeEachWord(`You unleash Atma Shock, smashing both fists into the ground sending a wave of energy at the `, this.color, line1)
				customizeEachWord(`${enemy.name}`, enemy.color, line1)
				customizeEachWord(`!`, this.color, line1)
				customizeEachWord(`Atma Shock `, this.color, line2)
				customizeEachWord(`hits for `, 'green', line2)
				customizeEachWord(`${atmaShockDamageAfterMitigation} `, 'light-blue', line2)
				customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
				customizeEachWord(`damage. `, 'green', line2)
				customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
				customizeEachWord(`${atmaShockDamageBlocked}`, 'light-blue', line2)
				customizeEachWord(`)`, 'white', line2)
				blankSpace()
				applyDamageToEnemy(enemy, atmaShockDamageAfterMitigation)
			})
		}
		else {
			this.sequence = 1
			player.sequence = 1
			blankSpace()
			customizeEachWord(`You land a stiff jab on the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`! `, `monk-ability-text-color`, line1)
			customizeEachWord(`You knock it off balance lowering its dodge and accuracy!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Quick Jab `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${quickJabDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${quickJabDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, quickJabDamageAfterMitigation)
			debuff = {
				name: `Quick Jab's Blind and Hinderance`,
				refName: 'quickJab',
				modifiedStats: ['dodge', 'accuracy'],
				duration: 15000,
				dodge: -5,
				accuracy: -5,
			}
			applyDebuff(enemy, debuff)
		}
		clearTimeout(catalystTimeout)
		catalystTimeout = setTimeout(() => {
			this.sequence = 0
		}, this.duration)
		// return totalDamage
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`swing your fist at the `, 'white', line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.catalyst)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.catalyst)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
catalyst.addToPlayer()
const tempest = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Tempest',
	refName: 'tempest',
	color: 'monk-color',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	multiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 9,
	sequence: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	duration: 2000,
	comboCollector:  {
		name: 'Combo Collector',
		refName: 'comboCollector',
		duration: 30000,
		stacks: 0,
		maxStacks: function() {
			return 5
		},
	},
	damage: function (enemy) {
		baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		penetrationType = calculatePenetrationRoll()
		penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
		damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
		damageBlocked = baseDamage - damageAfterArmor

		let meteorKickLevelMultiplier
		let behemothBashLevelMultiplier
		let flyingKneeLevelMultiplier
		let hurricaneKickLevelMultiplier
////////////////////////////////////////////////////////////////////////////////
		let behemothBlitzBuff = {
			name: `B.Blitz Buff`,
			refName: 'behemothBlitzBuff',
			duration: 3000,
			mods: {
				str: 10,
				dex: 10,
				agi: 10,
			},
			stacks: 1,
			maxStacks: function() {return 1}
		}

		let flyingKneeBuff = {
			name: 'Flying Knee Buff',
			refName: 'flyingKneeBuff',
			duration: 15000,
			mods: {
				slashingArmor: 0,
				piercingArmor: 0,
				bluntArmor: 0,
			},
			stacks: 1,
			maxStacks: function() {return 1}
		}

		let hurricaneKickBuff = {
			name: 'H Kick Buff',
			refName: 'hurricaneKickBuff',
			duration: 20000,
			mods: {
				accuracy: 0,
			},
			stacks: 1,
			maxStacks: function() {return 1}
		}

		let sommersaultKickBuff = {
			name: `SS Kick Buff`,
			refName: 'sommersaultKickBuff',
			duration: 20000,
			mods: {
				dodge: 0,
			},
			stacks: 1,
			maxStacks: function() {return 1}		
		}
		const multipliers = [
			{ meteorKick: 1.1, behemothBash: 1.3, flyingKnee: 1.5, hurricaneKick: 1.75, behemothBlitzBuff: 1, flyingKneeBuff: 2, hurricaneKickBuff: 3, sommersaultKickBuff: 3 },
			{ meteorKick: 1.2, behemothBash: 1.4, flyingKnee: 1.6, hurricaneKick: 1.85, behemothBlitzBuff: 2, flyingKneeBuff: 4, hurricaneKickBuff: 6, sommersaultKickBuff: 6  },
			{ meteorKick: 1.3, behemothBash: 1.5, flyingKnee: 1.7, hurricaneKick: 1.95, behemothBlitzBuff: 3, flyingKneeBuff: 6, hurricaneKickBuff: 9, sommersaultKickBuff: 9  },
			{ meteorKick: 1.4, behemothBash: 1.6, flyingKnee: 1.8, hurricaneKick: 2.05, behemothBlitzBuff: 4, flyingKneeBuff: 8, hurricaneKickBuff: 12, sommersaultKickBuff: 12  },
			{ meteorKick: 1.5, behemothBash: 1.7, flyingKnee: 1.9, hurricaneKick: 2.15, behemothBlitzBuff: 5, flyingKneeBuff: 10, hurricaneKickBuff: 15, sommersaultKickBuff: 15  },
			{ meteorKick: 1.6, behemothBash: 1.8, flyingKnee: 2.0, hurricaneKick: 2.25, behemothBlitzBuff: 6, flyingKneeBuff: 13, hurricaneKickBuff: 18, sommersaultKickBuff: 18  },
			{ meteorKick: 1.7, behemothBash: 1.9, flyingKnee: 2.1, hurricaneKick: 2.35, behemothBlitzBuff: 7, flyingKneeBuff: 16, hurricaneKickBuff: 21, sommersaultKickBuff: 21  },
			{ meteorKick: 1.8, behemothBash: 2.0, flyingKnee: 2.2, hurricaneKick: 2.45, behemothBlitzBuff: 8, flyingKneeBuff: 20, hurricaneKickBuff: 24, sommersaultKickBuff: 24  },
			{ meteorKick: 1.9, behemothBash: 2.1, flyingKnee: 2.3, hurricaneKick: 2.55, behemothBlitzBuff: 9, flyingKneeBuff: 24, hurricaneKickBuff: 27, sommersaultKickBuff: 27  },
			{ meteorKick: 2.0, behemothBash: 2.2, flyingKnee: 2.4, hurricaneKick: 2.1, behemothBlitzBuff: 10, flyingKneeBuff: 28, hurricaneKickBuff: 30, sommersaultKickBuff: 30  }
		];

		// Determine the player's level (capped at 10)
		const level = Math.min(player.catalyst.level, 10) - 1;
		
		// Set the multipliers from the lookup table
		meteorKickLevelMultiplier = multipliers[level].meteorKick;
		behemothBashLevelMultiplier = multipliers[level].behemothBash;
		flyingKneeLevelMultiplier = multipliers[level].flyingKnee;
		hurricaneKickLevelMultiplier = multipliers[level].hurricaneKick;

		behemothBlitzBuff.mods.str = multipliers[level].behemothBlitzBuff
		behemothBlitzBuff.mods.dex = multipliers[level].behemothBlitzBuff
		behemothBlitzBuff.mods.agi = multipliers[level].behemothBlitzBuff

		flyingKneeBuff.mods.slashingArmor = multipliers[level].flyingKneeBuff
		flyingKneeBuff.mods.piercingArmor = multipliers[level].flyingKneeBuff
		flyingKneeBuff.mods.bluntArmor = multipliers[level].flyingKneeBuff

		hurricaneKickBuff.mods.accuracy = multipliers[level].hurricaneKickBuff
		sommersaultKickBuff.mods.dodge = multipliers[level].sommersaultKickBuff
		///////////////////////////////////////////////////////////////////////////////////




		if (player.tempest.level == 1) {meteorKickLevelMultiplier = 1.1 
										behemothBashLevelMultiplier = 1.3
										flyingKneeLevelMultiplier  = 1.5
										hurricaneKickLevelMultiplier = 1.75	}		
		if (player.tempest.level == 2) {meteorKickLevelMultiplier = 1.2
										behemothBashLevelMultiplier = 1.4
										flyingKneeLevelMultiplier  = 1.6
										hurricaneKickLevelMultiplier = 1.85	}		
		if (player.tempest.level == 3) {meteorKickLevelMultiplier = 1.3 
										behemothBashLevelMultiplier = 1.5
										flyingKneeLevelMultiplier  = 1.7
										hurricaneKickLevelMultiplier = 1.95	}		
		if (player.tempest.level == 4) {meteorKickLevelMultiplier = 1.4 
										behemothBashLevelMultiplier = 1.6
										flyingKneeLevelMultiplier  = 1.8
										hurricaneKickLevelMultiplier = 2.05	}		
		if (player.tempest.level == 5) {meteorKickLevelMultiplier = 1.5 
										behemothBashLevelMultiplier = 1.7
										flyingKneeLevelMultiplier  = 1.9
										hurricaneKickLevelMultiplier = 2.15	}		
		if (player.tempest.level == 6) {meteorKickLevelMultiplier = 1.6 
										behemothBashLevelMultiplier = 1.8
										flyingKneeLevelMultiplier  = 2.0
										hurricaneKickLevelMultiplier = 2.25	}		
		if (player.tempest.level == 7) {meteorKickLevelMultiplier = 1.7 
										behemothBashLevelMultiplier = 1.9
										flyingKneeLevelMultiplier  = 2.1
										hurricaneKickLevelMultiplier = 2.35	}		
		if (player.tempest.level == 8) {meteorKickLevelMultiplier = 1.8 
										behemothBashLevelMultiplier = 2.0
										flyingKneeLevelMultiplier  = 2.2
										hurricaneKickLevelMultiplier = 2.45	}		
		if (player.tempest.level == 9) {meteorKickLevelMultiplier = 1.9
										behemothBashLevelMultiplier = 2.1
										flyingKneeLevelMultiplier  = 2.3
										hurricaneKickLevelMultiplier = 2.55	}		
		if (player.tempest.level >= 10) {meteorKickLevelMultiplier = 2.0 
										behemothBashLevelMultiplier = 2.2
										flyingKneeLevelMultiplier  = 2.4
										hurricaneKickLevelMultiplier = 2.1	}

		let bonusMeteorKickDamage = Math.ceil((((enemy.health / enemy.maxHealth) * -1) + 1).toFixed(2))
		let meteorKickBaseDamage = Math.ceil((baseDamage * bonusMeteorKickDamage) + baseDamage)
		let meteorKickDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, meteorKickBaseDamage, penetrationType)
		let meteorKickDamageBlocked = Math.ceil(meteorKickBaseDamage - meteorKickDamageAfterMitigation)

		let behemothBashBaseDamage = Math.ceil(baseDamage * behemothBashLevelMultiplier)
		let behemothBashDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, behemothBashBaseDamage, penetrationType)
		let behemothBashDamageBlocked = Math.ceil(behemothBashBaseDamage - behemothBashDamageAfterMitigation)
		console.log(behemothBashBaseDamage, ' base damage')
		console.log(behemothBashDamageAfterMitigation, ' damage after mitigation')
		console.log(behemothBashDamageBlocked, ' damage blocked')

		let flyingKneeBaseDamage = Math.ceil(baseDamage * flyingKneeLevelMultiplier)
		let flyingKneeDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, flyingKneeBaseDamage, penetrationType)
		let flyingKneeDamageBlocked = Math.ceil(flyingKneeBaseDamage - flyingKneeDamageAfterMitigation)

		let hurricaneKickBaseDamage = Math.ceil(baseDamage * hurricaneKickLevelMultiplier)
		let hurricaneKickDamageAfterMitigation = calculateAbilityDamageAgainstEnemyArmor(enemy, hurricaneKickBaseDamage, penetrationType)
		let hurricaneKickDamageBlocked = Math.ceil(hurricaneKickBaseDamage - hurricaneKickDamageAfterMitigation)
		
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let sequence = this.sequence
		switch(player.catalyst.sequence) {
			case 0:
			case 5:
			//ENEMY MISSING HEALTH BONUS DAMAGE FOR JUMP FLYING SIDE KICK
			blankSpace()
			customizeEachWord(`You leap at the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`crashing into it with Meteor Kick!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Meteor Kick `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${meteorKickDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${meteorKickDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, meteorKickDamageAfterMitigation)
			break
			case 1:
			blankSpace()
			customizeEachWord(`Focusing your energy to your legs, you deliver a Behemoth Blitz to the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`! `, `monk-ability-text-color`, line1)
			customizeEachWord(`You feel invigorated as you gain empowerment!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Behemoth `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${behemothBashDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${behemothBashDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, behemothBashDamageAfterMitigation)
			applyBuff(behemothBlitzBuff)
			applyBuff(player.tempest.comboCollector)

			break
			case 2: //strength buff
			applyBuff(flyingKneeBuff)
			blankSpace()
			customizeEachWord(`You lunge forward with a Flying Knee smashing into the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Flying Knee `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${flyingKneeDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${flyingKneeDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, flyingKneeDamageAfterMitigation)
			applyBuff(player.tempest.comboCollector)
			break
			case 3: //agility buff
				totalDamage = Math.ceil(baseDamage)
			applyBuff(hurricaneKickBuff)
			blankSpace()
			customizeEachWord(`You spin in a blurring whirl deliving a Hurricane Kick to the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Hurricane Kick `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${hurricaneKickDamageAfterMitigation} `, 'light-blue', line2)
			customizeEachWord(`${penetrationFlavorText} `, penetrationFlavorText, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${hurricaneKickDamageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
			applyDamageToEnemy(enemy, hurricaneKickDamageAfterMitigation)
			applyBuff(player.tempest.comboCollector)
			break
			case 4: //Armor Reduction on enemies
				totalDamage = Math.ceil(baseDamage)
				quickMessage(`Apply armor reduction to enemies applied`)
				let getEnemiesInCombat = getAllEnemiesInCombat()
				customizeEachWord(``, 'monk-color', line1)
				blankSpace()
				getEnemiesInCombat.forEach(enemy => {
					let line0 = lineFunc()
					let line1 = lineFunc()
					let line2 = lineFunc()
					let line3 = lineFunc()
					totalDamage = randomNumberRange(500, 750)
					customizeEachWord(`**`, 'white', line0)
					customizeEachWord(`SHOCKWAVE`, 'activate-skill', line0)
					customizeEachWord(`**`, 'white', line0)
					customizeEachWord(` [4]`, 'white', line0)
					customizeEachWord(`The shockwave blasts the `, 'monk-color', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`!`, 'monk-color', line1)
					customizeEachWord(`You hit for `, 'green', line2)
					customizeEachWord(`${totalDamage} `, 'light-blue', line2)
					customizeEachWord(`damage.`, 'green', line2)
					blankSpace()
					applyDamageToEnemy(enemy, totalDamage)
					applyBuff(player.tempest.comboCollector)
					applyBuff(sommersaultKickBuff)
				})
				break
		}
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	// flavorText: function(enemy, weapon, damage) {
	// 	let line1 = lineFunc()
	// 	let line2 = lineFunc()
	// 	customizeEachWord(`You slide behind the `, 'gray', line1)
	// 	customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
	// 	customizeEachWord(`and sink your `, 'gray', line1)
	// 	customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
	// 	customizeEachWord(`into its back!`, 'gray', line1)
	// 	customizeEachWord(`You hit for `, 'green', line2)
	// 	customizeEachWord(`${damage} `, 'light-blue', line2)
	// 	customizeEachWord(`damage.`, 'green', line2)
	// },
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.tempest)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.tempest)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
tempest.addToPlayer()

const colossusPunch = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Colossus Punch',
	refName: 'colossusPunch',
	color: 'monk-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.colossusPunch)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.colossusPunch)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
colossusPunch.addToPlayer()
const hydraStrike = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Hydra Strike',
	refName: 'hydraStrike',
	color: 'monk-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.hydraStrike)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.hydraStrike)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
hydraStrike.addToPlayer()
const gigasUppercut = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Gigas Uppercut',
	refName: 'gigasUppercut',
	color: 'monk-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.gigasUppercut)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.gigasUppercut)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
gigasUppercut.addToPlayer()
const atmaShock = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Atma Shock',
	refName: 'atmaShock',
	color: 'monk-color',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.atmaShock)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.atmaShock)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
atmaShock.addToPlayer()




const blazingFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Blazing Fist',
	refName: 'blazingFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'fire',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.blazingFist.level == 1) { levelMultiplier = 1.1}
		if (player.blazingFist.level == 2) { levelMultiplier = 1.2}
		if (player.blazingFist.level == 3) { levelMultiplier = 1.3}
		if (player.blazingFist.level == 4) { levelMultiplier = 1.4}
		if (player.blazingFist.level == 5) { levelMultiplier = 1.5}
		if (player.blazingFist.level == 6) { levelMultiplier = 1.6}
		if (player.blazingFist.level == 7) { levelMultiplier = 1.7}
		if (player.blazingFist.level == 8) { levelMultiplier = 1.8}
		if (player.blazingFist.level == 9) { levelMultiplier = 1.9}
		if (player.blazingFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'Blazing Fist',
		refName: 'blazingFist',
		duration: 15000,
		stacks: 0,
		maxStacks: function() {
			return player.blazingFist.level
		},
		type: 'seal',
		color: 'fire',
	},
	sealCombo: {
		name: 'Hydroplosion',
		refName: 'hydroplosion',
		type: 'seal combo',
		element: 'fire',
		color: 'fire',
		damage: function(enemy) {
			// let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
			let botDamage = player.mysticPower * player.blazingFist.botMultiplier
			let topDamage = player.mysticPower * player.blazingFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.blazingFist.level == 1) { levelMultiplier = 1.1}
			if (player.blazingFist.level == 2) { levelMultiplier = 1.2}
			if (player.blazingFist.level == 3) { levelMultiplier = 1.3}
			if (player.blazingFist.level == 4) { levelMultiplier = 1.4}
			if (player.blazingFist.level == 5) { levelMultiplier = 1.5}
			if (player.blazingFist.level == 6) { levelMultiplier = 1.6}
			if (player.blazingFist.level == 7) { levelMultiplier = 1.7}
			if (player.blazingFist.level == 8) { levelMultiplier = 1.8}
			if (player.blazingFist.level == 9) { levelMultiplier = 1.9}
			if (player.blazingFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the air around you into glowing orbs of fire around your hands. You dash forward, slamming them into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Blazing Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.blazingFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.blazingFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
blazingFist.addToPlayer()

const tidalFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Tidal Fist',
	refName: 'tidalFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'water',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.tidalFist.level == 1) { levelMultiplier = 1.1}
		if (player.tidalFist.level == 2) { levelMultiplier = 1.2}
		if (player.tidalFist.level == 3) { levelMultiplier = 1.3}
		if (player.tidalFist.level == 4) { levelMultiplier = 1.4}
		if (player.tidalFist.level == 5) { levelMultiplier = 1.5}
		if (player.tidalFist.level == 6) { levelMultiplier = 1.6}
		if (player.tidalFist.level == 7) { levelMultiplier = 1.7}
		if (player.tidalFist.level == 8) { levelMultiplier = 1.8}
		if (player.tidalFist.level == 9) { levelMultiplier = 1.9}
		if (player.tidalFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	debuff: {
		name: 'tidalFist',
		refName: 'tidalFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return player.tidalFist.level
		},
		type: 'seal',
		color: 'water',
	},
	sealCombo: {
		name: 'Hydroplosion',
		refName: 'hydroplosion',
		type: 'seal combo',
		element: 'water',
		color: 'water',
		damage: function(enemy) {
			let botDamage = player.mysticPower * player.tidalFist.botMultiplier
			let topDamage = player.mysticPower * player.tidalFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.tidalFist.level == 1) { levelMultiplier = 1.1}
			if (player.tidalFist.level == 2) { levelMultiplier = 1.2}
			if (player.tidalFist.level == 3) { levelMultiplier = 1.3}
			if (player.tidalFist.level == 4) { levelMultiplier = 1.4}
			if (player.tidalFist.level == 5) { levelMultiplier = 1.5}
			if (player.tidalFist.level == 6) { levelMultiplier = 1.6}
			if (player.tidalFist.level == 7) { levelMultiplier = 1.7}
			if (player.tidalFist.level == 8) { levelMultiplier = 1.8}
			if (player.tidalFist.level == 9) { levelMultiplier = 1.9}
			if (player.tidalFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the air around you into glowing orbs of water around your hands. You dash forward, slamming them into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Tidal Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.tidalFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.tidalFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
tidalFist.addToPlayer()
const quakeFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Quake Fist',
	refName: 'quakeFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'earth',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Quake Fist',
		refName: 'quakeFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'seal',
		color: 'earth',
	},
	sealCombo: {
		name: 'Molten Quake',
		refName: 'moltenQuake',
		type: 'seal combo',
		element: 'earth',
		color: 'earth',
		debuff: {
			name: 'Molten Quake',
			refName: 'moltenQuake',
			duration: 15000,
			stacks: 0,
			maxStacks: function() {
				return player.quakeFist.level
			},
			// type: 'seal',
			color: 'dark-red',
		},
		damage: function(enemy) {
			// let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
			let botDamage = player.mysticPower * player.quakeFist.botMultiplier
			let topDamage = player.mysticPower * player.quakeFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.quakeFist.level == 1) { levelMultiplier = 1.1}
			if (player.quakeFist.level == 2) { levelMultiplier = 1.2}
			if (player.quakeFist.level == 3) { levelMultiplier = 1.3}
			if (player.quakeFist.level == 4) { levelMultiplier = 1.4}
			if (player.quakeFist.level == 5) { levelMultiplier = 1.5}
			if (player.quakeFist.level == 6) { levelMultiplier = 1.6}
			if (player.quakeFist.level == 7) { levelMultiplier = 1.7}
			if (player.quakeFist.level == 8) { levelMultiplier = 1.8}
			if (player.quakeFist.level == 9) { levelMultiplier = 1.9}
			if (player.quakeFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.quakeFist.level == 1) { levelMultiplier = 1.1}
		if (player.quakeFist.level == 2) { levelMultiplier = 1.2}
		if (player.quakeFist.level == 3) { levelMultiplier = 1.3}
		if (player.quakeFist.level == 4) { levelMultiplier = 1.4}
		if (player.quakeFist.level == 5) { levelMultiplier = 1.5}
		if (player.quakeFist.level == 6) { levelMultiplier = 1.6}
		if (player.quakeFist.level == 7) { levelMultiplier = 1.7}
		if (player.quakeFist.level == 8) { levelMultiplier = 1.8}
		if (player.quakeFist.level == 9) { levelMultiplier = 1.9}
		if (player.quakeFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the earth, pulling particals from the ground to form around your hands. Dashing forward, you deliver a Quake Fist to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Quake Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.quakeFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.quakeFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
quakeFist.addToPlayer()
const lightningFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Lightning Fist',
	refName: 'lightningFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	element: 'lightning',
	color: 'yellow',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Lightning Fist',
		refName: 'lightningFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'seal',
		color: 'lightning',
	},
	sealCombo: {
		name: `Lightning Fist`,
		refName: 'lightningFist',
		type: 'seal combo',
		element: 'lightning',
		color: 'lightning',
		damage: function(enemy) {
			// let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
			let botDamage = player.mysticPower * player.lightningFist.botMultiplier
			let topDamage = player.mysticPower * player.lightningFist.topMultiplier
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let levelMultiplier
			if (player.lightningFist.level == 1) { levelMultiplier = 1.1}
			if (player.lightningFist.level == 2) { levelMultiplier = 1.2}
			if (player.lightningFist.level == 3) { levelMultiplier = 1.3}
			if (player.lightningFist.level == 4) { levelMultiplier = 1.4}
			if (player.lightningFist.level == 5) { levelMultiplier = 1.5}
			if (player.lightningFist.level == 6) { levelMultiplier = 1.6}
			if (player.lightningFist.level == 7) { levelMultiplier = 1.7}
			if (player.lightningFist.level == 8) { levelMultiplier = 1.8}
			if (player.lightningFist.level == 9) { levelMultiplier = 1.9}
			if (player.lightningFist.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamage * levelMultiplier
			return totalDamage		
		},
	},
	damage: function() {
		let baseDamage = ((baseAttackDamageRight() + baseAttackDamageLeft()) * 0.5) + player.mysticPower
		let levelMultiplier
		if (player.lightningFist.level == 1) { levelMultiplier = 1.1}
		if (player.lightningFist.level == 2) { levelMultiplier = 1.2}
		if (player.lightningFist.level == 3) { levelMultiplier = 1.3}
		if (player.lightningFist.level == 4) { levelMultiplier = 1.4}
		if (player.lightningFist.level == 5) { levelMultiplier = 1.5}
		if (player.lightningFist.level == 6) { levelMultiplier = 1.6}
		if (player.lightningFist.level == 7) { levelMultiplier = 1.7}
		if (player.lightningFist.level == 8) { levelMultiplier = 1.8}
		if (player.lightningFist.level == 9) { levelMultiplier = 1.9}
		if (player.lightningFist.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You transmute the air around you into lightning around your hands. Dashing forward, you deliver a Lightning Fist to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Lightning Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.lightningFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.lightningFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
lightningFist.addToPlayer()
const elementalTempest = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Elemental Tempest',
	refName: 'elementalTempest',
	cooldown: 1000,
	cooldownSet: 1000,
	color: 'monk-color',
	topMultiplier: 2.0,
	botMultiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	buff: {
		name: 'Lightning Fist',
		refName: 'lightningFist',
		duration: 500000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'seal',
		color: 'lightning',
	},
	damage: function() {
		let baseDamagePhysical = baseAttackDamageRight() + baseAttackDamageLeft()
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
		let baseDamage = baseDamagePhysical + baseDamageMystic
		let levelMultiplier
		if (player.elementalTempest.level == 1) { levelMultiplier = 1.1}
		if (player.elementalTempest.level == 2) { levelMultiplier = 1.2}
		if (player.elementalTempest.level == 3) { levelMultiplier = 1.3}
		if (player.elementalTempest.level == 4) { levelMultiplier = 1.4}
		if (player.elementalTempest.level == 5) { levelMultiplier = 1.5}
		if (player.elementalTempest.level == 6) { levelMultiplier = 1.6}
		if (player.elementalTempest.level == 7) { levelMultiplier = 1.7}
		if (player.elementalTempest.level == 8) { levelMultiplier = 1.8}
		if (player.elementalTempest.level == 9) { levelMultiplier = 1.9}
		if (player.elementalTempest.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	aquaVoltDamage: function() {
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	thunderBlazeDamage: function() {
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	hydroplosionDamage: function() {
		let mysticPowerBot = player.mysticPower * player.elementalTempest.botMultiplier
		let mysticPowerTop = player.mysticPower * player.elementalTempest.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You shape your hands, thrusting a double palm strike into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, `monk-color`, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextAquaVolt: function(enemy, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		blankSpace()
		customizeEachWord(`Elemental Tempest reacts with the energy from Aqua Volt!`, `monk-ability-text-color`, line1)
		customizeEachWord(`A torrent of water and electricity erupt from your palms, blasting the `, `monk-ability-text-color`, line2)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line2)
		customizeEachWord(`!`, `monk-ability-text-color`, line2)
		customizeEachWord(`${this.name} `, penetrationType, line3)
		customizeEachWord(`hits for `, 'green', line3)
		customizeEachWord(`${damage} `, 'light-blue', line3)
		customizeEachWord(`${penetrationType} `, penetrationType, line3)
		customizeEachWord(`damage. `, 'green', line3)
		customizeEachWord(`(Enemy resists `, 'white', line3)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line3)
		customizeEachWord(`)`, 'white', line3)
		blankSpace()
	},
	flavorTextThunderBlaze: function(enemy, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Fire and lightning explode from your palms engulfing every enemy in front of you, searing and electrocuting the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, penetrationType, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextHydroplosion: function(enemy, damage, penetrationType, damageBlocked) {
		quickMessage(`${penetrationType} - penetration type`)
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Water and fire combine into a swirling orb of elemental energy before bursting in a blinding explosion, blasting the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and nearby enemies!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, penetrationType, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextHydroplosionAdditionalTargets: function(enemy, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`The blast from Hydroplosion scorches the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, `lightning`, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You dash forward, attempting to land a Lightning Fist on the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.elementalTempest)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.elementalTempest)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
elementalTempest.addToPlayer()

const transcendence = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Transcendence',
	refName: 'transcendence',
	cooldown: 1000,
	cooldownSet: 1000,
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	hydroplosionFire:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		skillEnhanced: {
			name: 'cleave',
			get level() {
				return player.transcendence.level
			},
		},
		buff: true,
		seal: true,
		duration: 30000,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	hydroplosionWater:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 30000,
		color: 'water',
		element: 'water',
		resistType: 'waterResist',
		penType: 'waterPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	thunderBlazeFire:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 30000,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	thunderBlazeLightning:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'lightning',
		element: 'lightning',
		resistType: 'lightningResist',
		penType: 'lightningPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	aquaVoltWater:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'water',
		element: 'water',
		resistType: 'waterResist',
		penType: 'waterPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	aquaVoltLightning:  {
		name: 'Transcendence',
		refName: 'transcendence',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
			let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
			let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'lightning',
		element: 'lightning',
		resistType: 'lightningResist',
		penType: 'lightningPen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorTextAquaVolt: function(avatar) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You consume the energy of `, `monk-ability-text-color`, line1)
		customizeEachWord(`Aqua Volt`, `aquaVolt`, line1)
		customizeEachWord(`! Energy swirls around you, engulfing you with ${avatar}!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	flavorTextThunderBlaze: function(avatar) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You consume the energy of `, `monk-ability-text-color`, line1)
		customizeEachWord(`Thunder Blaze`, `thunderBlaze`, line1)
		customizeEachWord(`! Energy swirls around you, engulfing you with ${avatar}!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	flavorTextHydroplosion: function(avatar) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You consume the energy of `, `monk-ability-text-color`, line1)
		customizeEachWord(`Hydroplosion`, `hydroplosion`, line1)
		customizeEachWord(`! Energy swirls around you, engulfing you with ${avatar}!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.transcendence)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.transcendence)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
transcendence.addToPlayer()

const callOfWind = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Call Of Wind',
	refName: 'callOfWind',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	element: 'wind',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 5,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	resourceBonus: function() {
		if (this.level <= 1) {return 15}
		if (this.level == 2) {return 20}
		if (this.level == 3) {return 25}
		if (this.level == 4) {return 30}
		if (this.level == 5) {return 35}
		if (this.level == 6) {return 40}
		if (this.level == 7) {return 45}
		if (this.level >= 8) {return 50}
	},
	damageRanged: function(enemy) {
		let mysticPowerBot = player.mysticPower * player.transcendence.botMultiplier
		let mysticPowerTop = player.mysticPower * player.transcendence.topMultiplier
		let totalDamage = randomNumberRange(mysticPowerBot, mysticPowerTop)
		return Math.ceil(totalDamage)
	},
	damageCombat: function (enemy) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		return Math.ceil(baseDamage)
	},
	debuff: {
		name: 'Call Of Wind',
		refName: 'callOfWind',
		stacks: 0,
		damage: function(swingObject) {
			return 0
		},
		maxStacks: function() {
			return 1
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorTextRanged: function(enemy, damageAfterResist, element, damageResisted) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You fire an energy charged ball of `, 'monk-ability-text-color', line1)
		customizeEachWord(`wind `, 'wind', line1)
		customizeEachWord(`at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! `, 'monk-ability-text-color', line1)
		customizeEachWord(`After the impact, a swirling orb of `, 'monk-ability-text-color', line1)
		customizeEachWord(`wind `, 'wind', line1)
		customizeEachWord(`surrounds the enemy.`, 'monk-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
		customizeEachWord(`${element} `, element, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageResisted}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextCombat: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You command the wind surrounding the enemy to pull you in. You speed through the air at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`delivering to it a `, `monk-ability-text-color`, line1)
		customizeEachWord(`Flying Side-Kick`, this.color, line1)
		customizeEachWord(`!`, `white`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)		
		blankSpace()
	},
	flavorTextMissRanged: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You fire a ball of energy charged `, 'monk-ability-text-color', line1)
		customizeEachWord(`wind `, 'wind', line1)
		customizeEachWord(`at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `,  enemy.color, line1)
		customizeEachWord(`,but `, 'monk-ability-text-color', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'monk-ability-text-color', line1)
		blankSpace()
	},
	flavorTextMissCombat: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You fly toward the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name} `,  enemy.color, line1)
		customizeEachWord(`with a `, 'monk-ability-text-color', line1)
		customizeEachWord(`Flying Side-Kick`, this.color, line1)
		customizeEachWord(`, but `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'monk-ability-text-color', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.callOfWind)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.callOfWind)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
callOfWind.addToPlayer()
const knuckleBlitz = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Knuckle Blitz',
	refName: 'knuckleBlitz',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	multiplier: 1.5,
	resourceName: 'focus',
	resourceCost: 15,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function (enemy) {
		let baseDamage = (baseAttackDamageRight() + baseAttackDamageLeft()) * 0.75
		let levelMultiplier
		if (player.knuckleBlitz.level == 1) { levelMultiplier = 1.1}
		if (player.knuckleBlitz.level == 2) { levelMultiplier = 1.2}
		if (player.knuckleBlitz.level == 3) { levelMultiplier = 1.3}
		if (player.knuckleBlitz.level == 4) { levelMultiplier = 1.4}
		if (player.knuckleBlitz.level == 5) { levelMultiplier = 1.5}
		if (player.knuckleBlitz.level == 6) { levelMultiplier = 1.6}
		if (player.knuckleBlitz.level == 7) { levelMultiplier = 1.7}
		if (player.knuckleBlitz.level == 8) { levelMultiplier = 1.8}
		if (player.knuckleBlitz.level == 9) { levelMultiplier = 1.9}
		if (player.knuckleBlitz.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You launch a barrage of fists at the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, 'monk-color', line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)		
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Your `, 'monk-ability-text-color', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`flies just past the `, 'monk-ability-text-color', line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'monk-ability-text-color', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.knuckleBlitz)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.knuckleBlitz)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
knuckleBlitz.addToPlayer()
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////
////////////////////////////////// ELEMENTAL MONK 2ND COMBOS //////////////////////////////////////

const hydroplosionDebuff = {
	name: 'Hydroplosion',
	refName: 'hydroplosion',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'hydroplosion',
}
const moltenQuakeDebuff = {
	name: 'Molten Quake',
	refName: 'moltenQuakeDebuff',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'moltenQuake',
}
const earthTideDebuff = {
	name: 'Earth Tide',
	refName: 'earthTideDebuff',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'earthTide',
}
const thunderBlazeDebuff = {
	name: 'Thunder Blaze',
	refName: 'thunderBlaze',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'thunderBlaze',
}
const aquaVoltDebuff = {
	name: 'Aqua Volt',
	refName: 'aquaVolt',
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	// type: 'seal',
	color: 'aquaVolt',
}
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
/////////////////////////////////// TRANSCENDENCE BUFFS ////////////////////////////////////
const hydroplosionBuff = {
	name: 'Hydroplosion Transcendence',
	refName: 'hydroplosion',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'hydroplosion',
}
const moltenQuakeBuff = {
	name: 'Molten Quake Transcendence',
	refName: 'moltenQuakeDebuff',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'moltenQuake',
}
const earthTideBuff = {
	name: 'Earth Tide Transcendence',
	refName: 'earthTideDebuff',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'earthTide',
}
const thunderBlazeBuff = {
	name: 'Thunder Blaze Transcendence',
	refName: 'thunderBlaze',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'thunderBlaze',
}
const aquaVoltBuff = {
	name: 'Aqua Volt',
	refName: 'aquaVolt',
	transcendence: true,
	duration: 15000,
	stacks: 0,
	maxStacks: function() {
		return 1
	},
	color: 'aquaVolt',
}


const fireSeal = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Fire Seal',
	refName: 'fireSeal',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'seal',
	color: 'monk-color',
	elementalType: 'fire',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Fire Seal',
		refName: 'fireSeal',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.fireSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.fireSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.fireSeal.level == 1) { levelMultiplier = 1.25}
			if (player.fireSeal.level == 2) { levelMultiplier = 1.50}
			if (player.fireSeal.level == 3) { levelMultiplier = 1.75}
			if (player.fireSeal.level == 4) { levelMultiplier = 2.0}
			if (player.fireSeal.level == 5) { levelMultiplier = 2.25}
			if (player.fireSeal.level == 6) { levelMultiplier = 2.50}
			if (player.fireSeal.level == 7) { levelMultiplier = 2.75}
			if (player.fireSeal.level == 8) { levelMultiplier = 3.0}
			if (player.fireSeal.level == 9) { levelMultiplier = 3.25}
			if (player.fireSeal.level >= 10) { levelMultiplier = 3.5}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		duration: 30000,
		stacks: 0,
		numHitsToActivate: 5,
		additionalTargets: 2,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You break the Fire Seal on the enemy! Fire erupts from your fist on impact, scorching the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, 'fire', line1)
			customizeEachWord(`Fireseal Break `, `fire`, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
			customizeEachWord(`${element} `, element, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy resists `, 'white', line2)
			customizeEachWord(`${damageResisted}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
		flavorTextCleave: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`The explosion from your Fire Seal blasts the `, 'fire', line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, 'fire', line1)
			customizeEachWord(`Fireseal Breaker `, 'fire', line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
			customizeEachWord(`${element} `, element, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy resists `, 'white', line2)
			customizeEachWord(`${damageResisted}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
	},
	buff: {
		name: 'Fire Enchant',
		refName: 'fireEnchant',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.fireSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.fireSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.fireSeal.level == 1) { levelMultiplier = 1.1}
			if (player.fireSeal.level == 2) { levelMultiplier = 1.2}
			if (player.fireSeal.level == 3) { levelMultiplier = 1.3}
			if (player.fireSeal.level == 4) { levelMultiplier = 1.4}
			if (player.fireSeal.level == 5) { levelMultiplier = 1.5}
			if (player.fireSeal.level == 6) { levelMultiplier = 1.6}
			if (player.fireSeal.level == 7) { levelMultiplier = 1.7}
			if (player.fireSeal.level == 8) { levelMultiplier = 1.8}
			if (player.fireSeal.level == 9) { levelMultiplier = 1.9}
			if (player.fireSeal.level >= 10) { levelMultiplier = 2.0}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		type: 'enchantment',
		buff: true,
		seal: true,
		duration: 20000,
		color: 'fire',
		element: 'fire',
		resistType: 'fireResist',
		penType: 'firePen',
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You deal `, 'green', line1)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`${element} `, element, line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		}
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelMultiplier
		if (player.fireSeal.level == 1) { levelMultiplier = 1.1}
		if (player.fireSeal.level == 2) { levelMultiplier = 1.2}
		if (player.fireSeal.level == 3) { levelMultiplier = 1.3}
		if (player.fireSeal.level == 4) { levelMultiplier = 1.4}
		if (player.fireSeal.level == 5) { levelMultiplier = 1.5}
		if (player.fireSeal.level == 6) { levelMultiplier = 1.6}
		if (player.fireSeal.level == 7) { levelMultiplier = 1.7}
		if (player.fireSeal.level == 8) { levelMultiplier = 1.8}
		if (player.fireSeal.level == 9) { levelMultiplier = 1.9}
		if (player.fireSeal.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slam your palm into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! A glowing red mark is left behind on the enemy.`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.fireSeal)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.fireSeal)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
fireSeal.addToPlayer()
const waterSeal = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Water Seal',
	refName: 'waterSeal',
	cooldown: 5000,
	cooldownSet: 5000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Water Seal',
		refName: 'waterSeal',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.waterSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.waterSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.waterSeal.level == 1) { levelMultiplier = 1.25}
			if (player.waterSeal.level == 2) { levelMultiplier = 1.50}
			if (player.waterSeal.level == 3) { levelMultiplier = 1.75}
			if (player.waterSeal.level == 4) { levelMultiplier = 2.0}
			if (player.waterSeal.level == 5) { levelMultiplier = 2.25}
			if (player.waterSeal.level == 6) { levelMultiplier = 2.50}
			if (player.waterSeal.level == 7) { levelMultiplier = 2.75}
			if (player.waterSeal.level == 8) { levelMultiplier = 3.0}
			if (player.waterSeal.level == 9) { levelMultiplier = 3.25}
			if (player.waterSeal.level >= 10) { levelMultiplier = 3.5}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		duration: 30000,
		stacks: 0,
		numHitsToActivate: 5,
		type: '',
		color: 'water',
		element: 'water',
		resistType: 'waterResist',
		penType: 'waterPen',
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`You break the Water Seal on the enemy! Water erupts from your fist on impact, blasting the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Waterseal Break `, `water`, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line2)
			customizeEachWord(`${element} `, element, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy resists `, 'white', line2)
			customizeEachWord(`${damageResisted}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
	},
	buff: {
		name: 'Water Enchant',
		refName: 'waterEnchant',
		type: 'enchantment',
		buff: true,
		seal: true,
		mys: 1,
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		heal: function() {
			let mysticPowerBot = player.mysticPower * player.waterSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.waterSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.waterSeal.level == 1) { levelMultiplier = 1.25}
			if (player.waterSeal.level == 2) { levelMultiplier = 1.50}
			if (player.waterSeal.level == 3) { levelMultiplier = 1.75}
			if (player.waterSeal.level == 4) { levelMultiplier = 2.0}
			if (player.waterSeal.level == 5) { levelMultiplier = 2.25}
			if (player.waterSeal.level == 6) { levelMultiplier = 2.50}
			if (player.waterSeal.level == 7) { levelMultiplier = 2.75}
			if (player.waterSeal.level == 8) { levelMultiplier = 3.0}
			if (player.waterSeal.level == 9) { levelMultiplier = 3.25}
			if (player.waterSeal.level >= 10) { levelMultiplier = 3.5}
			let totalHeal = (baseDamageMystic * levelMultiplier) * 0.1
			return Math.ceil(totalHeal)	
		},
		duration: 20000,
		flavorText: function(enemy, heal) {
			let line1 = lineFunc()
			customizeEachWord(`You heal yourself for `, 'green', line1)
			customizeEachWord(`${heal}`, 'light-blue', line1)
			customizeEachWord(`health.`, 'green', line1)
		}
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelMultiplier
		if (player.waterSeal.level == 1) { levelMultiplier = 1.1}
		if (player.waterSeal.level == 2) { levelMultiplier = 1.2}
		if (player.waterSeal.level == 3) { levelMultiplier = 1.3}
		if (player.waterSeal.level == 4) { levelMultiplier = 1.4}
		if (player.waterSeal.level == 5) { levelMultiplier = 1.5}
		if (player.waterSeal.level == 6) { levelMultiplier = 1.6}
		if (player.waterSeal.level == 7) { levelMultiplier = 1.7}
		if (player.waterSeal.level == 8) { levelMultiplier = 1.8}
		if (player.waterSeal.level == 9) { levelMultiplier = 1.9}
		if (player.waterSeal.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slam your palm into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! A glowing blue mark is left behind on the enemy.`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, 'water', line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.waterSeal)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.waterSeal)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
waterSeal.addToPlayer()
const earthSeal = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Earth Seal',
	refName: 'earthSeal',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Earth Seal',
		refName: 'earthSeal',
		damage: function() {
			let mysticPowerBot = player.mysticPower * player.earthSeal.botMultiplier
			let mysticPowerTop = player.mysticPower * player.earthSeal.topMultiplier
			let baseDamageMystic = randomNumberRange(mysticPowerBot, mysticPowerTop)
			let levelMultiplier
			if (player.earthSeal.level == 1) { levelMultiplier = 1.25}
			if (player.earthSeal.level == 2) { levelMultiplier = 1.50}
			if (player.earthSeal.level == 3) { levelMultiplier = 1.75}
			if (player.earthSeal.level == 4) { levelMultiplier = 2.0}
			if (player.earthSeal.level == 5) { levelMultiplier = 2.25}
			if (player.earthSeal.level == 6) { levelMultiplier = 2.50}
			if (player.earthSeal.level == 7) { levelMultiplier = 2.75}
			if (player.earthSeal.level == 8) { levelMultiplier = 3.0}
			if (player.earthSeal.level == 9) { levelMultiplier = 3.25}
			if (player.earthSeal.level >= 10) { levelMultiplier = 3.5}
			let totalDamage = baseDamageMystic * levelMultiplier
			return Math.ceil(totalDamage)
		},
		duration: 30000,
		stacks: 0,
		numHitsToActivate: 5,
		color: 'earth',
		element: 'earth',
		resistType: 'earthResist',	
		penType: 'earthPen',	
		flavorText: function(enemy, damageAfterResist, element, damageResisted) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			blankSpace()
			customizeEachWord(`You break the Earth Seal on the enemy! Earth erupts from your fist on impact, blasting the `, `monk-ability-text-color`, line1)
			customizeEachWord(`${enemy.name}`, enemy.color, line1)
			customizeEachWord(`!`, `monk-ability-text-color`, line1)
			customizeEachWord(`Earth from the explosion swirls around you, forming a shield around you increasing your armor!`, `monk-ability-text-color`, line2)
			customizeEachWord(`Earthseal Break `, 'earth', line3)
			customizeEachWord(`hits for `, 'green', line3)
			customizeEachWord(`${damageAfterResist} `, 'light-blue', line3)
			customizeEachWord(`${element} `, element, line3)
			customizeEachWord(`damage. `, 'green', line3)
			customizeEachWord(`(Enemy resists `, 'white', line3)
			customizeEachWord(`${damageResisted}`, 'light-blue', line3)
			customizeEachWord(`)`, 'white', line3)
			blankSpace()
		},
	},
	buff: {
		name: 'Earth Enchant',
		refName: 'earthEnchant',
		buff: true,
		seal: true,
		get slashingArmor() {
			return player.earthSeal.level
		},
		get slashingArmor() {
			return player.earthSeal.level
		},
		get slashingArmor() {
			return player.earthSeal.level
		},
		stacks: 1,
		maxStacks: function() {
			return 1
		},
		duration: 20000,
		// flavorText: function() {
		// 	let line1 = lineFunc()
		// 	blankSpace()
		// 	customizeEachWord(`sdfdas`, 'white', line1)
		// 	blankSpace()
		// },
	},
	damage: function () {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let levelMultiplier
		if (player.earthSeal.level == 1) { levelMultiplier = 1.1}
		if (player.earthSeal.level == 2) { levelMultiplier = 1.2}
		if (player.earthSeal.level == 3) { levelMultiplier = 1.3}
		if (player.earthSeal.level == 4) { levelMultiplier = 1.4}
		if (player.earthSeal.level == 5) { levelMultiplier = 1.5}
		if (player.earthSeal.level == 6) { levelMultiplier = 1.6}
		if (player.earthSeal.level == 7) { levelMultiplier = 1.7}
		if (player.earthSeal.level == 8) { levelMultiplier = 1.8}
		if (player.earthSeal.level == 9) { levelMultiplier = 1.9}
		if (player.earthSeal.level >= 10) { levelMultiplier = 2.0}
		let totalDamage = baseDamage * levelMultiplier
		return Math.ceil(totalDamage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You slam your palm into the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`! A glowing earthy mark is left behind on the enemy.`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, `earth`, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.earthSeal)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.earthSeal)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
earthSeal.addToPlayer()
const mysticFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Mystic Fist',
	refName: 'mysticFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		name: 'Mystic Fist',
		refName: 'mysticFist',
		duration: 30000,
		stacks: 0,
		maxStacks: function() {
			return 5
		},
	},
	buff: {
		name: 'Mystic Fist',
		refName: 'mysticFist',
		seal: true,
		duration: 15000,
		stacks: 1,
		str: 1,
		maxStacks: function() {
			return 5
		},
		// flavorText: function() {
		// 	let line1 = lineFunc()
		// 	blankSpace()
		// 	customizeEachWord(`BLAST`, 'white', line1)
		// 	blankSpace()
		// },
	},
	damage: function (enemy) {
		let damage = baseAttackDamageRight() + player.mysticPower
		return Math.ceil(damage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`Your hands begin to glow and you become super-charged with electricity! `, `monk-ability-text-color`, line1)
		customizeEachWord(`You rush forward at the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`letting loose a barage of fists!`, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, 'earth', line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.mysticFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.mysticFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
mysticFist.addToPlayer()

const unleashedPower = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Unleashed Power',
	refName: 'unleashedPower',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'monk-color',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	debuff: {
		// name: 'Mystic Fist',
		// refName: 'mysticFist',
		// duration: 30000,
		// stacks: 0,
		// maxStacks: function() {
		// 	return 5
		// },
	},
	buff: {
		name: 'Unleashed Power',
		refName: 'unleashedPower',
		duration: 15000,
		stacks: 1,
		get str() {
			return 1
		},
		get dex() {
			return 1	
		},
		get agi() {
			return 1		
		},
		get mys() {
			return 1
		},		
		maxStacks: function() {
			let stacksBonus = 1
			for (let buff in player.buffs) {
				if (player.buffs[buff].seal) {
					stacksBonus++
				}
			}
			return stacksBonus
		},
		// flavorText: function() {
		// 	let line1 = lineFunc()
		// 	blankSpace()
		// 	customizeEachWord(`BLAST`, 'white', line1)
		// 	blankSpace()
		// },
	},
	damage: function (enemy) {
		let bonusSealDamageStacks = 0
		for (let buff in player.buffs) {
			if (player.buffs[buff].seal) {
				bonusSealDamageStacks++
			}
		}
		let damage = (baseAttackDamageRight() + player.mysticPower) * bonusSealDamageStacks
		return Math.ceil(damage)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You explode yourself and hit the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`${this.name} `, 'earth', line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy resists `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'you', line1)
		customizeEachWord(`attempt to apply a `, `monk-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`to the `, `monk-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`, but you `, `monk-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `monk-ability-text-color`, line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.unleashedPower)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.unleashedPower)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
unleashedPower.addToPlayer()

const waveFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Flamestrike',
	refName: 'flameStrike',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'activate-skill',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function () {
		//SET THESE UP:
		//ABILITY DAMAGE
		//GIVE BASE MYSTICISM IN CHARACTER CREATION
		let currentAttackPower = player.currentWeaponSkill.attackPower + player.mysticPower
		let currentWeaponSkillBotModifier = player.currentWeaponSkill.botMultiplier
		let currentWeaponSkillTopModifier = player.currentWeaponSkill.topMultiplier
		let totalBotDamage = player.currentRightHandWeapon().botDamage == undefined ? player.currentLeftHandWeapon.botDamage : player.currentRightHandWeapon().botDamage
		let totalTopDamage = player.currentRightHandWeapon().topDamage == undefined ? player.currentRightHandWeapon.topDamage : player.currentRightHandWeapon().topDamage
		let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * totalBotDamage * (1 + this.level * 0.1))
		let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * totalTopDamage * (1 + this.level * 0.1))
		let totalDamage = randomNumberRange(lowDamage, highDamage)
		return totalDamage
	},
	heal: function() {
		let topAbilityPower = player.mysticPower * player.waterSeal.topMultiplier
		let botAbilityPower = player.mysticPower * player.waterSeal.botMultiplier
		return Math.ceil(randomNumberRange(botAbilityPower, topAbilityPower))
	},
	sealBreakerDamage: function() {
		return randomNumberRange(10, 30)
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You slide behind the `, 'gray', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and sink your `, 'gray', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back!`, 'gray', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()
	},
	sealBreakerFlavorText: function(heal) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You consume the power of your Water Seal, healing yourself!`, 'water', line1)
		customizeEachWord(`You heal yourself for `, 'green', line2)
		customizeEachWord(`${heal} `, `fire`, line2)
		customizeEachWord(`health.`, 'green', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.waveFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.waveFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
waveFist.addToPlayer()


const riptideFist = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Riptide Fist',
	refName: 'riptideFist',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	color: 'activate-skill',
	topMultiplier: 1.5,
	botMultiplier: 1.0,
	resourceName: 'focus',
	resourceCost: 0,
	stacks: 0,
	weaponTypesUsed: ['unarmed'],
	rightWeaponTypes: ['unarmed'],
	leftWeaponTypes: ['unarmed'],
	damage: function () {
		let currentAttackPower = player.currentWeaponSkill.attackPower + player.mysticPower
		let currentWeaponSkillBotModifier = player.currentWeaponSkill.botMultiplier
		let currentWeaponSkillTopModifier = player.currentWeaponSkill.topMultiplier
		let totalBotDamage = player.currentRightHandWeapon().botDamage == undefined ? player.currentLeftHandWeapon.botDamage : player.currentRightHandWeapon().botDamage
		let totalTopDamage = player.currentRightHandWeapon().topDamage == undefined ? player.currentRightHandWeapon.topDamage : player.currentRightHandWeapon().topDamage
		let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * totalBotDamage * (1 + this.level * 0.1))
		let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * totalTopDamage * (1 + this.level * 0.1))
		let stackBonus = player.riptideFist.stacks + 1
		let totalDamage = Math.ceil(randomNumberRange(lowDamage, highDamage) * stackBonus)
		quickMessage(`Stacks: ${this.stacks}`)
		return totalDamage
	},
	combo: function() {
				let topAbilityPower = player.mysticPower * player.riptideFist.topMultiplier
				let botAbilityPower = player.mysticPower * player.riptideFist.botMultiplier
				return Math.ceil(randomNumberRange(botAbilityPower, topAbilityPower))
		},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1 == undefined && weapon2 == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	flavorText: function(enemy, weapon, damage) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`You slide behind the `, 'gray', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`and sink your `, 'gray', line1)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
		customizeEachWord(`into its back!`, 'gray', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()
	},
	comboFlavorText: function(enemy, damage) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		customizeEachWord(`Your fist slams into the `, 'water', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`erupting a waterfall explosion!`, 'water', line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`damage.`, 'green', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`dash behind the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`attempting to  `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`it with your `, 'white', line1)
		customizeEachWord(`${weapon.name}`, `${weapon.color}`, line1)
		customizeEachWord(`, but you narrowly `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.riptideFist)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.riptideFist)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
riptideFist.addToPlayer()

//RANGER ABILITIES



const markOfTheBeast = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Mark of the Beast',
	refName: 'markOfTheBeast',
	type: 'skill',
	color: 'green',
	descritpion: ``,
	debuff: {
		name: 'Mark of the Beast',
		refName: 'markOfTheBeast',
		duration: 6000,
		stacks: 0,
		maxStacks: function() {
			return 5
		},
		damage: function(enemy, swingObject) {
			let stacks = enemy.debuffs.markOfTheBeast.stacks
			let bonusMultiplier = 0
			if (player.markOfTheBeast.level == 1) {bonusMultiplier = 0.1 * stacks}
			if (player.markOfTheBeast.level == 2) {bonusMultiplier = 0.2 * stacks}
			if (player.markOfTheBeast.level == 3) {bonusMultiplier = 0.3 * stacks}
			if (player.markOfTheBeast.level == 4) {bonusMultiplier = 0.4 * stacks}
			if (player.markOfTheBeast.level >= 5) {bonusMultiplier = 0.5 * stacks}
			let damage = swingObject.totalDamage
			let bonusDamage = Math.ceil(damage * bonusMultiplier)
			return bonusDamage

		},
		type: 'mark',
		color: 'ranger-color',
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.markOfTheBeast)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.markOfTheBeast)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
markOfTheBeast.addToPlayer()


const shadowMark = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Shadow Mark',
	refName: 'shadowMark',
	type: 'ability',
	color: 'sinistral-color',
	descritpion: ``,
	maxLevel: 10,
	debuff: {
		name: 'Shadow Mark',
		refName: 'shadowMark',
		duration: 60000,
		stacks: 0,
		maxStacks: function() {
			if (player.shadowMark.level == 1) {return 3}
			if (player.shadowMark.level == 2) {return 4}
			if (player.shadowMark.level == 3) {return 5}
			if (player.shadowMark.level == 4) {return 6}
			if (player.shadowMark.level == 5) {return 7}
			if (player.shadowMark.level == 6) {return 8}
			if (player.shadowMark.level == 7) {return 9}
			if (player.shadowMark.level == 8) {return 10}
			if (player.shadowMark.level == 9) {return 11}
			if (player.shadowMark.level >= 10) {return 12}
			else { return 1}
		},
		type: 'mark',
		color: 'shadow',
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.shadowMark)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.shadowMark)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shadowMark.addToPlayer()

const sinisterMark = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Sinister Mark',
	refName: 'sinisterMark',
	type: 'skill',
	color: 'green',
	maxLevel: 10,
	adrenalineBonus: function() {
		if (player.sinisterMark.level == 1) {return 2}
		if (player.sinisterMark.level == 2) {return 4}
		if (player.sinisterMark.level == 3) {return 6}
		if (player.sinisterMark.level == 4) {return 8}
		if (player.sinisterMark.level == 5) {return 10}
		if (player.sinisterMark.level == 6) {return 12}
		if (player.sinisterMark.level == 7) {return 14}
		if (player.sinisterMark.level == 8) {return 16}
		if (player.sinisterMark.level == 9) {return 18}
		if (player.sinisterMark.level >= 10) {return 20}
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.sinisterMark)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.sinisterMark)
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`A Sinister Mark is applied to a target by landing a successful Backstab (Assassin ability). Increasing the skill level of Sinister Mark will increase the armor reduction effect, as well as increase the bonus Adrenaline gained from killing an enemy with Guillotine, however, the amount of stacks able to be applied is equal to Backstab's level + 1.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
sinisterMark.addToPlayer()

const shadowsurge = {
	get level() {
	return calculateStat(player, this.refName)
	},
	name: 'Shadowsurge',
	refName: 'shadowsurge',
	cooldown: 1000,
	cooldownSet: 1000,
	type: 'ability',
	element: 'shadow',
	color: 'sinistral-color',
	multiplier: 1.5,
	resourceName: 'adrenaline',
	resourceCost: 0,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	rightWeaponTypes: ['daggers', 'oneHanded'],
	leftWeaponTypes: ['daggers', 'oneHanded'],
	damage: function (enemy, doesPlayerShadowStep) {
		let baseDamage = baseAttackDamageRight() + baseAttackDamageLeft()
		let totalDamage = 0
		if (doesPlayerShadowStep) {
			//Calculate damage for shadowstep
			let levelMultiplier
			if (player.shadowsurge.level == 1) { levelMultiplier = 1.25}
			if (player.shadowsurge.level == 2) { levelMultiplier = 1.35}
			if (player.shadowsurge.level == 3) { levelMultiplier = 1.45}
			if (player.shadowsurge.level == 4) { levelMultiplier = 1.55}
			if (player.shadowsurge.level == 5) { levelMultiplier = 1.65}
			if (player.shadowsurge.level == 6) { levelMultiplier = 1.75}
			if (player.shadowsurge.level == 7) { levelMultiplier = 1.85}
			if (player.shadowsurge.level == 8) { levelMultiplier = 1.95}
			if (player.shadowsurge.level == 9) { levelMultiplier = 2.05}
			if (player.shadowsurge.level >= 10) { levelMultiplier = 2.15}
			totalDamage = baseDamage * levelMultiplier
		} else {
			//Calculate damage for shadowsurge
			let levelMultiplier
			let shadowMarkMultiplier = enemy.debuffs?.shadowMark?.stacks ? enemy.debuffs.shadowMark.stacks * 0.2 : 0
			if (player.shadowsurge.level == 1) { levelMultiplier = 1.1 }
			if (player.shadowsurge.level == 2) { levelMultiplier = 1.2 }
			if (player.shadowsurge.level == 3) { levelMultiplier = 1.3 }
			if (player.shadowsurge.level == 4) { levelMultiplier = 1.4 }
			if (player.shadowsurge.level == 5) { levelMultiplier = 1.5 }
			if (player.shadowsurge.level == 6) { levelMultiplier = 1.6 }
			if (player.shadowsurge.level == 7) { levelMultiplier = 1.7 }
			if (player.shadowsurge.level == 8) { levelMultiplier = 1.8 }
			if (player.shadowsurge.level == 9) { levelMultiplier = 1.9 }
			if (player.shadowsurge.level >= 10) { levelMultiplier = 2.0 }
			totalDamage = (levelMultiplier + shadowMarkMultiplier) * baseDamage
		}
		return Math.ceil(totalDamage)
	},
	buff: {
		name: 'Shadowbane',
		refName: 'shadowbane',
		duration: 30000,
		stacks: 0,
		dodge: 10,
		maxStacks: function() {
			return 10
		},
	},
	abilityWeaponsCheck: function(weapon1, weapon2) {
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'daggers') {return false}
		if (weapon1.skillUsed == 'daggers' && weapon2.skillUsed == 'unarmed') {return false}
		if (weapon1.skillUsed == 'unarmed' && weapon2.skillUsed == 'daggers') {return false}
		else {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform Venom Blade while wielding any weapon other than a dagger`, 'white', line1)
			return true
		}
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked, doesPlayerShadowStep) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You travel through the shadows behind the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`sinking your `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
			customizeEachWord(`into its back!`, `sinistral-ability-text-color`, line1)
			customizeEachWord(`Shadow Step `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${penetrationType} `, penetrationType, line2)
			customizeEachWord(`damage. `, 'green', line2)
			customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		}
		if (!doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You call upon the Shadows swirling around the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`to consume it, draining its lifeforce!`, `sinistral-ability-text-color`, line1)
			customizeEachWord(`Shadowsurge `, this.color, line2)
			customizeEachWord(`hits for `, 'green', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`shadow `, 'shadow', line2)
			customizeEachWord(`damage.`, `green`, line2)
			customizeEachWord(` (Enemy resists `, `white`, line2)
			customizeEachWord(`${damageBlocked}`, `light-blue`, line2)
			customizeEachWord(`)`, `white`, line2)
			blankSpace()
		}
	},
	flavorTextRegularHit: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`You flow through the shadows behind the enemy, and in a cross-slash motion of your daggers you eviscerate the `, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, `${enemy.color}`, line1)
		customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon, doesPlayerShadowStep) {
		let line0 = lineFunc()
		let line1 = lineFunc()
		if (doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You travel through the shadows behind the `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
			customizeEachWord(`attemping to strike it with your `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${weapon.name} `, `${weapon.color}`, line1)
			customizeEachWord(`but `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`miss`, 'red', line1)
			customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
			blankSpace()
		}
		if (!doesPlayerShadowStep) {
			blankSpace()
			customizeEachWord(`You attempt to eviscerate the enemy with `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			customizeEachWord(`, but `, `sinistral-ability-text-color`, line1)
			customizeEachWord(`miss`, `red`, line1)
			customizeEachWord(`!`, `sinistral-ability-text-color`, line1)
			blankSpace()
		}
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowsurge)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowsurge)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shadowsurge.addToPlayer()

const shadowVenom = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Shadow Venom',
	refName: 'shadowVenom',
	type: 'ability',
	color: 'sinistral-color',
	descritpion: ``,
	weaponTypesUsed: ['daggers', 'oneHanded'],
	buff: {
		name: 'Shadow Venom',
		refName: 'shadowVenom',
		resistType: 'shadowResist',
		penType: 'shadowPen',
		duration: 30000,
		stacks: 0,
		damage: function(enemy) {
			let topEnd
			let botEnd
			if (player.shadowVenom.level <= 1) {
				topEnd = 1.0
				botEnd = 0.8
			}
			if (player.shadowVenom.level == 2) {
				topEnd = 1.1
				botEnd = 0.9
			}
			if (player.shadowVenom.level == 3) {
				topEnd = 1.2
				botEnd = 1.0
			}
			if (player.shadowVenom.level == 4) {
				topEnd = 1.3
				botEnd = 1.1
			}
			if (player.shadowVenom.level == 5) {
				topEnd = 1.5
				botEnd = 1.3
			}
			if (player.shadowVenom.level == 6) {
				topEnd = 1.7
				botEnd = 1.5
			}
			if (player.shadowVenom.level == 7) {
				topEnd = 1.9
				botEnd = 1.7
			}
			if (player.shadowVenom.level == 8) {
				topEnd = 2.1
				botEnd = 1.9
			}
			if (player.shadowVenom.level == 9) {
				topEnd = 2.3
				botEnd = 2.1
			}
			if (player.shadowVenom.level >= 10) {
				topEnd = 2.5
				botEnd = 2.3
			}
			let botDamage = player.currentWeaponSkill.attackPower * botEnd
			let topDamage = player.currentWeaponSkill.attackPower * topEnd
			let baseDamage = randomNumberRange(botDamage, topDamage)
			let totalDamage = baseDamage
			if (enemy.debuffs) {
				if (enemy.debuffs.shadowMark) {
					let stacks = enemy.debuffs.shadowMark.stacks
					if (!stacks || stacks == 0) {totalDamage = baseDamage}
					if (stacks == 1) {totalDamage = baseDamage * 1.1}
					if (stacks == 2) {totalDamage = baseDamage * 1.2}
					if (stacks == 3) {totalDamage = baseDamage * 1.3}
					if (stacks == 4) {totalDamage = baseDamage * 1.4}
					if (stacks == 5) {totalDamage = baseDamage * 1.5}
					if (stacks == 6) {totalDamage = baseDamage * 1.6}
					if (stacks == 7) {totalDamage = baseDamage * 1.7}
					if (stacks == 8) {totalDamage = baseDamage * 1.8}
					if (stacks == 9) {totalDamage = baseDamage * 1.9}
					if (stacks >= 10) {totalDamage = baseDamage * 2.0}
				}
			}
			return Math.ceil(totalDamage)
		},
		maxStacks: function() {
			return 5
		},
		flavorText: function(enemy, damage, element, damageResisted) {
			let line1 = lineFunc()
			customizeEachWord(`You hit for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`additional `, 'green', line1)
			customizeEachWord(`shadow `, 'shadow', line1)
			customizeEachWord(`damage. `, 'green', line1)
			customizeEachWord(`(Enemy resists `, 'white', line1)
			customizeEachWord(`${damageResisted}`, 'light-blue', line1)
			customizeEachWord(`)`, 'white', line1)
		},
		flavorTextWearsOff: function() {
			let line1 = lineFunc()
			customizeEachWord(`${this.name} `, 'shadow', line1)
			customizeEachWord(`has faded from your weapon`, 'white', line1)
		},
		flavorTextApplyBuff: function() {
			let line1 = lineFunc()
			customizeEachWord(`Your weapon glows purple with `, 'white', line1)
			customizeEachWord(`${this.name}`, 'shadow', line1)
		},
		type: 'mark',
		color: 'shadow',
	},
	debuff: {
		name: 'Shadow Mark',
		refName: 'shadowMark',
		resistType: 'shadowResist',
		penType: 'shadowPen',
		stacks: 1,
		maxStacks: function() {
			return 5
		},
	},
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.shadowVenom)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.shadowVenom)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shadowVenom.addToPlayer()

const poison = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Poison',
	refName: 'poison',
	resistType: 'poisonResist',
	penType: 'poisonPen',
	stacks: 0,
	duration: function() {
		if (player.contagion.level == 1) {return 30000}
		if (player.contagion.level == 2) {return 60000}
		if (player.contagion.level == 3) {return 90000}
		if (player.contagion.level == 4) {return 150000}
		if (player.contagion.level == 5) {return 240000}
		if (player.contagion.level == 6) {return 360000}
		if (player.contagion.level == 7) {return 480000}
		if (player.contagion.level == 8) {return 600000}
		if (player.contagion.level == 9) {return 900000}
		if (player.contagion.level >= 10) {return 1200000}
		else {return 0}
	},
	color: 'dark-green',
	damage: function(swingObject) {
		let botModifier = 0
		let topModifier = 0
		if (this.level == 1) {
			botModifier = 0.5
			topModifier = 1.0
		}
		if (this.level == 2) {
			botModifier = 0.55
			topModifier = 1.05
		}
		if (this.level == 3) {
			botModifier = 0.6
			topModifier = 1.1
		}
		if (this.level == 4) {
			botModifier = 0.65
			topModifier = 1.15
		}
		if (this.level == 5) {
			botModifier = 0.70
			topModifier = 1.20
		}
		if (this.level == 6) {
			botModifier = 0.75
			topModifier = 1.25
		}
		if (this.level == 7) {
			botModifier = 0.80
			topModifier = 1.30
		}
		if (this.level == 8) {
			botModifier = 0.85
			topModifier = 1.35
		}
		if (this.level == 9) {
			botModifier = 0.90
			topModifier = 1.40
		}
		if (this.level == 10) {
			botModifier = 1.0
			topModifier = 1.5
		}
		else {
			botModifier = 0.5
			topModifier = 1.0
		}
		let botDamage = player.currentWeaponSkill.attackPower * botModifier
		let topDamage = player.currentWeaponSkill.attackPower * topModifier
		let baseDamage = randomNumberRange(botDamage, topDamage)
		let bonusDamage = this.stacks
		let totalDamage = baseDamage + bonusDamage
		return Math.ceil(totalDamage)
	},
	maxStacks: function() {
		if (player.contagion.level == 1) {return 2}
		if (player.contagion.level == 2) {return 3}
		if (player.contagion.level == 3) {return 4}
		if (player.contagion.level == 4) {return 5}
		if (player.contagion.level == 5) {return 6}
		if (player.contagion.level == 6) {return 7}
		if (player.contagion.level == 7) {return 8}
		if (player.contagion.level == 8) {return 9}
		if (player.contagion.level == 9) {return 10}
		if (player.contagion.level >= 10) {return 12}
		else {return 0}	
	},
	flavorText: function(enemy, damage, element, damageResisted) {
		let line1 = lineFunc()
		customizeEachWord(`You hit for `, 'green', line1)
		customizeEachWord(`${damage} `, 'light-blue', line1)
		customizeEachWord(`additional `, 'green', line1)
		customizeEachWord(`poison `, `dark-green`, line1)
		customizeEachWord(`damage. `, `green`, line1)
		customizeEachWord(`(Enemy resists `, `white`, line1)
		customizeEachWord(`${damageResisted}`, `light-blue`, line1)
		customizeEachWord(`)`, `white`, line1)
	},
	flavorTextWearsOff: function() {
		let line1 = lineFunc()
		customizeEachWord(`${this.name} `, 'dark-green', line1)
		customizeEachWord(`has faded from your weapon`, 'white', line1)
	},
	flavorTextApplyBuff: function() {
		let line1 = lineFunc()
		customizeEachWord(`Your weapon glows green with `, 'white', line1)
		customizeEachWord(`${this.name}`, 'dark-green', line1)
	},
	goldToUpgrade: function () {
		return goldUpgradeCost2(player.poison)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost2(player.poison)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
poison.addToPlayer()


const piercingArrow = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Piercing Arrow',
	refName: 'piercingArrow',
	color: 'ranger-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: function() {
		if (this.level == 1) { return 7000}
		if (this.level == 2) { return 6500}
		if (this.level == 3) { return 6000}
		if (this.level == 4) { return 5500}
		if (this.level == 5) { return 5000}
		if (this.level == 6) { return 4500}
		if (this.level == 7) { return 4000}
		if (this.level == 8) { return 3500}
		if (this.level == 9) { return 3000}
		if (this.level >= 10) { return 2000}
	},
	timer: function() {
		if (this.level == 1) { return 7000}
		if (this.level == 2) { return 6500}
		if (this.level == 3) { return 6000}
		if (this.level == 4) { return 5500}
		if (this.level == 5) { return 5000}
		if (this.level == 6) { return 4500}
		if (this.level == 7) { return 4000}
		if (this.level == 8) { return 3500}
		if (this.level == 9) { return 3000}
		if (this.level >= 10) { return 2000}
	},
	resourceName: 'focus',
	resourceCost: 5,
	weaponTypesUsed: ['bows'],
	debuff: {
		name: 'Piercing Arrow',
		refName: 'piercingArrow',
		damage: function(swingObject) {
			return Math.ceil(swingObject.totalDamage * 0.5)
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		type: 'mark',
		color: 'ranger-color',
		flavorText: function(enemy, damage) {
			let line1 = lineFunc()
			customizeEachWord(`Piercing Arrow mark `, 'ranger-color', line1)
			customizeEachWord(`hits for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`damage.`, 'green', line1)
			blankSpace()
		},
	},
	damage: function () {
			let bonusMultiplier = 1.0
			if (this.timer() != 0) {
				if (this.timer() < this.windUp * 0.05) {
					// quickMessage(`You hit for 3.0x damage!`)
					bonusMultiplier = 3.0
				}
				else if (this.timer() < this.windUp * 0.1) {
					bonusMultiplier = 2.5
					// quickMessage(`You hit for 2.5x damage!`)
				}
				else if (this.timer() < this.windUp * 0.2) {
					bonusMultiplier = 2.0
					// quickMessage(`You hit for 2.0x damage!`)
				}
				else if (this.timer() < this.windUp * 0.3) {
					bonusMultiplier = 1.75
					// quickMessage(`You hit for 1.75x damage!`)
				}
				else if (this.timer() < this.windUp * 0.4) {
					bonusMultiplier = 1.6
				}
				else if (this.timer() < this.windUp * 0.5) {
					bonusMultiplier = 1.5
				}
				else if (this.timer() < this.windUp * 1.0) {
					bonusMultiplier = 1.0
				}
			}
		return Math.ceil(baseAttackDamageRight() * bonusMultiplier)
	},
	initiateTimer: function(secondCommand, thirdCommand) {
		//windup
		const conjureBar = document.querySelector('.bar-1')
		conjureBar.classList.add('ranger-resource-bar')	
		//timer	
		let windUpTime = this.windUp()
		let remainingTime = windUpTime
		let width = 0
		if (this.onCooldown == false) {
			this.queued = true
			player.isAbilityQueued = true
			piercingArrowInterval = setInterval(() => {
				if (remainingTime <= 0) {
					player.isAbilityQueued = false
					this.queued = false
					conjureBar.style.width = 0
					let weaponTypesToCheck = this.weaponTypesUsed
					let weaponUsed = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
					// let totalDamage = this.damage(weaponUsed)
					let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
					let hitChance = playerAbilityHitChance(targetEnemy)
					let baseDamage = this.damage()
					let penetrationType = calculatePenetrationRoll()
					let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					let damageBlocked = baseDamage - damageAfterArmor
					if (hitChance == false) {
						this.releaseTimer()
						this.timer = this.windUp()
						this.flavorTextMiss(targetEnemy, weaponUsed)
						clearInterval(piercingArrowInterval)
					} else if (hitChance == true) {
						this.releaseTimer(weaponUsed)
						this.timer = this.windUp()
						this.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(targetEnemy, damageAfterArmor)
						updateScroll()
					} 
					clearInterval(piercingArrowInterval)
					return
				}
				width = ((windUpTime - remainingTime) / windUpTime) * 100
				conjureBar.style.width = `${width}%`
				remainingTime -= 10
				this.timer() -= 10
			}, 10)
		}
	},
	releaseTimer: function() {
		let conjureBar = document.querySelector('.bar-1')
		this.timer = this.windUp
		conjureBar.style.width = 0
		clearInterval(piercingArrowInterval)
		this.queued = false
		this.cooldown = this.cooldownSet
		updateScroll()
		
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You gather your focus as you try to time the perfect shot with `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		customizeEachWord(`After honing your full attention to this shot, you pull back the bowstring of your `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`and let fly an arrow that pierces the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `ranger-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
		customizeEachWord(`Your concentration was broken at the last second. You fire your arrow at the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, `ranger-ability-text-color`, line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, `ranger-ability-text-color`, line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.piercingArrow)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.piercingArrow)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
piercingArrow.addToPlayer()

const hydraArrow = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Hydra Arrow',
	refName: 'hydraArrow',
	color: 'ranger-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 1,
	resourceName: 'focus',
	resourceCost: 5,
	statusEffect: 'huntersMark',
	debuff: {
		name: 'Hydra Arrow',
		refName: 'hydraArrow',
		damage: function(swingObject) {
			let damage = swingObject.totalDamage
			return Math.ceil(damage * 0.5)
		},
		duration: 20000,
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		flavorText: function(enemy, damage) {
			let line1 = lineFunc()
			customizeEachWord(`Hydra Arrow mark `, 'ranger-color', line1)
			customizeEachWord(`hits for `, 'green', line1)
			customizeEachWord(`${damage} `, 'light-blue', line1)
			customizeEachWord(`damage.`, 'green', line1)
			blankSpace()
		},
		type: 'mark',
		color: 'ranger-color',
	},
	shotCount: function() {
		if (player.hydraArrow.level == 1) { return 3 }
		if (player.hydraArrow.level == 2) { return 3 }
		if (player.hydraArrow.level == 3) { return 3 }
		if (player.hydraArrow.level == 4) { return 3 }
		if (player.hydraArrow.level == 5) { return 4 }
		if (player.hydraArrow.level == 6) { return 4 }
		if (player.hydraArrow.level == 7) { return 4 }
		if (player.hydraArrow.level == 8) { return 4 }
		if (player.hydraArrow.level == 9) { return 5 }
		if (player.hydraArrow.level >= 10) { return 5 }
	},
	weaponTypesUsed: ['bows'],
	damage: function () {
		let baseDamage = baseAttackDamageRight()
		let levelMultiplier
		if (player.hydraArrow.level == 1) { levelMultiplier = 1.00 }
		if (player.hydraArrow.level == 2) { levelMultiplier = 1.25 }
		if (player.hydraArrow.level == 3) { levelMultiplier = 1.50 }
		if (player.hydraArrow.level == 4) { levelMultiplier = 1.75 }
		if (player.hydraArrow.level == 5) { levelMultiplier = 2.00 }
		if (player.hydraArrow.level == 6) { levelMultiplier = 2.25 }
		if (player.hydraArrow.level == 7) { levelMultiplier = 2.50 }
		if (player.hydraArrow.level == 8) { levelMultiplier = 2.75 }
		if (player.hydraArrow.level == 9) { levelMultiplier = 3.00 }
		if (player.hydraArrow.level >= 10) { levelMultiplier = 3.25 }
		let totalDamage = Math.ceil(baseDamage * levelMultiplier)
		return totalDamage
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You position arrows on your `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`, firing them all at once at the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `ranger-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
	flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		customizeEachWord(`An arrow strays just passed the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, 'white', line1)
		customizeEachWord(`misses`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.hydraArrow)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.hydraArrow)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
hydraArrow.addToPlayer()
const rapidFireShot = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Rapid Fire Shot',
	refName: 'rapidFireShot',
	color: 'ranger-color',
	cooldownSet: 10000,
	cooldown: 10000,
	windUp: 5,
	resourceName: 'focus',
	resourceCost: 5,
	shotCount: function() {
		return this.level + 2
	},
	weaponTypesUsed: ['bows'],
	damage: function (enemy) {
		let baseDamage = baseAttackDamageRight()
		let markBonus = enemy?.debuffs?.markOfTheBeast?.damage() ? enemy?.debuffs?.markOfTheBeast?.damage() : 0
		let bonusDamage = baseDamage * markBonus
		let totalDamage = Math.ceil(baseDamage + bonusDamage)
		return totalDamage
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You begin gathering the arrows needed for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage, penetrationType, damageBlocked) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You draw back several arrows with your `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`, firing them all at the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`in rapid succession!`, `ranger-ability-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`${penetrationType} `, penetrationType, line2)
		customizeEachWord(`damage. `, 'green', line2)
		customizeEachWord(`(Enemy's armor blocks `, 'white', line2)
		customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
		customizeEachWord(`)`, 'white', line2)
		blankSpace()
	},
		flavorTextMiss: function(enemy) {
		let line1 = lineFunc()
		customizeEachWord(`An arrow from your volley wizzes just by the `, `ranger-ability-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`and `, 'white', line1)
		customizeEachWord(`misses`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.rapidFireShot)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.rapidFireShot)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
rapidFireShot.addToPlayer()
const aimedShot = {
		get level() {
		return calculateStat(player, this.refName)
	},
	requiredPlayerLevel: function() {
		if (player.aimedShot.level == 0) {
			return 5
		} else if (player.aimedShot.level == 1) {
			return 10
		} else if (player.aimedShot.level == 2) {
			return 15
		}
	},
	name: 'Aimed Shot',
	refName: 'aimedShot',
	color: 'ranger-color',
	cooldownSet: 20000,
	cooldown: 20000,
	windUp: 3,
	shotCount: function() {
		return this.level + 1
	},
	resourceName: [],
	marksThisConsumes: ['huntersMark'],
	weaponTypesUsed: ['bows'],
	damage: function (weapons, enemy) {
			let currentAttackPower = player[weapons.skillUsed].attackPower
			let currentWeaponSkillBotModifier = player[weapons.skillUsed].botMultiplier
			let currentWeaponSkillTopModifier = player[weapons.skillUsed].topMultiplier
			let currentWeaponSkillBotDamage = weapons.botDamage
			let currentWeaponSkillTopDamage = weapons.topDamage
			let currentWeaponWeight = weapons.mods.weight
			let lowDamage = Math.floor(currentAttackPower * currentWeaponSkillBotModifier * currentWeaponSkillBotDamage + (1 + this.level * 0.1))
			let highDamage = Math.floor(currentAttackPower * currentWeaponSkillTopModifier * currentWeaponSkillTopDamage + (1 + this.level * 0.1))
			console.log(lowDamage, ' LOW DAMAGE')
			console.log(highDamage, ' HIGH DAMAGE')
			let weaponDamage = randomNumberRange(lowDamage, highDamage)
			let bonusDamage = Math.ceil(weaponDamage * ((player.might - 1) * .1)) + 10 //this does 10% per stack of might bonus damage + 10 flat damage rounded up
			let totalDamageWithMark = (weaponDamage + bonusDamage) * 2
			let totalDamage = weaponDamage + bonusDamage
			if (enemy.statusEffects.huntersMark) {
				return totalDamageWithMark
			}
			return totalDamage
	},
	abilityWeaponsCheck: function(playerWeapon) {
		if (playerWeapon == undefined) {
			let line1 = lineFunc()
			customizeEachWord(`You cannot perform ${this.name} while wielding these weapons`, 'white', line1)
			blankSpace()
			return true
		}
	},
	windUpText: function() {
		let line1 = lineFunc()
		customizeEachWord(`You begin gathering your energy for `, 'white', line1)
		customizeEachWord(`${this.name}`, this.color, line1)
	},
	flavorText: function(enemy, weapon, damage) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		let line3 = document.createElement('div')
		customizeEachWord(`With a burst of energy, you launch yourself at the enemy!`, this.color, line1)
		customizeEachWord(`Pivoting on your heel, you whirl around, swinging your `, this.color, line2)
		customizeEachWord(`${weapon.name} `, `${weapon.color}`, line2)
		customizeEachWord(`in a wide arc ripping into the `, enemy.color, line2)
		customizeEachWord(`${enemy.name}`, `enemy.color`, line2)
		customizeEachWord(`!`, this.color, line2)
		customizeEachWord(`You hit for `, 'green', line3)
		customizeEachWord(`${damage} `, 'light-blue', line3)
		customizeEachWord(`damage.`, 'green', line3)
		blankSpace()
	},
		flavorTextMiss: function(enemy, weapon) {
		let line1 = lineFunc()
		//You launch yourself toward the enemy, swinging your {weapon} in a wide arc, but it moves out of the way just in time and you miss!
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`launch yourself toward the `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`swinging your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`in a wide arc, but it moves out of the way just in time and you `, 'white', line1)
		customizeEachWord(`miss`, 'red', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
	},
	queued: false,
	onCooldown: false,
	type: 'ability',
	goldToUpgrade: function () {
		return abilityGoldUpgradeCost(player.aimedShot)
	},
	pointsToUpgrade: function () {
		return abilityUpgradeCost(player.aimedShot)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
aimedShot.addToPlayer()

const unarmed = {
	id: 1,
	name: 'Martial Arts',
	refName: 'unarmed',
	type: 'skill',
	get attackPower() {
		let twoHandedAttributes = player.str + player.dex + player.agi
		let attackPowerMods = calculateStat(player, 'attackPower')
		return Math.ceil((twoHandedAttributes + attackPowerMods) * 0.5)
	},
	get level() {
		return calculateStat(player, this.refName)
	},
	get topMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get botMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get speed() {
		let main = Math.max(2, parseFloat(4.1 - Math.floor((player.unarmed.level / 10) * 100) / 100).toFixed(1))
		let bonus = Math.floor(player.burden * 0.1)
		return main + bonus
	},
	get accuracy() {
		let dualSwingPenalty = 10
		return Math.floor(10 + (player.dex + player.accuracy + 
			player.unarmed.level - dualSwingPenalty) * 10) / 10
	},
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.unarmed)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.unarmed)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
unarmed.addToPlayer()
const daggers = {
	id: 2,
	name: 'Daggers',
	refName: 'daggers',
	type: 'skill',
	get attackPower() {
		let daggers = player.dex + player.agi + (player.str * 0.5)
		let attackPowerMods = calculateStat(player, 'attackPower')
		return Math.ceil((daggers + attackPowerMods) * 0.5)
	},
	get level() {
		return calculateStat(player, this.refName)
	},
	get topMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get botMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get speed() {
		let main = Math.max(2, parseFloat((5.2 - Math.floor((this.level / 5) * 100) / 100).toFixed(1)))
		let bonus = Math.floor(player.burden * 0.1)
		return main + bonus
	},
	get accuracy() {
		let dualSwingPenalty = 10
		return Math.floor(((player.dex + player.daggers.level + player.accuracy) * 10) / 10) - dualSwingPenalty
	},
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.daggers)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.daggers)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
daggers.addToPlayer()
const oneHanded = {
	id: 3,
	name: 'One Handed',
	refName: 'oneHanded',
	type: 'skill',
	get attackPower() {
		let oneHandedAttributes = player.str + player.dex + (player.agi * 0.5)
		let attackPowerMods = calculateStat(player, 'attackPower')
		return Math.ceil((oneHandedAttributes + attackPowerMods) * 0.5)
	},
	get level() {
		return calculateStat(player, this.refName)
	},
	get topMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get botMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get speed() {
		let main = Math.max(2, parseFloat((5.2 - Math.floor((this.level / 5) * 100) / 100).toFixed(1)))
		let bonus = Math.floor(player.burden * 0.1)
		return main + bonus
	},
	get accuracy() {
		let dualSwingPenalty = 10
		return player.oneHanded.accuracy = Math.floor(((player.dex + player.oneHanded.level + player.accuracy) * 10) / 10) - dualSwingPenalty

	},
	color: 'green',
	description: function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`This is the primary skill for those specializing in one-handed weapons. Training this skill will increase your swing speed, damage, and accuracy with all one handed weapon types. Once the maximum swing speed has been reached, damage is further increased.`, 'white', line1)
		blankSpace()
		customizeEachWord(`One-handed weapons include swords, axes, maces, and other similar weapon types. One-handed weapons do not include daggers, fist weapons, bows, or shields.`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.oneHanded)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.oneHanded)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
oneHanded.addToPlayer()

const twoHanded = {
	id: 4,
	name: 'Two Handed',
	refName: 'twoHanded',
	type: 'skill',
	get attackPower() {
		let twoHandedAttributes = (player.str * 2) + ((player.dex + player.agi) * 0.5)
		let attackPowerMods = calculateStat(player, 'attackPower')
		return Math.ceil((twoHandedAttributes + attackPowerMods) * 0.5)
	},
	get level() {
		return calculateStat(player, this.refName)
	},
	get topMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get botMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get speed() {
		let main = Math.max(2, parseFloat((6.2 - Math.floor((this.level / 5) * 100) / 100).toFixed(1)))
		let bonus = Math.floor(player.burden * 0.1)
		return main + bonus
	},
	get accuracy() {
		let dex = player.dex
		return Math.floor(10 + ((dex * 3) + this.level + player.accuracy) * 10) / 10
	},
	color: 'green',
	description: function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		customizeEachWord(`This is the primary skill for those specializing in two-handed weapons. Training this skill will increase your swing speed, damage, and accuracy with all two handed weapon types. Once the maximum swing speed has been reached, damage is further increased.`, 'white', line1)
		blankSpace()
		customizeEachWord(`Two-handed weapons include swords, axes, maces, and other similar weapon types that are wielded in both hands. Two-handed weapons do not include daggers, fist weapons, bows, or shields.`, 'white', line2)
		blankSpace()
	},
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.twoHanded)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.twoHanded)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	}
}
twoHanded.addToPlayer()

const bows = {
	name: 'Bows',
	refName: 'bows',
	type: 'skill',
	get attackPower() {
		let twoHandedAttributes = (player.agi + player.dex) + (player.str * 0.5)
		let attackPowerMods = calculateStat(player, 'attackPower')
		return Math.ceil((twoHandedAttributes + attackPowerMods) * 0.5)
	},
	get level() {
		return calculateStat(player, this.refName)
	},
	get topMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get botMultiplier() {
		return parseFloat((allWeaponSkillMultipliers + this.level / allWeaponSkillIncrements).toFixed(2))
	},
	get speed() {
		let main = Math.max(2, parseFloat((5.1 - Math.floor((this.level / 5) * 100) / 100).toFixed(1)))
		let bonus = Math.floor(player.burden * 0.1)
		return main + bonus
	},
	get accuracy() {
		let dex = player.dex
		return Math.floor(10 + (dex + player.bows.level + player.accuracy) * 10) / 10
	},
	color: 'skill',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.bows)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.bows)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
bows.addToPlayer()
const shields = {
	name: 'Shields',
	refName: 'shields',
	type: 'skill',
	attackPower: 0,
	rating: function() {
		return this.level
	},
		get level() {
		return calculateStat(player, this.refName)
	},
	topMultiplier: 0.4,
	botMultiplier: 0.4,
	speed: 0,
	accuracy: 0,
	slashingPen: 0,
	piercingPen: 0,
	bluntPen: 0,
	color: 'green',
	goldToUpgrade: function () {
		return goldUpgradeCost1(player.shields)
	},
	pointsToUpgrade: function () {
		return skillUpgradeCost1(player.shields)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
shields.addToPlayer()


///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////
///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////
///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////
///////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////////////////////

const fireflames = {
	get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Fireflames',
	refName: 'fireflames',
	color: 'fire',
	conjureBarColor: 'fire-conjure',
	type: 'fire',
	element: 'fire',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.fireflames.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.fireflames.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.fireflames.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.fireflames.level <= 1) {spellLevelReduction = 0}
		if (player.fireflames.level == 2) {spellLevelReduction = 0}
		if (player.fireflames.level == 3) {spellLevelReduction = 0}
		if (player.fireflames.level == 4) {spellLevelReduction = 0}
		if (player.fireflames.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.fireflames.level <= 1) {spellLevelReduction = 0}
		if (player.fireflames.level == 2) {spellLevelReduction = 0}
		if (player.fireflames.level == 3) {spellLevelReduction = 0}
		if (player.fireflames.level == 4) {spellLevelReduction = 0}
		if (player.fireflames.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		fireSpellConjure.play()
	},
	castAudio: function() {
		fireflamesArray[randomNumberRange(0, 2)].play()
	},
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.fireflames)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.fireflames)
	},
	damage: function(enemy) {
		let burnStacks = enemy?.debuffs?.burn?.stacks ? enemy?.debuffs?.burn?.stacks : 0
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damageBeforeBonus = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let burnBonusDamage = ((burnStacks * player.burn.bonusModifier()) + 1)
		let damageWithBurn = damageBeforeBonus * burnBonusDamage
		let levelMultiplier
		if (player.fireflames.level == 1) { levelMultiplier = 1.0 }
		if (player.fireflames.level == 2) { levelMultiplier = 1.2 }
		if (player.fireflames.level == 3) { levelMultiplier = 1.4 }
		if (player.fireflames.level == 4) { levelMultiplier = 1.6 }
		if (player.fireflames.level == 5) { levelMultiplier = 1.8 }
		if (player.fireflames.level == 6) { levelMultiplier = 2.0 }
		if (player.fireflames.level == 7) { levelMultiplier = 2.2 }
		if (player.fireflames.level == 8) { levelMultiplier = 2.4 }
		if (player.fireflames.level == 9) { levelMultiplier = 2.6 }
		if (player.fireflames.level >= 10) { levelMultiplier = 2.8 }
		let totalDamage = Math.ceil(damageWithBurn * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Burn',
		refName: 'burn',
		stacks: 0,
		duration: 30000,
		maxStacks: function() {
			return player.fireflames.level + 2
		},
		damage: function() {
			let damage = player.fireflames.damage() * 2
			return damage
		}
	},
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1.0,
	chambered: false,
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		calculateBurnEffect(enemy, spell, damageBeforeMagicResist)
		if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`With a wave of your arm you send a ball of `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Fire `, 'fire', line1)
		customizeEachWord(`hurling towards the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	description: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`Fireflames is the first spell learned by a Pyromancer, and is the base spell for enhancing their other spells. Fireflames is a single target spell that deals damage and applies the debuff Burn to the target. Each stack of Burn increases the damage of all your fire spells against that target. See Inferno for the special interaction that it has with Burn.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
fireflames.addToPlayer()


const inferno = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Inferno',
	refName: 'inferno',
	color: 'fire',
	conjureBarColor: 'fire-conjure',
	type: 'fire',
	element: 'fire',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.inferno.level <= 1) {return 15 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 2) {return 30 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 3) {return 45 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 4) {return 60 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 5) {return 75 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 6) {return 90 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 7) {return 105 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 8) {return 120 * player.sorceryMastery.reduction()}
		if (player.inferno.level == 9) {return 135 * player.sorceryMastery.reduction()}
		if (player.inferno.level >= 10) {return 150 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.inferno.level <= 1) {spellLevelReduction = 0}
		if (player.inferno.level == 2) {spellLevelReduction = 0}
		if (player.inferno.level == 3) {spellLevelReduction = 0}
		if (player.inferno.level == 4) {spellLevelReduction = 0}
		if (player.inferno.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.inferno.level <= 1) {spellLevelReduction = 0}
		if (player.inferno.level == 2) {spellLevelReduction = 0}
		if (player.inferno.level == 3) {spellLevelReduction = 0}
		if (player.inferno.level == 4) {spellLevelReduction = 0}
		if (player.inferno.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		fireSpellConjure.play()
	},
	castAudio: function() {
		infernoArray[randomNumberRange(0, 2)].play()
	},
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.inferno)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.inferno)
	},
	damage: function(enemy) {
		let burnStacks = enemy?.debuffs?.burn?.stacks ? enemy?.debuffs?.burn?.stacks : 0
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damageBeforeBonus = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let burnBonusDamage = ((burnStacks * player.burn.bonusModifier()) + 1)
		let damageWithBurn = damageBeforeBonus * burnBonusDamage
		let levelMultiplier
		if (player.inferno.level == 0) { levelMultiplier = 1 }
		if (player.inferno.level == 1) { levelMultiplier = 1.5 }
		if (player.inferno.level == 2) { levelMultiplier = 1.7 }
		if (player.inferno.level == 3) { levelMultiplier = 1.9 }
		if (player.inferno.level == 4) { levelMultiplier = 2.1 }
		if (player.inferno.level == 5) { levelMultiplier = 2.3 }
		if (player.inferno.level == 6) { levelMultiplier = 2.5 }
		if (player.inferno.level == 7) { levelMultiplier = 2.7 }
		if (player.inferno.level == 8) { levelMultiplier = 2.9 }
		if (player.inferno.level == 9) { levelMultiplier = 3.1 }
		if (player.inferno.level >= 10) { levelMultiplier = 3.3 }
		let totalDamage = Math.ceil(damageWithBurn * levelMultiplier)
		return totalDamage
	},
	botMod: 1.5,
	topMod: 2.5,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.inferno)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Holding out your arms, a raging `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Inferno `, 'fire', line1)
		customizeEachWord(`rapidly forms around you before it surges into the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		// if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		let allEnemiesInRoom = getAllEnemiesInRoom()
		let enemiesToTarget = allEnemiesInRoom.slice(0, allEnemiesInRoom.length);
		let enemyFireResist = enemy?.fireResist ? enemy?.fireResist : 0
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		calculateBurnEffect(enemy, spell, damageBeforeMagicResist, enemiesToTarget)
	},
	specialEffect: function(enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Inferno's `, 'fire', line1)
		customizeEachWord(`explosion blasts the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, 'white', line1)
		customizeEachWord(`${this.name} `, `fire`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
inferno.addToPlayer()

const meteor = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Meteor',
	refName: 'meteor',
	color: 'fire',
	conjureBarColor: 'fire-conjure',
	type: 'fire',
	element: 'fire',
	aoe: true,
	numberOfTargets: 'all',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.meteor.level <= 1) {return 25 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 2) {return 50 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 3) {return 75 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 4) {return 100 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 5) {return 125 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 6) {return 150 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 7) {return 175 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 8) {return 200 * player.sorceryMastery.reduction()}
		if (player.meteor.level == 9) {return 225 * player.sorceryMastery.reduction()}
		if (player.meteor.level >= 10) {return 250 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.meteor.level <= 1) {spellLevelReduction = 0}
		if (player.meteor.level == 2) {spellLevelReduction = 0}
		if (player.meteor.level == 3) {spellLevelReduction = 0}
		if (player.meteor.level == 4) {spellLevelReduction = 0}
		if (player.meteor.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.meteor.level <= 1) {spellLevelReduction = 0}
		if (player.meteor.level == 2) {spellLevelReduction = 0}
		if (player.meteor.level == 3) {spellLevelReduction = 0}
		if (player.meteor.level == 4) {spellLevelReduction = 0}
		if (player.meteor.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		fireSpellConjure.play()
	},
	castAudio: function() {
		meteorArray[randomNumberRange(0, 2)].play()
	},
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.meteor)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.meteor)
	},
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	// Add an effect so that if the enemy has 3 burn stacks when this spell hits, it deals bonus damage
	damage: function(enemy) {
		let burnStacks = enemy?.debuffs?.burn?.stacks ? enemy?.debuffs?.burn?.stacks : 0
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damageBeforeBonus = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let burnBonusDamage = ((burnStacks * player.burn.bonusModifier()) + 1)
		let damageWithBurn = damageBeforeBonus * burnBonusDamage
		let levelMultiplier
		if (player.meteor.level <= 1) { levelMultiplier = 1.0 }
		if (player.meteor.level == 2) { levelMultiplier = 1.2 }
		if (player.meteor.level == 3) { levelMultiplier = 1.4 }
		if (player.meteor.level == 4) { levelMultiplier = 1.6 }
		if (player.meteor.level == 5) { levelMultiplier = 1.8 }
		if (player.meteor.level == 6) { levelMultiplier = 2.0 }
		if (player.meteor.level == 7) { levelMultiplier = 2.2 }
		if (player.meteor.level == 8) { levelMultiplier = 2.4 }
		if (player.meteor.level == 9) { levelMultiplier = 2.6 }
		if (player.meteor.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damageWithBurn * levelMultiplier)
		return totalDamage
	},
	botMod: 2.0,
	topMod: 3.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.meteor)
	},
	cast: function(enemy, spell) {
		let allEnemies = getAllEnemiesInRoom();
		let numberOfTargets = spell.numberOfTargets == 'all' ? allEnemies.length : spell.numberOfTargets;
		let enemiesToTarget = allEnemies.slice(0, numberOfTargets);
		for (let i = 0; i < enemiesToTarget.length; i++) {
			let enemy = enemiesToTarget[i];
			// let damage = Math.ceil(damage / numberOfTargets);
			let damageObject = calculateMagicDamage(enemy, spell)
			let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
			spell.chambered = false
			spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterMagicResist)
			calculateBurnEffect(enemy, spell, damageBeforeMagicResist)
			if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		}
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You hold your arms out above your head as you summon forth a massive `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Meteor`, 'fire', line1)
		customizeEachWord(`. Pulling your arms down, the ball of fire follows your motions as it speeds through the air, exploding as it crashes into the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`Meteor `, 'fire', line1)
		customizeEachWord(`explodes!!! And blasts the `, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `pyromancer-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`fire `, `fire`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
meteor.addToPlayer()

const frostfreeze = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Frostfreeze',
	refName: 'frostfreeze',
	color: 'ice',
	conjureBarColor: 'ice-conjure',
	type: 'ice',
	element: 'ice',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.frostfreeze.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.frostfreeze.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.frostfreeze.level <= 1) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 2) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 3) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 4) {spellLevelReduction = 0}
		if (player.frostfreeze.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.frostfreeze.level <= 1) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 2) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 3) {spellLevelReduction = 0}
		if (player.frostfreeze.level == 4) {spellLevelReduction = 0}
		if (player.frostfreeze.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		iceSpellConjure.play()
	},
	castAudio: function() {
		frostfreezeArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.frostfreeze.level == 1) { levelMultiplier = 1.0 }
		if (player.frostfreeze.level == 2) { levelMultiplier = 1.2 }
		if (player.frostfreeze.level == 3) { levelMultiplier = 1.4 }
		if (player.frostfreeze.level == 4) { levelMultiplier = 1.6 }
		if (player.frostfreeze.level == 5) { levelMultiplier = 1.8 }
		if (player.frostfreeze.level == 6) { levelMultiplier = 2.0 }
		if (player.frostfreeze.level == 7) { levelMultiplier = 2.2 }
		if (player.frostfreeze.level == 8) { levelMultiplier = 2.4 }
		if (player.frostfreeze.level == 9) { levelMultiplier = 2.6 }
		if (player.frostfreeze.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Frostbite',
		refName: 'frostbite',
		stacks: 0,
		maxStacks: function() {
			return 3
		},
	},
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.frostfreeze)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let enemyIceResist = enemy.iceResist
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		calculateFrostbiteEffect(enemy, spell, damageObject)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Ice particles crystallize around your hand. You swing your arm sending a barrage of ice shards into the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function(enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `cryo-mage-spell-text-color`, line1)
		blankSpace()
	},
	specialEffect2: function(enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`${this.name}'s Shatter `, this.color, line2)
		customizeEachWord(`hits `, `green`, line2)
		customizeEachWord(`${enemy.name} `, enemy.color, line2)
		customizeEachWord(`for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
frostfreeze.addToPlayer()
const blizzard = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Blizzard',
	refName: 'blizzard',
	color: 'ice',
	conjureBarColor: 'ice-conjure',
	type: 'ice',
	element: 'ice',
	aoe: true,
	get numberOfTargets() {
		return 2 + this.level
	}, 
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.blizzard.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.blizzard.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.blizzard.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.blizzard.level <= 1) {spellLevelReduction = 0}
		if (player.blizzard.level == 2) {spellLevelReduction = 0}
		if (player.blizzard.level == 3) {spellLevelReduction = 0}
		if (player.blizzard.level == 4) {spellLevelReduction = 0}
		if (player.blizzard.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.blizzard.level <= 1) {spellLevelReduction = 0}
		if (player.blizzard.level == 2) {spellLevelReduction = 0}
		if (player.blizzard.level == 3) {spellLevelReduction = 0}
		if (player.blizzard.level == 4) {spellLevelReduction = 0}
		if (player.blizzard.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		iceSpellConjure.play()
	},
	castAudio: function() {
		blizzardArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.blizzard.level == 1) { levelMultiplier = 1.0 }
		if (player.blizzard.level == 2) { levelMultiplier = 1.2 }
		if (player.blizzard.level == 3) { levelMultiplier = 1.4 }
		if (player.blizzard.level == 4) { levelMultiplier = 1.6 }
		if (player.blizzard.level == 5) { levelMultiplier = 1.8 }
		if (player.blizzard.level == 6) { levelMultiplier = 2.0 }
		if (player.blizzard.level == 7) { levelMultiplier = 2.2 }
		if (player.blizzard.level == 8) { levelMultiplier = 2.4 }
		if (player.blizzard.level == 9) { levelMultiplier = 2.6 }
		if (player.blizzard.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Frostbite',
		refName: 'frostbite',
		stacks: 0,
		maxStacks: function() {
			return 2
		},
		// damage: function() {
		// 	let damage = player.blizzard.damage() * 2
		// 	return damage
		// }
	},
	botMod: 1.5,
	topMod: 2.5,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.blizzard)
	},
	cast: function(undefined, spell) {
		let mainAllEnemies = getAllEnemiesInRoom()
		let numberOfTargets = spell.numberOfTargets > mainAllEnemies.length ? mainAllEnemies.length : spell.numberOfTargets
		let allEnemies = mainAllEnemies.slice(0, numberOfTargets);
		if (checkAvailableEnemy(allEnemies[0])) {return}
		for (let i = 0; i < numberOfTargets; i++) {
			let enemyIceResist = allEnemies[i]?.iceResist ? allEnemies[i]?.iceResist : 0
			let damageObject = calculateMagicDamage(allEnemies[i], spell)
			console.log(damageObject, ' DAMAGE OBJECT')
			let { damageAfterMagicResist, damageResisted } = damageObject
			spell.flavorTextCast(allEnemies[i], damageAfterMagicResist, damageResisted)
			applyDamageToEnemy(allEnemies[i], damageAfterMagicResist)
			if (spell.debuff) {applyDebuff(allEnemies[i], spell.debuff)}
		}
		let spellIndex = player.spellsConjured.indexOf(spell)
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You raise your arms to the sky, conjuring a storm of ice that crashes down onto the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, `cryo-mage-spell-text-color`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
blizzard.addToPlayer()

const cryoclast = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Cryoclast',
	refName: 'cryoclast',
	color: 'ice',
	conjureBarColor: 'ice-conjure',
	type: 'ice',
	element: 'ice',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.cryoclast.level == 1) {return 25 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 2) {return 50 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 3) {return 75 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 4) {return 100 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 5) {return 125 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 6) {return 150 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 7) {return 175 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 8) {return 200 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level == 9) {return 225 * player.sorceryMastery.reduction()}
		if (player.cryoclast.level >= 10) {return 250 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.cryoclast.level <= 1) {spellLevelReduction = 0}
		if (player.cryoclast.level == 2) {spellLevelReduction = 0}
		if (player.cryoclast.level == 3) {spellLevelReduction = 0}
		if (player.cryoclast.level == 4) {spellLevelReduction = 0}
		if (player.cryoclast.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.cryoclast.level <= 1) {spellLevelReduction = 0}
		if (player.cryoclast.level == 2) {spellLevelReduction = 0}
		if (player.cryoclast.level == 3) {spellLevelReduction = 0}
		if (player.cryoclast.level == 4) {spellLevelReduction = 0}
		if (player.cryoclast.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		iceSpellConjure.play()
	},
	castAudio: function() {
		cryoclastArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.cryoclast.level == 1) { levelMultiplier = 1.0 }
		if (player.cryoclast.level == 2) { levelMultiplier = 1.2 }
		if (player.cryoclast.level == 3) { levelMultiplier = 1.4 }
		if (player.cryoclast.level == 4) { levelMultiplier = 1.6 }
		if (player.cryoclast.level == 5) { levelMultiplier = 1.8 }
		if (player.cryoclast.level == 6) { levelMultiplier = 2.0 }
		if (player.cryoclast.level == 7) { levelMultiplier = 2.2 }
		if (player.cryoclast.level == 8) { levelMultiplier = 2.4 }
		if (player.cryoclast.level == 9) { levelMultiplier = 2.6 }
		if (player.cryoclast.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Frostbite',
		refName: 'frostbite',
		stacks: 0,
		maxStacks: function() {
			return 2
		},
		// damage: function() {
		// 	let damage = player.fire.damage() * 2
		// 	return damage
		// }
	},
	botMod: 2.0,
	topMod: 3.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.cryoclast)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		// if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
		let enemyIceResist = enemy?.iceResist ? enemy?.iceResist : 0
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		calculateFrostbiteEffect(enemy, spell, damageObject, enemyIceResist)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You conjure an enormous boulder of ice above your head, launching it at blinding speed into the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, `ice`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect2: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The impact causes the ice around the `, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`to explode in an icy blast!`, `cryo-mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, `ice`, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`ice `, `ice`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
cryoclast.addToPlayer()
const flashbolt = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Flashbolt',
	refName: 'flashbolt',
	color: 'lightning',
	conjureBarColor: 'lightning-conjure',
	type: 'lightning',
	element: 'lightning',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.flashbolt.level == 1) {return 10 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 2) {return 20 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 3) {return 30 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 4) {return 40 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 5) {return 50 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 6) {return 60 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 7) {return 70 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 8) {return 80 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level == 9) {return 90 * player.sorceryMastery.reduction()}
		if (player.flashbolt.level >= 10) {return 100 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.flashbolt.level <= 1) {spellLevelReduction = 0}
		if (player.flashbolt.level == 2) {spellLevelReduction = 0}
		if (player.flashbolt.level == 3) {spellLevelReduction = 0}
		if (player.flashbolt.level == 4) {spellLevelReduction = 0}
		if (player.flashbolt.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.flashbolt.level <= 1) {spellLevelReduction = 0}
		if (player.flashbolt.level == 2) {spellLevelReduction = 0}
		if (player.flashbolt.level == 3) {spellLevelReduction = 0}
		if (player.flashbolt.level == 4) {spellLevelReduction = 0}
		if (player.flashbolt.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		lightningSpellConjure.play()
	},
	castAudio: function() {
		flashboltArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.flashbolt.level == 1) { levelMultiplier = 1.0 }
		if (player.flashbolt.level == 2) { levelMultiplier = 1.2 }
		if (player.flashbolt.level == 3) { levelMultiplier = 1.4 }
		if (player.flashbolt.level == 4) { levelMultiplier = 1.6 }
		if (player.flashbolt.level == 5) { levelMultiplier = 1.8 }
		if (player.flashbolt.level == 6) { levelMultiplier = 2.0 }
		if (player.flashbolt.level == 7) { levelMultiplier = 2.2 }
		if (player.flashbolt.level == 8) { levelMultiplier = 2.4 }
		if (player.flashbolt.level == 9) { levelMultiplier = 2.6 }
		if (player.flashbolt.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Shock',
		refName: 'shock',
		stacks: 0,
		maxStacks: function() {
			return 1
		},
		// damage: function() {
		// 	let damage = player.fire.damage() * 2
		// 	return damage
		// }
	},
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.flashbolt)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let mainAllEnemies = getAllEnemiesInRoom()
		let allEnemies = mainAllEnemies.slice(0, mainAllEnemies.length);
		let enemyLightningResist = enemy.lightningResist
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)
		//if there is more than 1 enemy and it does not have shock debuff
		if (allEnemies.length > 1 && enemy?.debuffs?.shock) {
			let indexOfTarget = allEnemies.indexOf(enemy)
			//Find the next target without a shock debuff as indexes increase - Finds first monster to the right
			for (let i = indexOfTarget; i < allEnemies.length; i++) {
				let enemyToCheck = allEnemies[i + 1]
				if (enemyToCheck && !enemyToCheck?.debuffs?.shock) {
					applyDebuff(enemyToCheck, spell.debuff)
					break
				}
			}
			//Find the next target without a shock debuff as indexes decrease - Finds first monster to the left
			for (let i = indexOfTarget; i < allEnemies.length; i--) {
				let enemyToCheck = allEnemies[i - 1]
				if (enemyToCheck && !enemyToCheck?.debuffs?.shock) {
					applyDebuff(enemyToCheck, spell.debuff)
					break
				}
				if (i == -1) {
					break
				}
			}
		}
		for (let i = 0; i < allEnemies.length; i++) {
			let enemyTarget = allEnemies[i]
			let mainTargetIndex = allEnemies.indexOf(enemy)
			if (enemyTarget?.debuffs?.shock && i != mainTargetIndex) {
				let enemyLightningResist = enemyTarget.lightningResist
				let damageObject = calculateMagicDamage(enemyTarget, spell)
				let { damageAfterMagicResist, damageResisted } = damageObject
				spell.flavorTextCast(enemyTarget, damageAfterMagicResist, damageResisted)
				applyDamageToEnemy(enemyTarget, damageAfterMagicResist)
			}
		}

		if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Holding up your hand, you channel electricity to the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(` in an electric flash!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
flashbolt.addToPlayer()
const chainLightning = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Chain Lightning',
	refName: 'chainLightning',
	color: 'lightning',
	conjureBarColor: 'lightning-conjure',
	type: 'lightning',
	element: 'lightning',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.chainLightning.level == 1) {return 15 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 2) {return 30 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 3) {return 45 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 4) {return 60 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 5) {return 75 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 6) {return 90 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 7) {return 105 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 8) {return 120 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level == 9) {return 135 * player.sorceryMastery.reduction()}
		if (player.chainLightning.level >= 10) {return 150 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.chainLightning.level <= 1) {spellLevelReduction = 0}
		if (player.chainLightning.level == 2) {spellLevelReduction = 0}
		if (player.chainLightning.level == 3) {spellLevelReduction = 0}
		if (player.chainLightning.level == 4) {spellLevelReduction = 0}
		if (player.chainLightning.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.chainLightning.level <= 1) {spellLevelReduction = 0}
		if (player.chainLightning.level == 2) {spellLevelReduction = 0}
		if (player.chainLightning.level == 3) {spellLevelReduction = 0}
		if (player.chainLightning.level == 4) {spellLevelReduction = 0}
		if (player.chainLightning.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		lightningSpellConjure.play()
	},
	castAudio: function() {
		chainLightningArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.chainLightning.level == 1) { levelMultiplier = 1.0 }
		if (player.chainLightning.level == 2) { levelMultiplier = 1.2 }
		if (player.chainLightning.level == 3) { levelMultiplier = 1.4 }
		if (player.chainLightning.level == 4) { levelMultiplier = 1.6 }
		if (player.chainLightning.level == 5) { levelMultiplier = 1.8 }
		if (player.chainLightning.level == 6) { levelMultiplier = 2.0 }
		if (player.chainLightning.level == 7) { levelMultiplier = 2.2 }
		if (player.chainLightning.level == 8) { levelMultiplier = 2.4 }
		if (player.chainLightning.level == 9) { levelMultiplier = 2.6 }
		if (player.chainLightning.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	debuff: {
		name: 'Shock',
		refName: 'shock',
		stacks: 0,
		maxStacks: function() {
			return 2
		},
		// damage: function() {
		// 	let damage = player.fire.damage() * 2
		// 	return damage
		// }
	},
	botMod: 1.5,
	topMod: 2.5,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.chainLightning)
	},
	cast: function(enemy, spell) {
		let numberOfTargets = this.level + 4
		let mainAllEnemies = getAllEnemiesInRoom()
		let allEnemies = mainAllEnemies.slice(0, numberOfTargets);
		for (let i = 0; i < numberOfTargets; i++) {
			if (checkAvailableEnemy2(allEnemies[i])) {break}
			// let damageObject = {
			// 	damageBeforeMagicResist: 0,
			// 	damageAfterMagicResist: 0,
			// 	damageResisted: 0,
			// 	bonusShockDamage: 0,
			// }
			let enemyLightningResist = allEnemies[i].lightningResist ? allEnemies[i].lightningResist : 0
			let damageObject = calculateMagicDamage(allEnemies[i], spell)
			let { damageAfterMagicResist, damageResisted } = damageObject
			if (allEnemies[i]?.debuffs?.shock) {
				quickMessage(`SHOULD CALC BONUS SHOCK damage.`)
				damageObject.bonusShockDamage = calculateShockEffect(allEnemies[i], spell, damageObject)
			} else {
				damageObject.bonusShockDamage = 0
			}
			damageObject.totalDamage = damageObject.damageAfterMagicResist + damageObject.bonusShockDamage
			spell.flavorTextCast(allEnemies[i], damageObject.totalDamage, damageResisted)
			applyDamageToEnemy(allEnemies[i], damageObject.totalDamage)
			if (allEnemies[i]?.debuffs?.shock?.stacks == 1) {applyDebuff(allEnemies[i], spell.debuff)}
			console.log(damageObject, 'Chain Lightning Damage Object')
		}
		let spellIndex = player.spellsConjured.indexOf(spell)
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You hold your arms back as they accumulate lightning energy. Throwing your arms forward, thick tendrils of lightning surge into the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name}`, enemy.color, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The accumulated ice around the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`shatters!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`You hit for `, 'green', line2)
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
chainLightning.addToPlayer()

const gigavolt = {
		get level() {
		return calculateStat(player, this.refName)
	},
	name: 'Gigavolt',
	refName: 'gigavolt',
	color: 'lightning',
	conjureBarColor: 'lightning-conjure',
	type: 'lightning',
	element: 'lightning',
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.gigavolt.level == 1) {return 25 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 2) {return 50 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 3) {return 75 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 4) {return 100 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 5) {return 125 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 6) {return 150 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 7) {return 175 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 8) {return 200 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level == 9) {return 225 * player.sorceryMastery.reduction()}
		if (player.gigavolt.level >= 10) {return 250 * player.sorceryMastery.reduction()}
	},
	conjureTime: function() {
		let baseConjureTime = 4000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.gigavolt.level <= 1) {spellLevelReduction = 0}
		if (player.gigavolt.level == 2) {spellLevelReduction = 0}
		if (player.gigavolt.level == 3) {spellLevelReduction = 0}
		if (player.gigavolt.level == 4) {spellLevelReduction = 0}
		if (player.gigavolt.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 4000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.gigavolt.level <= 1) {spellLevelReduction = 0}
		if (player.gigavolt.level == 2) {spellLevelReduction = 0}
		if (player.gigavolt.level == 3) {spellLevelReduction = 0}
		if (player.gigavolt.level == 4) {spellLevelReduction = 0}
		if (player.gigavolt.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {
		lightningSpellConjure.play()
	},
	castAudio: function() {
		gigavoltArray[randomNumberRange(0, 2)].play()
	},
	damage: function() {
		let botDamage = player.spellPower * this.botMod
		let topDamage = player.spellPower * this.topMod
		let damage = Math.pow(randomNumberRange(botDamage, topDamage), this.proficiency)
		let levelMultiplier
		if (player.gigavolt.level == 1) { levelMultiplier = 1.0 }
		if (player.gigavolt.level == 2) { levelMultiplier = 1.2 }
		if (player.gigavolt.level == 3) { levelMultiplier = 1.4 }
		if (player.gigavolt.level == 4) { levelMultiplier = 1.6 }
		if (player.gigavolt.level == 5) { levelMultiplier = 1.8 }
		if (player.gigavolt.level == 6) { levelMultiplier = 2.0 }
		if (player.gigavolt.level == 7) { levelMultiplier = 2.2 }
		if (player.gigavolt.level == 8) { levelMultiplier = 2.4 }
		if (player.gigavolt.level == 9) { levelMultiplier = 2.6 }
		if (player.gigavolt.level >= 10) { levelMultiplier = 3.0 }
		let totalDamage = Math.ceil(damage * levelMultiplier)
		return totalDamage
	},
	botMod: 2.0,
	topMod: 3.0,
	proficiency: 1.0,
	chambered: false,
	goldToUpgrade: function () {
		return spellGoldUpgradeCost(player.gigavolt)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.gigavolt)
	},
	cast: function(enemy, spell) {
		if (checkAvailableEnemy(enemy)) {return}
		let enemyLightningResist = enemy.lightningResist
		let spellIndex = player.spellsConjured.indexOf(spell)
		let damageObject = calculateMagicDamage(enemy, spell)
		let { damageAfterMagicResist, damageResisted } = damageObject
		// player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterMagicResist)

		let allEnemies = getAllEnemiesInRoom()
		let allConduitEnemies = allEnemies.filter(enemy => enemy?.debuffs?.shock?.stacks == 2)
		allConduitEnemies.forEach(enemy => {
			let enemyLightningResist = enemy.lightningResist
			let spellIndex = player.spellsConjured.indexOf(spell)
			let damageObject = calculateMagicDamage(enemy, spell)
			let { damageAfterMagicResist, damageResisted } = damageObject
			spell.chambered = false
			spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterMagicResist)
		})
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`The air crackles with electricity as you channel a giant bolt of lightning from the sky that spirals into the `, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`with a deafening boom!`, `lightning-magus-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line2)
		customizeEachWord(`hits for `, `green`, line2)		
		customizeEachWord(`${damage} `, 'light-blue', line2)
		customizeEachWord(`lightning `, `lightning`, line2)
		customizeEachWord(`damage. `, `green`, line2)
		customizeEachWord(`(Enemy resists `, `white`, line2)
		customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	specialEffect: function (enemy, damage, damageResisted) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`FIX GFIX FGIX IFG `, `lightning-magus-spell-text-color`, line1)
		// customizeEachWord(`${enemy.name} `, enemy.color, line1)
		// customizeEachWord(`shatters!`, `lightning-magus-spell-text-color`, line1)
		// customizeEachWord(`You hit for `, 'green', line2)
		// customizeEachWord(`${damage} `, 'light-blue', line2)
		// customizeEachWord(`lightning `, `lightning`, line2)
		// customizeEachWord(`damage. `, `green`, line2)
		// customizeEachWord(`(Enemy resists `, `white`, line2)
		// customizeEachWord(`${damageResisted}`, `light-blue`, line2)
		// customizeEachWord(`)`, `white`, line2)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
gigavolt.addToPlayer()

const heal = {
	name: 'Heal',
	refName: 'heal',
	color: 'heal',
	type: 'restorative',
		get level() {
		return calculateStat(player, this.refName)
	},
	conjureTime: function() {
		let baseConjureTime = 6000
		let clearMindReduction = player.clearMind.reduction()
		let spellLevelReduction 
		if (player.heal.level <= 1) {spellLevelReduction = 0}
		if (player.heal.level == 2) {spellLevelReduction = 0}
		if (player.heal.level == 3) {spellLevelReduction = 0}
		if (player.heal.level == 4) {spellLevelReduction = 0}
		if (player.heal.level >= 5) {spellLevelReduction = 0}
		let totalConjureTime = baseConjureTime - clearMindReduction - spellLevelReduction
		return totalConjureTime
	},
	channelTime: function() {
		let baseChannelTime = 6000
		let magicDexterity = player.magicDexterity.reduction()
		let spellLevelReduction 
		if (player.heal.level <= 1) {spellLevelReduction = 0}
		if (player.heal.level == 2) {spellLevelReduction = 0}
		if (player.heal.level == 3) {spellLevelReduction = 0}
		if (player.heal.level == 4) {spellLevelReduction = 0}
		if (player.heal.level >= 5) {spellLevelReduction = 0}
		let totalChannelTime = baseChannelTime - magicDexterity - spellLevelReduction
		return totalChannelTime	
	},
	conjureAudio: function() {

	},
	resourceName: 'mana', 
	resourceCost: function() {
		if (player.heal.level == 1) {return 20 * player.mysticismMastery.reduction()}
		if (player.heal.level == 2) {return 35 * player.mysticismMastery.reduction()}
		if (player.heal.level == 3) {return 52 * player.mysticismMastery.reduction()}
		if (player.heal.level == 4) {return 70 * player.mysticismMastery.reduction()}
		if (player.heal.level == 5) {return 91 * player.mysticismMastery.reduction()}
		if (player.heal.level == 6) {return 113 * player.mysticismMastery.reduction()}
		if (player.heal.level == 7) {return 137 * player.mysticismMastery.reduction()}
		if (player.heal.level == 8) {return 162 * player.mysticismMastery.reduction()}
		if (player.heal.level == 9) {return 189 * player.mysticismMastery.reduction()}
		if (player.heal.level >= 10) {return 215 * player.mysticismMastery.reduction()}
	},
	conjureBarColor: 'restorative-spell',
	botMod: 1.0,
	topMod: 2.0,
	proficiency: 1,
	chambered: false,
	color: 'heal',
	heal: function() {
		let botHeal = player.mysticPower * this.botMod
		let topHeal = player.mysticPower * this.topMod
		let healAmount = Math.pow(randomNumberRange(botHeal, topHeal), this.proficiency)
		let levelMultiplier
		if (player.heal.level == 1) { levelMultiplier = 1.0 }
		if (player.heal.level == 2) { levelMultiplier = 1.2 }
		if (player.heal.level == 3) { levelMultiplier = 1.4 }
		if (player.heal.level == 4) { levelMultiplier = 1.6 }
		if (player.heal.level == 5) { levelMultiplier = 1.8 }
		if (player.heal.level == 6) { levelMultiplier = 2.0 }
		if (player.heal.level == 7) { levelMultiplier = 2.2 }
		if (player.heal.level == 8) { levelMultiplier = 2.4 }
		if (player.heal.level == 9) { levelMultiplier = 2.6 }
		if (player.heal.level >= 10) { levelMultiplier = 3.0 }
		let totalHeal = Math.ceil(healAmount * levelMultiplier)
		return totalHeal
	},
	goldToUpgrade: function () {
		spellGoldUpgradeCost(player.heal)
	},
	pointsToUpgrade: function () {
		return spellUpgradeCost(player.heal)
	},
	cast: function() {
		let healAmount = player.heal.heal()
		healAmount = player.health + healAmount > player.maxHealth ? player.maxHealth - player.health : healAmount
		this.chambered = false
		this.flavorTextCast(healAmount)
		applyHealToPlayer(healAmount)
	},
	flavorTextConjure: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you conjure `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.conjureTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextChannel: function (enemy) {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You shape your hands in concentration as you channel `, `mage-spell-text-color`, line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime() / 1000}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		blankSpace()
	},
	flavorTextCast: function (healAmount) {
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		blankSpace()
		customizeEachWord(`You place your hands on your chest and a green glow sinks into your body as you `, 'white', line1)
		customizeEachWord(`${this.name} `, this.color, line1)
		customizeEachWord(`Yourself.`, 'white', line1)
		customizeEachWord(`You heal for `, 'green', line2)
		customizeEachWord(`${healAmount} `, 'light-blue', line2)
		customizeEachWord(`health.`, 'green', line2)
		blankSpace()

	},
	description: function () {
		let line1 = document.createElement('div')
		blankSpace()
		customizeEachWord(`Heal `, this.color, line1)
		customizeEachWord(`will heal yourself for an amount based on your Mysticpower.`, 'white', line1)
		blankSpace()
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
heal.addToPlayer()

//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////
//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////
//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////
//////////////////////////////////////////SPELLS SPELLS SPELLS SPELLS///////////////////////

//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
// const firefist = {
// 	name: 'Fire Fist',
// 	refName: 'fireFist',
// 	color: 'fire-fist-color',
// 	type: 'enchantment',
// 	enchantWeaponOrArmor: 'weapon',
// 	level: 1,
// 	conjureTime: function() {return 2000},
// 	channelTime: 4.0,
// 	damage: 5,
// 	botMod: 1.0,
// 	topMod: 3.5,
// 	proficiency: 1.0,
// 	duration: 1000000,
// 	chambered: false,
// 	color: 'fire',
// 	buff: {
// 		name: 'Fire Fist',
// 		refName: 'fireFist',
// 		duration: 100000,
// 		onHit: true,
// 	},
// 	onHit: function (weapon, damage, enemy) {
// 		let line1 = document.createElement('div')
// 		customizeEachWord(`A burst of flames erupts from your `, 'white', line1)
// 		customizeEachWord(`${weapon.name} `, weapon.color, line1)
// 		customizeEachWord(`blasting the `, 'white', line1)
// 		customizeEachWord(`${enemy.name} `, enemy.color, line1)
// 		customizeEachWord(`for `, 'white', line1)
// 		customizeEachWord(`${damage} `, 'blue', line1)
// 		customizeEachWord(`damage.`, 'white', line1)
// 	},
// 	goldToUpgrade: function () {
// 		return 9 * this.level
// 	},
// 	pointsToUpgrade: function () {
// 		return this.level + 1
// 	},
// 	channel: function () {
// 		let line1 = document.createElement('div')
// 		customizeEachWord(`You `, 'light-blue', line1)
// 		customizeEachWord(`shape your hands in concentration as you channel `, 'white', line1)
// 		customizeEachWord(`Fire Fist `, 'ice-color', line1)
// 		customizeEachWord(`[`, 'white', line1)
// 		customizeEachWord(`${this.channelTime}`, 'yellow', line1)
// 		customizeEachWord(`]`, 'white', line1)
// 	},
// }
// player.firefist = {...firefist}
const lightningFistEnchant = {
	name: 'Lightning Fist',
	refName: 'lightningFistEnchant',
	color: 'lightning-fist-color',
	type: 'enchantment',
	enchantWeaponOrArmor: 'weapon',
		get level() {
		return calculateStat(player, this.refName)
	},
	conjureTime: 1.0,
	channelTime: 1.0,
	damage: 5,
	botMod: 2.0,
	topMod: 5.5,
	proficiency: 1.0,
	duration: 10000,
	chambered: false,
	color: 'lightning-spell',
	onHit: function (weapon, damage, enemy) {
		let line1 = document.createElement('div')
		customizeEachWord(`Sparks explode from your `, 'white', line1)
		customizeEachWord(`${weapon.name} `, weapon.color, line1)
		customizeEachWord(`as it impacts the `, 'white', line1)
		customizeEachWord(`${enemy.name}, `, enemy.color, line1)
		customizeEachWord(`shocking it for `, 'white', line1)
		customizeEachWord(`${damage} `, 'blue', line1)
		customizeEachWord(`damage.`, 'white', line1)
	},
	goldToUpgrade: function () {
		return 9 * this.level
	},
	pointsToUpgrade: function () {
		return this.level + 1
	},
	channel: function () {
		let line1 = document.createElement('div')
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`shape your hands in concentration as you channel `, 'white', line1)
		customizeEachWord(`Fire Fist `, 'ice-color', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${this.channelTime}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
	},
	cast: function (weapon) {
		let line1 = document.createElement('div')
		customizeEachWord(`With a wave of `, 'white', line1)
		customizeEachWord(`your `, 'light-blue', line1)
		customizeEachWord(`arm you send an `, 'white', line1)
		customizeEachWord(`Ice `, 'ice-color', line1)
		customizeEachWord(`hurling towards the `, 'white', line1)
		customizeEachWord(`${enemy.name}!`, `${enemy.color}`, line1)
	},
	description: function (weapon) {
		let line1 = document.createElement('div')
		customizeEachWord(`You `, 'light-blue', line1)
		customizeEachWord(`freeze the `, 'green', line1)
		customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
		customizeEachWord(`for `, 'green', line1)
		customizeEachWord(`${damage} `, 'light-blue', line1)
		customizeEachWord(`ice damage.`, `${this.color}`, line1)
	},
	addToPlayer: function() {
		player[this.refName] = {}
		copyGettersAndSetters(player[this.refName], this)
	},
}
lightningFistEnchant.addToPlayer()
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////
//////////////////////////////////////////ENCHANTMENTS ENCHANTMENTS ENCHANTMENTS///////////////////////


const allItems = []
// player.spells.push(fire)
// player.spells.push(fireFist)
// player.spells.push(ice)
// player.spells.push(lightningFist)
//---------------------------------------------------

function getUnarmedAttackPower(modifiers) {
	if (modifiers) {
		let attackPowerTotal = [...modifiers].reduce((a, b) => a + b) + player.unarmedAttackPower
		return attackPowerTotal
	} else {
		return player.unarmedAttackPower
	}
}
function getUnarmedSkillDamageMultiplier(modifiers) {
	if (modifiers) {
		let unarmedDamage = [...modifiers].reduce((a, b) => a + b) + player.botMultiplier
		return unarmedDamage
	} else {
		return player.unarmed.botMultiplier
	}
}

//-------------------------------------------------

function getOneHandedAttackPower(modifiers) {
	if (modifiers) {
		let attackPowerTotal = [...modifiers].reduce((a, b) => a + b) + player.oneHandedAttackPower
		return attackPowerTotal
	} else {
		return player.oneHandedAttackPower
	}
}

//__________________________________________________________________________________________________________________________________
//__________________________________________________________________________________________________________________________________

//________________________________________________________________________________________________________________________________________
//________________________________________________________________________________________________________________________________________

function displayPlayerHealthFunc() {}

var playerProxy = new Proxy(player, {
	set: function (target, key, value) {
		target[key] = value
		return true
	},
})

function displayPlayerStats() {
const playerLevel = document.querySelector('.level')

const attributeStr = document.querySelector('.str-number')
const attributeStrMod = document.querySelector('.str-mod')
const attributeDex = document.querySelector('.dex-number')
const attributeDexMod = document.querySelector('.dex-mod')
const attributeAgi = document.querySelector('.agi-number')
const attributeAgiMod = document.querySelector('.agi-mod')
const attributeInt = document.querySelector('.int-number')
const attributeIntMod = document.querySelector('.int-mod')
const attributeWis = document.querySelector('.wis-number')
const attributeWisMod = document.querySelector('.wis-mod')
const attributeMys = document.querySelector('.mys-number')
const attributeMysMod = document.querySelector('.mys-mod')
const attributeCon = document.querySelector('.con-number')
const attributeConMod = document.querySelector('.con-mod')

const statAttack = document.querySelector('.attack-number')
const statAccuracy = document.querySelector('.accuracy-number')
const statSpeed = document.querySelector('.speed-number')
const statSpellpower = document.querySelector('.spellpower-number')
const statMysticpower = document.querySelector('.mysticpower-number')

const statArmorSlashing = document.querySelector('.slashing-armor-number')
const statArmorPiercing = document.querySelector('.piercing-armor-number')
const statArmorBlunt = document.querySelector('.blunt-armor-number')
const statDodge = document.querySelector('.dodge-number')
const statWeightEffective = document.querySelector('.weight-effective-number')
const statWeightTotal = document.querySelector('.weight-total-number')

playerLevel.innerHTML = `Level ${player.level}`

attributeStr.innerHTML = `Str ${player.baseStats.str ?? 0}`
attributeStrMod.innerHTML = calculateBonusStat(player, 'str') > 0 ? ` +${calculateBonusStat(player, 'str')}` : ``
attributeDex.innerHTML = `Dex ${player.baseStats.dex ?? 0}`
attributeDexMod.innerHTML = calculateBonusStat(player, 'dex') > 0 ? ` +${calculateBonusStat(player, 'dex')}` : ``
attributeAgi.innerHTML = `Agi ${player.baseStats.agi ?? 0}`
attributeAgiMod.innerHTML = calculateBonusStat(player, 'agi') > 0 ? ` +${calculateBonusStat(player, 'agi')}` : ``
attributeInt.innerHTML = `Int ${player.baseStats.int ?? 0}`
attributeIntMod.innerHTML = calculateBonusStat(player, 'int') > 0 ? ` +${calculateBonusStat(player, 'int')}` : ``
attributeWis.innerHTML = `Wis ${player.baseStats.wis ?? 0}`
attributeWisMod.innerHTML = calculateBonusStat(player, 'wis') > 0 ? ` +${calculateBonusStat(player, 'wis')}` : ``
attributeMys.innerHTML = `Mys ${player.baseStats.mys ?? 0}`
attributeMysMod.innerHTML = calculateBonusStat(player, 'mys') > 0 ? ` +${calculateBonusStat(player, 'mys')}` : ``
attributeCon.innerHTML = `Con ${player.baseStats.con ?? 0}`
attributeConMod.innerHTML = calculateBonusStat(player, 'con') > 0 ? ` +${calculateBonusStat(player, 'con')}` : ``

statAttack.innerHTML = `${player.currentWeaponSkill.attackPower}`
statAccuracy.innerHTML = `${(player.currentWeaponSkill.accuracy + 75)}%`
statSpeed.innerHTML = `${player.currentWeaponSkill.speed}`
statSpellpower.innerHTML = `${player.spellPower}`
statMysticpower.innerHTML = `${player.mysticPower}`

statArmorSlashing.innerHTML = `${player.slashingArmor}`
statArmorPiercing.innerHTML = `${player.piercingArmor}`
statArmorBlunt.innerHTML = `${player.bluntArmor}`
statDodge.innerHTML = `${player.dodge + 25}%`

statWeightEffective.innerHTML = `${player.burden}`
statWeightTotal.innerHTML = `${player.weight}`

let percent = (player.mana / player.maxMana) * 100
manaBar.style.width = `${percent}%`
manaText.innerHTML = `Mana: ${player.mana}/${Math.max(0, player.maxMana || 0)}`

let healthPercent = (player.health / player.maxHealth) * 100 > 100 ? 100 : (player.health / player.maxHealth) * 100 
healthBar.style.width = `${healthPercent}%`
healthText.innerHTML = `Health: ${player.health}/${isNaN(player.maxHealth) ? 0 : player.maxHealth}`
if (player.magicShield > 0) {
	let healthPercent = (player.magicShield / player.maxShield) * 100 > 100 ? 100 : (player.magicShield / player.maxShield) * 100 
	magicShieldBar.style.width = `${healthPercent}%`
	magicShieldBar.innerHTML = `Shield: ${player.magicShield}`
} else {
	magicShieldBar.style.width = `0%`
	magicShieldBar.innerHTML = ``
}

///////////////////////////////////////////////////////////////////////

}

/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////

const warriorTemplate = {
	maxHealth: 30,
}
const healthBar = document.querySelector('.health-bar')
const magicShieldBar = document.querySelector('.magic-shield-bar')
const healthText = document.querySelector('.health-text')
const manaBar = document.querySelector('.mana-bar')
const manaText = document.querySelector('.mana-text')
const resourceBar = document.querySelector('.class-resource-bar')
const resourceText = document.querySelector('.class-resource-text')
const currentAttributes = document.querySelectorAll('.attribute')
const currentWeaponSkillRightDisplay = document.querySelector('.current-weapon-skill-right')
const currentWeaponSkillLeftDisplay = document.querySelector('.current-weapon-skill-left')
const expBar = document.querySelector('.exp-bar')
expBar.textContent


function updateResource() {
	let resource
	let maxResource
	let resourceName
	switch (player.guild) {
		case 'Warrior':
			resource = 'might'
			maxResource = 'maxMight'
			resourceName = 'Might'
			resourceBar.classList.add('warrior-resource-bar')
			break;
		case 'Sinistral':
			resource = 'adrenaline'
			maxResource = 'maxAdrenaline'
			resourceName = 'Adrenaline'
			resourceBar.classList.add('sinistral-resource-bar')

			break;
		case 'Monk':
			resource = 'focus'
			maxResource = 'maxFocus'
			resourceName = 'Focus'
			resourceBar.classList.add('monk-resource-bar')

			break;
		case 'Ranger':
			resource = 'focus'
			maxResource = 'maxFocus'
			resourceName = 'Focus'
			resourceBar.classList.add('ranger-resource-bar')
			break;
		default:
			resource = ''
			maxResource = ''
			resourceName = ''
	}
	player.maxResource = 30
	const percent =  resource ? (player[resource] / player[maxResource]) * 100 : resource
	resourceBar.style.width =  resource ? `${percent}%` : ``
	resourceText.innerHTML = resource ? `${capitalizeFirstLetter(resourceName)}: ${player[resource]}/${player[maxResource]}` : ``
}
function updateHealth() {
	const percent = (player.health / player.maxHealth) * 100 > 100 ? 100 : (player.health / player.maxHealth) * 100 
	healthBar.style.width = `${percent}%`
	healthText.innerHTML = `Health: ${player.health}/${isNaN(player.maxHealth) ? 0 : player.maxHealth}`
	if (player.magicShield > 0) {
		const percent = (player.magicShield / player.maxShield) * 100 > 100 ? 100 : (player.magicShield / player.maxShield) * 100 
		magicShieldBar.style.width = `${percent}%`
		magicShieldBar.innerHTML = `Shield: ${player.magicShield}`
	} else {
		magicShieldBar.style.width = `0%`
		magicShieldBar.innerHTML = ``
	}
}
function updateEXP() {
	let currentExp = player.experience
	let currentExpBracket = player.experienceNeededToLevel[player.level - 1]
	let nextExpBracket = player.experienceNeededToLevel[player.level]

	let bracketBase = nextExpBracket - currentExpBracket
	let newExpBase = currentExp - currentExpBracket
	let percentOfTheWayThere = parseInt((newExpBase / bracketBase) * 100).toFixed(2)
	expBar.style.width = `${percentOfTheWayThere}%`
}

function updateMana() {
	// let manaFromWisdom = (player.wis + player.wis) * 10
	// let multipliers = preClass.manaMultiplier + player.devotion.manaMultiplier()
	// let flatBonuses = preRace.maxMana + preClass.maxMana + player.maxMana + (preClass.manaPerLevel * player.level)

	// player.maxMana = Math.ceil((manaFromWisdom * multipliers) + flatBonuses)
}
function updateTwoHanded() {
	// let str = player.str + player.mods.str
	// let dex = player.dex + player.mods.dex
	// let agi = player.agi + player.mods.agi

	// let twoHandedAttributes = ((str * 2) + dex + agi) - 4
	// player.twoHanded.attackPower = Math.floor((twoHandedAttributes + player.mods.attackPower) * 0.5)
	// player.twoHanded.topMultiplier = parseFloat((0.05 + player.twoHanded.level / 20).toFixed(2))
	// player.twoHanded.botMultiplier = parseFloat((0.05 + player.twoHanded.level / 20).toFixed(2))
	// player.twoHanded.accuracy = Math.floor(10 + ((dex * 3) + player.twoHanded.level + player.mods.accuracy) * 10) / 10
	// player.twoHanded.speed = player.twoHanded.speed <= 2 ? 2 : parseFloat((6.2 - Math.floor((player.twoHanded.level / 5) * 100) / 100).toFixed(1))
	// player.twoHanded.speed += player.weight * 0.1
}
function copyGettersAndSetters(target, source) {
	Object.keys(source).forEach(key => {
	  let descriptor = Object.getOwnPropertyDescriptor(source, key);
	  Object.defineProperty(target, key, descriptor);
	});
  }

function updateOneHanded() {
	// let str = player.str + player.mods.str
	// let dex = player.dex + player.mods.dex
	// const rightWeapon = player.currentRightHandWeapon().skillUsed;
	// const leftWeapon = player.currentLeftHandWeapon().skillUsed;
	// //This is basically saying, if the player is dual wielding daggers or swords, apply the accuracy penalty of -10
	// if ((leftWeapon === 'daggers' || leftWeapon === 'oneHanded') &&
    // (rightWeapon === 'daggers' || rightWeapon === 'oneHanded')) {
	// 	player.oneHanded.accuracy = Math.floor(((dex + player.oneHanded.level + player.mods.accuracy) * 10) / 10) - 10
	// } else {
	// 	player.oneHanded.accuracy = Math.floor(10 + (dex + player.oneHanded.level + player.mods.accuracy) * 10) / 10
	// }
	// let oneHandedAttributes = str + dex
	// player.oneHanded.attackPower = Math.floor((oneHandedAttributes + player.mods.attackPower) * 0.5)
	// player.oneHanded.topMultiplier = parseFloat((0.05 + player.oneHanded.level / 20).toFixed(2)) //parseFloat((0.40 + 1 / 20).toFixed(2));
	// player.oneHanded.botMultiplier = parseFloat((0.05 + player.oneHanded.level / 20).toFixed(2))
	// player.oneHanded.speed = player.oneHanded.speed <= 2 ? 2 : parseFloat((5.1 - Math.floor((player.oneHanded.level / 5) * 100) / 100).toFixed(1))
	// player.oneHanded.speed += player.weight * 0.1
}

function updateDaggers() {
// 	// let str = player.str + player.mods.str
// 	let dex = player.dex + player.mods.dex
// 	let agi = player.agi + player.mods.agi
// 	let dualSwingPenalty = 10

// 	let daggersAttributes = dex + agi
// //mods
// 	player.daggers.attackPower = Math.ceil((daggersAttributes  + player.mods.attackPower) * 0.5)
// 	player.daggers.topMultiplier = parseFloat((0.05 + player.daggers.level / 20).toFixed(2))
// 	player.daggers.botMultiplier = parseFloat((0.05 + player.daggers.level / 20).toFixed(2))
// 	//1 point of dex increases accuracy by 1
// 	player.daggers.speed = player.daggers.speed <= 2 ? 2 : parseFloat((5.1 - Math.floor((player.daggers.level / 5) * 100) / 100).toFixed(1))
// 	player.daggers.speed += player.weight * 0.1

}

function updateUnarmed() {
	// let str = player.str + player.mods.str
	// let dex = player.dex + player.mods.dex
	// let agi = player.agi + player.mods.agi
	// let dualSwingPenalty = 10
	// let unarmedAttributes = str + dex + agi

	// player.unarmed.attackPower = Math.ceil((unarmedAttributes + player.mods.attackPower) * 0.5)
	// player.unarmed.topMultiplier = parseFloat((0.05 + player.unarmed.level / 20).toFixed(2))
	// player.unarmed.botMultiplier = parseFloat((0.05 + player.unarmed.level / 20).toFixed(2))
	// player.unarmed.accuracy = Math.floor(10 + (dex + player.mods.accuracy + player.unarmed.level - dualSwingPenalty) * 10) / 10
	// player.unarmed.speed = parseFloat((4.1 - Math.floor((player.unarmed.level / 5) * 100) / 100).toFixed(1) < 2 ? 2 : parseFloat((4.1 - Math.floor((player.unarmed.level / 10) * 100) / 100).toFixed(1)))
	// player.unarmed.speed += player.weight * 0.1
}

function updateBows() {
	// let dex = player.dex + player.mods.dex
	// let agi = player.agi + player.mods.agi
	// let bowsAttributes = dex + agi

	// player.bows.attackPower = Math.ceil((bowsAttributes + player.mods.attackPower) * 0.5)
	// player.bows.topMultiplier = parseFloat((0.05 + player.bows.level / 20).toFixed(2))
	// player.bows.botMultiplier = parseFloat((0.05 + player.bows.level / 20).toFixed(2))
	// player.bows.accuracy = Math.floor(10 + (dex + player.bows.level + player.mods.accuracy) * 10) / 10
	// player.bows.speed = player.bows.speed <= 2 ? 2 : parseFloat((5.1 - Math.floor((player.bows.level / 5) * 100) / 100).toFixed(1))
	// player.bows.speed += player.weight * 0.1
}

function updateEquipmentMods() {
	//Collects all bonuses from equipped and wielding items
	let nonBackpackItems = getAllItemsOnPerson().filter(item => item.roomId != 'backpack')
	let modsObject = {}
	for (let mod in player.equipmentMods) {
		player.equipmentMods[mod] = 0
	}
	for (let i = 0; i < nonBackpackItems.length; i++) {
		if (nonBackpackItems[i].type.armor && nonBackpackItems[i].roomId == 'right hand' || nonBackpackItems[i].roomId == 'left hand') {
		} else {
			for (let mod in nonBackpackItems[i].mods) {
				modsObject[mod] ? modsObject[mod] += nonBackpackItems[i].mods[mod] : modsObject[mod] = nonBackpackItems[i].mods[mod]
			}
		}
	}
	console.log(modsObject)
	for (let mod in modsObject) {
		player.equipmentMods[mod] = modsObject[mod]
	}
	displayPlayerStats()
}
function updateBuffMods() {
	let modsObject = {}
	if (Object.entries(player?.buffs).length != 0) {
		for (let buff in player.buffs) {
			// buffName would be fury: {}
			let buffName = player.buffs[buff]
			for (let mod in buffName.mods) {
				modsObject[mod] ? modsObject[mod] += buffName.mods[mod] : modsObject[mod] = buffName.mods[mod]
			}
		}
	}
	console.log(modsObject)
	for (let mod in modsObject) {
		player.buffMods[mod] = modsObject[mod]
	}
	displayPlayerStats()
}
function updateDebuffMods() {
	let modsObject = {}
	if (Object.entries(player?.debuffs).length != 0) {
		for (let debuff in player.debuffs) {
			modsObject[debuff] ? modsObject[debuff] += player.debuffs[debuff].mods[debuff] : modsObject[debuff] = player.buffs[debuff].mods[debuff]
		}
	}
	console.log(modsObject)
	for (let mod in modsObject) {
		player.debuffMods[mod] = modsObject[mod]
	}
	displayPlayerStats()
}


function updateShields() {
	let str = player.str
	let dex = player.dex 
	let agi = player.agi 
	let con = player.con 
	let armor = player.armor
	let weight = player.weight
	let shieldsAttributes = str / 2 + con * 2
	let shieldsArmorAndWeightBonus = armor + weight / 5

	player.shields.attackPower = Math.ceil(shieldsArmorAndWeightBonus + shieldsAttributes)
	player.shields.topMultiplier = parseFloat((0.45 + player.shields.level / 20).toFixed(2))
	player.shields.botMultiplier = parseFloat((0.45 + player.shields.level / 20).toFixed(2))
	player.shields.accuracy = Math.floor(10 + (shieldsAttributes + player.shields.level + player.accuracy) * 10) / 10
	player.shields.speed = player.shields.speed <= 0 ? 2 : (6.1 - Math.floor((player.shields.level / 10) * 100) / 100).toFixed(1)
}

function updateDodge() {
	//SHOULD MAKE AGILITY FACTOR INTO DODGE
	//every point of agility gives 3 to dodge
	// let calculatedDodge = (player.level + player.dodging.rating() + ((player.agi + player.agi) * 3) + player.dodge) - player.weight
	// player.dodge = calculatedDodge
}


function updateArmor() {
	// player.armor = player.armor
	// player.slashingArmor = player.slashingArmor + player.toughness.rating()
	// player.piercingArmor = player.piercingArmor + player.toughness.rating()
	// player.bluntArmor = player.bluntArmor + player.toughness.rating()
}
function updateMagicResist() {
	player.magicResist.fire = player.fire
}


function updateExpertise() {
	// player.slashingPen = player.slashingPen + player.slashingExpertise.amount()
	// player.piercingPen = player.piercingPen + player.piercingExpertise.amount()
	// player.bluntPen = player.bluntPen + player.bluntExpertise.amount()
}



function updateCurrentWeaponSkill() {
	let playerWeaponSkill = pushItem.find(item => item.roomId == 'right hand' && item.type.weapon)
	let playerWeaponSkillAlt = pushItem.find(item => item.roomId == 'left hand' && item.type.weapon)
	if (player.leftHand == 'empty' && player.rightHand == 'empty') {
		player.currentWeaponSkill = player.unarmed
	} else if (playerWeaponSkill && playerWeaponSkillAlt) {
		player.currentWeaponSkill = player[playerWeaponSkill.skillUsed]
	} else if (playerWeaponSkill != undefined) {

		player.currentWeaponSkill = player[playerWeaponSkill.skillUsed]
	} else if (playerWeaponSkillAlt != undefined) {
		player.currentWeaponSkill = player[playerWeaponSkillAlt.skillUsed]
	}
	currentWeaponSkillRightDisplay.innerHTML = `${player.currentWeaponSkill.name}`
	currentWeaponSkillLeftDisplay.innerHTML = `${player.currentWeaponSkill.name}`
}
function updateSpeed() {
	// player.currentWeaponSkill.speed = player.currentWeaponSkill.speed + (player.weight * 0.1)
}

function initializePlayerStats() {}

// function updateWeaponAndArmorMods() {
// 	let allItemsEquipped = pushItem.filter(
// 		item =>
// 			item.roomId == 'right hand' ||
// 			item.roomId == 'left hand' ||
// 			item.roomId == 'right ring' ||
// 			item.roomId == 'left ring' ||
// 			item.roomId == 'head' ||
// 			item.roomId == 'necklace' ||
// 			item.roomId == 'shoulders' ||
// 			item.roomId == 'chest' ||
// 			item.roomId == 'back' ||
// 			item.roomId == 'hands' ||
// 			item.roomId == 'waist' ||
// 			item.roomId == 'legs' ||
// 			item.roomId == 'feet'	
// 		)
// 		allItemsEquipped.forEach(equippedItem => {
// 			if (equippedItem.mods) {
// 				for (let itemMod in equippedItem.mods) {
// 					if (player.hasOwnProperty(itemMod)) {

// 						player[itemMod] = player[itemMod]
// 					}
// 					player[itemMod]
// 				}
// 			}
// 		})
// }



function updateSpellPower() {
	// let int = player.int + player.int
	// let wis = player.wis + player.wis
	// let spellWeaponBonus = player.currentWeaponRight().mods.spellPower ? player.currentWeaponRight().mods.spellPower * player.spellWeapons.bonus() : 0
	// player.spellPower = Math.ceil((int * 2) + wis + player.spellPower + spellWeaponBonus)
}
function updateMysticPower() {
	// let mys = player.mys + player.mys
	// let int = player.int + player.int
	// player.mysticPower = Math.ceil((mys * 2) + int + player.mysticPower)
}

// function updateAdvanceSpeed() {
// 	player.advanceTimer = player.advanceTimer - player.initiation.reduction() < 1 ? 1 : player.advanceTimer - player.initiation.reduction()
// }
// function updateRetreatSpeed() {
// 	player.retreatTimer = player.retreatTimer - player.fleetFooted.reduction() < 1.5 ? 1.5 : player.retreatTimer - player.fleetFooted.reduction()
// }

function updatePlayerStats() {
	updateBuffMods()
	updateWeaponIcons()
	updateInventory()
	updateEquipmentMods()
	updateResource()
	updateCurrentWeaponSkill()
	updateEXP()
	displayPlayerStats()
}
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////
/////////////////////////////////////////////////////UPADTE STATS//////////////////////////////////////////////////////

//MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------MOVE DIRECTION----------------

function moveDirection(command) {
	let direction = abvDirectionToFullDirection(command)
	let directionMoved
	if (player.restStasis) {
		let line1 = document.createElement('div')
		player.stasis = false
		player.restStasis = false
		customizeEachWord(`You are no longer `, 'white', line1)
		customizeEachWord(`resting`, 'light-blue', line1)
		blankSpace()
	}
	switch (direction) {
		case 'up':
			directionMoved = `You move above`
			break
		case 'down':
			directionMoved = `You move below`
			break
		case 'northwest':
			directionMoved = `You move to the northwest`
			break
		case 'north':
			directionMoved = `You move to the north`
			break
		case 'northeast':
			directionMoved = `You move to the northeast`
			break
		case 'east':
			directionMoved = `You move to the east`
			break
		case 'southeast':
			directionMoved = `You move to the southeast`
			break
		case 'south':
			directionMoved = `You move to the south`
			break
		case 'southwest':
			directionMoved = `You move to the southwest`
			break
		case 'west':
			directionMoved = `You move to the west`
			break
	}
	if (currentArea.descriptions.zoneChange != undefined && currentArea.descriptions.zoneChange[direction] && currentArea.descriptions.zoneExitsBool[direction] == true) {
		currentArea.descriptions.zoneChange[direction]()
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
		blankSpace()
	} else if (currentArea.descriptions.zoneExitsBool[direction] == true) {
		blankSpace()
		switch (direction) {
			case 'up':
				player.z++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'down':
				player.z--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northwest':
				player.x--
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'north':
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northeast':
				player.x++
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'east':
				player.x++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southeast':
				player.x++
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'south':
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southwest':
				player.x--
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'west':
				player.x--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
		}
		blankSpace()
		updateScroll()
	} else if (currentArea.descriptions.zoneExitsBool[direction] == undefined) {
		let line1 = document.createElement('div')
		customizeEachWord(`You cannot move in that direction`, 'white', line1)
	} else if (currentArea.descriptions.zoneExitsBool[direction] == 'locked' || currentArea.descriptions.zoneExitsBool[direction] == 'blocked') {
		console.log(currentArea.descriptions)
		if (currentArea.descriptions?.zoneExitsLocked) {
			currentArea.descriptions.zoneExitsLocked[direction]()
		} else {
			quickMessage(`You cannot pass through here`)
		}
	}
}
function retreatDirection(command) {
	let direction = abvDirectionToFullDirection(command)
	let moveOrRetreat = player.combat == false ? ' move ' : ' retreat '
	let directionMoved

	if (currentArea.descriptions.zoneExitsBool[direction] == true) {
		blankSpace()
		switch (direction) {
			case 'up':
				directionMoved = `You ${moveOrRetreat} above`
				player.z++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'down':
				directionMoved = `You ${moveOrRetreat} below`
				player.z--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northwest':
				directionMoved = `You ${moveOrRetreat} to the northwest`
				player.x--
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'north':
				directionMoved = `You ${moveOrRetreat} to the north`
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'northeast':
				directionMoved = `You ${moveOrRetreat} to the northeast`
				player.x++
				player.y++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'east':
				directionMoved = `You ${moveOrRetreat} to the east`
				player.x++
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southeast':
				directionMoved = `You ${moveOrRetreat} to the southeast`
				player.x++
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'south':
				directionMoved = `You ${moveOrRetreat} to the south`
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'southwest':
				directionMoved = `You ${moveOrRetreat} to the southwest`
				player.x--
				player.y--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
			case 'west':
				directionMoved = `You ${moveOrRetreat} to the west`
				player.x--
				newLocation(player.x, player.y, player.z, player.special)
				youMoveToThe(directionMoved, currentArea, yellow)
				break
		}
		blankSpace()
	} else if (currentArea.descriptions.zoneExitsBool[direction] == undefined) {
		quickMessage(`You cannot ${moveOrRetreat} in that direction`)
	} else if (currentArea.descriptions.zoneExitsBool[direction] == 'locked') {
		currentArea.descriptions[direction]()
	}
}

const moveUp = () => {
	if (currentArea.descriptions.zoneExitsBool.up === true) {
		directionMoved = 'You move above'
		player.z++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		quickMessage(`That direction is blocked`)
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveDown = () => {
	if (currentArea.descriptions.zoneExitsBool.down === true) {
		directionMoved = 'You move below'
		player.z--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveNorth = () => {
	if (currentArea.descriptions.zoneExitsBool.north === true) {
		directionMoved = 'You move to the north'
		player.y++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveNortheast = () => {
	if (currentArea.descriptions.zoneExitsBool.northeast === true) {
		directionMoved = 'You move to the northeast'
		player.y++
		player.x++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveEast = () => {
	if (currentArea.descriptions.zoneExitsBool.east === true) {
		directionMoved = 'You move to the east'
		player.x++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveSoutheast = () => {
	if (currentArea.descriptions.zoneExitsBool.southeast === true) {
		directionMoved = 'You move to the southeast'
		player.x++
		player.y--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveSouth = () => {
	if (currentArea.descriptions.zoneExitsBool.south === true) {
		directionMoved = 'You move to the south'
		player.y--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveSouthwest = () => {
	if (currentArea.descriptions.zoneExitsBool.southwest === true) {
		directionMoved = 'You move to the southwest'
		player.y--
		player.x--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveWest = () => {
	if (currentArea.descriptions.zoneExitsBool.west === true) {
		directionMoved = 'You move to the west'
		player.x--
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}
const moveNorthwest = () => {
	if (currentArea.descriptions.zoneExitsBool.northwest === true) {
		directionMoved = 'You move to the northwest'
		player.x--
		player.y++
		newLocation(player.x, player.y, player.z, player.special)
		youMoveToThe(directionMoved, currentArea, yellow)
	} else if (currentArea.descriptions.zoneExitsBool.east == 'locked') {
		//do nothing if locked
	} else {
		quickMessage(noMove, yellow)
	}
}

let egbert = {
	npc: true,
	id: 0,
	x: 0,
	y: 5,
	z: -2,
	name: 'Egbert',
	refName: 'egbert',
	picture: "images/npcs/male/civilians/egbert/egbert.png",
	nameColor: 'egbert-name',
	prefix: 'Old Tutor, ',
	prefixColor: 'egbert-title',
	keywords: ['egbert', 'tutor', 'old tutor', 'old tutor egbert'],
	race: `Human`,
	occupation: `Tutor`,
	description: `Egbert is an old man with a wiry frame and long white hair. He has the look of not being presently aware, perhaps caught up in too many thoughts.`,
	get location() {
		
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questItem: 'pair of glasses',
	questStage: 1,
	questSequence: {
		preFirst: false,
		first: false,
		second: false,
		third: false,
		fourth: false,
		fifth: false,
		sixth: false,
		seventh: false,
		eighth: false,
		ninth: false,
		tenth: false,
		eleventh: false,
		twelth: false,
		thirteenth: false,
		fourteenth: false,
		fifteenth: false,
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)

		// if (!this.questSequence.eleventh) {
		// 	let line1 = lineFunc()
		// 	customizeEachWord(`${this.name}: `, this.nameColor, line1)
		// 	customizeEachWord(`You're not ready for this yet.`, this.prefixColor, line1)
		// } else {
		// }
	},
	skillsOffered: [oneHanded, twoHanded, unarmed, daggers, bows, shields],
	skillsMaxLevel: {
		oneHanded: 3,
		twoHanded: 3,
		unarmed: 3,
		daggers: 3,
		bows: 3,
		shields: 3,
	},
	desc: function () {
		blankSpace()
		npcDescription(this)
		blankSpace()
	},
	questStage: 1,
	dialogueStage: 0,
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let line5 = lineFunc()
		// let stage = player.questLog?.egbert?.stage
		let stage = this.dialogueStage
		if (stage == 0) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Ahh there you are! I was wondering where you'd run off to. The rest of the class is already outside fighting in the Training Fields. Let's get you caught up on the basics, then we'll meet up with the others outside."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"First, we'll start with the basics. If you look at the room description above, you can see the room you're in, a description of the room, room exits, and other people who might be in the room with you. If you use the LOOK or L command, you can refresh your view of the room. This is useful if you can no longer see the room description or exits."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"As you can see, the only exit out of this room is to the north. To move, simply type the direction you want to go. You can shorthand any direction as well as most commands. Try typing NORTH or N to move to the next room."`, 'white', line3)
			customizeEachWord(`NOTE: You can also use the NumPad to move. Each number, except 5, corresponds to cardinal and intermediate directions. To move UP, use the . key. To move DOWN, use the 0 key.`, 'white', line4)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line5)
			customizeEachWord(`Follow me to the north when you're ready.`, 'white', line5)
			blankSpace()
			await dialogueWait(200)
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea2, 'north')
			dialogueChangeStage(this, 1)
			return
		}
		else if (stage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Directions marked in yellow means that you cannot pass in that direction, but there is something you can do to open the way. Trying to move in a direction that is yellow will usually hint at why it is blocked and might also provide a hint as how to open the way."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Areas will sometimes have keywords highlighted in them which indicates that there is something of interest to investigate. By using the EXAMINE or EX command, you can find out more information about it. Investigating keywords can be useful as they may lead to something important like a hidden room, an item, or finding a way through a locked or blocked room. Go ahead and try "examine wall" or "ex wall"."`, 'white', line2)
			blankSpace()
			return
		}
		else if (stage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Excellent! Let us continue."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea3, 'north')
			dialogueChangeStage(this, 3)
			return
		}
		else if (stage == 3) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Some rooms will appear to have no obvious exits other than the way you came in. Here, you see that there is a lever on the wall. Use what you just learned to see if you can find a way forward."`, 'white', line1)
			blankSpace()
			return
		}
		else if (stage == 4) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Looks like you're already familiar with how to get around!"`, 'white', line1)
			blankSpace()
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea3, 'north')
			dialogueChangeStage(this, 6)
			return
		}
		else if (stage == 5) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Great! Moving on."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea5, 'north')
			dialogueChangeStage(this, 6)
			return
		}
		else if (stage == 6) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Hmmm... I must've dropped that key when I went looking for you. Go ahead and pick it up, we'll need it in the next room. To pick up an item on the ground, use the GET or G command followed by any word in the item's name. To pick up the key, try "g simple" or "g key" -- whichever you prefer."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Once you've picked up or received an item, you can see it in your inventory by using the INVENTORY or I command. This will show you everything you have in your backpack, your equipped weapons and armor, and your gold."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`NOTE: You can use the GET command followed by ALL to pick up everything on the ground including gold.`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea4, 'north')
			dialogueChangeStage(this, 7)
			return
		}
		else if (stage == 7 && currentArea.descriptions.zoneExitsBool.north == 'locked') {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Locked doors will appear yellow. Simple locks can be unlocked by using a simple key, picking the lock -- if you have the skill, or using an unlock spell -- if you have the spell. Some locks require a specific key open in which case a simple key, lockpicking skill or spell, will not work. A simple key only has a single use before it disappears, but once a door is unlocked, it will remain open."`, 'white', line1)
			blankSpace()
			return
		}
		else if (stage == 7 && currentArea.descriptions.zoneExitsBool.north == true) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Alrighty, on to the next!"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea6, 'north')
			dialogueChangeStage(this, 8)
			return
		}
		else if (stage == 8) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"You might've noticed the (Q) beside my name. This indicates that I have a quest to offer. Completing a quest can offer a range of rewards from any combination of experience points, skill points, attribute points, gold, and sometimes an item. To see what a quest entails, use the SHOW QUEST command. If there's only one person in the room offering quests, that command alone will work. If there are multiple people in the same room offering quests, you will need to specify SHOW QUEST followed by the name of the person."`, `white`, line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"You also might've noticed that the direction to the east is red. This means that there is a hard requirement that must be fulfilled before you can go there. A few examples include needing to be a certain level to pass, completing a specific quest, being at a certain point in the story progression, etc. In this case, you need to complete my quest first before you can move in that direction."`, `white`, line2)
			blankSpace()
			return
		}
		else if (stage == 9) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Alright, let's get you combat ready. The rooms to the south and east will each have a weapon and piece of armor for you. Once you have them both equipped, meet me in the room to the north where you'll get to practice fighting!"`, `white`, line1)
			await dialogueWait(200)
			blankSpace()
			npcMovesAndChangesRoom(this, galvadiaWelcomeArea14, 'north')
			galvadiaWelcomeArea8.descriptions.zoneExitsBool.north = true
			dialogueChangeStage(this, 10)
			return 
		} 
		else if (stage == 10) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			if (player.guild != 'Mage') {
				customizeEachWord(`"The room to the west will teach you the basics of combat. You should practice attacking and retreating until you're comfortable with it. As you level up, you will obtain your class abilities which will add another dimension to combat, but we'll go over how to use your abilities once you learn them."`, `white`, line2)
			} else {
				customizeEachWord(`"The room to the west will teach you the basics of combat. You should practice spell casting and retreating until you're comfortable with it. As you level up, you will obtain more spells, but for now, you can practice with the one you already know. "`, `white`, line2)
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`Egbert: `, this.nameColor, line2)
				customizeEachWord(`One more thing. Spells cost mana to cast, so you'll need to know how to replenish it when you get low or run out. To do this, use the REST command. This will put you in a resting state that will regenerate both your health and mana slowly over time. To stop resting, just move in a direction or perform an action.`, 'white', line2)
			}
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"Come find me to the north when you've finished practicing."`, `white`, line3)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			npcMovesAndChangesRoom(this, th_b_center_1, 'north')
			galvadiaWelcomeArea8.descriptions.zoneExitsBool.north = true
			dialogueChangeStage(this, 11)
			return 
		}
		else if (stage == 11) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"There's a mechanism in the rooms to the east and west that will open this door. Go and see if you can figure out how to open it."`, `white`, line2)
			blankSpace()
			return
		}
		else if (stage == 12) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Excellent! Follow me up the stairs to the Training Halls Common Room."`, white, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			npcMovesAndChangesRoom(this, trainingHallsCommonRoom, 'north')
			galvadiaWelcomeArea8.descriptions.zoneExitsBool.north = true
			dialogueChangeStage(this, 13)
			updateNpcPicture()
			return
		}
		else if (stage == 13) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Now it's time to put some of that combat training to the test! You will meet with your class trainer who will guide you through the rest of your training. From here, go all the way east where they will be waiting for you."`, white, line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"But before you go, I want to teach you about the HELP command. I expect you don't remember everything we went over in our training, so you can use this command to get a list of topics to see detailed information about. For example, typing 'help basics' will bring up a list of every subject and command that we went over."`, white, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"Alright, goodluck out there ${player.name}!"`, white, line3)
			blankSpace()
			dialogueChangeStage(this, 14)
			return
		}
		else if (stage == 14) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"Go to the Training Fields to the east to meet with your class trainer."`, white, line1)
			blankSpace()
			return
		}
		else if (stage == 15) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"${fieldsTrainer.name} informed me of your accomplishements! You will make a fine ${player.guild}. You can return here at any time to practice on the training dummies or revisit any rooms to refresh."`, white, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Before you go, I want to tell you how to get to the Town Square and the Guild Plaza where the ${player.guild}'s Guild is. Go west from here, then southwest, then straight south until you come to the Castle Crossroads. Follow the bend in the road, continuing south, and you'll be there in no time. Read any signs you come across. They're very useful for getting directions to various places around Galvadia."`, white, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"If you ever find yourself completely lost and unable to find your way, I have placed a blessing on you that will last until level 10 that will allow you to use the RECALL command. This command will instantly teleport you back to this room. After level 10, you will no longer be able to use this command. It's a safety measure we have to take as I'm sure you can imagine the security risk of having anyone trained in combat and above level 10 teleporting inside the castle walls would impose."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line4)
			customizeEachWord(`"Alright, I'll let you on your way."`, 'white', line4)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			dialogueChangeStage(this, 16)
			npcMovesAndChangesRoom(this, trainingHallsCommonRoom, 'north')
			updateNpcPicture()
			return
		}
		quickMessage(`Next quest sequence not yet programmed`)
	},
	quest: async function () {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"I've barely been able to see going through these halls. It's a wonder I found you! Go and retrieve my glasses for me. I believe I left them somewhere in my office to the west."`, `white`, line1)
		blankSpace()
	},
	isQuestAvailable: true,
	offer: async function() {
		if (this.questStage == 1) {
			let npcQuestItem = pairOfGlasses()
			let playerQuestItem = questFindPlayerItem(npcQuestItem)
			if (playerQuestItem && npcQuestItem.refName === playerQuestItem.refName) {
				questChangeStage(egbert, 0)
				questReward({exp: 10})
				removeItemFromPerson(playerQuestItem)
				enableDirection('east')
				spawnTutorialWeapons()
				
				npcMovesInADirection('east', this)
				npcRemoveFromTheirCurrentRoom(this)
				npcAddToRoom(galvadiaWelcomeArea8, this)
			}
		}
		let qItem = pushItem.find(x => x.name.toLowerCase() == this.questItem)
		let qItemIndex = pushItem.indexOf(qItem)
		if (this.questSequence.first == false && qItem != undefined && player.backpack.find(item => item == qItem.name)) {
			pushItem.splice(qItemIndex, 1)
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand the `, 'white', line1)
			customizeEachWord(`${qItem.name} `, qItem.color, line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			blankSpace()
			await dialogueWait(200)
			playerGainQuestExperience(10)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line2)
			customizeEachWord(`"Wonderful! Completing quests will grant you experience points, and sometimes you'll receive other rewards. Use the EXP command to check your level progress (the white bar at the bottom of the screen shows this too). This will also show you how many skill and attribute points you have available. We'll ago over what those are and how to use them at a later time."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line3)
			customizeEachWord(`"I'll be in the room to the east when you are ready for your next lesson."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			currentArea.descriptions.zoneExitsBool.east = true
			spawnTutorialWeapons()
			npcMovesInADirection('east', this)
			npcRemoveFromTheirCurrentRoom(this)
			npcAddToRoom(galvadiaWelcomeArea8, this)			
			this.isQuestAvailable = false
			dialogueChangeStage(this, 9)
			updateNpcPicture()
		} else if (this.questSequence.first == false) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Egbert: `, this.nameColor, line1)
			customizeEachWord(`"If you can find my glasses, I'll be able to show you around. They should be somewhere in my office, in the room to the west."`, 'white', line1)
			blankSpace()
		} else {
			npcNoQuestAvailable(this)
			return
		}
	},
	displayShop: async function (ssiq) {
		this.questSequence.thirteenth = true
		displayShopSkillsOrSpells(this, ssiq)		

		// if (!this.questSequence.eleventh) {
		// 	let line1 = lineFunc()
		// 	customizeEachWord(`${this.name}: `, this.nameColor, line1)
		// 	customizeEachWord(`You're not ready for this yet.`, this.prefixColor, line1)
		// } else {
		// }
	},
}
allNpcsArray.push(egbert)


function npcMovesEastToWest(chosenNpc) {
	let eastCount = 0
	let westCount = 0
	let direction
	setInterval(() => {
		console.log('interval running')
		let npcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
		let thisIndexToRemove = npcArea.npc.indexOf(npcArea.npc.find(npc => npc.name == chosenNpc.name))
		let chosenDirection = () => {
			if (eastCount == chosenNpc.eastCount && westCount == chosenNpc.westCount) {
				eastCount = 0
				westCount = 0
			}
			if (eastCount < chosenNpc.eastCount) {
				eastCount++
				return 'east'
			} else if (eastCount == chosenNpc.westCount) {
				if (westCount < chosenNpc.westCount) {
					westCount++
					return 'west'
				}
			}
		}
		direction = chosenDirection()
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == false) {
			quickMessage(`In the same room, not moving`)
			return
		}
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == true) {
			let newNpcArea
			switch (direction) {
				case 'east':
					chosenNpc.x += 1
					break
				case 'west':
					chosenNpc.x -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			let line1 = document.createElement('div')
			customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
			npcRemoveFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			newNpcArea.npc.push(chosenNpc)
		} else if (coordinatesMatch(chosenNpc, player) == false) {
			let newNpcArea
			let entersFromDirection
			console.log(direction, 'DIRECTION')
			switch (direction) {
				case 'east':
					entersFromDirection = 'west'
					chosenNpc.x += 1
					break
				case 'west':
					entersFromDirection = 'east'
					chosenNpc.x -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			if (coordinatesMatch(chosenNpc, player) == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
				customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
			}
			npcRemoveFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			console.log(newNpcArea, ' NEW NPC AREA')
			newNpcArea.npc.push(chosenNpc)
		}
	}, chosenNpc.intervalTick)
}

function npcMovesNorthToSouth(chosenNpc) {
	let northCount = 0
	let southCount = 0
	let direction
	setInterval(() => {
		console.log('interval running')
		let npcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
		let thisIndexToRemove = npcArea.npc.indexOf(npcArea.npc.find(npc => npc.name == chosenNpc.name))
		let chosenDirection = () => {
			if (northCount == chosenNpc.northCount && southCount == chosenNpc.southCount) {
				northCount = 0
				southCount = 0
			}
			if (northCount < chosenNpc.northCount) {
				northCount++
				return 'north'
			} else if (northCount == chosenNpc.southCount) {
				if (southCount < chosenNpc.southCount) {
					southCount++
					return 'south'
				}
			}
		}
		direction = chosenDirection()
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == false) {
			quickMessage(`In the same room, not moving`)
			return
		}
		if (coordinatesMatch(chosenNpc, player) == true && chosenNpc.movesWhenPlayerIsHere == true) {
			let newNpcArea
			switch (direction) {
				case 'north':
					chosenNpc.y += 1
					break
				case 'south':
					chosenNpc.y -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			let line1 = document.createElement('div')
			customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
			npcRemoveFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			newNpcArea.npc.push(chosenNpc)
		} else if (coordinatesMatch(chosenNpc, player) == false) {
			let newNpcArea
			let entersFromDirection
			console.log(direction, 'DIRECTION')
			switch (direction) {
				case 'north':
					entersFromDirection = 'south'
					chosenNpc.y += 1
					break
				case 'south':
					entersFromDirection = 'north'
					chosenNpc.y -= 1
					break
				default:
					console.log('SOMETHING WENT WRONG FIGURE IT OUT')
			}
			if (coordinatesMatch(chosenNpc, player) == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`${chosenNpc.name} `, `${chosenNpc.nameColor}`, line1)
				customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
			}
			npcRemoveFromRoom(npcArea, thisIndexToRemove)
			newNpcArea = allAreas.find(area => area.x == chosenNpc.x && area.y == chosenNpc.y && area.z == chosenNpc.z)
			console.log(newNpcArea, ' NEW NPC AREA')
			newNpcArea.npc.push(chosenNpc)
		}
	}, chosenNpc.intervalTick)
}

//USE THIS FUNCTION TO GIVE NPCS EXACT DIRECTIONS TO MOVE
async function specificNpcMovement(npc) {
	//eastcount
	let currentNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	//For xAxis, 1 = EAST, -1 = WEST, 0 = DOESN'T MOVE ON THIS AXIS
	let xAxisA = npc.xa
	let yAxisA = npc.ya
	let xAxisB = npc.xb
	let yAxisB = npc.yb
	let xCounterA = 0
	let yCounterA = 0
	let xCounterB = 0
	let yCounterB = 0
	let direction
	let entersFromDirection
	//intervaltick
	let behaviorA = true
	let behaviorB = false
	const movesToDirectionMap = {
			'1,0': 'east',
			'-1,0': 'west',
			'0,1': 'north',
			'0,-1': 'south',
			'1,1': 'northeast',
			'1,-1': 'southeast',
			'-1,-1': 'southwest',
			'-1,1': 'northwest',
		}
	const entersFromDirectionMap = {
			'1,0': 'west',
			'-1,0': 'east',
			'0,1': 'south',
			'0,-1': 'north',
			'1,1': 'southwest',
			'1,-1': 'northwest',
			'-1,-1': 'northeast',
			'-1,1': 'southeast',
		}
		//inverse
	while(npc.isBehaviorOn) {
	updateNpcPicture()
	if (!npc.isInConversation) {
		await waitForNextAction(npc.waitInterval)
	}
	if (npc.isInConversation) {
		await waitForNextAction(100)
	} else if (behaviorA) {
		let directionKey = `${xAxisA[xCounterA]},${yAxisA[yCounterA]}`
		direction = movesToDirectionMap[directionKey]
		entersFromDirection = entersFromDirectionMap[directionKey]
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${capitalizeFirstLetter(npc.prefix)} `, npc.prefixColor, line1)
			customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
		}
		currentNpcArea.npc.splice(currentNpcArea.npc.indexOf(npc), 1)
		npc.x = npc.x + xAxisA[xCounterA]
		npc.y = npc.y + yAxisA[yCounterA]
		currentNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		currentNpcArea.npc.push(npc)
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${npc.prefix} `, npc.prefixColor, line1)
			customizeEachWord(`${npc.name} `, npc.nameColor, line1)
			customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
		}
		xCounterA++
		yCounterA++
		if (xCounterA == xAxisA.length) {
			xCounterB = 0
			yCounterB = 0
			behaviorA = false
			behaviorB = true
		}
	}   else if (behaviorB == true) {
		// console.log('before NPC moves')
		let directionKey = `${xAxisB[xCounterB]},${yAxisB[yCounterB]}`
		direction = movesToDirectionMap[directionKey]
		entersFromDirection = entersFromDirectionMap[directionKey]
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${capitalizeFirstLetter(npc.prefix)} `, npc.prefixColor, line1)
			customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
		}
		currentNpcArea.npc.splice(currentNpcArea.npc.indexOf(npc), 1)
		npc.x = npc.x + xAxisB[xCounterB]
		npc.y = npc.y + yAxisB[yCounterB]
		currentNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		currentNpcArea.npc.push(npc)
		if (coordinatesMatch(npc, player)) {
			let line1 = lineFunc()
			customizeEachWord(`${capitalizeFirstLetter(npc.prefix)} `, npc.prefixColor, line1)
			customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
			customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
		}
		xCounterB++
		yCounterB++
		if (xCounterB == xAxisB.length) {
			xCounterA = 0
			yCounterA = 0
			behaviorA = true
			behaviorB = false
			}
		}
	}
}

function applySkillBuff(buff) {
	player[buff.skillEnhanced.name].level += buff.skillEnhanced.level
	setTimeout(() => {
		player[buff.skillEnhanced.name].level -= buff.skillEnhanced.level
	}, buff.duration)
}

function npcRemoveFromRoom(area, selectNpc) {
	let allNpcsInRoom = area.npc
	let npcIndex = allNpcsInRoom.indexOf(selectNpc)
	area.npc.splice(npcIndex, 1)
}
function npcRemoveFromTheirCurrentRoom(selectNpc) {
	console.log(selectNpc.refName, ' NPC TO BE REMOVED ON LOAD')
	let npcCurrentRoom = allAreas.find(area => area?.npc?.[0]?.refName == selectNpc.refName)
	if (!npcCurrentRoom) {
		console.log('no npc current room')
		return
	}
	let allNpcsInRoom = npcCurrentRoom.npc
	let npcIndex = allNpcsInRoom.indexOf(selectNpc)
	npcCurrentRoom.npc.splice(npcIndex, 1)
}
function npcRemoveFromRoomPack(selectNpc, npcRoomPack) {
	let npcCurrentRoom = npcRoomPack.find(area => area.npc.find(npc => npc.refName == selectNpc.refName))
	let allNpcsInRoom = npcCurrentRoom.npc
	let npcIndex = allNpcsInRoom.indexOf(selectNpc)
	npcCurrentRoom.npc.splice(npcIndex, 1)
}
function npcMovesAndChangesRoom(npc, area, direction, movesTo = true) {
	npcRemoveFromTheirCurrentRoom(npc)
	npcAddToRoom(area, npc)
	// npcAddLocationToPlayerObject(npc, area)
	// npcUpdateLocation(npc, area)
	if (!direction) return

	if (direction) {
		if (movesTo) {npcMovesInADirection(direction, npc)}
		else {npcEntersFromADirection(direction, npc)}
	}
}
// let npcCurrentRoom = npcRoomPack.find(area => 
// 	area.npc.find(npc => npc.refName === selectNpc.refName)
//   );
// function npcAddToLocationTracker(npc, area) {
// 	npcLocationTracker[npc.refName] = area
// }
function npcAddToRoom(area, npc) {
	// let roomToAddNpc = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	area.npc.push(npc)
	// npc.currentArea = area
	npcUpdateLocation(npc, area)
	// npcAddToLocationTracker(npc, area)
}
function npcMovesInADirection(direction, npc) {
	let line1 = lineFunc()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`moves to the ${direction}`, 'white', line1)
	blankSpace()
}
function npcEntersFromADirection(direction, npc) {
	let line1 = lineFunc()
	let entersFromDirection = ``
	if (direction == 'northwest') {entersFromDirection = 'southeast'}
	if (direction == 'north') {entersFromDirection = 'south'}
	if (direction == 'northeast') {entersFromDirection = 'southwest'}
	if (direction == 'east') {entersFromDirection = 'west'}
	if (direction == 'southeast') {entersFromDirection = 'northwest'}
	if (direction == 'south') {entersFromDirection = 'north'}
	if (direction == 'southwest') {entersFromDirection = 'northeast'}
	if (direction == 'west') {entersFromDirection = 'east'}
	if (direction == 'up') {entersFromDirection = 'below'}
	if (direction == 'down') {entersFromDirection = 'above'}
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
	blankSpace()
}

async function npcNoQuestAvailable(npc) {
	let line1 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`is not currently offering any quests.`, 'white', line1)
	blankSpace()
}



function spawnTutorialWeapons() {
	if (player.playerClass.name == 'Berserker') {
		weaponGen(trainingTwoHandedSword())
		armorGen(trainingMailChestpiece())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
		pushItem[pushItem.length - 2].roomId = galvadiaWelcomeArea9.id

	}
	if (player.playerClass.name == 'Fighter') {
		weaponGen(trainingShortsword())
		weaponGen(trainingShortsword())
		armorGen(trainingMailChestpiece())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
		pushItem[pushItem.length - 2].roomId = galvadiaWelcomeArea9.id
		pushItem[pushItem.length - 3].roomId = galvadiaWelcomeArea9.id


	}
	if (player.playerClass.name == 'Knight') {
		weaponGen(trainingShortsword())
		weaponGen(trainingShield())
		armorGen(trainingMailChestpiece())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
		pushItem[pushItem.length - 2].roomId = galvadiaWelcomeArea9.id
		pushItem[pushItem.length - 3].roomId = galvadiaWelcomeArea9.id


	}
	if (player.guild == 'Sinistral') {
		weaponGen(trainingDagger())
		weaponGen(trainingDagger())
		armorGen(trainingLeatherTunic())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
		pushItem[pushItem.length - 2].roomId = galvadiaWelcomeArea9.id
		pushItem[pushItem.length - 3].roomId = galvadiaWelcomeArea9.id

	}
	if (player.playerClass.name == 'Martial Monk' || player.playerClass.name == 'Mystic Monk') {
		armorGen(trainingLeatherTunic())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
	}
	if (player.playerClass.name == 'Elemental Monk') {
		armorGen(trainingClothChestpiece())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
	}
	if (player.guild == 'Ranger') {
		weaponGen(trainingBow())
		armorGen(trainingLeatherTunic())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
		pushItem[pushItem.length - 2].roomId = galvadiaWelcomeArea9.id

	}
	if (player.guild == 'Mage') {
		weaponGen(trainingStaff())
		armorGen(trainingClothChestpiece())
		pushItem[pushItem.length - 1].roomId = galvadiaWelcomeArea11.id
		pushItem[pushItem.length - 2].roomId = galvadiaWelcomeArea9.id

	}
}


function compareCoordinates(comparedObject) {
	if (comparedObject.s == undefined) {
		if (comparedObject.x == player.x && comparedObject.y == player.y && comparedObject.z == player.z) {
			return true
		} else {
			return false
		}
	} else if (comparedObject.s != undefined) {
		if (comparedObject.x == player.x && comparedObject.y == player.y && comparedObject.z == player.z && comparedObject.s == player.s) {
			return true
		} else {
			return false
		}
	}
}

//x = 1, y = 1
//x = 2, y = 2

function npcMovesRandomlyNew(npc) {
	//currentArea
	let npcAreas = npc.areas
	let npcCurrentArea = npcAreas.find(area => area?.npc?.some(person => person.refName == npc.refName))
	let possibleDirectionsArray = Object.keys(npcCurrentArea.descriptions.zoneExitsBool)
	let selectedDirection = possibleDirectionsArray[randomNumberRange(0, possibleDirectionsArray.length - 1)]
	let x = 0
	let y = 0
	let z = 0
	if (selectedDirection == 'east') {x = 1}
	if (selectedDirection == 'west') {x = -1}
	if (selectedDirection == 'north') {y = 1}
	if (selectedDirection == 'south') {y = -1}
	if (selectedDirection == 'up') {z = 1}
	if (selectedDirection == 'down') {z = -1}
	if (selectedDirection == 'northeast') {
		x = 1
		y = 1
	}
	if (selectedDirection == 'southwest') {
		x = -1
		y = -1
	}
	if (selectedDirection == 'northwest') {
		x = -1
		y = 1
	}
	if (selectedDirection == 'southeast') {
		x = 1
		y = -1
	}
	let newArea = npcAreas.find(area => npcCurrentArea.x + x == area.x && npcCurrentArea.y + y == area.y && npcCurrentArea.z + z == area.z)
	if (newArea == undefined) {
		for (let i = 0; i < 10; i++) {
			newArea = npcAreas.find(area => npcCurrentArea.x + x == area.x && npcCurrentArea.y + y == area.y && npcCurrentArea.z + z == area.z)
			if (newArea != undefined) {
				break
			}
		}
		if (newArea == undefined) {return}
	}
	console.log(selectedDirection, ' SELECTED DIRECTION')
	if (npcCurrentArea == currentArea) {
		if (npc.getAwayAttempts < 5) {
			npc.getAwayAttempts++
			return
		} else {
			npcMovesInADirection(selectedDirection, npc)
		}
	} else if (newArea == currentArea) {
		npcEntersFromADirection(selectedDirection, npc)
	}
	npcRemoveFromRoom(npcCurrentArea, npc)
	npcAddToRoom(newArea, npc)
	console.log(npc.name, ' moves')
}

function npcMovesRandomly(npc) {
	let npcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	console.log(npc, ' NPC')
	let newNpcArea
	let canNpcMove = npcArea.descriptions.zoneExits.split(' ')
	let randomDirectionIndex = randomNumberRange(0, canNpcMove.length - 1)
	let thisIndexToRemove = npcArea.npc.indexOf(npcArea.npc.find(npc => npc.name == npc.name))
	let direction = canNpcMove[randomDirectionIndex]
	while (npcArea.descriptions.zoneExitsBool[direction] != true) {
		randomDirectionIndex = randomNumberRange(0, canNpcMove.length - 1)
		direction = canNpcMove[randomDirectionIndex]
	}
	if (coordinatesMatch(npc, player) == true && npc.movesWhenPlayerIsHere == false) {
		quickMessage(`In the same room, not moving`)
		return
	}
	if (coordinatesMatch(npc, player) == true && npc.movesWhenPlayerIsHere == true) {
		if (direction != 'up' || direction != 'down') {
			let line1 = document.createElement('div')
			customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
			customizeEachWord(`moves to the ${direction}`, 'white', line1)
		} else if (direction == 'up') {
			let line1 = document.createElement('div')
			customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
			customizeEachWord(`moves above`, 'white', line1)
		} else if (direction == 'down') {
			let line1 = document.createElement('div')
			customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
			customizeEachWord(`moves below`, 'white', line1)
		}
		switch (direction) {
			case 'west':
				npc.x = npc.x - 1
				break
			case 'northwest':
				npc.x = npc.x - 1
				npc.y = npc.y + 1
				break
			case 'north':
				npc.y = npc.y + 1
				break
			case 'northeast':
				npc.x = npc.x + 1
				npc.y = npc.y + 1
				break
			case 'east':
				npc.x = npc.x + 1
				break
			case 'southeast':
				npc.x = npc.x + 1
				npc.y = npc.y - 1
				break
			case 'south':
				npc.y = npc.y - 1
				break
			case 'southwest':
				npc.x = npc.x - 1
				npc.y = npc.y - 1
				break
			case 'up':
				npc.z = npc.z + 1
				break
			case 'down':
				npc.z = npc.z - 1
				break
			default:
				quickMessage(`This is the default. Figure out what went wrong. This should probably never run`)
		}
		npcRemoveFromRoom(npcArea, thisIndexToRemove)
		newNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		newNpcArea.npc.push(npc)
	} else if (coordinatesMatch(npc, player) == false) {
		switch (direction) {
			case 'west':
				npc.x = npc.x - 1
				entersFromDirection = 'east'
				break
			case 'northwest':
				npc.x = npc.x - 1
				npc.y = npc.y + 1
				entersFromDirection = 'southeast'
				break
			case 'north':
				npc.y = npc.y + 1
				entersFromDirection = 'south'
				break
			case 'northeast':
				npc.x = npc.x + 1
				npc.y = npc.y + 1
				entersFromDirection = 'southwest'
				break
			case 'east':
				npc.x = npc.x + 1
				entersFromDirection = 'west'
				break
			case 'southeast':
				npc.x = npc.x + 1
				npc.y = npc.y - 1
				entersFromDirection = 'northwest'
				break
			case 'south':
				npc.y = npc.y - 1
				entersFromDirection = 'north'
				break
			case 'southwest':
				npc.x = npc.x - 1
				npc.y = npc.y - 1
				entersFromDirection = 'northeast'
				break
			case 'up':
				npc.z = npc.z + 1
				entersFromDirection = 'below'
				break
			case 'down':
				npc.z = npc.z - 1
				entersFromDirection = 'above'
				break
			default:
				quickMessage(`This is the default. Figure out what went wrong. This should probably never run`)
		}

		if (coordinatesMatch(npc, player) == true) {
			if (entersFromDirection != 'below' || entersFromDirection != 'above') {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
				customizeEachWord(`enters from the ${entersFromDirection}`, 'white', line1)
			} else if (entersFromDirection == 'below') {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
				customizeEachWord(`enters from below`, 'white', line1)
			} else {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, `${npc.nameColor}`, line1)
				customizeEachWord(`enters from above`, 'white', line1)
			}
		}
		npcRemoveFromRoom(npcArea, thisIndexToRemove)
		newNpcArea = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
		newNpcArea.npc.push(npc)
	}
}

class NPCCreator {
	constructor(options) {
		this.x = options.x || null
		this.y = options.y || null
		this.z = options.z || null
		this.name = options.name || null
		this.nameColor = options.nameColor || null
		this.keywords = options.keywords || null
		this.displayName = options.displayName || null
		this.prefix = options.prefix || null
		this.prefixColor = options.prefixColor || null
		this.suffix = options.suffix || null
		this.suffixColor = options.suffixColor || null
		this.skillsOffered = options.skillsOffered || null
		this.skillsMaxLevel = options.skillsMaxLevel || null
		this.spellsOffered = options.spellsOffered || null
		this.spellsMaxLevel = options.spellsMaxLevel || null
		this.itemsOffered = options.itemsOffered || null
		this.buy = options.buy || null
		this.train = options.train || null
		this.learn = options.learn || null
		this.description = options.description || null
		this.desc = options.desc || null
		this.speak = options.speak || null
		this.displayShop = options.displayShop || null
	}
}


const benjamin = {
	x: -3,
	y: 2,
	z: 0,
	name: 'Benjamin',
	name2: 'Naker',
	refName: 'benjamin',
	nameColor: 'food',
	suffix: ', Castle Baker',
	suffixColor: 'light-brown',
	keywords: ['ben', 'benjamin', 'baker'],
	occupation: `Shopkeeper`,
	race: `Human`,
	description: `A jolly looking baker`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [apple, applePie],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello! I am Benjamin Naker, the Castle Baker. I make a wonderful Mudpie, but I'm all out of Mudballs to make them, and the Mudlings in the Fields are too strong for me to handle, sadly."`, this.suffixColor, line1)
			blankSpace()
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I'm back to making my spectacular Mudpies, thanks to you!"`, this.suffixColor, line1)
			blankSpace()
		}
	},
	questStage: 1,
	questSequence: {
		first: false,
	},
	questItem: 'mudball',
	quest: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Drats! I'm all out of Mudballs. I can't cook any more Mudpies without Mudballs. All I need is one Mudball to get me through the day.`, this.suffixColor, line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace()
		}
	},
	offer: async function() {
		let questItem = pushItem.find(item => (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand') && item.keywords.some(keyword => keyword == this.questItem))
		let questItemIndex = pushItem.indexOf(questItem)
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first && questItem) {
			pushItem.splice(questItemIndex, 1)
			player.backpack.splice(questItemIndex, 1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand the `, 'white', line1)
			customizeEachWord(`${questItem.name} `, questItem.color, line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${this.name}`, this.color, line1)
			blankSpace()
			await dialogueWait(200)
			playerGainQuestExperience(20)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Benjamin: `, this.nameColor, line2)
			customizeEachWord(`"You've saved the day! Now I can continue making Mudpies!"`, this.suffixColor, line2)
			blankSpace()
			this.questSequence.first = true
			return
		} else if (this.questSequence.first == true) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You do not have the correct quest item.`, 'white', line1)
			blankSpace()
			return
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const threx = {
	x: -10,
	y: -10,
	z: 0,
	name: 'Threx',
	refName: 'threx',
	nameColor: 'dark-orange',
	prefix: 'Warrior Recruitment Officer, ',
	prefixColor: 'warrior-color',
	keywords: ['threx'],
	occupation: `Warrior's Guild Officer`,
	race: `Human`,
	description: `Warrior`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (!this.questSequence.second) {
			let line1 = lineFunc()
			customizeEachWord(`You must be a member of the `, 'white', line1)
			customizeEachWord(`Warrior's Guild `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [oneHanded, twoHanded, toughness, shields, ripslash, charge],
	skillsMaxLevel: {
		oneHanded: 5,
		twoHanded: 5,
		toughness: 5,
		shields: 5,
		ripslash: 2,
		charge: 1,
	},
	questStage: 1,
	questSequence: {},
	speakSequence: {},
	speak: async function () {
		if (!this.questSequence.first) {
			threxSpeakDialogue.dialogue1()
			return
		}
		if (!this.questSequence.second) {
			threxSpeakDialogue.dialogue2()
		}
	},
	questItem: 'cult texts',
	quest: async function () {
		if (!this.questSequence.first) {
			threxQuestDialogue.dialogue1()
			return
		}
		if (!this.questSequence.second) {
			threxQuestDialogue.dialogue2()
			return
		}
		if (!this.questSequence.third) {
			threxQuestDialogue.dialogue3()
		}
	},
	offer: async function() {
		if (!this.questSequence.first) {
			threxOfferDialogue.dialogue1()
		} 
	},
	displayShop: async function(ssiq) {
		if (!this.questSequence.second) {
			let line1 = lineFunc()
			customizeEachWord(`You must be a member of the `, 'white', line1)
			customizeEachWord(`Warrior's Guild `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		displayShopSkillsOrSpells(this, ssiq)
	}
}
let threxSpeakDialogue = {
	dialogue1: async function() {
		let line1 = lineFunc()
		let randomNumber = randomNumberRange(1, 3)
		await dialogueWait(200)
		blankSpace()
		if (randomNumber == 1) {	
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"Greetings, traveller."`, 'white', line1)
		}
		if (randomNumber == 2) {
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"This is the Warrior's Guild. Only guild members are allowed in."`, 'white', line1)
		}
		if (randomNumber == 3) {
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"There's been a disturbance in the magics lately. Even the other guilds are talking about it."`, 'white', line1)
		}
		blankSpace()
	},
	dialogue2: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line1)
		customizeEachWord(`"Go ahead and take a look around the guild. There are several restricted Guild Shops and trainers that require certain levels to be able to use. As you level up, you will be able to access these shops and trainers."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line2)
		customizeEachWord(`"I have no more quests for you at this time, but many of the guild members here have quests to offer. As you level and complete quests, can check back in with them because they might have some new quests waiting for you."`, 'white', line2)
		blankSpace()
	},
	dialogue3: async function() {},
}
let threxQuestDialogue = {
	dialogue1: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line1)
		customizeEachWord(`"Hello, ${player.name}. I've been expecting you. Since you've proven yourself in combat, I'd like to see if you can help the guild obtain some information. There's been a disturbance in the magics around here, and we'd like to find out what's going on. I've heard rumors that there have been cultists sneaking into the graveyard to meet. Your objective is to visit the graveyard and report back with any findings. We suspect that the Cultists have something on them that will have information on their practices which we believe to be connected to the disturbance."`, this.prefixColor, line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Threx: `, threx.nameColor, line2)
		customizeEachWord(`"If you can complete this task, you will be accepted into the Warrior's Guild. Goodluck."`, this.prefixColor, line2)
		blankSpace()
		return
	},
	dialogue2: async function() {

	},
	dialogue3: async function() {

	},
}
let threxOfferDialogue = {
	dialogue1: async function() {
		let questItem = pushItem.find(item => (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand') && item.keywords.some(keyword => keyword == threx.questItem))
		if (questItem) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand the `, 'white', line1)
			customizeEachWord(`${questItem.name} `, questItem.color, line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${threx.name}`, threx.color, line1)
			blankSpace()
			await dialogueWait(200)
			playerGainQuestExperience(100)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, threx.nameColor, line2)
			customizeEachWord(`"It would appear as though the Cultists know about the disturbances in the magics, and are actively working to further the disruption. I will need to discuss this with the guild leaders to figure out our next course of action."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, threx.nameColor, line3)
			customizeEachWord(`"There's nothing we can do in the immediate, so for now, we'll focus on getting you trained up! Come with me to the Guild Halls."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx `, threx.nameColor, line4)
			customizeEachWord(`moves to the south`, 'white', line4)
			blankSpace()
			threx.questSequence.first = true
			threx.x = -12
			threx.y = -13
			threx.z = -2
			galvadiaWarriorsGuildEntrance.descriptions.zoneExitsBool.south = true
			removeItemFromPerson(questItem)
			npcRemoveFromRoom(galvadiaWarriorsGuildEntrance, threx)
			npcAddToRoom(threx)
			return
		} else {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, threx.nameColor, line1)
			customizeEachWord(`"Return when you've found out some information."`, 'white', line1)
			blankSpace()
		}
	},
	dialogue2: async function() {},
	dialogue3: async function() {},
}

let velthash = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Velthash',
	refName: 'velthash',
	nameColor: 'dark-purple',
	color: 'warrior-color',
	prefix: 'Berserker Warmaster, ',
	prefixColor: 'warrior-color',
	keywords: ['velthash', 'vel'],
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand, npc) {
	if (player.guild != 'Warrior') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Warrior `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, npc)
	},
	questSequence: {
	},
	skillsOffered: [oneHanded, twoHanded, shields],
	skillsMaxLevel: {
		oneHanded: 5,
		twoHanded: 5,
		shields: 5
	},
	itemsOffered: [shortsword],
	questItem: [cultTexts],
	isQuestAvailable: false,
	learn: (secondCommand, npc) => {
		learnInteraction(secondCommand, npc)
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

const ragnar = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Ragnar',
	refName: 'ragnar',
	picture: 'images/npcs/male/warriors/fighters/ragnar/ragnar.png',
	nameColor: 'ragnar-name',
	prefix: 'Lord of War, ',
	prefixColor: 'warrior-color',
	keywords: ['ragnar'],
	occupation: `Fighter Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Fighter') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Fighter in order to train with Ragnar`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [dualStrike, charge, oneHanded, initiation, tactics, vigor]
		} else if (player.level < 20) {
			return [dualStrike, shred, bladeBlitz, charge, oneHanded, initiation, tactics, vigor, warcraft, precision, 
				slashingExpertise, piercingExpertise, bluntExpertise, bleed]
		} else if (player.level < 30) {
			return [dualStrike, shred, bladeBlitz, charge, oneHanded, thrillOfTheKill, battleRage, counterAttack, brutalBlows, 
				multipleStrikes, stunningBlows, resilience, initiation, tactics, vigor, warcraft, precision, slashingExpertise, 
				piercingExpertise, bluntExpertise, bleed]
		} else {
			return 	[dualStrike, shred, bladeBlitz, charge, oneHanded, thrillOfTheKill, slashingExpertise, piercingExpertise, 
				bluntExpertise, battleRage, blacksmithing, counterAttack, tactics, initiation, brutalBlows, 
				multipleStrikes, stunningBlows, vigor, warcraft, resilience, bleed]
		}
	},
	skillsMaxLevel: {
		get dualStrike() {return skillMaxLevel2(player.dualStrike)},
		get shred() {return skillMaxLevel2(player.shred)},
		get bladeBlitz() {return skillMaxLevel2(player.bladeBlitz)},
		get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
		get charge() {return skillMaxLevel5(player.charge)},
		get thrillOfTheKill() {return skillMaxLevel2(player.thrillOfTheKill)},
		get slashingExpertise() {return skillMaxLevel5(player.slashingExpertise)},
		get piercingExpertise() {return skillMaxLevel5(player.piercingExpertise)},
		get bluntExpertise() {return skillMaxLevel5(player.bluntExpertise)},
		get battleRage() {return skillMaxLevel5(player.battleRage)},
		blacksmithing: 10,
		get counterAttack() {return skillMaxLevel2(player.counterAttack)},
		get tactics() {return skillMaxLevel5(player.tactics)},
		get initiation() {return skillMaxLevel5(player.initiation)},
		get brutalBlows() {return skillMaxLevel2(player.brutalBlows)},
		get multipleStrikes() {return skillMaxLevel2(player.multipleStrikes)},
		get stunningBlows() {return skillMaxLevel2(player.stunningBlows)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get resilience() {return skillMaxLevel3(player.resilience)},
		get bleed() {return skillMaxLevel3(player.bleed)},
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Ragnar. I'm here to train Warrior's Guild Prospects who are interested in joining the Warrior's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const magvello = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Magvello',
	refName: 'magvello',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'red',
	prefix: 'Howling Blade, ',
	prefixColor: 'warrior-color-dark',
	keywords: ['magvello'],
	occupation: `Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with Magvello`)
		}
	},
	get skillsOffered() {
		let level5Skills = [twoHanded, initiation, tactics, vigor, rest]
		let level10Skills = [ripslash, cyclone, cataclysm, charge, bleed, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, rest]
		let level15Skills = [ripslash, cyclone, cataclysm, charge, bleed, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, rest]
		let level20Skills = [ripslash, cyclone, cataclysm, charge, bleed, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, counterAttack, stunningBlows, multipleStrikes, brutalBlows, thrillOfTheKill, battleRage, slashingExpertise, piercingExpertise, bluntExpertise, rest]
		if (player.level <= 5) {return level5Skills} 
		if (player.level <= 10) {return level10Skills} 
		if (player.level <= 15) {return level15Skills}
		if (player.level < 20) {return level20Skills}
	},
	skillsMaxLevel: {
		get ripslash() {return skillMaxLevel2(player.ripslash)},
		get cyclone() {return skillMaxLevel2(player.cyclone)},
		get cataclysm() {return skillMaxLevel2(player.cataclysm)},
		get twoHanded() {return weaponSkillMaxLevel(player.twoHanded)},
		get charge() {return skillMaxLevel5(player.charge)},
		get thrillOfTheKill() {return skillMaxLevel2(player.thrillOfTheKill)},
		get cleave() {return skillCleaveMaxLevel(player.cleave)},
		get slashingExpertise() {return skillMaxLevel5(player.slashingExpertise)},
		get piercingExpertise() {return skillMaxLevel5(player.piercingExpertise)},
		get bluntExpertise() {return skillMaxLevel5(player.bluntExpertise)},
		get battleRage() {return skillMaxLevel5(player.battleRage)},
		blacksmithing: 10,
		get counterAttack() {return skillMaxLevel2(player.counterAttack)},
		get tactics() {return skillMaxLevel5(player.tactics)},
		get initiation() {return skillMaxLevel5(player.initiation)},
		get brutalBlows() {return skillMaxLevel2(player.brutalBlows)},
		get multipleStrikes() {return skillMaxLevel1(player.multipleStrikes)},
		get stunningBlows() {return skillMaxLevel2(player.stunningBlows)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get resilience() {return skillMaxLevel3(player.resilience)},
		get bleed() {return skillMaxLevel3(player.bleed)},
	},
	questStage: 0,
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const allSkillsMan = {
	x: -7,
	y: 4,
	z: 0,
	name: 'All Skills Man',
	refName: 'allSkillsMan',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'red',
	prefix: 'Super Skilled Man, ',
	prefixColor: 'warrior-color-dark',
	keywords: ['skills', 'skill', 'man'],
	occupation: `Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)
		
	},
	//shadowmark
	//shadowvenom
	//poison
	//bleed
	skillsOffered: [twoHanded, oneHanded, unarmed, daggers, bows, shields, perception, rest, slashingExpertise, piercingExpertise, 
		bluntExpertise, firePenetration, icePenetration, lightningPenetration, weakSpot, vigor, devotion, cleave, multipleStrikes, 
		doubleDraw, extraStrike, stunningBlows, precision, warcraft, stealth, block, dodging, supremeDodging, toughness, sideStep, 
		quickshot, dodgeStrike, preemptiveStrike, lockpicking, smokeBomb, mindsEye, arcaneKnowledge, mysticismMastery, sorceryMastery, 
		magicDexterity, battleRage, resilience, hardenedSkin, knightsResolve, blacksmithing, evasiveRoll, 
		athletics, ridingSkill, tauntingShout, berserking, headshot, backstabbing, brutalBlows, thrillOfTheKill, counterAttack, 
		fleetFooted, initiation, vigilance, tactics, fistsOfFury, fistsOfPrecision, wayOfTheFist, bleed, burn, charge, stealth, 
		poison, shadowMark, shadowVenom],
	skillsMaxLevel: {
		twoHanded: 10,
		oneHanded: 10,
		unarmed: 10,
		daggers: 10,
		bows: 10,
		shields: 10,
		perception: 10,
		rest: 10,
		slashingExpertise: 10,
		piercingExpertise: 10,
		bluntExpertise: 10,
		firePenetration: 10,
		icePenetration: 10,
		lightningPenetration: 10,
		weakSpot: 10,
		vigor: 10,
		devotion: 10,
		cleave: 10,
		multipleStrikes: 10,
		doubleDraw: 10,
		extraStrike: 10,
		stunningBlows: 10,
		precision: 10,
		warcraft: 10,
		stealth: 10,
		precision: 10,
		block: 10,
		dodging: 10,
		supremeDodging: 10,
		sideStep: 10,
		dodgeStrike: 10,
		preemptiveStrike: 10,
		lockpicking: 10,
		smokeBomb: 10,
		mindsEye: 10,
		arcaneKnowledge: 10,
		mysticismMastery: 10,
		sorceryMastery: 10,
		magicDexterity: 10,
		battleRage: 10,
		resilience: 10,
		hardenedSkin: 10,
		knightsResolve: 10,
		blacksmithing: 10,
		evasiveRoll: 10,
		athletics: 10,
		ridingSkill: 10,
		tauntingShout: 10,
		berserking: 10,
		headshot: 10,
		backstabbing: 10,
		brutalBlows: 10,
		thrillOfTheKill: 10,
		counterAttack: 10,
		fleetFooted: 10,
		initiation: 10,
		vigilance: 10,
		brutalBlows: 10,
		tactics: 10,
		fistsOfFury: 10,
		fistsOfPrecision: 10,
		wayOfTheFist: 10,
		bleed: 10,
		burn: 10,
		charge: 10,
		stealth: 10,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const allAbilitiesMan = {
	x: -7,
	y: 4,
	z: 0,
	name: 'All Abilities Man',
	refName: 'allSkillsMan',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'red',
	prefix: 'Super Ability Man, ',
	prefixColor: 'warrior-color-dark',
	keywords: ['ability', 'man'],
	occupation: `Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
			trainInteraction(secondCommand, this)
	},
	skillsOffered: [ripslash, cyclone, cataclysm, dualStrike, shred, bladeBlitz, valorStrike, shieldSlam, boomingMight, 
	ambush, backstab, guillotine, venomBlade, contagion, bane, shadowDaggers, shadowsurge, shadowNova, catalyst, tempest, 
	callOfWind, knuckleBlitz, fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, blazingFist, tidalFist, 
	lightningFist, elementalTempest, transcendence, piercingArrow, rapidFireShot, hydraArrow, colossusPunch, hydraStrike, gigasUppercut, atmaShock],
	skillsMaxLevel: {
		ripslash: 10,
		cyclone: 10,
		cataclysm: 10,
		dualStrike: 10,
		shred: 10,
		bladeBlitz: 10,
		valorStrike: 10,
		shieldSlam: 10,
		boomingMight: 10,
		ambush: 10,
		backstab: 10,
		guillotine: 10,
		venomBlade: 10,
		contagion: 10,
		bane: 10,
		shadowDaggers: 10,
		shadowsurge: 10,
		shadowNova: 10,
		catalyst: 10,
		tempest: 10,
		callOfWing: 10,
		knuckleBlitz: 10,
		fireSeal: 10,
		waterSeal: 10,
		earthSeal: 10,
		mysticFist: 10,
		unleashedPower: 10,
		blazingFist: 10,
		tidalFist: 10,
		lightningFist: 10,
		elementalTempest: 10,
		transcendence: 10,
		piercingArrow: 10,
		rapidFireShot: 10,
		hydraArrow: 10,
		colossusPunch: 1,
		hydraStrike: 1,
		gigasUppercut: 1,
		atmaShock: 1,
	},
	itemsOffered: [shortsword, longsword, mailChestGuard, mailGloves, mailBoots, squiresShield],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const noviceBerserkerTrainer = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Novice Berserker Trainer',
	refName: 'noviceBerserkerTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'dark-red',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['berserker', 'novice', 'trainer'],
	occupation: `Novice Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `A novice teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with this guy`)
		}
	},
	get skillsOffered() {
		let level5Skills = [twoHanded, initiation, tactics, vigor, rest]
		return level5Skills
	},
	skillsMaxLevel: {
		twoHanded: 5,
		initiation: 5,
		tactics: 5,
		vigor: 5,
		rest: 5
	},
	speak: async function () {
		let line1 = lineFunc()
		customizeEachWord(`Hello, I am the Novice Trainer. I can teach you some basic skills.`, 'white', line1)
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const apprenticeBerserkerTrainer = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Apprenctice Berserker Trainer',
	refName: 'apprenticeBerserkerTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'dark-red',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['berserker', 'apprentice', 'trainer'],
	occupation: `Apprentice Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `A apprentice teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with this guy`)
		}
	},
	get skillsOffered() {
		let level10Skills = [ripslash, cyclone, cataclysm, charge, bleed, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, rest]
		return level10Skills
	},
	skillsMaxLevel: {
		ripslash: 2,
		cyclone: 2,
		cataclysm: 2,
		charge: 1,
		bleed: 2,
		twoHanded: 7,
		initiation: 7,
		tactics: 7,
		vigor: 5,
		warcraft: 3,
		precision: 3,
		cleave: 3,
		rest: 5
	},
	speak: async function () {
		let line1 = lineFunc()
		customizeEachWord(`Hello, I am the Apprentice Trainer. I can teach you some basic skills.`, 'white', line1)
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

const adeptBerserkerTrainer = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Adept Berserker Trainer',
	refName: 'adeptBerserkerTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'dark-red',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['berserker', 'adept', 'trainer'],
	occupation: `Adept Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `An adept teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with this guy`)
		}
	},
	get skillsOffered() {
		let level15Skills = [ripslash, cyclone, cataclysm, bleed, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, rest]
		return level15Skills
	},
	skillsMaxLevel: {
		ripslash: 5,
		cyclone: 5,
		cataclysm: 5,
		bleed: 6,
		twoHanded: 15,
		initiation: 10,
		tactics: 10,
		vigor: 10,
		warcraft: 6,
		precision: 6,
		cleave: 5,
		rest: 10
	},
	speak: async function () {
		let line1 = lineFunc()
		customizeEachWord(`Hello, I am the Adept Trainer. I can teach you some basic skills.`, 'white', line1)
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const skilledBerserkerTrainer = {
	x: -6,
	y: 5,
	z: 0,
	name: 'Skilled Berserker Trainer',
	refName: 'skilledBerserkerTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'dark-red',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['berserker', 'skilled', 'trainer'],
	occupation: `Skilled Berserker Class Trainer`,
	race: `Half-Minotaur`,
	description: `A skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Berserker') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Berserker in order to train with this guy`)
		}
	},
	get skillsOffered() {
		let level20Skills = [ripslash, cyclone, cataclysm, charge, bleed, twoHanded, initiation, tactics, vigor, warcraft, precision, cleave, counterAttack, stunningBlows, multipleStrikes, brutalBlows, thrillOfTheKill, battleRage, slashingExpertise, piercingExpertise, bluntExpertise, rest]
		return level20Skills
	},
	skillsMaxLevel: {
		ripslash: 5,
		cyclone: 5,
		cataclysm: 5,
		bleed: 6,
		twoHanded: 15,
		initiation: 10,
		tactics: 10,
		vigor: 10,
		warcraft: 6,
		precision: 6,
		cleave: 5,
		counterAttack: 3,
		stunningBlows: 3,
		multipleStrikes: 3,
		brutalBlows: 3,
		thrillOfTheKill: 3,
		battleRage: 3,
		slashingExpertise: 10,
		piercingExpertise: 10,
		bluntExpertise: 10,
		rest: 10
	},
	speak: async function () {
		let line1 = lineFunc()
		customizeEachWord(`Hello, I am the Skilled Trainer. I can teach you some basic skills.`, 'white', line1)
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const blacksmithingProfessionTrainer = {
	x: -3,
	y: 5,
	z: 0,
	name: 'Blacksmithing Profession Trainer',
	refName: 'blacksmithingProfessionTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'blacksmithingProfessionTrainer',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['blacksmithing', 'profession', 'trainer'],
	occupation: `Blacksmithing Profession Trainer`,
	race: `Dwarf`,
	description: `A blacksmith who teaches Blacksmithing.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		let blacksmithingSkills = [blacksmithing]
		return blacksmithingSkills
	},
	skillsMaxLevel: {
		get blacksmithing() {
			if (player.level <= 10) {return 2}
			if (player.level <= 15) {return 3}
			if (player.level <= 20) {return 4}
			if (player.level >= 21) {return 5}
		}
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`Blacksmithing Trainer: `, 'blacksmithingProfessionTrainer', line1)
		customizeEachWord(`"Welcome to the Blacksmithing Training House! Blacksmithing is a powerful skill that you can use to enhance your weapons and armor."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`Blacksmithing Trainer: `, 'blacksmithingProfessionTrainer', line2)
		customizeEachWord(`"If you've learned as much as I can teach you, you can check back every 5 levels. I will only be able to teach you Blacksmithing so high depending on your level."`, 'white', line2)
		blankSpace()
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const leatherworkingProfessionTrainer = {
	x: -3,
	y: 5,
	z: 0,
	name: 'Leatherworking Profession Trainer',
	refName: 'leatherworkingProfessionTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'leatherworkingProfessionTrainer',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['leatherworking', 'profession', 'trainer'],
	occupation: `Leatherworking Profession Trainer`,
	race: `Dwarf`,
	description: `A Leatherworker who teaches Leatherworking.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		let leatherworkingSkills = [leatherworking]
		return leatherworkingSkills
	},
	skillsMaxLevel: {
		get leatherworking() {
			if (player.level <= 10) {return 2}
			if (player.level <= 15) {return 3}
			if (player.level <= 20) {return 4}
			if (player.level >= 21) {return 5}
		}
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`Leatherworking Trainer: `, 'leatherworkingProfessionTrainer', line1)
		customizeEachWord(`"Welcome to the Leatherworking Training House! Leatherworking is a powerful skill that you can use to enhance your weapons and armor."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`Leatherworking Trainer: `, 'leatherworkingProfessionTrainer', line2)
		customizeEachWord(`"If you've learned as much as I can teach you, you can check back every 5 levels. I will only be able to teach you Leatherworking so high depending on your level."`, 'white', line2)
		blankSpace()
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const magicWeavingProfessionTrainer = {
	x: -3,
	y: 5,
	z: 0,
	name: 'Magic Weaving Profession Trainer',
	refName: 'magicWeavingProfessionTrainer',
	picture: 'images/npcs/male/warriors/berserkers/magvello/magvello.png',
	nameColor: 'magicWeavingProfessionTrainer',
	// prefix: 'Howling Blade, ',
	// prefixColor: 'warrior-color-dark',
	keywords: ['magic', 'weaving', 'profession', 'trainer'],
	occupation: `Magic Weaving Profession Trainer`,
	race: `Half-Elf`,
	description: `A Magic Weaver who teaches Magic Weaving.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		let magicWeavingSkills = [magicWeaving]
		return magicWeavingSkills
	},
	skillsMaxLevel: {
		get magicWeaving() {
			if (player.level <= 10) {return 2}
			if (player.level <= 15) {return 3}
			if (player.level <= 20) {return 4}
			if (player.level >= 21) {return 5}
		}
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Magic Weaving Trainer: `, 'magicWeavingProfessionTrainer', line1)
		customizeEachWord(`"Welcome to the Magic Weaving Training House! Magic Weaving is a powerful skill that you can use to enhance your weapons and armor."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`Magic Weaving Trainer: `, 'magicWeavingProfessionTrainer', line2)
		customizeEachWord(`"If you've learned as much as I can teach you, you can check back every 5 levels. I will only be able to teach you Magic Weaving so high depending on your level."`, 'white', line2)
		blankSpace()

	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

let fieldsTrainer
let fieldsTrainerQuestSequence = {
		first: false,
		second: false,
		third: false,
}
let fieldsTrainerOffer = {
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the town and Guild Halls. Most of the items you'll need can be found in the town shops, and the guild has teachers who will help you train your skills. Once you've outgrown it, you should explore east and west of the Castle Crossroads. To the east is the Glade of Galvadia. It's where a lot of the townspeople spend their time, but there's an area called The Shallows in the northeast corner of the glade that has some enemies that might suite your level. To the west of the Castle Crossroads is the Kobold Caves. You'll have to trek the path a ways to get there. It's a little more dangerous than The Shallows, so make sure you're well equipped. Those Kobolds can be nasty little buggers."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office after I meet with the other leaders. Come see me when you've reached level 10. That should give me enough time to figure out our next steps."`, 'white', line3)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} `, this.nameColor, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		let guildOffice
		if (player.guild == 'Warrior') {guildOffice = warriorsGuildOfficeHallVelthash}
		else if (player.guild == 'Sinistral') {guildOffice = sinistralsGuildZellOffice}
		else if (player.guild == 'Monk') {guildOffice = monksGuildSitoriaOffice}
		else if (player.guild == 'Ranger') {guildOffice = rangersGuildTilwinOffice}
		else if (player.guild == 'Mage') {guildOffice = mageGuildOlivandraOffice}
		npcRemoveFromTheirCurrentRoom(fieldsTrainer)
		npcAddToRoom(guildOffice, fieldsTrainer)
		pushItem.splice(qItemIndex, 1)
		fieldsTrainer.questSequence.ninth = true
		this.questStage = 10
		this.isQuestAvailable = false
	},
}
let fieldsTrainerQuest = {
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"There was a group many years ago that studied the least understood aspects of magic. Their knowledge was kept secret in the libraries of the cathedral. Some people wanted this knowledge out in the open, but the Monks and Priests wanted to completely understand the magic before allowing the public to study it. (continue)"`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"The Graveyard is on the otherside of the wall behind the Guild Plaza to the south, so you'll have to take the road east of the Galvadian Plaza. If you get lost, just read any signs you come across, and they'll point you in the right direction."`, 'white', line3)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line4)
		customizeEachWord(`"Come back when you think you've found something."`, 'white', line4)
		blankSpace()
		return
	},
}
let fieldsTrainerDialogue = {
	// quest: async function() {
	// 	if (!this.questSequence.first) {
	// 		quickMessage(`Try SPEAKing to Velthash`)
	// 		return
	// 	}
	// },
	speak: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let line5 = lineFunc()
		let line6 = lineFunc()
		let line7 = lineFunc()
		//All non-mage class dialogue
		if (!this.questSequence.first) {
			let meleeDialogue = `"Greetings, ${player.name}! You've come a long way since you first joined the Guild Prospect Training Academy. You're now ready to put all that knowledge to the test out in the Training Fields. I will be teaching you the essentials of being a ${player.playerClass.name}. We will go over using abilities, learning skills, increasing attributes, as well as some useful fighting tips. But, there's a problem. You don't have any skill or attribute points, and you don't know any abilities yet. So first, I want you to go into the Training Fields to the north to kill a few monsters until you gain a level. That should get you your first ability along with some skill and attribute points."`
			let mageDialogue = `"Greetings, you must be ${player.name}! I am ${this.name}. I will be teaching you the essentials of being a ${player.playerClass.name}. We will go over using spells, learning skills, increasing attributes, as well as some useful fighting tips. But, there's a problem. You don't have any skill or attribute points. So first, I want you to go into the Training Fields to the north to kill a few monsters until you gain a level. That should get you your first ability along with some skill and attribute points."`
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			if (player.guild != "Mage") {
				customizeEachWord(`${meleeDialogue}`, 'white', line1)
			} else {
				customizeEachWord(`${mageDialogue}`, 'white', line1)
			}
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Enemies can only appear and move around in hostile areas. This means that you are safe once you enter a room like this one as they cannot follow you here. The color change from one area to another can sometimes indicate entering/exiting a hostile area, but not always."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"The Training Fields have slightly more difficult enemies toward the back, so if you're new to combat, I would suggest not going in too deep until you gain a level or two. The area will also be a slightly different color, so you will know if you've gone too far."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line5)
			customizeEachWord(`"Be sure to pick up any items from the ground you want to keep. Enemies will pick up leftover items if you're not in the same room, though, if you kill them they will drop everything they picked up."`, 'white', line5)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`You can now move to the `, 'white', line4)
			customizeEachWord(`north`, 'green', line4)
			blankSpace()
			currentArea.descriptions.zoneExitsBool.north = true
			this.questSequence.first = true
			return
		}
		if (!this.questSequence.second && player.level == 1) {
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Go to the Training Fields to the north and fight the monsters there until you reach level 2."`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.second && player.level >= 2) {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"Good work! Now that you've leveled up, I'll teach you a few things."`, 'white', line1)
				blankSpace()
				
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line2)
				customizeEachWord(`"Skills must be learned from a class trainer, such as myself. To see a list of skills that a class trainers has to offer, use the SHOW SKILLS command. Then use the TRAIN command followed by the skill number to increase its level. Abilities can only be learned by reaching certain levels, however, you can increase their potency by training them with skill points."`, 'white', line2)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"Every skill I have to offer is worth training, but I would recommend starting with your weapon skill first. This is your most important skill because it increases your damage, accuracy, and it's the only skill that increases your attack speed. If you don't know what your main weapon skill is, equip the weapon you found in the Training Halls Basement and see what it says underneath the weapon icons at the bottom of the screen"`, 'white', line3)
				blankSpace()
				
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line4)
				customizeEachWord(`"You can increase your attributes at any time as long as you have attribute points to spend. To do this, use the INCREASE command followed by the attribute you want to increase. For example, if you wanted to increase your strength, the command would look like this: increase strength (shorthand would be: inc str). Once an attribute has been increased, you will not be able to refund the points, so be careful when allocating them."`, 'white', line4)
				blankSpace()
				if (player.guild != 'Mage') {
					await dialogueWait(200)
					customizeEachWord(`${this.name}: `, this.nameColor, line5)
					customizeEachWord(`"Abilities are your core damaging attacks, and they can be used alongside your regular attacks. This means that you can use abilities even while unbalanced from swinging your weapon. But, you can only use one ability at a time, i.e., you cannot use ability 1, 2, and 3 in quick succession. As you level up, you will gain a total of 3 abilities. You can use your abilities by using commands on the NumPad. Your first ability that you just learned can be performed by using the / command. Once you've learned them, your second and third ability are performed by using the * and - command, respectively."`, 'white', line5)
					blankSpace()
				}
				if (player.guild == 'Mage') {
					await dialogueWait(200)
					customizeEachWord(`${this.name}: `, this.nameColor, line5)
					customizeEachWord(`"As a Mage class, you will wear cloth armor because it will enhance the potency of your spells, however, it provides no armor. Because of this, Magic Shield is a Mage's primary means of defense. It takes longer to cast than offensive spells, so be careful not to get caught while channeling it. You should always apply Magic Shield to yourself before going into combat. 
						You can only cast one ability at a time, i.e., you cannot use spells 1, 2, and 3 in quick succession. As you level up, you will gain a total of 3 spells. You can use your spells by using commands on the NumPad. Your first spell that you just learned can be performed by using the / command. Once you've learned them, your second and third spells are performed by using the * and - command, respectively."`, 'white', line5)
					blankSpace()
				}
				if (player.guild == 'Warrior') {
					await dialogueWait(200)
					customizeEachWord(`${this.name}: `, this.nameColor, line6)
					customizeEachWord(`"Warrior abilities are considered "wind-up" abilities. This means when you use an ability, it will begin winding up, and your ability bar will start filling up. When it fills completely, the ability will execute. You need to be engaged in combat with an enemy for it to deal damage, just like regular attacks. If you're not in combat when your ability is executed, you will expend too much energy and will have to wait a long duration before you can use another ability."`, 'white', line6)
					customizeEachWord(`"Warriors utilize MIGHT to perform abilities. You gain 1 Might each time you successfully land a regular attack. It's important to note that because Warriors are such battle hungry fighters, they will lose some of their accumulated Might if they retreat."`, 'white', line6)
					blankSpace()
				}
				if (player.guild == 'Sinistral') {
					await dialogueWait(200)
					customizeEachWord(`${this.name}: `, this.nameColor, line6)
					customizeEachWord(`"Sinistral abilities will strike an enemy instantly when used as long as you use the ability while stealthed or if you're already engaged. Some abilities will grant you bonuses or deal extra damage when used from stealth."`, 'white', line6)
					customizeEachWord(`"Sinistral abilities cost Adrenaline to execute. Each time you land a successful regular attack, you will gain 2 Adrenaline"`, 'white', line6)
					blankSpace()
				}
				if (player.guild == 'Monk') {
					await dialogueWait(200)
					customizeEachWord(`${this.name}: `, this.nameColor, line6)
					customizeEachWord(`"Monk abilities will strike an enemy instantly when used as long as you're engaged."`, 'white', line6)
					customizeEachWord(`"Monk abilities cost Focus to execute. Each time you land a successful regular attack, you will gain 2 Focus"`, 'white', line6)
					blankSpace()
				}
				if (player.guild == 'Ranger') {
					await dialogueWait(200)
					customizeEachWord(`${this.name}: `, this.nameColor, line6)
					customizeEachWord(`"Ranger abilities are considered wind-up abilities. This means when you use an ability, it will begin winding up, and your ability bar will start filling up. When it fills completely, the ability will execute. Unlike Warriors, you must have a target first in order for the ability to begin winding up. If your ability executes without an enemy in the room for it to hit, you will expend too much energy, and you won't be able to use another ability for a duration."`, 'white', line6)
					customizeEachWord(`"Ranger abilities cost Focus to execute. Each time you land a successful regular attack, you will gain Focus."`, 'white', line6)
					blankSpace()
				}
			this.questSequence.second = true
			return
		}
		if (!this.questSequence.third && player.level == 2) {
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Go back to the Training Fields to practice what I've taught you. Return when you've reached level 3."`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.third && player.level >= 3) {
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Now that you have some combat experience under your belt, I'd like to share some useful combat tactics with you."`, 'white', line1)
			blankSpace()
			if (player.guild != 'Mage') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line2)
				customizeEachWord(`"If you find yourself taking too much damage, you can employ the "attack and retreat" tactic. You can wait for the enemy to advance you, attack it as soon as it does, then retreat in a direction. This will allow you to retreat in a direction before the enemy is able to hit you. However, there are a few things to consider. Each time you enter a room in a combat area, there's a chance for an enemy to appear, so if you retreat in a direction too much you might find yourself overwhelmed with enemies. At later levels, enemies will move and attack much quicker, so it will be harder to employ this tactic later on."`, 'white', line2)
				blankSpace()
			}
			if (player.guild == 'Warrior') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"Classes of the Warrior's Guild have a unique aspect with their abilities in that they can be used without needing a target first. This can allow you to time your windups to finish as soon as an enemy advances you, and then follow up with a regular attack to get big burst of damage."`, 'white', line3)
				blankSpace()
			}
			if (player.guild == 'Sinistral') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"While classes of the Sinisral's Guild can retreat immediately after using an ability, the cooldown of your ability will be applied to your retreat timer. You can reduce this penalty by training the skill Fleet Footed. This skill reduces the overall amount of time it takes to recover after retreating."`, 'white', line3)
				blankSpace()
			}
			if (player.guild == 'Monk') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"While classes of the Monk's Guild can retreat immediately after using an ability, the cooldown of your ability will be applied to your retreat timer. You can reduce this penalty by training the skill Fleet Footed. This skill reduces the overall amount of time it takes to recover after retreating."`, 'white', line3)
				blankSpace()
			}
			if (player.guild == 'Ranger') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"Instead of waiting for an enemy to advance you before retreating, Rangers have the unique ability to attack and move in a direction before the enemy can advance you. However, each time you enter a room, there's a chance for an enemy to appear, so if you move around too much, you could find yourself overwhelmed. Also, the ability to move before an enemy advances you depends on the enemy's speed vs your attack speed. At higher levels, enemies will move much more quickly making it harder to employ this tactic."`, 'white', line3)
				blankSpace()
			}
			if (player.guild == 'Mage') {
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line2)
				customizeEachWord(`"Be careful not to stay in the same room too long casting your spells as you'll leave yourself vulnerable to enemy attacks. If enemies are advancing you while you channel your spells, you can employ the "cast and retreat tactic" by retreating in a direction as soon as your spell is cast. This will allow your spell to hit the enemy while simultaneously moving in a direction before the enemy can attack you. However, there are a few things to consider. Each time you enter a room in a combat area, there's a chance feor an enemy to appear, so if you retreat in a direction too much you might find yourslef overwhelmed with enemies. At later levels, enemies will move and attack much quicker, so it will be harder to employ this tactic later on.`, 'white', line2)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line3)
				customizeEachWord(`"If there are multiple enemies in the room, you can target any of them with your spells. You need to have a spell conjured first, then use the TARGET or T command followed by the number of the enemy you want to target. An enemy's number corresponds to their portrait in the enemy panel.`, 'white', line3)
				blankSpace()
			}
			this.questSequence.third = true
			return
		}
		if (!this.questSequence.fourth && player.level == 3) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Go back and train in the fields until you've reached level 4.`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.fourth) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"In combat areas, there will sometimes be a more powerful creature lurking around. Finding them will require a certain level of `, 'white', line1)
			customizeEachWord(`Perception`, 'green', line1)
			customizeEachWord(`. `, 'white', line1)
			customizeEachWord(`Perception `, 'green', line1)
			customizeEachWord(`is the ability to see hidden things in a room that you otherwise wouldn't be able to see or interact with. Your `, 'white', line1)
			customizeEachWord(`Perception `, 'green', line1)
			customizeEachWord(`skill naturally increases with your level, so sometimes you might not notice something hidden until you reach a certain level."`, 'white', line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			// customizeEachWord(`"If you haven't already noticed, you should see something new in this room. Try to find a way to open the way to the south."`, 'white', line2)
			customizeEachWord(`"You probably noticed that you can see more in this room now. That's because your perception has increased as it does when you gain a level. Go ahead and try examining the grass in this room to see if you can find the hidden area. Once you do, make sure to slay the enemies there and return here once you have."`, 'white', line2)
			blankSpace()
			this.questSequence.fourth = true
			return
		}
		if (!this.questSequence.fifth && currentArea.descriptions.zoneExitsBool.south == 'blocked') {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Try examining the grass in this room to see if you can find a way to the south."`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.sixth && (player.killList.littleMudElemental || player.killList.littleGrassElemental || player.killList.littleWaterElemental)) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Congratulations, you've completed your combat training! You're ready to join the ${player.guild}'s Guild. For now, go back to Egbert so he can complete your admissions, and then meet me outside the ${player.guild}'s Guild when you're ready."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"I'll see you soon, ${player.name}!"`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name} `, this.nameColor, line3)
			customizeEachWord(`walks to the west`, 'white', line3)
			blankSpace()
			this.questSequence.sixth = true
			crossroads_shops_and_fields.npc.pop()
			switch(player.guild) {
				case 'Warrior':
				warriorsGuildEntrance.npc.push(this)
				break;
				case 'Mage':
				mageGuildEntrance.npc.push(this)
				break;
				case 'Sinistral':
				sinistralsGuildEntrance.npc.push(this)
				break;
				case 'Monk':
				monksGuildEntrance.npc.push(this)
				break;
				case 'Ranger':
				rangersGuildEntrance.npc.push(this)
				break;
				default:
				quickMessage(`none of these`)
			}
			dialogueChangeStage(egbert, 15)
			return
		} else if (!this.questSequence.sixth && !player.killList.littleMudElemental && !player.killList.littleGrassElemental && !player.killList.littleWaterElemental) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Let me know when you've slain the monsters to the south."`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.seventh) {
			console.log(this.questSequence, 'full quest sequence')
			console.log(this.questSequence.fifth, 'full quest sequence')
			let direction
			if (player.guild == 'Warrior') {direction = `to the south and down the stairs.`}
			if (player.guild == 'Sinistral') {direction = `to the southeast and down the stairs.`}
			if (player.guild == 'Monk') {direction = `to the west.`}
			if (player.guild == 'Ranger') {direction = `to the east and up the stairs.`}
			if (player.guild == 'Mage') {direction = `to the southwest.`}
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Welcome to the ${player.guild}'s Guild! Let's head inside so I can show you around. Meet me in the ${player.guild}'s Guild Common Room ${direction}"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name} `, this.nameColor, line2)
			customizeEachWord(`goes inside the ${player.guild}'s Guild.`, 'white', line2)
			blankSpace()
			switch(player.guild) {
				case 'Warrior':
					warriorsGuildDownstairsInterior2.npc.push(this)
					break;
				case 'Mage':
					mageGuildCommonRoom.npc.push(this)
					break;
				case 'Sinistral':
					sinistralsGuildCommonRoom.npc.push(this)
					break;
				case 'Monk':
					monksGuildCommonRoom.npc.push(this)
					break;
				case 'Ranger':
					rangersGuildStaircase.npc.push(this)
					break;
					default:
					quickMessage(`none of these`)
			}
			currentArea.npc.pop()
			this.questSequence.seventh = true
			return
		}
		if (!this.questSequence.seventh) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"This is the ${player.guild}'s Guild Commons. It's the central room in the guild that branches into the Class Halls, where you will do most of your training. You can read the sign here to see where each class's wing is. As you level up, you will gain access to more of your class's wing, allowing you to train skills to higher levels and even gain access to new skills that are currently unavailable to you. However, you are only allowed to train from teachers of your class."`, 'white', line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"To start your journey as a ${player.guild}, we already have a task prepared for you. Let me know when you're ready, and I'll share the details with you."`, 'white', line2)
			blankSpace()
			this.questSequence.seventh = true
			this.isQuestAvailable = true
			return
		}
		if (!this.questSequence.eighth) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"There was a group many years ago that studied the least understood aspects of magic. Their knowledge was kept secret in the libraries of the cathedral. Some people wanted this knowledge out in the open, but the Monks and Priests wanted to completely understand the magic before allowing the public to study it. (continue)"`, 'white', line2)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"The Graveyard is on the otherside of the wall behind the Guild Plaza to the south, so you'll have to take the road east of the Galvadian Plaza. If you get lost, just read any signs you come across, and they'll point you in the right direction."`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line4)
			customizeEachWord(`"Come back when you think you've found something."`, 'white', line4)
			blankSpace()
			this.questSequence.eighth = true
			return
		}
		if (!this.questSequence.ninth) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"The Graveyard is to the south behind the walls, but there's no direct road there. You'll have to go to the town square and read the bulletin in the square. Return back when you've found something worth investigating."`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.tenth && player.level >= 10) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"After meeting with the other leaders, we've discovered some unsettling news. It turns out that someone within the castle ranks has been communicating secrets of magic and other inside information to the outside. To who, we don't know yet. We believe this is also tied to the unusual activity in the Goblin Hills that we've spotted from the North Garrison. They must know that the Council of Kings are out on official business and won't be back for some time. This is something not even guild leaders were made aware of. And nobody would dare attack us if the Council was here."`, 'white', line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"If this is all true, we have to prepare. This is why I need you to gain as much experience in combat as you can before heading to the North Garrison. Once there, speak with the commander to get your assignment."`, 'white', line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"You'll need to reach at least level 20 before heading to the North Garrison. The Kobold Caves should be a good place for you to fight right now. Once you can handle the Kobolds easily, you can explore the Gnoll plains north of the Kobold Caves."`, 'white', line3)
			blankSpace()
			this.questSequence.tenth = true
			return
		} else if (player.level < 10) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You should explore east and west of the Castle Crossroads. To the east is the Glade of Galvadia. It's where a lot of the townspeople spend their time, but there's an area called The Shallows in the northeast corner that has some enemies suitable for your level. To the west of the Castle Crossroads is the Kobold Caves. You'll have to trek the path a ways to get there. It's a little more dangerous than The Shallows, so make sure you're well equipped. Those Kobolds can be nasty little buggers."`, 'white', line1)
			blankSpace()
			return
		}
		if (!this.questSequence.eleventh && player.level >= 20) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You've done it! You're Ready to fight GOBLINS!!"`, 'white', line1)
			blankSpace()
			this.questSequence.eleventh = true
			return
		} else if (player.level < 20) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Keep training. We need to make sure you're strong enough to take on Goblins. They're nasty creatures. I suggest fighting Kobolds until you're strong enough for the Gnolls in the Gnoll Plains."`, 'white', line1)
			blankSpace()
			return
		}
	},


}

let questObject = {
	todlin: {
		gnollFur: {
			questItem: gnollFur,
		}
	},
	weaponsmith: {
		copperQuest: {
			count: 0,
			oreMax: 6,
			questItem: copperOre,
			questSequence1: {
			}
		},
		ironQuest: {
			count: 0,
			oreMax: 0,
			questItem: ironOre,
			questSequence1: {
				complete: false,
			}
		},
		lightHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: lightHide,
			questSequence1: {
				complete: false,
			}
		},
		thickHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: thickHide,
			questSequence1: {
				complete: false,
			}
		},
		cloverQuest: {
			count: 0,
			questItem: clover,
			questSequence1: {
				complete: false,
			}
		},
		orchidQuest: {
			count: 0,
			questItem: orchid,
			questSequence1: {
				complete: false,
			}
		},
	},
	armorsmith: {
		copperQuest: {
			count: 0,
			oreMax: 0,
			questItem: copperOre,
			questSequence1: {
				complete: false,
			}
		},
		ironQuest: {
			count: 0,
			oreMax: 0,
			questItem: ironOre,
			questSequence1: {
				complete: false,
			}
		},
		lightHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: lightHide,
			questSequence1: {
				complete: false,
			}
		},
		thickHideQuest: {
			count: 0,
			hideMax: 0,
			questItem: thickHide,
			questSequence1: {
				complete: false,
			}
		},
		cloverQuest: {
			count: 0,
			questItem: clover,
			questSequence1: {
				complete: false,
			}
		},
		orchidQuest: {
			count: 0,
			questItem: orchid,
			questSequence1: {
				complete: false,
			}
		},
	},
}
async function craftQuestTurnIn1(npc, rewardAmount) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`hands you `, 'white', line1)
	customizeEachWord(`${rewardAmount} `, 'yellow', line1)
	customizeEachWord(`gold`, 'white', line1)
	playerGainGold(rewardAmount)
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name}: `, npc.nameColor, line2)
	customizeEachWord(`"For every 3 ores, I can craft a new set of weapons. So fa, you have turned in a total of ${questObject.weaponsmith.copperQuest.count}"`, 'white', line2)
	blankSpace()
}
async function craftQuestTurnIn2(npc, rewardAmount) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`hands you `, 'white', line1)
	customizeEachWord(`${rewardAmount} `, 'yellow', line1)
	customizeEachWord(`gold`, 'white', line1)
	await dialogueWait(200)
	blankSpace()
	playerGainGold(rewardAmount)
	customizeEachWord(`${npc.name}: `, npc.nameColor, line2)
	customizeEachWord(`"I can craft a new set of weapons! Check out the shop to see what's in stock."`, 'white', line2)
	blankSpace()
}
async function craftQuestTurnIn3(npc, rewardAmount) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`hands you `, 'white', line1)
	customizeEachWord(`${rewardAmount} `, 'yellow', line1)
	customizeEachWord(`gold`, 'white', line1)
	playerGainGold(rewardAmount)
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name}: `, npc.nameColor, line2)
	customizeEachWord(`"I can now craft all weapons that are made using copper ore."`, 'white', line2)
	blankSpace()
}
async function craftQuestComplete(npc) {
	let line1 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name}: `, npc.nameColor, line1)
	customizeEachWord(`"I don't need any copper ore. I can make everything that utilizes copper."`, 'white', line1)
	blankSpace()
}


let questDialogueObject = {

}

let greaves = {
	x: -10,
	y: -13,
	z: -1,
	name: 'Greaves',
	refName: 'greaves',
	picture: 'images/npcs/male/warriors/knights/greaves/greaves.png',
	nameColor: 'blue',
	prefix: 'Hand of Justice, ',
	prefixColor: 'warrior-color-light',
	keywords: ['greaves'],
	occupation: `Knight's Guild Master`,
	race: `Human`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Knight') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Knight in order to train with Greaves.`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [valorStrike, tauntingShout, oneHanded, shields, initiation, tactics, vigor]
		} else if (player.level < 20) {
			return [valorStrike, shieldSlam, boomingMight, tauntingShout, oneHanded, shields, block, knightsResolve, initiation, tactics, vigor, warcraft, precision, 
				slashingExpertise, piercingExpertise, bluntExpertise]
		} else if (player.level < 30) {
			return [valorStrike, shieldSlam, boomingMight, tauntingShout, oneHanded, shields, block, knightsResolve, battleRage, counterAttack, brutalBlows, 
				multipleStrikes, stunningBlows, resilience, initiation, tactics, vigor, warcraft, precision, slashingExpertise, 
				piercingExpertise, bluntExpertise]
		} else {
			return 	[valorStrike, shieldSlam, boomingMight, tauntingShout, oneHanded, shields, block, knightsResolve, slashingExpertise, piercingExpertise, 
				bluntExpertise, battleRage, blacksmithing, counterAttack, tactics, initiation, brutalBlows, 
				multipleStrikes, stunningBlows, vigor, warcraft, precision, resilience]
		}
	},
	skillsMaxLevel: {
		get valorStrike() {return skillMaxLevel2(player.valorStrike)},
		get shieldSlam() {return skillMaxLevel2(player.shieldSlam)},
		get boomingMight() {return skillMaxLevel2(player.boomingMight)},
		get tauntingShout() {return skillMaxLevel5(player.tauningShout)},
		get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
		get shields() {return weaponSkillMaxLevel(player.shields)},
		get block() {return skillMaxLevel3(player.block)},
		get knightsResolve() {return skillMaxLevel5(player.knightsResolve)},
		get slashingExpertise() {return skillMaxLevel5(player.slashingExpertise)},
		get piercingExpertise() {return skillMaxLevel5(player.piercingExpertise)},
		get bluntExpertise() {return skillMaxLevel5(player.bluntExpertise)},
		get battleRage() {return skillMaxLevel5(player.battleRage)},
		blacksmithing: 10,
		get counterAttack() {return skillMaxLevel2(player.counterAttack)},
		get tactics() {return skillMaxLevel5(player.tactics)},
		get initiation() {return skillMaxLevel5(player.initiation)},
		get brutalBlows() {return skillMaxLevel2(player.brutalBlows)},
		get multipleStrikes() {return skillMaxLevel2(player.multipleStrikes)},
		get stunningBlows() {return skillMaxLevel2(player.stunningBlows)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get resilience() {return skillMaxLevel3(player.resilience)},
	},
	questSequence: {
	},
	itemsOffered: [shortsword, longsword],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {

	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}


const daggslain = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Daggslain',
	refName: 'daggslain',
	nameColor: 'yellow',
	prefix: 'Silent Carnage, ',
	prefixColor: 'sinistral-color',
	keywords: ['daggslain'],
	occupation: `trainer`,
	race: `Human`,
	description: `Assassin's Guild Master`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Assassin') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Sinistral's Guild Prospect `, 'sinistral-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [ambush, stealth, daggers, dodging, fleetFooted, vigilance]
		} else if (player.level < 20) {
			return [ambush, backstab, guillotine, smokeBomb, stealth, daggers, dodging, fleetFooted, vigilance, vigor, precision, multipleStrikes, sinisterMark]
		} else if (player.level < 30) {
			return [ambush, backstab, guillotine, smokeBomb, stealth, daggers, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, sinisterMark]
		} else {
			return [ambush, backstab, guillotine, smokeBomb, stealth, daggers, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, sinisterMark]
		}
	},
	skillsMaxLevel: {
		get ambush() {return skillMaxLevel2(player.ambush)},
		get backstab() {return skillMaxLevel2(player.backstab)},
		get guillotine() {return skillMaxLevel2(player.guillotine)},
		get smokeBomb() {return skillMaxLevel5(player.smokeBomb)},
		get daggers() {return weaponSkillMaxLevel(player.daggers)},
		get stealth() {return skillMaxLevel5(player.stealth)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get dodgeStrike() {return skillMaxLevel3(player.dodgeStrike)},
		get supremeDodging() {return skillMaxLevel5(player.supremeDodging)},
		get backstabbing() {return skillMaxLevel5(player.backstabbing)},
		get fleetFooted() {return skillMaxLevel5(player.fleetFooted)},
		get vigilance() {return skillMaxLevel5(player.vigilance)},
		get vigor() {return skillMaxLevel3(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get multipleStrikes() {return skillMaxLevel3(player.multipleStrikes)},
		get sinisterMark() {return skillMaxLevel5(player.sinisterMark)},
	},
		questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const zell = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Zell',
	refName: 'zell',
	nameColor: 'yellow',
	prefix: 'Silent Carnage, ',
	prefixColor: 'sinistral-color',
	keywords: ['zell'],
	occupation: `trainer`,
	race: `Human`,
	description: `Assassin's Guild Master`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.guild != 'Sinistral') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Sinistral `, 'sinistral-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [daggers, oneHanded, stealth],
	skillsMaxLevel: {
		daggers: 5,
		stealth: 2,
	},
	questStage: 1,
	questSequence: {
	first: false,
	second: false,
	},
	questItem: [cultTexts],
	itemsOffered: [],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	isQuestAvailable: false,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"There was a group many years ago that studied the least understood aspects of magic. Their knowledge was kept secret in the libraries of the cathedral. Some people wanted this knowledge out in the open, but the Monks and Priests wanted to completely understand the magic before allowing the public to study it. (continue)"`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"The Graveyard is on the otherside of the wall behind the Guild Plaza to the south, so you'll have to take the road east of the Galvadian Plaza. If you get lost, just read any signs you come across, and they'll point you in the right direction."`, 'white', line3)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line4)
		customizeEachWord(`"Come back when you think you've found something."`, 'white', line4)
		blankSpace()
		return
	},
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the Guild Halls. The class trainers here have more skills to offer you. As for training, the Graveyard should suffice for a while. Once you've outgrown it, you should explore east and west of the Castle Crossroads. To the east is the Glade -- a very peaceful and relaxing place, typically teeming with townspeople. A little farther in and to the northeast, you'll find the entrance to The Shallows. To the west of the Castle Crossroads is the Kobold Caves. It's a little more dangerous than The Shallows, so make sure you're well equipped."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office inside the guild once I'm finished meeting with the guild leaders. Check in after you've reached level 10. That should give me enough time. I might have a new task for you after we discuss our next move."`, 'white', line3)
		blankSpace()
		customizeEachWord(`${this.name} `, this.color, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		currentArea.npc.pop()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.seventh = true
		this.isQuestAvailable = false
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
		// if (this.questSequence.second) {
		// 	this.questSequence.first = true
		// 	this.speak()
		// }
	},
}
const shallox = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Shallox',
	refName: 'shallox',
	nameColor: 'yellow',
	// prefix: 'Shadow Tamer, ',
	prefix: 'Master of Shadows, ',
	prefixColor: 'dark-purple',
	keywords: ['Shallox'],
	occupation: `Shadowblade Guild Master`,
	race: `Human`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Shadowblade') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Sinistral's Guild Prospect `, 'sinistral-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [shadowsurge, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance]
		} else if (player.level < 20) {
			return [shadowsurge, shadowDaggers, shadowNova, smokeBomb, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance, vigor, precision, multipleStrikes, shadowMark]
		} else if (player.level < 30) {
			return [shadowsurge, shadowDaggers, shadowNova, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, shadowMark]
		} else {
			return [shadowsurge, shadowDaggers, shadowNova, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, shadowMark]
		}
	},
	skillsMaxLevel: {
		get shadowsurge() {return skillMaxLevel2(player.shadowsurge)},
		get shadowDaggers() {return skillMaxLevel2(player.shadowDaggers)},
		get shadowNova() {return skillMaxLevel2(player.shadowNova)},
		get smokeBomb() {return skillMaxLevel5(player.smokeBomb)},
		get daggers() {return weaponSkillMaxLevel(player.daggers)},
		get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
		get stealth() {return skillMaxLevel5(player.stealth)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get dodgeStrike() {return skillMaxLevel3(player.dodgeStrike)},
		get supremeDodging() {return skillMaxLevel5(player.supremeDodging)},
		get backstabbing() {return skillMaxLevel5(player.backstabbing)},
		get fleetFooted() {return skillMaxLevel5(player.fleetFooted)},
		get vigilance() {return skillMaxLevel5(player.vigilance)},
		get vigor() {return skillMaxLevel3(player.vigor)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get multipleStrikes() {return skillMaxLevel3(player.multipleStrikes)},
		get shadowMark() {return skillMaxLevel5(player.shadowMark)},
	},
		questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [crudeShiv, leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Shallox. I'm here to train Sinistral's Guild Prospects who are interested in joining the Sinistral's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}

	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const kaijin = {
	x: -8,
	y: 6,
	z: 0,
	name: 'Kaijin',
	refName: 'kaijin',
	nameColor: 'monk-color',
	prefix: 'Wisened Fool, ',
	prefixColor: 'purple',
	keywords: ['kaijin'],
	occupation: `trainer`,
	race: `Dragonkin`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Monk') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Monk's Guild Prospect `, 'monk-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.catpitalName}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [unarmed, toughness, dodging],
	skillsMaxLevel: {
		unarmed: 5,
		toughness: 5,
		dodging: 5,
		// empoweringStrike: 1,
		// catalyst: 5,
		// tempest: 5,
		// fireSeal: 5,
		// flameStrike: 5,
		// waterSeal: 5,
		// waveFist: 5,
		// blazingFist: 5,
		// riptideFist: 5,
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Kaijin. I'm here to train Monk's Guild Prospects who are interested in joining the Monk's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const delverick = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Delverick',
	refName: 'delverick',
	nameColor: 'monk-color',
	prefix: 'Martial Monk, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color-light',
	keywords: ['delverick'],
	occupation: `trainer`,
	race: `Human`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Martial Monk') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Martial Monk in order to train with Delverick`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [catalyst, tempest, unarmed, dodging, toughness, vigor, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 20) {
			return [catalyst, tempest, callOfWind, knuckleBlitz, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 30) {
			return [catalyst, tempest, callOfWind, knuckleBlitz, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		} else {
			return [catalyst, tempest, callOfWind, knuckleBlitz, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		}
	},
	skillsMaxLevel: {
		get catalyst() {return skillMaxLevel2(player.catalyst)},
		get tempest() {return skillMaxLevel2(player.tempest)},
		get callOfWind() {return skillMaxLevel2(player.callOfWind)},
		get knuckleBlitz() {return skillMaxLevel2(player.knuckleBlitz)},
		get unarmed() {return weaponSkillMaxLevel(player.unarmed)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get toughness() {return skillMaxLevel5(player.toughness)},
		get hardenedSkin() {return skillMaxLevel5(player.hardenedSkin)},
		get resilience() {return skillMaxLevel5(player.resilience)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel4(player.warcraft)},
		get precision() {return skillMaxLevel4(player.precision)},
		get wayOfTheFist() {return skillMaxLevel4(player.wayOfTheFist)},
		get stunningBlows() {return skillMaxLevel3(player.stunningBlows)},
		get preemptiveStrike() {return skillMaxLevel3(player.preemptiveStrike)},
		get fistsOfFury() {return skillMaxLevel3(player.fistsOfFury)},
		get fistsOfPrecision() {return skillMaxLevel3(player.fistsOfPrecision)},
		get extraStrike() {return skillExtraStrikeMaxLevel(player.extraStrike)},
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Delverick. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const maelius = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Maelius',
	refName: 'maelius',
	nameColor: 'monk-color',
	prefix: 'Mystic Monk, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color',
	keywords: ['maelius'],
	occupation: `trainer`,
	race: `Elf`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Mystic Monk') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be a Mystic Monk in order to train with Maelius`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [fireSeal, waterSeal, earthSeal, unarmed, dodging, toughness, vigor, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 20) {
			return [fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 30) {
			return [fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		} else {
			return [fireSeal, waterSeal, earthSeal, mysticFist, unleashedPower, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		}
	},
	skillsMaxLevel: {
		get fireSeal() {return skillMaxLevel2(player.fireSeal)},
		get waterSeal() {return skillMaxLevel2(player.waterSeal)},
		get earthSeal() {return skillMaxLevel2(player.earthSeal)},
		get mysticFist() {return skillMaxLevel2(player.mysticFist)},
		get unleashedPower() {return skillMaxLevel2(player.unleashedPower)},
		get unarmed() {return weaponSkillMaxLevel(player.unarmed)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get toughness() {return skillMaxLevel5(player.toughness)},
		get hardenedSkin() {return skillMaxLevel5(player.hardenedSkin)},
		get resilience() {return skillMaxLevel5(player.resilience)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel4(player.warcraft)},
		get precision() {return skillMaxLevel4(player.precision)},
		get wayOfTheFist() {return skillMaxLevel4(player.wayOfTheFist)},
		get stunningBlows() {return skillMaxLevel3(player.stunningBlows)},
		get preemptiveStrike() {return skillMaxLevel3(player.preemptiveStrike)},
		get fistsOfFury() {return skillMaxLevel3(player.fistsOfFury)},
		get fistsOfPrecision() {return skillMaxLevel3(player.fistsOfPrecision)},
		get extraStrike() {return skillExtraStrikeMaxLevel(player.extraStrike)},
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Maelius. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const fearecia = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Fearecia',
	refName: 'fearecia',
	nameColor: 'monk-color',
	prefix: 'Elemental Monk, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color-dark',
	keywords: ['fearecia'],
	occupation: `trainer`,
	race: `Dragon Kin`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name == 'Elemental Monk') {
			trainInteraction(secondCommand, this)
		} else {
			quickMessage(`You must be an Elemental Monk in order to train with Fearecia`)
		}
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [blazingFist, tidalFist, lightningFist, unarmed, dodging, toughness, vigor, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 20) {
			return [blazingFist, tidalFist, lightningFist, elementalTempest, transcendence, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, fistsOfFury, fistsOfPrecision]
		} else if (player.level < 30) {
			return [blazingFist, tidalFist, lightningFist, elementalTempest, transcendence, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		} else {
			return [blazingFist, tidalFist, lightningFist, elementalTempest, transcendence, unarmed, dodging, toughness, hardenedSkin, resilience, vigor, warcraft, precision, wayOfTheFist, stunningBlows, preemptiveStrike, fistsOfFury, fistsOfPrecision, extraStrike]
		}
	},
	skillsMaxLevel: {
		get blazingFist() {return skillMaxLevel2(player.blazingFist)},
		get tidalFist() {return skillMaxLevel2(player.tidalFist)},
		get lightningFist() {return skillMaxLevel2(player.lightningFist)},
		get elementalTempest() {return skillMaxLevel2(player.elementalTempest)},
		get transcendence() {return skillMaxLevel2(player.transcendence)},
		get unarmed() {return weaponSkillMaxLevel(player.unarmed)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get toughness() {return skillMaxLevel5(player.toughness)},
		get hardenedSkin() {return skillMaxLevel5(player.hardenedSkin)},
		get resilience() {return skillMaxLevel5(player.resilience)},
		get vigor() {return skillMaxLevel5(player.vigor)},
		get warcraft() {return skillMaxLevel4(player.warcraft)},
		get precision() {return skillMaxLevel4(player.precision)},
		get wayOfTheFist() {return skillMaxLevel4(player.wayOfTheFist)},
		get stunningBlows() {return skillMaxLevel3(player.stunningBlows)},
		get preemptiveStrike() {return skillMaxLevel3(player.preemptiveStrike)},
		get fistsOfFury() {return skillMaxLevel3(player.fistsOfFury)},
		get fistsOfPrecision() {return skillMaxLevel3(player.fistsOfPrecision)},
		get extraStrike() {return skillExtraStrikeMaxLevel(player.extraStrike)},
	},
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Fearecia. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const sitoria = {
	aaa: 'this is Sitoria and not fields trainer',
	x: 0,
	y: 0,
	z: 0,
	name: 'Sitoria',
	refName: 'sitoria',
	nameColor: 'light-blue',
	prefix: 'Fatal Fist, ',
	//prefix: Fatal Fist,
	prefixColor: 'monk-color-dark',
	keywords: ['sitoria'],
	occupation: `trainer`,
	race: `Human`,
	description: `Very skilled Monk.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.guild != 'Monk') {
			quickMessage(`You must be a Monk to train with Sitoria`)
		} else {
			trainInteraction(secondCommand, this)
		}
	},
	skillsOffered: [unarmed],
	skillsMaxLevel: {
		unarmed: 5,
	},
	questStage: 1,
	questSequence: {
	},
	itemsOffered: [leatherTunic, leatherBoots, leatherGloves],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	questItem: [cultTexts],
	isQuestAvailable: false,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"There was a group many years ago that studied the least understood aspects of magic. Their knowledge was kept secret in the libraries of the cathedral. Some people wanted this knowledge out in the open, but the Monks and Priests wanted to completely understand the magic before allowing the public to study it. (continue)"`, 'white', line2)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"The Graveyard is on the otherside of the wall behind the Guild Plaza to the south, so you'll have to take the road east of the Galvadian Plaza. If you get lost, just read any signs you come across, and they'll point you in the right direction."`, 'white', line3)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line4)
		customizeEachWord(`"Come back when you think you've found something."`, 'white', line4)
		blankSpace()
		return
	},
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the Guild Halls. The class trainers here have more skills to offer you. As for training, the Graveyard should suffice for a while. Once you've outgrown it, you should explore east and west of the Castle Crossroads. To the east is the Glade -- a very peaceful and relaxing place, typically teeming with townspeople. A little farther in and to the northeast, you'll find the entrance to The Shallows. To the west of the Castle Crossroads is the Kobold Caves. It's a little more dangerous than The Shallows, so make sure you're well equipped."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office inside the guild once I'm finished meeting with the guild leaders. Check in after you've reached level 10. That should give me enough time. I might have a new task for you after we discuss our next move."`, 'white', line3)
		blankSpace()
		customizeEachWord(`${this.name} `, this.color, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		currentArea.npc.pop()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.seventh = true
		this.isQuestAvailable = false
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Sitoria. I can teach you skills."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.first = true
			return
		}
	},
	displayShop: async function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

const talon = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Talon',
	refName: 'talon',
	nameColor: 'ranger-color',
	prefix: `Nature's Guardian, `,
	prefixColor: 'light-brown',
	keywords: ['talon'],
	occupation: `trainer`,
	race: `Half-Elf`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Ranger') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Ranger's Guild Prospect `, 'ranger-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return [piercingArrow, evasiveRoll, bows, sideStep, warcraft, precision, dodging]
		} else if (player.level < 20) {
			return [piercingArrow, rapidFireShot, hydraArrow, evasiveRoll, bows, headshot, markOfTheBeast, quickshot, sideStep, warcraft, precision, dodging, vigor]
		} else if (player.level < 30) {
			return [piercingArrow, rapidFireShot, hydraArrow, evasiveRoll, bows, doubleDraw, headshot, markOfTheBeast, quickshot, sideStep, weakSpot, warcraft, precision, dodging, vigor]
		} else {
			return [piercingArrow, rapidFireShot, hydraArrow, evasiveRoll, bows, doubleDraw, headshot, markOfTheBeast, quickshot, sideStep, weakSpot, warcraft, precision, dodging, vigor]
		}
	},
	skillsMaxLevel: {
		get piercingArrow() {return skillMaxLevel2(player.piercingArrow)},
		get rapidFireShot() {return skillMaxLevel2(player.rapidFireShot)},
		get hydraArrow() {return skillMaxLevel2(player.hydraArrow)},
		get evasiveRoll() {return skillMaxLevel5(player.evasiveRoll)},
		get bows() {return weaponSkillMaxLevel(player.bows)},
		get doubleDraw() {return skillMaxLevel2(player.doubleDraw)},
		get headshot() {return skillMaxLevel2(player.headshot)},
		get markOfTheBeast() {return skillMaxLevel5(player.markOfTheBeast)},
		get quickshot() {return skillMaxLevel3(player.quickshot)},
		get sideStep() {return skillMaxLevel3(player.sideStep)},
		get weakSpot() {return skillMaxLevel3(player.weakSpot)},
		get warcraft() {return skillMaxLevel3(player.warcraft)},
		get precision() {return skillMaxLevel3(player.precision)},
		get dodging() {return skillMaxLevel5(player.dodging)},
		get vigor() {return skillMaxLevel3(player.vigor)},
	},
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortbow, leatherTunic, leatherGloves, leatherBoots],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, I am Talon. I'm here to train Ranger's Guild Prospects who are interested in joining the Ranger's Guild. The first thing I will teach you is how to interact with skill trainers. To see the list of skills a trainer can teach you, type "show skills". Go ahead and try this now."`, this.prefixColor, line1)
			blankSpace()
			this.questSequence.second = true
			return
		}
		if (this.questSequence.second) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"To acquire a new skill or to train a skill to a higher level, type "train" followed by the number next to the skill. A class trainer can only train your skills to a certain level. If you want to train your skills higher, you'll need to seek out more experience trainers. Once you join a guild, you'll find many experienced class trainers."`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Before I let you get to training, know that you can better understand what a skill does by typing "help" followed by the skill name."`, this.prefixColor, line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"Ok, that's it. Off ya go!"`, this.prefixColor, line3)
			blankSpace()
			this.questSequence.second = false
			return
		}
		if (!this.questSequence.third) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You can see a list of skills I have to offer by typing "show skills". To learn more about a particular skill, type "help" followed by the skill name."`, this.prefixColor, line1)
			blankSpace()
			return
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const tilwin = {
	x: 0,
	y: 0,
	z: 0,
	name: 'Tilwin',
	refName: 'tilwin',
	nameColor: 'ranger-color',
	prefix: `Lord of Arrows, `,
	prefixColor: 'light-blue',
	keywords: ['tilwin'],
	occupation: `trainer`,
	race: `Half-Elf`,
	description: `Very skilled teacher`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand) {
		if (player.guild != 'Ranger') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Ranger's Guild Prospect `, 'ranger-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	skillsOffered: [bows],
	skillsMaxLevel: {
		bows: 5,
	},
	questStage: 1,
	questSequence: {
		first: false,
		second: false,
	},
	itemsOffered: [shortbow, leatherTunic, leatherGloves, leatherBoots],
	questItem: [cultTexts],

	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	isQuestAvailable: false,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details."`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"There was a group many years ago that studied the least understood aspects of magic. Their knowledge was kept secret in the libraries of the cathedral. Some people wanted this knowledge out in the open, but the Monks and Priests wanted to completely understand the magic before allowing the public to study it. (continue)"`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"The Graveyard is on the otherside of the wall behind the Guild Plaza to the south, so you'll have to take the road east of the Galvadian Plaza. If you get lost, just read any signs you come across, and they'll point you in the right direction."`, 'white', line3)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line4)
		customizeEachWord(`"Come back when you think you've found something."`, 'white', line4)
		blankSpace()
		return
	},
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the Guild Halls. The class trainers here have more skills to offer you. As for training, the Graveyard should suffice for a while. Once you've outgrown it, you should explore east and west of the Castle Crossroads. To the east is the Glade -- a very peaceful and relaxing place, typically teeming with townspeople. A little farther in and to the northeast, you'll find the entrance to The Shallows. To the west of the Castle Crossroads is the Kobold Caves. It's a little more dangerous than The Shallows, so make sure you're well equipped."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office inside the guild once I'm finished meeting with the guild leaders. Check in after you've reached level 10. That should give me enough time. I might have a new task for you after we discuss our next move."`, 'white', line3)
		blankSpace()
		customizeEachWord(`${this.name} `, this.color, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		currentArea.npc.pop()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.seventh = true
		this.isQuestAvailable = false
	},
	speak: async function () {
		let line1 = lineFunc()
		console.log(this)
		if (!this.questSequence.first) {
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const joch = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Joch',
	refName: 'joch',
	picture: "images/npcs/male/civilians/joch/joch.png",
	nameColor: 'joch-name',
	prefix: 'Weaponsmith ',
	prefixColor: 'joch-prefix',
	keywords: ['joch'],
	occupation: `Shopkeeper`,
	race: `Human`,
	description: `Joch looks happy to be selling his wares`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [shortsword, broadSword, gladius, handAxe, beardedAxe, serratedAxe, mace, stoutedMace, flangedMace, longsword, claymore, bastardSword, poleAxe, beardedPoleAxe, serratedPoleaxe, sledgehammer, maul, flangedMaul, squiresShield, bronzeShield, galvadianKiteShield],
	// itemsOffered: [shortsword, phi, phi, handAxe, phi, phi, mace, phi, phi, longsword, phi, phi, poleAxe, phi, phi, sledgehammer, phi, phi, squiresShield, phi, phi],
	isQuestAvailable: true,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"If you bring us some copper ore, I'll let you use our forge. The forge can be used to enhance your weapons and armor."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"You can find copper ore in the Kobold Caves. It's dangerous for lower levels. I wouldn't recommend venturing there until at least level 10."`, 'white', line2)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Ahhh, I live for the smell of smoldering metal."`, 'white', line1)
			blankSpace()
			return
		}
	},
	questStage: 1,
	questSequence: {},
	questItem: {
		first: copperOre,
	},
	offer: async function() {
		if (!this.questSequence.first) {
			let questItem = getAllItemsOnPerson().find(item => item.refName == this.questItem.first().refName)
			if (questItem) {
				let line1 = lineFunc()
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`Very nice find! Here's a little something for your efforts.`, 'white', line1)
				blankSpace()
				questReward({gold: 100, exp: 500, sp: 3, ap: 3})
				removeItemFromPerson(questItem)
				questSequenceComplete(this)
				questAvailableSwitch(this)
			} else {
				questDeny()
				return
			}
		} else {
			noAvailableQuest(this)
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, welcome to my shop! Well, our shop. Me and my brother Clyde work the smith here. I make the weapons, and he makes the armor!"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`(To see the items for sale, try SHOW ITEMS JOCH)`, 'white', line2)
			blankSpace()
			// customizeEachWord(`${this.name}: `, this.nameColor, line2)
			// customizeEachWord(`"If you bring us some copper ore, I'll let you use our forge. The forge can be used to enhance your weapons and armor."`, 'white', line2)
			// blankSpace()
		} else {
			let randomNumber = randomNumberRange(1, 2)
			if (randomNumber == 1) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I live for the smell of smoldering ore!`, 'white', line1)
				blankSpace()
			} else if (randomNumber == 2) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I'd love to be able to go up north to the mountains. I've heard there's some good ores up there, but the goblins have set up camp at the base of the mountain.`, 'white', line1)
				blankSpace()
			}
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let clyde = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	get name() {
		if (this.isQuestAvailable) {
			return 'Clyde (Q)'
		} else {
			return 'Clyde'
		}
	},	refName: 'clyde',
	picture: "images/npcs/male/civilians/clyde/clyde.png",
	nameColor: 'clyde-name',
	prefix: 'Armorsmith ',
	prefixColor: 'clyde-prefix',
	keywords: ['clyde'],
	occupation: 'Armorer',
	race: 'Human',
	description: 'Clyde looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, ringmailHauberk, ringmailLeggings, ringmailShoulders, ringmailHelm, ringmailGloves, ringmailStompers],
	// itemsOffered: [mailChestGuard, mailLegs, mailShoulders, mailHelm, mailGloves, mailBoots, phi, phi, phi, phi, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"If you bring us some copper ore, I'll let you use our forge. The forge can be used to enhance your weapons and armor."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"You can find copper ore in the Kobold Caves. It's dangerous for lower levels. I wouldn't recommend venturing there until at least level 10."`, 'white', line2)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Ahhh, I live for the smell of smoldering metal."`, 'white', line1)
			blankSpace()
			return
		}
	},
	isQuestAvailable: true,
	questStage: 1,
	questSequence: {},
	questItem: {
		first: copperOre,
	},
	offer: async function() {
		if (!this.questSequence.first) {
			let questItem = getAllItemsOnPerson().find(item => item.refName == this.questItem.first().refName)
			if (questItem) {
				let line1 = lineFunc()
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`Very nice find! Here's a little something for your efforts.`, 'white', line1)
				blankSpace()
				questReward({gold: 100, exp: 500, sp: 3, ap: 3})
				removeItemFromPerson(questItem)
				questSequenceComplete(this)
				questAvailableSwitch(this)
			} else {
				questDeny()
				return
			}
		} else {
			noAvailableQuest(this)
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		if (!questObject.weaponsmith.copperQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Hello, welcome to my shop! Well, our shop. Me and my brother Joch work the smith here. I make the armor, and he makes the weapons!"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`(To see the items for sale, try SHOW ITEMS CLYDE)`, 'white', line2)
			blankSpace()
		} else {
			let randomNumber = randomNumberRange(1, 2)
			if (randomNumber == 1) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I live for the smell of smoldering ore!`, 'white', line1)
				blankSpace()
			} else if (randomNumber == 2) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`I'd love to be able to go up north to the mountains. I've heard there's some good ores up there, but the goblins have set up camp at the base of the mountain.`, 'white', line1)
				blankSpace()
			}
		}
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let dolf = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Dolf',
	refName: 'dolf',
	picture: 'images/npcs/male/civilians/dolf/dolf.png',
	nameColor: 'dolf-name',
	prefix: 'Leatherworker ',
	prefixColor: 'dolf-prefix',
	keywords: ['dolf'],
	occupation: 'Leatherworker',
	race: 'Human',
	description: 'Dolf looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, studdedLeatherGloves, leatherBoots, studdedLeatherBoots],
	// itemsOffered: [leatherCap, phi, leatherTunic, phi, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.armorsmith.lightHideQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any light hide? My store could always use more light hide!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.armorsmith.lightHideQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.armorsmith.lightHideQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.armorsmith.lightHideQuest.questItem().refName)
		} else {

		}
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		//iron ore
		if (qItemName == 'Light Hide') {
			if (!questObject.armorsmith.lightHideQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.armorsmith.lightHideQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.armorsmith.lightHideQuest.count
				if (count == 6) {
					craftQuestTurnIn3(this, rewardAmount)
				} else {
					craftQuestTurnIn2(this, rewardAmount)
				}
				if (!questObject.armorsmith.lightHideQuest.questSequence1.first && count == 0) {
					questObject.armorsmith.lightHideQuest.questSequence1.first = true
					this.itemsOffered = [leatherCap, phi, leatherTunic, phi, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.second && count == 1) {
					questObject.armorsmith.lightHideQuest.questSequence1.second = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, phi, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.third && count == 2) {
					questObject.armorsmith.lightHideQuest.questSequence1.third = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, phi, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.fourth && count == 3) {
					questObject.armorsmith.lightHideQuest.questSequence1.fourth = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, phi, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.fifth && count == 4) {
					questObject.armorsmith.lightHideQuest.questSequence1.fifth = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, phi, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.sixth && count == 5) {
					questObject.armorsmith.lightHideQuest.questSequence1.sixth = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, studdedLeatherGloves, leatherBoots, phi]
				} else if (!questObject.armorsmith.lightHideQuest.questSequence1.seventh && count == 6) {
					questObject.armorsmith.lightHideQuest.questSequence1.seventh = true
					questObject.armorsmith.lightHideQuest.questSequence1.complete = true
					this.itemsOffered = [leatherCap, studdedLeatherHelm , leatherTunic, studdedLeatherJerkin, shoulderguards, studdedShoulderguards, leatherPants, studdedTrousers, leatherGloves, studdedLeatherGloves, leatherBoots, studdedLeatherBoots]
				} 
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Dolf the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let todlin = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Todlin',
	refName: 'todlin',
	picture: 'images/npcs/male/civilians/todlin/todlin.png',
	nameColor: 'todlin-name',
	prefix: 'Woodcrafter ',
	prefixColor: 'todlin-prefix',
	keywords: ['todlin'],
	occupation: 'Woodcrafter',
	race: 'Half-Elf',
	description: 'Todlin looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [shortbow, longbow, battleBow, dirk, stiletto, crescentDagger, hardenedLeatherFists, studdedLeatherFists, fighterFists],
	// itemsOffered: [shortbow, phi, phi, dirk, phi, phi, hardenedLeatherFists, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.todlin.gnollFur.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"There's a type of hide that I haven't been able to get my hands on. It's skinned from the hides of Gnolls. I could probably take one myself, but they travel in packs and I'm afraid of an ambush. They inhabit the plains northwest of the castle. If you come across one of their hides, bring it to me, and I'll be sure to give you a reward."`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let questItem =	getAllItemsOnPerson().find(item => item.refName == questObject.todlin.gnollFur.questItem().refName)
		if (!questObject.todlin.gnollFur.complete) {
			if (questItem) {
				quickMessage(`Quest complete!`)
				questObject.todlin.gnollFur.complete = true
			} else {
				quickMessage(`You do not have the correct item`)
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Todlin: `, this.nameColor, line1)
		customizeEachWord(`Greetings. I sell bows, daggers, and fist weapons. To see what I have to sell, try SHOW ITEMS TODLIN.`, 'white', line1)
		blankSpace()
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
let lyra = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Lyra',
	refName: 'lyra',
	picture: 'images/npcs/female/civilians/lyra/lyra.png',
	nameColor: 'lyra-name',
	prefix: 'Tailor ',
	prefixColor: 'lyra-prefix',
	keywords: ['lyra'],
	occupation: 'Tailor',
	race: 'Human',
	description: 'Lyra looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, silkGloves, sandals, silkFootwraps],
	// itemsOffered: [clothCap, phi, apprenticeRobes, phi, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.armorsmith.cloverQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any thin fiber? My store could always use more thin fiber!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.armorsmith.cloverQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.armorsmith.cloverQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.armorsmith.cloverQuest.questItem().refName)
		}
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		if (qItemName == 'Thin Fiber') {
			if (!questObject.armorsmith.cloverQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.armorsmith.cloverQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.armorsmith.cloverQuest.count
				if (count == 6) {
					craftQuestTurnIn3(this, rewardAmount)
				} else {
					craftQuestTurnIn2(this, rewardAmount)
				} 
				if (!questObject.armorsmith.cloverQuest.questSequence1.first && count == 0) {
					questObject.armorsmith.cloverQuest.questSequence1.first = true
					this.itemsOffered = [clothCap, phi, apprenticeRobes, phi, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.cloverQuest.questSequence1.second && count == 1) {
					questObject.armorsmith.cloverQuest.questSequence1.second = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, phi, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.cloverQuest.questSequence1.third && count == 2) {
					questObject.armorsmith.cloverQuest.questSequence1.third = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, phi, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.cloverQuest.questSequence1.fourth && count == 3) {
					questObject.armorsmith.cloverQuest.questSequence1.fourth = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, phi, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.cloverQuest.questSequence1.fifth && count == 4) {
					questObject.armorsmith.cloverQuest.questSequence1.fifth = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, phi, sandals, phi]
				} else if (!questObject.armorsmith.cloverQuest.questSequence1.sixth && count == 5) {
					questObject.armorsmith.cloverQuest.questSequence1.sixth = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, silkGloves, sandals, phi]
				} else if (!questObject.armorsmith.cloverQuest.questSequence1.seventh && count == 6) {
					questObject.armorsmith.cloverQuest.questSequence1.seventh = true
					questObject.armorsmith.cloverQuest.questSequence1.complete = true
					this.itemsOffered = [clothCap, silkHat, apprenticeRobes, silkVestments, clothMantle, silkShoulders, clothPants, silkTrousers, clothGloves, silkGloves, sandals, silkFootwraps]
				} 
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Lyra the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}

let faffa = {
	npc: true,
	id: 0,
	x: -1,
	y: 2,
	z: 0,
	name: 'Faffa',
	refName: 'faffa',
	picture: 'images/npcs/male/civilians/faffa/faffa.png',
	nameColor: 'faffa-name',
	prefix: 'Staff Crafter ',
	prefixColor: 'faffa-prefix',
	keywords: ['faffa'],
	occupation: 'Staff Crafter',
	race: 'Gnome',
	description: 'Faffa looks happy to be selling his wares',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [woodenStaff, powerStaff, runeStaff],
	// itemsOffered: [woodenStaff, phi, phi],
	quest: async function() {
		let line1 = lineFunc()
		if (!questObject.weaponsmith.cloverQuest.questSequence1.complete) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Got any thin fiber? My store could always use more thin fiber!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let qItem
		if (questObject.weaponsmith.cloverQuest.questSequence1.complete) {
			quickMessage(`Quest complete!`)
			return
		}
		if (!questObject.weaponsmith.cloverQuest.questSequence1.complete) {
			qItem =	getAllItemsOnPerson().find(item => item.refName == questObject.weaponsmith.cloverQuest.questItem().refName)
		} 
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let qItemIndex = pushItem.indexOf(qItem)
		let qItemName = qItem.name
		//iron ore
		if (qItemName == 'Thin Fiber') {
			if (!questObject.weaponsmith.cloverQuest.questSequence1.complete) {
				let rewardAmount = 10
				questObject.weaponsmith.cloverQuest.count++
				pushItem.splice(qItemIndex, 1)
				let count = questObject.weaponsmith.cloverQuest.count
				if (count == 1 || count == 3) {
					craftQuestTurnIn1(this, rewardAmount)
				} else if (count == 2 || count == 4) {
					if (count == 4) {
						craftQuestTurnIn3(this, rewardAmount)
					} else {
						craftQuestTurnIn2(this, rewardAmount)
					}
				} 
				if (!questObject.weaponsmith.cloverQuest.questSequence1.first && count <= 1) {
					questObject.weaponsmith.cloverQuest.questSequence1.first = true
					this.itemsOffered = [woodenStaff, phi, phi]
				} else if (!questObject.weaponsmith.cloverQuest.questSequence1.second && count == 2) {
					questObject.weaponsmith.cloverQuest.questSequence1.second = true
					this.itemsOffered = [woodenStaff, powerStaff, phi]
				} else if (!questObject.weaponsmith.cloverQuest.questSequence1.third && count == 4) {
					questObject.weaponsmith.cloverQuest.questSequence1.third = true
					questObject.weaponsmith.cloverQuest.questSequence1.complete = true
					this.itemsOffered = [woodenStaff, powerStaff, runeStaff]
				}
			}
		}
	},
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: function () {
		npcDialogue('Greetings! I am Faffa the shopkeeper. If you would like to see what I have to sell, please trade with me.', 'joch-name')
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}


let deylani = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Deylani',
	refName: 'deylani',
	picture: 'images/npcs/female/civilians/deylani/deylani.png',
	nameColor: 'deylani-name',
	// prefix: 'Villager ',
	// prefixColor: '',
	keywords: ['deylani'],
	occupation: '',
	race: 'Human',
	description: 'Deylani',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 3)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Good day, sir."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"It's a beautiful day outside today, don't you think?"`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 3) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I might go visit the Glade later. I could use a nice walk around there."`, 'white', line1)
			blankSpace()
			return
		}
	},
	get areas(){
		return galvadiaSquareRoomPack
	},
	npcBehavior: function () {
		let movementSpeed = randomNumberRange(2000, 2000)
		this.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, movementSpeed) 
	},
}
allNpcsArray.push(deylani)

let arnoldo = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Arnoldo',
	refName: 'arnoldo',
	// picture: 'images/npcs/female/civilians/deylani/deylani.png',
	nameColor: 'deylani-name',
	// prefix: 'Villager ',
	// prefixColor: '',
	keywords: ['arnoldo'],
	occupation: '',
	race: 'Human',
	description: 'arnoldo',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questStage: 1,
	questSequence: {
		first: false,
	},
	speak: function () {
		let randomNumber = randomNumberRange(1, 3)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Those damned Kobolds. I'd do anything to have them all slaughtered."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 2) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I had a son that went missing a few years ago. I'm pretty sure it was the Kobolds."`, 'white', line1)
			blankSpace()
			return
		}
		if (randomNumber == 3) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"If I wasn't so old, I would go after them all myself."`, 'white', line1)
			blankSpace()
			return
		}
	},
	quest: async function () {
		if (!this.questSequence.first) {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Arnoldo wants you to kill one of each Kobold type in the Kobold's Lair`, 'white', line1)
		blankSpace()
		return
		}
		if (this.questSequence.first) {
		quickMessage(`${this.name} doesn't have a quest to offer you`)
		}
	},
	offer: async function() {
		let line1 = lineFunc()
		let isQuestObjectiveComplete
		if (player.killList.koboldArcher == 1 &&
			player.killList.koboldChild == 1 &&
			player.killList.koboldDigger == 1 &&
			player.killList.koboldScoundrel == 1 &&
			player.killList.koboldSpearthrower == 1 &&
			player.killList.koboldChief == 1) {
				isQuestObjectiveComplete = true
			}
		if (!isQuestObjectiveComplete) {
			quickMessage(`You have not completed the quest objective`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Thank you so much.. Nothing will ever bring back my son, but I feel better knowing that those wretched things were slaughtered."`, 'white', line1)
		blankSpace()
		this.questSequence.first = true
		await dialogueWait(200)
		playerGainQuestExperience(250)

	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	xa: [0, 0, 0, 1, 1, 1, 1],
	ya: [1, 1, 1, 0, 0, 0, 0],
	xb: [-1, -1, -1, -1, 0, 0, 0],
	yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}
let timtim = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Tim-Tim',
	refName: 'timTim',
	picture: 'images/npcs/male/civilians/timtim/timtim.png',
	nameColor: 'timtim',
	// prefix: 'Tim-',
	// prefixColor: 'timtim',
	keywords: ['tim', 'tim tim', 'tim-tim'],
	occupation: '',
	race: 'Human',
	description: 'Lil Tim Tim',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	conversationNumber: 1,
	speak: async function () {
		let line1 = lineFunc()
		if (this.conversationNumber == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I'm looking for my sister. She's scared of the bugs I catch, and I just caught a big one!"`, 'white', line1)
			blankSpace()
			this.conversationNumber = 2
		} else if (this.conversationNumber == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I save all the gross stuff I find to freak out my sister, haha!"`, 'white', line1)
			blankSpace()
			this.conversationNumber = 1
		}
	},
	questStage: 1,
	questSequence: {
	},
	questItem: [wormGuts],
	isQuestAvailable: true,
	quest: async function() {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Do you have anything gross? I like to freak my sister out with gross stuff."`, 'white', line1)
		blankSpace()
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Oooooooo I'm gonna really get her with this! Thanks mister!"`, 'white', line1)
		blankSpace()
		sally.conversationNumber = 3
		sally.isQuestAvailable = true
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
		this.isQuestAvailable = false
		await dialogueWait(200)
		playerGainQuestExperience(100)

	},
	get areas(){
		return galvadiaSquareRoomPack
	},
	npcBehavior: function () {
		let movementSpeed = randomNumberRange(20000, 60000)
		this.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, movementSpeed) 
	},
}
allNpcsArray.push(timtim)

let sally = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Sally',
	refName: 'sally',
	picture: 'images/npcs/female/civilians/sally/sally.png',
	nameColor: 'sally',
	keywords: ['sally'],
	occupation: '',
	race: 'Human',
	description: 'Sally',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	conversationNumber: 1,
	speak: async function () {
		let line1 = lineFunc()
		if (!timtim.questSequence.first) {
			if (this.conversationNumber == 1) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"My brother is so gross! My mommy had to get the beetle out of my hair that he put in it yesterday."`, 'white', line1)
				blankSpace()
				this.conversationNumber = 2
			} else if (this.conversationNumber == 2) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"If he does something gross to me again I'm going to get him back!"`, 'white', line1)
				blankSpace()
				this.conversationNumber = 1
			}
		} else if (timtim.questSequence.first) {
			if (this.conversationNumber == 3) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"UGH! Tim-Tim put worm guts on me!"`, 'white', line1)
				blankSpace()
			}
		}
	},
	questStage: 1,
	questSequence: {
	},
	questItem: [mudBall],
	quest: async function() {
		if (!timtim.questSequence.first) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"It's ok, my brother hasn't picked on me today. But if he does, I'll be looking to get him back."`, 'white', line1)
			blankSpace()
			return
		}
		if (timtim.questSequence.first) {
			let line1 = lineFunc()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"My brother put worm guts on me!! I hate him so much I wanna smear mud all over his face!"`, 'white', line1)
			blankSpace()
			return
		}
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!timtim.questSequence.first) {
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"It's ok, my brother hasn't picked on me today. But if he does, I'll be looking to get him back."`, 'white', line1)
			blankSpace()
			return
		} 
		if (timtim.questSequence.first && !qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Thanks Mister! I'm gonna throw this right in his face!"`, 'white', line1)
		blankSpace()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
		this.isQuestAvailable = false
		await dialogueWait(200)
		playerGainQuestExperience(200)
	},
	get areas(){
		return galvadiaSquareRoomPack
	},
	npcBehavior: function () {
		let movementSpeed = 2000
		this.behaviorInterval = setInterval(() => {
			console.log(movementSpeed)
			npcMovesRandomlyNew(this)
		}, movementSpeed) 
	},
}
allNpcsArray.push(sally)

let travellingWagon = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Wagon',
	refName: 'wagon',
	picture: 'images/npcs/male/civilians/wagon/wagon.png',
	nameColor: 'dark-brown',
	prefix: 'Travelling ',
	prefixColor: 'dark-brown',
	keywords: ['travelling', 'wagon', 'travelling wagon', 'coachman'],
	occupation: '',
	race: 'Human',
	description: 'A Travelling Wagon',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	conversationNumber: 1,
	speak: function () {
		let line1 = lineFunc()
		if (this.conversationNumber == 1) {
			blankSpace()
			customizeEachWord(`Wagon Coachman: `, this.nameColor, line1)
			customizeEachWord(`"I cart these roads, bringing food and supplies to the town and castle. I'm very familiar with all parts of Galvadia, at least the parts that roads pass through."`, 'white', line1)
			blankSpace()
			this.conversationNumber = 2
		}else if (this.conversationNumber == 2) {
			blankSpace()
			customizeEachWord(`Wagon Coachman: `, this.nameColor, line1)
			customizeEachWord(`"Most of the dangerous areas are to the west of the crossroads and to the northwest of the castle."`, 'white', line1)
			blankSpace()
			this.conversationNumber = 1
		}
	},
	questStage: 1,
	questSequence: {
	},
	questItem: [sackOfGrain],
	isQuestAvailable: true,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first) {
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Coachman: `, this.nameColor, line1)
		customizeEachWord(`"If you come across any food supplies lying in the road, it probably fell off my cart."`, 'white', line1)
		blankSpace()
		} else {
			quickMessage(`There are no quests being offered here.`)
		}
	},
	offer: async function() {
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You do not have the proper item for this quest`)
			return
		} 
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Coachman: `, this.nameColor, line1)
		customizeEachWord(`"Oho! I thought my wagon felt a little lighter. I appreciate you bringing this back to me. I'd be out some gold if I didn't have that sack. I think cuttin' you half the price would be fair."`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`The coachman grins at you as he hands you a sack of gold.`, ['white', 'italic'], line2)
		blankSpace()
		await dialogueWait(200)
		playerGainQuestExperience(200)
		await dialogueWait(200)
		playerGainGold(100)
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}

const strayKitty = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Kitty',
	refName: 'kitty',
	picture: 'images/npcs/female/civilians/stray cat/stray cat.png',
	nameColor: 'grey',
	prefix: 'Stray ',
	prefixColor: 'dark-grey',
	keywords: ['stray', 'kitty', 'stray kitty', 'cat', 'stray cat'],
	occupation: '',
	race: 'Cat',
	description: 'A stray cat',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: async function () {
		let randomNumber = randomNumberRange(1, 1)
		let line1 = lineFunc()
		if (randomNumber == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`The stray cat runs away from you and keeps an eye on you from a distance...`, ['white', 'italic'], line1)
			blankSpace()
			return
		}
	},
	questStage: 1,
	questSequence: {
	},
	questItem: [halfEatenFish],
	isQuestAvailable: true,
	quest: function() {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`The kitty looks hungry`, ['white', 'italic'], line1)
		blankSpace() 
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == strayKitty.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`You place the Half-Eaten Fish on the ground and step away. After several moments, the cat slowly approaches the fish. After a few quick sniffs, the cat bites into it and runs off`, ['white', 'italic'], line1)
		blankSpace()
		await dialogueWait(200)
		playerGainQuestExperience(250)
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true

	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}
let frederickGregory = {
	npc: true,
	id: 0,
	x: -6,
	y: -2,
	z: 0,
	name: 'Frederick Gregory',
	refName: 'frederickGregory',
	picture: 'images/npcs/female/civilians/stray cat/stray cat.png',
	nameColor: 'grey',
	prefix: 'Stray ',
	prefixColor: 'dark-grey',
	keywords: ['frederick', 'gregory', 'frederick gregory'],
	occupation: '',
	race: 'Human',
	description: 'A Fisherman',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speakSequence: 1,
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let line5 = lineFunc()
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I spend most of my free time here fishing. If you get yourself a `, 'white', line1)
			customizeEachWord(`Fishing Rod`, 'green', line1)
			customizeEachWord(`, I can teach you a thing or two."`, 'white', line1)
			blankSpace()
			return
		}
		//quest has been completed. fishing instruction speak enabled.
		if (this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"So you'd like to try your hand at fishing, eh? In my travels with the Galvadian Knights, I've fished most of the waters in the region."`, 'white', line1)
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"First things first. You need to unpack and hold your fishing rod in your right hand. Next, use the FISH command. This will cast your line into the water. Once your line has been cast, all you need to do is wait for a fish to bite. When a fish bites, your casting bar will turn red and begin to move. If you use FISH command again when the bar turns green, you will reel in the fish, and your catch will be successful. It's that simple!"`, 'green', line2)
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"There are a few additional things to note. When the catch bar turns green, it will only be green for a short duration before turning red again. If you use the FISH command while the bar is red, your catch won't be successful, and you'll have to try again. The bar will only switch to green once, so be on your toes!"`, 'white', line3)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line4)
			customizeEachWord(`"The amount of time it takes for a fish to bite varies from fish to fish as does the timing of the catch bar. For example, some fish might bite between ten and thirty seconds after your line is cast, and some might bite between thirty and sixty seconds. Some fish you might have two seconds to reel in, and others (higher level fish) you might have only half a second to reel in. Increasing your Fishing Skill level and using quality fishing rods can decrease the time it takes to catch a fish, but not how quickly you reel in the fish (using the FISH command when the bar is green)."`, 'white', line4)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line5)
			customizeEachWord(`""`, 'white', line4)
			blankSpace()
			return
		}
	},
	questItem: [emptyBucket],
	questStage: 1,
	questSequence: {
	},
	quest: async function() {
		let line1 = lineFunc()
		if (!frederickGregory.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Gaahhh! I forgot to grab my fish bucket before coming out today. If you find one for me, I'll let you have my spare rod."`, 'white', line1)
			blankSpace() 
		} else {
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace() 
		}	
	},
	offer: async function () {
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first) {
			if (!qItem) {
				quickMessage(`You have not offered the proper item for this quest`)
				return
			}
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Oh, you found a bucket! Here let me see... I have a spare rod in case this one breaks, but I suppose it would be a fair trade."`, 'white', line1)
			questReward({gold: 50, exp: 50, item: fishingRod, sp: 2, ap: 0})
			blankSpace()
			pushItem.splice(qItemIndex, 1)
			player.backpack.splice(qItemIndex, 1)
			this.questSequence.first = true
			await dialogueWait(200)
		} else {
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
		}
	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	//xa and ya make the npc go from his fishing spot to a house. This is just for testing
	xa: [-1, -1, -1,  -1,  0,   0, 1, 1, 1, 1,  1,  1,  1, 1, 1, 1, 0],
	ya: [ 0,  0,  0,  -1, -1,  -1, 0, 0, 0, 0, -1, -1, -1, 0, 0, 0, 1],
	//xb and yb not configured to match xa and ya
	xb: [-1, -1, -1, -1, 0, 0, 0],
	yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 5000,
	conversationInterval: 5000,
	waitInterval: 5000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}

const shadowyDealer = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Shadowy Dealer',
	refName: 'shadowyDealer',
	picture: "",
	nameColor: 'shadowyDealer-name',
	keywords: ['shadowy', 'dealer', 'shadowy dealer'],
	occupation: `Shopkeeper`,
	race: `Human`,
	description: `A strange, shadowy figure`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	itemsOffered: [shabbyCloak, shoddyCloak, shreddedCloak, shiftyCloak, shelledCloak],
	isQuestAvailable: false,
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}`, this.nameColor, line1)
		customizeEachWord(`: "Don't ask me why I'm here... Or where I got these cloaks..."`, 'white', line1)
		blankSpace()
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
const bromwelBoulderbash = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Bromwel Boulderbash',
	prefix: 'Tavern Keeper, ',
	refName: 'bromwelBoulderbash',
	picture: "",
	nameColor: 'bromwelBoulderbash-name',
	prefixColor: 'tavern-keeper',
	keywords: ['bromwel', 'boulderbash', 'bromwel boulderbash'],
	occupation: `Tavern Keeper`,
	race: `Human`,
	description: `A Dwarf`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	// itemsOffered: [shabbyCloak, shoddyCloak, shreddedCloak, shiftyCloak, shelledCloak],
	isQuestAvailable: false,
	// buy: function (secondCommand) {
	// 	buyInteraction(secondCommand, this)
	// },
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "Ah, well if it isn't a new face wanderin' into me tavern! Welcome, ${player.guild}! The name's Bromwel Boulderbash, master of this tavern. If ye need a pint o' me finest ale to wash the road dust from yer throat, you've come to the right place!"`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "Check out me store if ye want somethin' te drink! I got a lil somethin' fer everyone!"`, 'white', line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
		if (this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "I bet I got somethin that would quinch the thirst of a Jagged Gilled Mud Belly!"`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
	},
	// displayShop: function (ssiq) {
	// 	displayShopSkillsOrSpells(this, ssiq)
	// },
}
const telgremGreyhorn = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Telgrem Greyhorn',
	refName: 'telgremGreyhorn',
	picture: "",
	nameColor: 'telgremGreyhorn-name',
	keywords: ['telgrem', 'greyhorn', 'telgrem greyhorn'],
	occupation: `Adventurer`,
	race: `Dwarf`,
	description: `A rugged looking dwarf`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage || this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "The Boulderbashes have been runnin' this tavern since before the Civil War. That must'a been over two hundred years ago! Time really flies once ye get to be over one hundred. That an' drinkin every night!" **hiccups**`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "People travel all 'round the continent to visit the Boulderbash Tavern. It's known even beyond the great seas!"`, 'white', line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
	},
	// displayShop: function (ssiq) {
	// 	displayShopSkillsOrSpells(this, ssiq)
	// },
}
const ulfregSnagdril = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Ulfreg Snagdril',
	refName: 'ulfregSnagdril',
	picture: "",
	nameColor: 'ulfregSnagdril-name',
	keywords: ['ulfreg', 'snagdril', 'ulfreg snagdril'],
	occupation: `Adventurer`,
	race: `Dwarf`,
	description: `A rugged looking dwarf`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage || this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "You been upstairs yet? They got gamblin' and games up there! I can't get enough of Snail Racin'!"`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
	},
	// displayShop: function (ssiq) {
	// 	displayShopSkillsOrSpells(this, ssiq)
	// },
}
const gulthradGreenbeard = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Gulthrad Greenbeard',
	refName: 'gulthradGreenbeard',
	picture: "",
	nameColor: 'gulthradGreenbeard-name',
	keywords: ['gulthrad', 'greenbeard', 'gulthrad greenbeard'],
	occupation: `Adventurer`,
	race: `Dwarf`,
	description: `A rugged looking dwarf`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage || this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "I hail from the Dwarven city of Boomhorn, far to the north. The trees are a nice change of scenery down here, but I do miss the hills and mountains of home."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "I'm not used to seein' so many different races runnin' around. Back where I'm from, it's mostly just us Dwarves and Minotaurs. Not many others enjoy the extreme hot an' cold of the mountains."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
	},
	// displayShop: function (ssiq) {
	// 	displayShopSkillsOrSpells(this, ssiq)
	// },
}
const seltathSilverwood = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Seltath Silverwood',
	refName: 'seltathSilverwood',
	picture: "",
	nameColor: 'seltathSilverwood-name',
	dialogueColor: 'white',
	keywords: ['seltath', 'silverwood', 'seltath silverwood'],
	occupation: `Adventurer`,
	race: `Elf`,
	description: `Elf Ranger`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage || this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "Most of my family moved here from Aleurn a long time ago. When the guilds were established after the war, a lot of them came here to train and study. I guess it runs in our blood. Me and my brother have spent most of our lives in the Ranger's Guild and recently attained the rank of Sentinel. We are part of the elite group of Rangers who watch over the Glade from the treetops."`, this.dialogueColor, line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "When I was young, I thought magic was only used to cast spells. After I came here to study, I learned that magic is used in nearly everything. As a Ranger, I can manipulate magic in the form of Focus to use powerful abilities."`, this.dialogueColor, line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
	},
	questStage: 1,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (this.questStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"You look like you have a fighting spirit. I think I have just the task for you. If you can slay 10 kobolds in the kobold caves, I'll give you a little somethin'."`, this.dialogueColor, line1)
			blankSpace()
			await dialogueWait(200)
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"I don't care what kind. Just as long as long as it's a kobold from the caves."`, this.dialogueColor, line2)
			blankSpace()
		}
	},
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (this.questStage == 1) {
			let koboldKillTotal = killListAggregateSpecificEnemies([koboldArcher, koboldChild, koboldSpearthrower, koboldScoundrel, 
				koboldDigger, koboldChief])
			if (koboldKillTotal >= 10) {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"Great work! That was the first task given to me when I first joined the Ranger's Guild."`, this.dialogueColor, line1)
				blankSpace()
				await dialogueWait(200)
				customizeEachWord(`${this.name}: `, this.nameColor, line2)
				customizeEachWord(`"Here's your reward as promised."`, this.dialogueColor, line2)
				blankSpace()
				//quest complete functions
				questChangeStage(seltathSilverwood, 0)
				questReward({exp: 300, gold: 200, sp: 10, ap: 3})
				
			} else {
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`${this.name}: `, this.nameColor, line1)
				customizeEachWord(`"You still need to slay more kobolds."`, this.dialogueColor, line1)
				blankSpace()
			}
		}
	}

}
const arlasSilverwood = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Arlas Silverwood',
	refName: 'arlasSilverwood',
	picture: "",
	nameColor: 'arlasSilverwood-name',
	keywords: ['arlas', 'silverwood', 'arlas silverwood'],
	occupation: `Ranger`,
	race: `Elf`,
	description: `Elf Ranger`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage || this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "Me and my brother come here when we're not watching over the forest. Our duties as Sentinels are second nature to us. As kids, we practically lived in the trees."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "We can see some interesting things up in the tree tops. As you get closer to the Mana Tree, the creatures get bigger and bigger. I've heard some strange noises from deep within the forest a few times -- what I believe to be Mana Beasts. We can't go beyond the Forest Deep, so I haven't been able to see for myself."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
	},
	// displayShop: function (ssiq) {
	// 	displayShopSkillsOrSpells(this, ssiq)
	// },
}
const vyrlanWyrmspire = {
	x: -1,
	y: 2,
	z: 0,
	name: 'Vyrlan Wyrmspire',
	refName: 'vyrlanWyrmspire',
	picture: "",
	nameColor: 'vyrlanWyrmspire-name',
	keywords: ['vyrlan', 'wyrmspire', 'vyrlan wyrmspire'],
	occupation: `Ranger`,
	race: `Elf`,
	description: `Elf Ranger`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	speak: async function () {
		let line1 = lineFunc()
		if (!this.dialogueStage || this.dialogueStage == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 1
			return
		}
		if (this.dialogueStage == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			customizeEachWord(`: "."`, 'white', line1)
			blankSpace()
			this.dialogueStage = 2
			return
		}
	},
	// displayShop: function (ssiq) {
	// 	displayShopSkillsOrSpells(this, ssiq)
	// },
}

async function questDeny() {
	let line1 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`You have not offered the proper item for this quest.`, 'white', line1)
	blankSpace()
}

async function noAvailableQuest(npc) {
	let line1 = lineFunc()
	await dialogueWait(200)
	blankSpace()
	customizeEachWord(`${npc.name} `, npc.nameColor, line1)
	customizeEachWord(`is not offering any quests at this time.`, 'white', line1)
	blankSpace()
}

function removeItemFromPerson(item) {
	let pushItemIndex = pushItem.indexOf(item)
	item.roomId == 'right hand' && (player.rightHand = 'empty')
	item.roomId == 'left hand' && (player.leftHand = 'empty')
	pushItem.splice(pushItemIndex, 1)
}

function enableDirection(directionToEnable) {
	currentArea.descriptions.zoneExitsBool[directionToEnable] = true
}

function killListAggregateSpecificEnemies(enemiesToAggregate = []) {
	let killTotal = 0
	enemiesToAggregate.forEach(enemy => {
		killTotal += player.killList?.[enemy.name] || 0
	})
	console.log(`Kill total: ${killTotal}`)
	return killTotal
}

function killListAggregateAll() {
	let killTotal = 0
	for (const enemy in player.killList) {
		killTotal += player.killList[enemy]
	}
	console.log(`Player Kill List Total: ${killTotal}`)
	return killTotal
}

function questAvailableSwitch(npc) {
	npc.isQuestAvailable = false
}
function questSequenceComplete(npc) {
	if (!npc.questSequence.first) {
		npc.questSequence.first = true
		return
	}
	if (!npc.questSequence.second) {
		npc.questSequence.second = true
		return
	}
	if (!npc.questSequence.third) {
		npc.questSequence.third = true
		return
	}
	if (!npc.questSequence.fourth) {
		npc.questSequence.fourth = true
		return
	}
	if (!npc.questSequence.fifth) {
		npc.questSequence.fifth = true
		return
	}
}

async function questReward({gold = 0, exp = 0, item = null, sp = 0, ap = 0}) {
	await dialogueWait(200)
	blankSpace()
	if (item) {
		let line1 = lineFunc()
		if (item().type.weapon) {weaponGen(item())}
		else if (item().type.armor) {armorGen(item())}
		else if (item().type.food) {foodGen(item())}
		else if (item().type.consumable) {consumableGen(item())}
		else if (item().type.treasure) {treasureGen(item())}
		else if (item().type.quest) {questItemGen(item())}
		else if (item().type.crafting) {craftingMaterialGen(item())}
		else if (item().type.fish) {fishItemGen(item())}
		pushItem[pushItem.length - 1].roomId = 'backpack'
		customizeEachWord(`You receive a `, 'white', line1)
		customizeEachWord(`${item().name}`, item().color, line1)
		customizeEachWord(`!`, 'white', line1)
	}
	if (gold > 0) {
		let line1 = lineFunc()
		customizeEachWord(`You receive `, 'white', line1)
		customizeEachWord(`${gold} `, 'yellow', line1)
		customizeEachWord(`gold pieces!`, 'white', line1)
	}
	if (exp > 0) {
		let line1 = lineFunc()
		customizeEachWord(`You receive `, 'white', line1)
		customizeEachWord(`${exp} `, 'light-blue', line1)
		customizeEachWord(`experience points!`, 'white', line1)
	}
	if (sp > 0) {
		let line1 = lineFunc()
		customizeEachWord(`You receive `, 'white', line1)
		customizeEachWord(`${sp} `, 'green', line1)
		customizeEachWord(`skill points!`, 'white', line1)
	}
	if (ap > 0) {
		let line1 = lineFunc()
		customizeEachWord(`You receive `, 'white', line1)
		customizeEachWord(`${ap} `, 'green', line1)
		customizeEachWord(`attribute points!`, 'white', line1)
	}
	player.gold += gold
	player.experience += exp
	player.skillPoints += sp
	player.attributePoints += ap
	blankSpace()
}

function forgeFailMessages(selectedItem, doesPlayerHaveMaterial, selectedOre, material, armorType, enhanceType) {
	let line1 = lineFunc()
	if (enhanceType == 'ore' && currentArea != galvadiaForge) {
		blankSpace()
		customizeEachWord(`You need to be at a forge in order to do this.`, 'white', line1)
		blankSpace()
		return true
	}
	if (enhanceType == 'hide' && currentArea != galvadiaTanner) {
		blankSpace()
		customizeEachWord(`You need to be at a tanner in order to do this.`, 'white', line1)
		blankSpace()
		return true
	}
	if (enhanceType == 'magic fiber' && currentArea != galvadiaForge) {
		blankSpace()
		customizeEachWord(`You need to be at a forge in order to do this.`, 'white', line1)
		blankSpace()
		return true
	}
	if (!selectedItem || (!selectedItem.type.weapon && !selectedItem.type.armor)) {
		blankSpace()
		customizeEachWord(`You need to have the item you want to enhance in your right hand.`, 'white', line1)
		blankSpace()
		return true
	}
	if (!doesPlayerHaveMaterial) {
		blankSpace()
		customizeEachWord(`You need to have ${enhanceType} in order to enhance this item.`, 'white', line1)
		blankSpace()
		return true
	}
	if (!selectedOre) {
		blankSpace()
		customizeEachWord(`You need to specify the type of ${enhanceType} you want to use.`, 'white', line1)
		blankSpace()
		return true
	}
	if (material == undefined) {
		blankSpace()
		customizeEachWord(`You need to specify the material you want to use.`, 'white', line1)
		blankSpace()
		return true
	}
	if (selectedItem.type.armor && (armorType != 'slashing' && armorType != 'piercing' && armorType != 'blunt' &&
		armorType != 'fire' && armorType != 'ice' && armorType != 'lightning' && armorType != 'water' && armorType != 'wind'
	)) {
		blankSpace()
		customizeEachWord(`You need to specify the armor type you want to enhance.`, 'white', line1)
		blankSpace()
		return true
	}
	if (selectedItem.type.tier > selectedOre.tier) {
		blankSpace()
		customizeEachWord(`You need an ore with stronger magical properties to enhance this item.`, 'white', line1)
		blankSpace()
		return true
	}
	return false
}
//forge sword copper 
async function forge(ore, armorType) {
	let line1 = lineFunc()
	let selectedOre = getAllItemsOnPerson().find(item => item.type[ore])
	let selectedArmorType
	let doesPlayerHaveAnyOre = getAllItemsOnPerson().find(({ keywords }) => keywords.some(keyword => keyword == 'ore'))
	let selectedItem = getAllItemsOnPerson().find(forgeTarget => forgeTarget.roomId == 'right hand')

	if (armorType == 'slashing') {selectedArmorType = 'slashingArmor'}
	if (armorType == 'piercing') {selectedArmorType = 'piercingArmor'}
	if (armorType == 'blunt') {selectedArmorType = 'bluntArmor'}
	if (forgeFailMessages(selectedItem, doesPlayerHaveAnyOre, selectedOre, ore, armorType, 'ore')) {return}
	await dialogueWait(200)
	if (selectedItem.type.weapon) {
		console.log('first conditional')
		if (!selectedItem.blacksmithing) {
			selectedItem.blacksmithing = {}
			// selectedItem.blacksmithing.topDamage = selectedOre.increase
			// selectedItem.blacksmithing.enhanced = true
		}
		if (!selectedItem.blacksmithing.topDamage) {
			selectedItem.blacksmithing.topDamage = selectedOre.increase
			selectedItem.topDamage += selectedOre.increase
			// selectedItem.blacksmithing.enhanced = true
		} else if (!selectedItem.blacksmithing.botDamage) {
			selectedItem.blacksmithing.botDamage = selectedOre.increase
			selectedItem.botDamage += selectedOre.increase
			// selectedItem.blacksmithing.enhanced = true
		} else {
			blankSpace()
			customizeEachWord(`You cannot enhance this property any further.`, 'white', line1)
			blankSpace()			
			return
		}
		// if (!selectedItem.modCount) {
		// 	selectedItem.modCount = {}
		// 	selectedItem.modCount.topDamage = 1
		// } else {
		// 	selectedItem.modCount.topDamage++
		// }
		blankSpace()
		customizeEachWord(`You have increased the damage of your `, 'white', line1)
		customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
		customizeEachWord(`by `, 'white', line1)
		customizeEachWord(`${selectedOre.increase}`, 'green', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
		selectedItem.mods.weight += selectedOre.increase
		removeItemFromPerson(selectedOre)
	}
	if (selectedItem.type.armor) {
		if (selectedItem?.blacksmithing?.[selectedArmorType]) {
			blankSpace()
			customizeEachWord(`You cannot enhance this property any further.`, 'white', line1)
			blankSpace()			
			return
		}
		// if (!selectedItem.mods[selectedArmorType]) {
		// 	blankSpace()
		// 	customizeEachWord(`You need to specify the armor type you wish to enhance.`, 'white', line1)
		// 	blankSpace()			
		// 	return
		// }
		if (!selectedItem.blacksmithing) {
			selectedItem.blacksmithing = {}
			selectedItem.blacksmithing[selectedArmorType] = selectedOre.increase
		} else {
			selectedItem.blacksmithing[selectedArmorType] = selectedOre.increase
		}
		blankSpace()
		customizeEachWord(`You have increased the effectiveness of your `, 'white', line1)
		customizeEachWord(`${selectedItem.name}'s `, selectedItem.color, line1)
		customizeEachWord(`${armorType} `, armorType, line1)
		customizeEachWord(`armor by `, 'white', line1)
		customizeEachWord(`${selectedOre.increase}`, 'green', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
		!selectedItem.mods[selectedArmorType] ? selectedItem.mods[selectedArmorType] = selectedOre.increase : selectedItem.mods[selectedArmorType] += selectedOre.increase
		selectedItem.mods.weight += selectedOre.increase
		removeItemFromPerson(selectedOre)
	}
}
//tool light slashing - weapon
//tool light fire - armor
async function tool(leather, armorPenOrMagicRes) {
    const selectedItem = getAllItemsOnPerson().find(item => item.roomId === 'right hand');
	let doesPlayerHaveAnyHide = getAllItemsOnPerson().find(({ keywords }) => keywords.some(keyword => keyword == 'hide'))

    const leatherTypes = {
        light: 'lightHide',
        thick: 'thickHide',
        wooly: 'woolyHide',
        gnoll: 'gnollHide'
    };
    const armorPenTypes = {
        slashing: 'slashingPen',
        piercing: 'piercingPen',
        blunt: 'bluntPen'
    };
    const magicResTypes = {
        fire: 'fireResist',
        ice: 'iceResist',
        lightning: 'lightningResist',
		water: 'waterResist',
		wind: 'windResist',
    };
	const armorPen = armorPenTypes[armorPenOrMagicRes]; //armorPenOrMagicRes needs to be slashing, piercing, or blunt
    const magicRes = magicResTypes[armorPenOrMagicRes]; //armorPenOrMagicRes needs to be fire, ice, lightning, etc
	const selectedLeather = getAllItemsOnPerson().find(item => item.refName === leatherTypes[leather]);
	if (forgeFailMessages(selectedItem, doesPlayerHaveAnyHide, selectedLeather, leather, armorPenOrMagicRes, 'leather')) {return}
	console.log(armorPen)
	console.log(magicRes)
	if (armorPen) {
		if (selectedItem.type.weapon) {
			if (selectedItem.mods[armorPen] == undefined) {
				console.log(selectedItem)
				console.log(selectedItem.mods)
				console.log(selectedItem.mods[armorPen])
				console.log(armorPen, ' ARMOR PEN')
				quickMessage(`You can only enhance a penetration type inherently on the weapon`)
				return
			}
			if (selectedItem.leatherworking?.[armorPen]) {
				quickMessage('You cannot enhance this property any further.')
				return
			}
			quickMessage('enhance weapon with leather')
			enhanceItemLeather(selectedItem, selectedLeather, armorPen);
		}
	}
	else if (magicRes) {
		if (selectedItem.type.armor) {
			if (selectedItem.leatherworking?.[magicRes]) {
				quickMessage('You cannot enhance this property any further.');
				return;
			}
			enhanceItemLeather(selectedItem, selectedLeather, magicRes);
		}
	}







	// if (selectedItem.type.weapon) {
	// 	if (selectedItem.leatherworking.slashingPen) {
	// 		blankSpace()
	// 		customizeEachWord(`You cannot enhance this property any further.`, 'white', line1)
	// 		blankSpace()			
	// 		return
	// 	}
	// 	if (!selectedItem.leatherworking) {
	// 		selectedItem.leatherworking = {}
	// 		selectedItem.leatherworking.botDamage = selectedLeather.increase
	// 		selectedItem.leatherworking.enhanced = true
	// 	}
	// 	blankSpace()
	// 	customizeEachWord(`You have increased the damage of your `, 'white', line1)
	// 	customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
	// 	customizeEachWord(`by `, 'white', line1)
	// 	customizeEachWord(`${selectedLeather.increase}`, 'green', line1)
	// 	customizeEachWord(`!`, 'white', line1)
	// 	blankSpace()
	// 	selectedItem.botDamage += selectedLeather.increase
	// 	selectedItem.mods.weight - selectedLeather.increase < 0 ? 0 : selectedItem.mods.weight - selectedLeather.increase
	// 	removeItemFromPerson(selectedLeather)
	// }
	// if (selectedItem.type.armor) {
	// 	if (selectedItem?.leatherworking?.[selectedArmorType]) {
	// 		blankSpace()
	// 		customizeEachWord(`You cannot enhance this property any further.`, 'white', line1)
	// 		blankSpace()			
	// 		return
	// 	}
	// 	if (!selectedItem.leatherworking) {
	// 		selectedItem.leatherworking = {}
	// 		selectedItem.leatherworking[selectedArmorType] = selectedLeather.increase
	// 	} else {
	// 		selectedItem.leatherworking[selectedArmorType] = selectedLeather.increase
	// 	}
	// 	blankSpace()
	// 	customizeEachWord(`You have increased the effectiveness of your `, 'white', line1)
	// 	customizeEachWord(`${selectedItem.name}'s `, selectedItem.color, line1)
	// 	customizeEachWord(`${armorType} `, armorType, line1)
	// 	customizeEachWord(`armor by `, 'white', line1)
	// 	customizeEachWord(`${selectedLeather.increase}`, 'green', line1)
	// 	customizeEachWord(`!`, 'white', line1)
	// 	blankSpace()
	// 	!selectedItem.mods[selectedArmorType] ? selectedItem.mods[selectedArmorType] = selectedLeather.increase: selectedItem.mods[selectedArmorType] += selectedLeather.increase
	// 	selectedItem.mods.weight - selectedLeather.increase < 0 ? 0 : selectedItem.mods.weight - selectedLeather.increase
	// 	removeItemFromPerson(selectedLeather)
	// }
}
function enhanceItemLeather(item, leather, property) {
	if (!item.leatherworking) {
		item.leatherworking = {};
	}
	console.log(item.mods[property])
	quickMessage(`Enhancing success!`)
	item.leatherworking[property] = leather.increase
	isNaN(item.mods[property]) ? item.mods[property] =  leather.increase : item.mods[property] += leather.increase
	item.mods.weight = Math.max(0, item.mods.weight - leather.increase);
	removeItemFromPerson(leather);
}
async function weave(fiber, bonus) {
	let line1 = lineFunc()
	let selectedFiber
	let selectedBonus
	let doesPlayerHaveAnyFiber = getAllItemsOnPerson().find(({ keywords }) => keywords.some(keyword => keyword == fiber))
	let selectedItem = getAllItemsOnPerson().find(toolTarget => toolTarget.roomId == 'right hand')
	if (fiber == 'clover') {selectedFiber = getAllItemsOnPerson().find(toolTarget => toolTarget.refName == 'clover')}
	else if (fiber == 'orchid') {selectedFiber = getAllItemsOnPerson().find(toolTarget => toolTarget.refName == 'orchid')}
	else if (fiber == 'lily') {selectedFiber = getAllItemsOnPerson().find(toolTarget => toolTarget.refName == 'lily')}
	else if (fiber == 'sage') {selectedFiber = getAllItemsOnPerson().find(toolTarget => toolTarget.refName == 'sage')}
	if (bonus == 'str' || bonus == 'strength') {selectedBonus = 'str'}
	else if (bonus == 'dex' || bonus == 'dexterity') {selectedBonus = 'dex'}
	else if (bonus == 'agi' || bonus == 'agility') {selectedBonus = 'agi'}
	else if (bonus == 'int' || bonus == 'intelligence') {selectedBonus = 'int'}
	else if (bonus == 'wis' || bonus == 'wisdom') {selectedBonus = 'wis'}
	else if (bonus == 'mys' || bonus == 'mysticism') {selectedBonus = 'mys'}
	else if (bonus == 'onehanded') {selectedBonus = 'oneHanded'}
	else if (bonus == 'twohanded') {selectedBonus = 'twoHanded'}
	else if (bonus == 'unarmed') {selectedBonus = 'unarmed'}
	else if (bonus == 'daggers') {selectedBonus = 'daggers'}
	else if (bonus == 'bows') {selectedBonus = 'bows'}
	else {selectedBonus = undefined}
	await dialogueWait(200)
	if (currentArea != galvadiaMagicWeave) {
		blankSpace()
		customizeEachWord(`You need to be at a magic weave in order to do this.`, 'white', line1)
		blankSpace()
		return
	}
	if (!selectedItem || (!selectedItem.type.weapon && !selectedItem.type.armor)) {
		blankSpace()
		customizeEachWord(`You need to have the item you want to enhance in your right hand.`, 'white', line1)
		blankSpace()
		return
	}
	if (!fiber) {
		blankSpace()
		customizeEachWord(`You need to specify the magic herb you want to use.`, 'white', line1)
		blankSpace()
		return
	}
	if (!selectedBonus) {
		blankSpace()
		customizeEachWord(`You need to specify a magical property already on this item.`, 'white', line1)
		blankSpace()
		return
	}
	if (!doesPlayerHaveAnyFiber) {
		blankSpace()
		customizeEachWord(`You don't have any magic herbs on you to enhance this item.`, 'white', line1)
		blankSpace()
		return
	}
	if (!selectedFiber) {
		blankSpace()
		customizeEachWord(`You need to specify the type of herb you want to use.`, 'white', line1)
		blankSpace()
		return
	}
	if (fiber == undefined) {
		blankSpace()
		customizeEachWord(`You need to specify the herb you want to use.`, 'white', line1)
		blankSpace()
		return
	}
	if (player[selectedBonus] == undefined) {
		quickMessage(selectedBonus)
		quickMessage(player[selectedBonus])
		blankSpace()
		customizeEachWord(`That is not a valid stat or skill`, 'white', line1)
		blankSpace()
		return
	}
	if (!selectedItem.mods[selectedBonus]) {
		blankSpace()
		customizeEachWord(`You can only enhanced an item that already has that magical property.`, 'white', line1)
		blankSpace()
		return
	}
	if (selectedItem.type.tier > selectedFiber.tier) {
		blankSpace()
		customizeEachWord(`You need an herb with stronger magical properties to enhance this item.`, 'white', line1)
		blankSpace()
		return
	}
	// if (selectedItem.type.weapon) {
	// 	if (selectedItem.magicWeaving) {
	// 		blankSpace()
	// 		customizeEachWord(`You cannot enhance this property any further.`, 'white', line1)
	// 		blankSpace()			
	// 		return
	// 	}
	// 	if (!selectedItem.magicWeaving) {
	// 		selectedItem.magicWeaving = {}
	// 		selectedItem.magicWeaving[selectedBonus] = selectedFiber.increase
	// 		selectedItem.magicWeaving.enhanced = true
	// 	}
	// 	blankSpace()
	// 	customizeEachWord(`You have increased the damage of your `, 'white', line1)
	// 	customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
	// 	customizeEachWord(`by `, 'white', line1)
	// 	customizeEachWord(`${selectedFiber.increase}`, 'green', line1)
	// 	customizeEachWord(`!`, 'white', line1)
	// 	blankSpace()
	// 	//THIS IS WHERE THE CHANGE TO THE ENHANCED ITEM GOES
	// 	removeItemFromPerson(selectedFiber)
	// }
		if (selectedItem?.magicWeaving?.[selectedBonus]) {
			blankSpace()
			customizeEachWord(`You cannot enhance this property any further.`, 'white', line1)
			blankSpace()			
			return
		}
		if (!selectedItem.magicWeaving) {
			selectedItem.magicWeaving = {}
			selectedItem.magicWeaving[selectedBonus] = selectedFiber.increase
		} else {
			selectedItem.magicWeaving[selectedBonus] = selectedFiber.increase
		}
		blankSpace()
		customizeEachWord(`You have increased the effectiveness of your `, 'white', line1)
		customizeEachWord(`${selectedItem.name}'s `, selectedItem.color, line1)
		customizeEachWord(`${bonus} `, green, line1)
		customizeEachWord(`armor by `, 'white', line1)
		customizeEachWord(`${selectedFiber.increase}`, 'green', line1)
		customizeEachWord(`!`, 'white', line1)
		blankSpace()
		selectedItem.mods[selectedBonus] += selectedFiber.increase
		removeItemFromPerson(selectedFiber)
}

let kasia = {
	npc: true,
	id: 0,
	x: 3,
	y: 0,
	name: 'Kasia Arnella',
	refName: 'kasia',
	picture: 'images/npcs/female/civilians/kasia/kasia.png',
	nameColor: 'kasia-name',
	prefix: '',
	prefixColor: 'kasia-title',
	keywords: ['kasia', 'lass', 'young lass', 'lass kasia', 'young lass kasia'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)

	},
	desc: () => inspectBlip('A young woman wearing a lovely silk dress stands here smiling.', 'descriptions'),
	conversationNumber: 1,
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		if (this.conversationNumber == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`She swings her basket of flowers happily as she speaks.`, ['white', 'italic'], line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"The Glade is such a beautiful place. There are many things that can only be found here like some of the prettiest flowers! I like to take home my favorite ones that I've found each day."`, 'white', line2)
			blankSpace()
			this.conversationNumber = 2
			return
		}
		if (this.conversationNumber == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I live east of town, but I come here every day. It's my favorite place in the whole world! It's also very safe, as long as you don't wander too far into the forest. The forest sentinels of the Ranger's Guild protect the Glade from high up in the treetops."`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Kasia looks upward.`, ['white', 'italic'], line2)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line3)
			customizeEachWord(`"You can't see, but there's many of them up there."`, 'white', line3)
			blankSpace()
			this.conversationNumber = 3
			return
		}
		if (this.conversationNumber == 3) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I wonder if I'll find a new flower here that I've never seen before. It's always so exciting when I do!"`, 'white', line1)
			blankSpace()
			this.conversationNumber = 1
			return
		}
	},
	questStage: 1,
	questSequence: {
	},
	questItem: [brightYellowFlower],
	isQuestAvailable: true,
	quest: async function () {
		let line1 = lineFunc()
		if (!kasia.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I'd like to find a new type of flower today. Let me know if you find one."`, 'white', line1)
			blankSpace() 
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`"You have already completed this quest."`, 'white', line1)
			blankSpace() 
		}
	},
	offer: async function () {
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		let line1 = lineFunc()
		let line2 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Kasia takes a deep smell of the flower`, ['white', 'italic'], line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This flower is just what I was looking to find today!"`, 'white', line2)
		blankSpace()
		pushItem.splice(qItemIndex, 1)
		player.backpack.splice(qItemIndex, 1)
		kasia.questSequence.first = true
		await dialogueWait(200)
		playerGainQuestExperience(200)
	},
}

let sevrox = {
	npc: true,
	id: 0,
	x: -16,
	y: -9,
	z: 0,
	name: 'Sevrox',
	refName: 'sevrox',
	picture: 'images/npcs/male/civilians/timtim/timtim.png',
	nameColor: 'sevrox',
	prefix: 'Stable Master, ',
	prefixColor: 'sevrox-prefix',
	keywords: ['stable', 'master', 'sevrox', 'stable master', 'stable master sevrox'],
	occupation: '',
	race: 'Half-Minotaur',
	description: 'A large minotaur',
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Sevrox: `, this.nameColor, line1)
		customizeEachWord(`"Hello, I am Sevrox, the castle grounds Stable Master. Lately, we've had an increase in attacks from the gnolls that roam the Galvadian Plains. They never used to attack without reason, but recently they've been acting unusual."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Sevrox: `, this.nameColor, line2)
		customizeEachWord(`"I fear letting anyone ride near the plains. If you were able to thin their numbers, or at least kill enough to strike fear into them, that might stifle their attacks."`, 'white', line2)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Sevrox: `, this.nameColor, line3)
		customizeEachWord(`"If you could bring me proof that you've slain at least 10, I would be satisfied."`, 'white', line3)
		blankSpace()
	},
	questStage: 1,
	questSequence: {
	},
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Sevrox: `, this.nameColor, line1)
		customizeEachWord(`"Hello, I am Sevrox, the castle grounds Stable Master. Lately, we've had an increase in attacks from the gnolls that roam the Galvadian Plains. They never used to attack without reason, but recently they've been acting unusual."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Sevrox: `, this.nameColor, line2)
		customizeEachWord(`"I fear letting anyone ride near the plains. If you were able to thin their numbers, or at least kill enough to strike fear into them, that might stifle their attacks."`, 'white', line2)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`Sevrox: `, this.nameColor, line3)
		customizeEachWord(`"If you could bring me proof that you've slain at least 10, I would be satisfied."`, 'white', line3)
		blankSpace()
	},
	offer: async function() {
		let line1 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"Oooooooo I'm gonna really get her with this!"`, 'white', line1)
		blankSpace()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.first = true
		await dialogueWait(200)
		playerGainQuestExperience(100)

	},
	movesWhenPlayerIsHere: true,
	isInConversation: false,
	// xa: [0, 0, 0, 1, 1, 1, 1],
	// ya: [1, 1, 1, 0, 0, 0, 0],
	// xb: [-1, -1, -1, -1, 0, 0, 0],
	// yb: [0, 0, 0, 0, -1, -1, -1],
	originalWaitInterval: 500000,
	conversationInterval: 500000,
	waitInterval: 500000,
	npcBehavior: function () {
		specificNpcMovement(this)
	},
}

let crutches = {
	name: 'Crutches',
	refName: 'crutches',
	nameColor: 'crutches-name',
	titleColor: 'crutches-title',
	speakComplete1: false,
	speakComplete2: false,
	keywords: ['crutches', 'jailor'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const titleSpan = document.createElement('span')

		const titleNode = document.createTextNode(`Jailor, `)
		const firstNameNode = document.createTextNode(`Crutches`)

		firstNameSpan.appendChild(firstNameNode)
		titleSpan.appendChild(titleNode)
		firstNameSpan.classList.add('crutches-name')
		titleSpan.classList.add('crutches-title')

		npcDiv.appendChild(titleSpan)
		npcDiv.appendChild(firstNameSpan)
		peopleDiv.appendChild(npcDiv)
	},
	desc: () => quickMessage(`A very old, hunch-backed old man`),
	speak: async () => {
		if (crutches.speakComplete1 == false) {
			player.dialogueStasis = true
			await dialogueWait(200)
			let line1 = paragraphFunc()
			customizeEachWord(`Crutches: `, ['greaves-name', 'indent'], line1)
			customizeEachWord(
				`"Ahhh, you must be another initiate! By the smell of you, you must be a prospective ${player.playerClass.name}. Before I let you go further, go north and bring me 3 fingers! "`,
				'white',
				line1
			)
			await dialogueWait(200)
			let line2 = gameLine()
			customizeGameDialogue(`You'll need one of these.`, 'white', line2)
			blankSpace()
			weaponGen(trainingShortsword())
			pushItem[pushItem.length - 1].roomId = 'backpack'
			await dialogueWait(200)
			let line3 = lineFunc()
			customizeEachWord(`You receive a `, 'indent', line3)
			customizeEachWord(`${pushItem[pushItem.length - 1].name}`, `${pushItem[pushItem.length - 1].color}`, line3)
			customizeEachWord(`!`, 'white', line3)
			await dialogueWait(200)
			let line4 = paragraphFunc()
			customizeEachWord(`When you have slain the Goblin Scout, return here and "offer crutches".`, 'white', line4)
			blankSpace()
			player.dialogueStasis = false
			crutches.speakComplete1 = true
		} else if (greaves.speakComplete1 == true && player.killList.goblin_scout == undefined) {
			setTimeout(() => {
				let line1 = paragraphFunc()
				customizeNPCDialogue(`Have you completed your task?`, 'greaves-name', line1)
				setTimeout(() => {
					let line2 = gameLine()
					customizeGameDialogue(`He looks you over to see that there is no blood on you. He turns back to his business without saying anything.`, 'white', line2)
				}, 1000)
			}, 1000)
		}
		if (player.killList.goblin_scout != undefined && greaves.speakComplete1 == true) {
			setTimeout(() => {
				let line1 = paragraphFunc()
				customizeNPCDialogue(`Great work, ${player.name}! You have proven yourself in combat. I will let the ${player.playerClass.name}'s guild admissions officer aware of your graduation status immediately.`, 'greaves-name', line1)
				customizeNPCDialogue(
					`From here, your next step is to gain admission to the ${player.playerClass.name}'s guild. You can find it south of here on the south side of the city. You can also explore as much as you'd like. The marketplace is now open, and the grassfields are no longer guarded. If you wish to travel to the city, you will find it to the south after exiting the training halls to the west.`,
					'greaves-name',
					line1
				)
			}, 1000)

			greaves.speakComplete2 = true
		} else if (greaves.speakComplete2 == true) {
			npcDialogue(`Placeholder`, 'greaves-name')
		}
	},
}

let till = (() => {
const till = {
	x: -3,
	y: 9,
	z: 0,
	name: 'Till',
	refName: 'till',
	nameColor: 'warrior-color',
	prefix: 'Warrior Prospect, ',
	prefixColor: 'brown',
	occupation: 'Warrior Prospect',
	race: 'Human',
	description: 'A very annoyed looking warrior prospect',
	keywords: ['till', 'annoyed', 'warrior', 'prospect', 'annoyed warrior', 'annoyed warrior prospect', 'warrior prospect'],
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	dialogueSequence: {},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"As a Warrior, I find it a lot easier to wait for the monsters to advance me first. If I time it right, I can hit it with my Ripslash ability and regular attack at the same time!"`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"The only problem is those `, 'white', line2)
			customizeEachWord(`Waterlings`, 'red', line2)
			customizeEachWord(`. They spit water from far away, so I have to start my ability windup and then advance it soon as my ability is ready to execute.`, 'white', line2)
			blankSpace()
		} 
	},
	quest: async function () {
	},
	offer: function () {
	},
	get areas(){
		return trainingFieldsRoomPack
	},
	npcBehavior: function() {
		till.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, 10000) 
	},
	get currentArea() {
		return fields9
	},
}
    allNpcsArray.push(till);
    return till;
})();


const lessa = {
	x: -2,
	y: 2,
	z: 0,
	name: 'Lessa',
	refName: 'lessa',
	nameColor: 'mage-color',
	prefix: 'Mud-covered Mage Prospect, ',
	prefixColor: 'purple',
	keywords: ['lessa'],
	occupation: `Mage prospect`,
	race: `Human`,
	description: ``,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"My `, 'white', line1)
			customizeEachWord(`Magic Shield `, 'green', line1)
			customizeEachWord(`spell is enough to prevent me from taking damage from these things, but it doesn't stop these `, 'white', line1)
			customizeEachWord(`Mudlings `, 'red', line1)
			customizeEachWord(`from getting their mud goo all over me..`, 'white', line1)
			blankSpace()
		} 
	},
	get areas(){
		return trainingFieldsRoomPack
	},
	npcBehavior: function() {
		lessa.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, 2000) 
	},
}
allNpcsArray.push(lessa)

const sylas = {
	x: -3,
	y: 9,
	z: 0,
	name: 'Sylas',
	refName: 'sylas',
	nameColor: 'sinistral-color',
	prefix: 'Shadowy Prospect, ',
	prefixColor: 'yellow',
	keywords: ['sylas', 'thief'],
	occupation: `Thief Prospect`,
	race: `Human`,
	description: `A shadowy thief`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	isQuestAvailable: false,
	dialogueSequence: {},
	questSequence: {
		first: false,
	},
	speak: async function () {
		this.getAwayAttempts = 0
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"When I stealth, I can attack monsters with my `, 'white', line1)
			customizeEachWord(`Ambush `, 'green', line1)
			customizeEachWord(`ability and regular attack at almost the same time. These things don't stand a chance!"`, 'white', line1)
			blankSpace()
		} 
	},
	get areas(){
		return trainingFieldsRoomPack
	},
	npcBehavior: function() {
		sylas.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, 10000) 
	},
	get currentArea() {
		return fields9
	},
}
allNpcsArray.push(sylas)

const krista = {
	x: -3,
	y: 9,
	z: 0,
	name: 'Krista',
	refName: 'krista',
	nameColor: 'light-pink',
	prefix: 'Monk Prospect, ',
	prefixColor: 'monk-color',
	keywords: ['krista'],
	occupation: `Monk Prospect`,
	race: `Human`,
	description: `An elegant Monk`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I could sit back and wait for monsters to advance me first, but I like to get straight into battle even if I take an extra hit. I was told I would probably like the `, 'white', line1)
			customizeEachWord(`Tactics `, 'green', line1)
			customizeEachWord(`skill because I'll get bonuses to some of my stats whenever I engage the enemy first."`, 'white', line1)
			blankSpace()
		} 
	},
	get areas(){
		return trainingFieldsRoomPack
	},
	npcBehavior: function() {
		krista.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, 1000) 
	},
	get currentArea() {
		return fields9
	},
}
allNpcsArray.push(krista)

const gaelwyn = {
	x: -3,
	y: 9,
	z: 0,
	name: 'Gaelwyn',
	refName: 'gaelwyn',
	nameColor: 'light-green',
	prefix: 'Ranger Prospect, ',
	prefixColor: 'ranger-color',
	keywords: ['gaelwyn'],
	occupation: `Ranger Prospect`,
	race: `Half-Elf`,
	description: `A pragmatic looking Ranger Prospect.`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questSequence: {
		first: false,
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"If I attack as soon as the monster appears, I usually have enough time to move to a different room before it advances me. When it follows me, I can just hit it and move to a different room and never worry about getting hit."`, 'white', line1)
			blankSpace()
		} 
	},
	get areas(){
		return trainingFieldsRoomPack
	},
	npcBehavior: function() {
		gaelwyn.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, 10000) 
	},
	get currentArea() {
		return fields9
	},
}
allNpcsArray.push(gaelwyn)


const levins = {
	npc: true,
	id: 0,
	x: -7,
	y: 8,
	z: 0,
	name: `Levins`,
	refName: 'levins',
	nameColor: 'light-blue',
	prefix: 'Commander ',
	prefixColor: 'blue',
	keywords: ['levins', 'commander', 'commander levins'],
	questComplete1: false,
	questComplete2: false,
	speakComplete1: false,
	speakComplete2: false,
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},
	desc: () => quickMessage('Commander Levins'),
	speak: () => {
		if (levins.speakComplete1 == false) {
			levins.speakComplete1 = true
			let weapon
			if (player.playerClass.name == 'Warrior') {
				weapon = 'Longsword'
				pushItem.push(longsword(10, false))
			} else if (player.playerClass.name == 'Rogue') {
				weapon = 'Shiv'
				pushItem.push(shiv(10, false))
			}
			pushItem.slice(-1)[0].roomId = 'backpack'
			npcDialogue(`For this last room, there's a Scout that we captured. He's a little tougher than the other creatures you've fought. To keep things on an even playing field, take this ${weapon}. Once you have defeated the scout, come back and'offer' me your completed task.`, 'levins-name')
			setTimeout(() => {
				let line1 = document.createElement('div')
				customizeEachWord(`You receive a `, 'game-dialogue', line1)
				customizeEachWord(`${weapon}`, 'green', line1)
				customizeEachWord(`!`, 'white', line1)
				blankSpace()
				setTimeout(() => {
					npcDialogue(
						`WEAPONS: To equip a weapon, you simply need to hold it. You can do this by using the 'UNPACK' command. Try 'unpack ${weapon}. Now you can check your inventory to see that your weapon is wielded. Two handed weapons are wielded by both hands, so they will take up two slots. You can dual wield one handed weapons, but only once you have trained the dual weapon skill.`
					)
				}, 1000)
			}, 1000)
		} else {
			let line1 = document.createElement('div')
			npcDialogue(`Return to me when you have completed your task`, 'levins-name')
			customizeEachWord(`(Try 'offer levins')`, 'game-dialogue', line1)
		}
	},
	quest: () => npcDialogue(`There are goblins in each of these rooms. Once you have slain them all, come back here and I will reward you.`),
	offer: function () {
		if (levins.questComplete1 == false && player.killList.goblin_scout) {
			levins.questComplete1 = true
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			npcDialogue(
				`Very nice! As you can see, upon gaining a level and completing your combat training quest, you have received 'stat points' and 'build points'. You will be able to use these to increase your attributes and learn new skills. You will learn all about how to do this once you join a guild.`,
				'levins-name'
			)
			npcDialogue(`If you're ever at the castle, feel free to drop by. I might have some tasks for you.`)
			setTimeout(() => {
				customizeEachWord(`You have been awarded `, 'white', line1)
				customizeEachWord(`100 `, 'yellow', line1)
				customizeEachWord(`gold!`, 'white', line1)
				customizeEachWord(`You have been awarded `, 'white', line2)
				customizeEachWord(`2 `, 'green', line2)
				customizeEachWord(`build `, 'light-blue', line2)
				customizeEachWord(`points!`, 'white', line2)
				player.gold = player.gold + 100
				player.skillPoints = player.skillPoints + 2
				setTimeout(() => {
					gameDialogue(`Commander Levins returns to the castle`)
					currentArea.npc = []
				}, 1000)
			}, 500)
		} else {
			let line1 = document.createElement('div')
			customizeEachWord(`You have not met the requirements to complete this quest`, 'white', line1)
		}
	},
}
allNpcsArray.push(levins)


const belric = {
	npc: true,
	id: 0,
	x: -7,
	y: 6,
	z: 0,
	name: `Belric`,
	refName: 'belric',
	nameColor: 'blue',
	suffix: ', Lord Commander of The Galvadian Guard',
	suffixColor: 'gold',
	keywords: ['belric'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},

	skills: [unarmedCombatSkill, oneHandedWeaponSkill, twoHandedWeaponSkill],
	skillsOffered: ['unarmed combat', 'one handed weapon skill', 'two handed weapon skill'],
	skillsMaxLevel: {
		unarmed: 10,
		oneHanded: 10,
		twoHanded: 10,
	},
	desc: () => quickMessage('A large, heavily armored knight stands before you.', 'descriptions'),
	quest: () => gameDialogue(`Belric holds out an open hand, expecting goblin heads.`),
	offer: function () {
		let questItems = pushItem.filter(item => item.name == 'goblin head')
		let questItemsIndexOfFirst = pushItem.indexOf(questItems[0])
		if (questItems[0] != undefined && questItems[1] == undefined) {
			quickMessage(`You hand a ${questItems[0].name} over to Belric`)
			player.experience += questItems[0].experience
			quickMessage(`You gain ${questItems[0].experience} points!`)
			pushItem.splice(questItemsIndexOfFirst, 1)
			player.backpack.splice(questItemsIndexOfFirst, 1)
			npcDialogue(`Ahhhh yes! The justice I feel from seeing their heads is palpable! Bring me more, and you will continue to be rewarded.`)
		} else if (questItems[0] != undefined && questItems[1] != undefined) {
			npcDialogue(`You hand over all your ${questItems[0].name}s to Belric`)
			npcDialogue(`Ahhhh yes! The justice I feel from seeing their heads is palpable! Bring me more, and you will continue to be rewarded.`)

			questExperienceMultipleItems(questItems)
		} else {
			gameDialogue(`You must have the proper item(s) to turn in this quest`)
		}
	},
}

allNpcsArray.push(belric)


const villagerMalchus = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Malchus',
	refName: 'malchus',
	nameColor: randomClassColor(),
	suffix: ', Villager',
	suffixColor: 'brown',
	keywords: ['villager', 'malchus'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},
	desc: function () {
		let message1 = 'Male villager (Malchus)'
		let message1Color = `${this.nameColor}`
		inspectBlip(message1, message1Color)
	},
	speak: function () {
		let line1 = lineFunc()
		customizeEachWord(`${this.name}`, [this.nameColor, 'indent'], line1)
		customizeEachWord(` Greetings! My name is Malchus. I have lived in Galvadia all my life. Never have I seen a more beautiful place. It has everything to offer from lakes and rivers to hills and forests.`, 'white', line1)
	},
	movesWhenPlayerIsHere: false,
	eastCount: 2,
	westCount: 2,
	intervalTick: 5000,
	// npcBehavior: function () {
	// 	setInterval(() => {
	// 		npcMovesRandomly(this)
	// 	}, this.intervalTick)
	// },
}
allNpcsArray.push(villagerMalchus)


const villagerLinus = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Linus',
	refName: 'linus',
	nameColor: randomClassColor(),
	suffix: ', Villager',
	suffixColor: 'brown',
	keywords: ['villager', 'linus'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	desc: function () {
		npcDescription(this)
	},
	movesWhenPlayerIsHere: false,
	eastCount: 3,
	westCount: 3,
	intervalTick: 5000,
	// npcBehavior: function () {
	// 	setInterval(() => {
	// 		npcMovesRandomly(this)
	// 	}, this.intervalTick)
	// },
}
const rissah = {
	npc: true,
	id: 0,
	x: -10,
	y: -5,
	z: 0,
	name: 'Rissah',
	refName: 'rissah',
	nameColor: randomClassColor(),
	picture: 'images/npcs/female/civilians/rissah/rissah.png',
	prefix: 'Villager ',
	prefixColor: 'light-brown',
	keywords: ['villager', 'rissah'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	questStage: 1,
	isQuestAvailable: true,
	questSequence: {
	},
	conversationNumber: 1,
	speak: async function () {
		let line1 = lineFunc()
		this.isInConversation = true
		if (this.conversationNumber == 1) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"I spend most the day shopping around the market. I don't even buy anything! I just have fun checking out what everyone has to sell each day."`, 'white', line1)
			blankSpace()
			this.conversationNumber = 2
		} else if (this.conversationNumber == 2) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Joch and Clyde are the brother blacksmiths. They've been crafting weapons and armor for as long as I can remember. Their craftsmanship is unmatched."`, 'white', line1)
			blankSpace()
			this.conversationNumber = 3
		} else if (this.conversationNumber == 3) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"The blacksmiths can be found northeast of the town square."`, 'white', line1)
			blankSpace()
			this.conversationNumber = 1
		}
		clearTimeout(NPCConversationIntervals.rissah)		
		NPCConversationIntervals.rissah = setTimeout(() => {
			this.isInConversation = false
		}, this.conversationInterval)
	},
	quest: async function () {
		if (!this.questSequence.first) {
		let line1 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"I'm really thirsty. Do you happen to have anything? I'd give you something in return."`, 'white', line1)
		blankSpace()
		}
		if (this.questSequence.first) {
		quickMessage(`${this.name} doesn't have a quest to offer you`)
		}
	},
	offer: async function () {
		let qItem = pushItem.find(({ keywords }) => keywords.some(keyword => keyword == 'water berry'))
		let qItemIndex = pushItem.indexOf(qItem)
		let line1 = line()
		let line2 = line()
		let line4 = line()
		if (this.questSequence.first) {
			customizeEachWord(`You have already completed this quest`, 'white', line1)
		} else if (!qItem) {
			quickMessage(`You must have the proper item to complete this quest`)
		} else if (!this.questSequence.first && qItem.roomId == 'backpack' || qItem.roomId == 'right hand' || qItem.roomId == 'left hand') {
			this.questSequence.first = true
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You hand a `, 'white', line1)
			customizeEachWord(`${qItem.name} `, 'green', line1)
			customizeEachWord(`to `, 'white', line1)
			customizeEachWord(`${this.name} `, this.nameColor, line1)
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line2)
			customizeEachWord(`"Oh my, a `, this.prefixColor, line2)
			customizeEachWord(`${qItem.name}`, 'green', line2)
			customizeEachWord(`! `, this.prefixColor, line2)
			customizeEachWord(`You must have worked really hard to get this. Benjamin only sells apples and mudpies. I should tell him to get you to collect some for him to sell. I bet he'd pay you for them.`, this.prefixColor, line2)
			await dialogueWait(200)
			playerGainQuestExperience(20)
			pushItem.splice(qItemIndex, 1)
			player.backpack.splice(qItemIndex, 1)
			return
		}  
	},
	desc: function () {
		npcDescription(this)
	},
	get areas(){
		return galvadiaSquareRoomPack
	},
	npcBehavior: function () {
		let movementSpeed = randomNumberRange(20000, 60000)
		this.behaviorInterval = setInterval(() => {
			npcMovesRandomlyNew(this)
		}, movementSpeed) 
	},
}
allNpcsArray.push(rissah)

const villager1 = {
	npc: true,
	id: 0,
	x: -4,
	y: 2,
	z: 0,
	name: 'Villager1',
	refName: 'villager1',
	nameColor: randomClassColor(),
	suffix: ', Villager',
	suffixColor: 'brown',
	keywords: ['villager', 'rissah'],
	displayName: function (peopleDiv) {
		const npcDiv = document.createElement('div')
		const firstNameSpan = document.createElement('span')
		const firstNameNode = document.createTextNode(`${this.name}`)
		if (this.prefix != undefined) {
			const prefixSpan = document.createElement('span')
			const prefixNode = document.createTextNode(`${this.prefix}`)
			prefixSpan.classList.add(this.prefixColor)
			prefixSpan.appendChild(prefixNode)
			npcDiv.appendChild(prefixSpan)
		}

		firstNameSpan.classList.add(this.nameColor)
		firstNameSpan.appendChild(firstNameNode)
		npcDiv.appendChild(firstNameSpan)

		if (this.suffix != undefined) {
			const suffixSpan = document.createElement('span')
			const suffixNode = document.createTextNode(`${this.suffix}`)
			suffixSpan.classList.add(this.suffixColor)
			suffixSpan.appendChild(suffixNode)
			npcDiv.appendChild(suffixSpan)
		}
		peopleDiv.appendChild(npcDiv)
	},
	desc: function () {
		let message1 = 'Female villager (Rissah)'
		let message1Color = `${this.nameColor}`
		inspectBlip(message1, message1Color)
	},
	movesWhenPlayerIsHere: true,
	eastCount: 4,
	westCount: 4,
	intervalTick: 5000,
	npcBehavior: function () {
		setInterval(() => {
			npcMovesEastToWest(this)
		}, this.intervalTick)
	},
}

// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 
// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 




// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 
// ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ ++NPC DIALOGUE++ 

function restFunction() {
	if (!player.restStasis) {
		quickMessage(`You are now resting...`)
		player.restStasis = true
		// let healthRecoveredPerTick = player.rest.healthPerTick()
		// let manaRecoveredPerTick = player.rest.manaPerTick()
		let restTimer = player.rest.restTimer
		let restInterval = setInterval(() => {
			if (player.restStasis) {
				let healthRecoveredPerTick = player.rest.healthPerTick()
				let manaRecoveredPerTick = player.rest.manaPerTick()
				if (player.health + healthRecoveredPerTick > player.maxHealth) {
					healthRecoveredPerTick = player.maxHealth - player.health
					player.health = player.maxHealth
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${healthRecoveredPerTick} `, 'green', line1)
					customizeEachWord(`hit points from resting`, 'white', line1)
					updatePlayerStats()
				} else {
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${healthRecoveredPerTick} `, 'green', line1)
					customizeEachWord(`hit points from resting`, 'white', line1)
					player.health = player.health + healthRecoveredPerTick
					updatePlayerStats()
				}
				if (player.mana + manaRecoveredPerTick > player.maxMana) {
					manaRecoveredPerTick = player.maxMana - player.mana
					player.mana = player.maxMana
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${manaRecoveredPerTick} `, 'blue', line1)
					customizeEachWord(`mana from resting`, 'white', line1)
					updatePlayerStats()
				} else {
					let line1 = document.createElement('div')
					customizeEachWord(`You recover `, 'white', line1)
					customizeEachWord(`${manaRecoveredPerTick} `, 'blue', line1)
					customizeEachWord(`mana from resting`, 'white', line1)
					player.mana = player.mana + manaRecoveredPerTick
					updatePlayerStats()
				}
			}
			if (!player.restStasis) {
				clearInterval(restInterval)
			}
		}, restTimer)
	} else {
		quickMessage(`You are already resting`)
	}
}

//function trainSkill(secondCommand, thirdCommand) {
//	console.log(thirdCommand)
//	var regExp = /[a-zA-Z]/g //used to test if string contains letters. returns true or false
//	let npcName = thirdCommand == undefined ? undefined : thirdCommand.replace(/\s/g, '') //if thirdCommand contains any spaces, this removes them
//	npcName = npcName == undefined ? undefined : npcName.toLowerCase()
//	let targetNpc = currentArea.npc.find(npc => npc.name == npcName && npc.skills[0] != undefined)
//	const skillNumber = secondCommand - 1
//	if (!currentArea.npc[0]) {
//		quickMessage(`There is nobody here teaching anything.`)
//	} else if (secondCommand == undefined) {
//		quickMessage(`You must specify what skill or spell you wish to train and who to train it from`)
//	} else if (thirdCommand != npcName) {
//		quickMessage(`You do not see anyone named ${thirdCommand}`)
//	} else if (targetNpc.skills[skillNumber] == undefined) {
//		quickMessage(`This person cannot teach you that skill or spell`)
//	} else if (targetNpc.skills[skillNumber]) {
//		quickMessage(`You successfully train ${targetNpc.skills[skillNumber]}!`)
//	}
//}

function buyCommand(secondCommand, thirdCommand) {
	const validItemsNpc = currentArea.npc.filter(npc => npc.itemsOffered).length > 0 ? currentArea.npc.filter(npc => npc.itemsOffered) : currentArea.npc.find(npc => npc.itemsOffered)
	const specifiedNpc = currentArea.npc.find(npc => npc.refName == thirdCommand)
	const thirdCommandIsNpcName = validItemsNpc.some(npc => npc.refName == thirdCommand)
	if (validItemsNpc && validItemsNpc[1] && !thirdCommandIsNpcName) {
		quickMessage(`You must specify who you wish to buy from`)
	} else if (validItemsNpc != undefined && validItemsNpc[1] != undefined && thirdCommandIsNpcName == true) {
		specifiedNpc.buy(secondCommand)
	} else if (specifiedNpc != undefined && specifiedNpc.itemsOffered != null) {
		specifiedNpc.buy(secondCommand)
	} else if (validItemsNpc != undefined) {
		validItemsNpc[0].buy(secondCommand)
	} else {
		quickMessage(`Nobody here is teaching skills`)
	}
}

function buyInteraction(secondCommand, npc) { //interaction response from npc object
	let npcItemIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	let masterItem = npc.itemsOffered[npcItemIndex] != undefined ? npc.itemsOffered[npcItemIndex] : undefined
	masterItem = masterItem != undefined ? masterItem() : undefined
	let playerGold = player.gold
	let goldCost = masterItem != undefined ? masterItem.price : undefined
	let line1 = document.createElement('div')
	if (masterItem == undefined || masterItem.name == '???') {
		customizeEachWord(`There is no item by that number being sold`, 'white', line1)
	} else if (playerGold < goldCost) {
		customizeEachWord(`You do not have enough gold to buy that item`, 'white', line1)
	} else if (masterItem != undefined) {
		let vowels = ['a', 'e', 'i', 'o', 'u']
		let aOrAn = vowels.includes(masterItem.name[0].toLowerCase()) ? 'an' : 'a'

		customizeEachWord(`You purchased ${aOrAn} `, 'white', line1)
		customizeEachWord(`${masterItem.name} `, masterItem.color, line1)
		customizeEachWord(`for `, 'white', line1)
		customizeEachWord(`${masterItem.price} `, 'yellow', line1)
		customizeEachWord(`gold`, 'white', line1)
		player.gold -= goldCost
		if (masterItem.type.weapon) {
			weaponGen(masterItem)
		} else if (masterItem.type.armor) {
			armorGen(masterItem)
		} else if (masterItem.type.food) {
			foodGen(masterItem)
		}
		let purchasedItem = pushItem[pushItem.length - 1]
		purchasedItem.roomId = 'backpack'
	} else {
		customizeEachWord(`Fix this line`, 'white', line1)
	}
}

function trainInteraction(secondCommand, npc) {
	console.log(npc)
	let npcSkillIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	let masterSkill = npc.skillsOffered[npcSkillIndex]
	if (!masterSkill) {
		quickMessage(`That is not a skill that you can learn`)
		return
	}
	let npcSkillMaxLevel = masterSkill != undefined ? npc.skillsMaxLevel[masterSkill.refName] : undefined
	let playerSkill = player[masterSkill.refName]
	let playerGold = player.gold
	let playerPoints = player.skillPoints
	let goldCost = playerSkill != undefined ? playerSkill.goldToUpgrade() : masterSkill.goldToUpgrade()
	let pointsCost = playerSkill != undefined ? playerSkill.pointsToUpgrade() : masterSkill.pointsToUpgrade()
	let line1 = document.createElement('div')
 	if (masterSkill == undefined) {
		customizeEachWord(`That skill is not one of the choices`, 'white', line1)
	} 
	// else if (masterSkill.requiredPlayerLevel && player.level < masterSkill.requiredPlayerLevel()) {
	// 	quickMessage(`You must be level ${masterSkill.requiredPlayerLevel()} in order to train this ability`)
	// } 
	else if (playerGold < goldCost) {
		quickMessage(`You do not have enough gold to learn this skill!`)
	} else if (playerPoints < pointsCost) {
		quickMessage(`You do not have enough ability points to learn this skill!`)
	} else if (playerSkill.level == 0 && masterSkill != undefined) {
		player.skillMods[playerSkill.refName] = 1
		customizeEachWord(`You have learned the `, 'white', line1)
		customizeEachWord(`${masterSkill.name} `, masterSkill.color, line1)
		customizeEachWord(`skill!`, 'white', line1)
		if (playerSkill.update) {player[playerSkill.refName].update()}
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else if (playerSkill.level < npcSkillMaxLevel) {
		player.skillMods[playerSkill.refName]++
		customizeEachWord(`You have furthered your knowledge of the `, 'white', line1)
		customizeEachWord(`${playerSkill.name} `, playerSkill.color, line1)
		customizeEachWord(`skill! You have increased its level to `, 'white', line1)
		customizeEachWord(`${playerSkill.level}`, `light-blue`, line1)
		console.log(playerSkill)
		if (playerSkill.update) {
			player[playerSkill.refName].update()
		}
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else {
		customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
		customizeEachWord(`cannot teach you any more of the `, 'white', line1)
		customizeEachWord(`${playerSkill.name} `, playerSkill.color, line1)
		customizeEachWord(`skill`, 'white', line1)
	}
}
function learnInteraction(secondCommand, npc) {
	let npcSpellIndex = secondCommand - 1 //0, 1, 2, 3, 4, etc
	console.log(npc)
	let masterSpell = npc.spellsOffered[npcSpellIndex]
	if (!masterSpell) {
		quickMessage(`Can't learn that`)
		return
	}
	let npcSkillMaxLevel = masterSpell != undefined ? npc.spellsMaxLevel[masterSpell.refName] : undefined
	let playerSpell = player[masterSpell.refName]
	let playerGold = player.gold
	let playerPoints = player.skillPoints
	let goldCost = playerSpell != undefined ? playerSpell.goldToUpgrade() : masterSpell.goldToUpgrade()
	let pointsCost = playerSpell != undefined ? playerSpell.pointsToUpgrade() : masterSpell.pointsToUpgrade()
	let line1 = document.createElement('div')
 	if (masterSpell == undefined) {
		customizeEachWord(`That spell is not one of the choices`, 'white', line1)
	} 
	// else if (masterSpell.requiredPlayerLevel && player.level < masterSpell.requiredPlayerLevel()) {
	// 	quickMessage(`You must be level ${masterSpell.requiredPlayerLevel()} in order to train this ability`)
	// } 
	else if (playerGold < goldCost) {
		quickMessage(`You do not have enough gold to learn this spell!`)
	} else if (playerPoints < pointsCost) {
		quickMessage(`You do not have enough ability points to learn this spell!`)
	} else if (playerSpell.level == 0 && masterSpell != undefined) {
		console.log("LEARNED NEW SPELL")
		player.skillMods[playerSpell.refName] = 1
		customizeEachWord(`You have learned the `, 'white', line1)
		customizeEachWord(`${masterSpell.refName} `, masterSpell.color, line1)
		customizeEachWord(`spell!`, 'white', line1)
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else if (playerSpell.level < npcSkillMaxLevel) {
		console.log("INCREASED SPELL LEVEL")
		player.skillMods[playerSpell.refName]++
		customizeEachWord(`You have furthered your knowledge of the `, 'white', line1)
		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
		customizeEachWord(`spell! You have increased its level to `, 'white', line1)
		customizeEachWord(`${playerSpell.level}`, `light-blue`, line1)
		player.gold -= goldCost
		player.skillPoints -= pointsCost
		// applyExpertiseUponLeveling(playerSkill)
	} else {
		customizeEachWord(`${capitalizeFirstLetter(npc.name)} `, npc.nameColor, line1)
		customizeEachWord(`cannot teach you any more of the `, 'white', line1)
		customizeEachWord(`${playerSpell.name} `, playerSpell.color, line1)
		customizeEachWord(`spell`, 'white', line1)
	}
}

// function applyExpertiseUponLeveling(skill) {
// 	// switch (skill.refName) {
// 	// 	case 'slashingExpertise':
// 	// 		skill.expertiseAmount()
// 	// 		break;
// 	// 	case 'piercingExpertise':
// 	// 		skill.expertiseAmount()
// 	// 		break;
// 	// 	case 'bluntExpertise':
// 	// 		skill.expertiseAmount()
// 	// 		break;
// 	// 	case 'firePenetration':
// 	// 		skill.penetrationAmount()
// 	// 		break;
// 	// }
// }

function sell(secondCommand, itemNumberPre) {
	//sell sword
	//sell 1
	//sell right/left
	if (currentArea.npc) {
		if (currentArea.npc[0] == undefined) {
			quickMessage(`There is nobody here to sell anything to`)
		} else if (currentArea.npc[0] && secondCommand == undefined) {
			quickMessage(`You must specify what you want to sell`)
		} else if (currentArea.npc[0]) {
			const itemNumber = itemNumberPre != undefined ? itemNumberPre - 1 : undefined
			const backpackArray = pushItem.filter(item => item.roomId == 'backpack')
			const itemSoldArray = backpackArray.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
			if (itemNumber) {
				let itemSold = itemSoldArray[itemNumber]
				if (!itemSold) {
					quickMessage(`You do not have that item to sell (you cannot sell items in your hands)`)
				} else {
					if (itemSold.sellValue == 0) {
						quickMessage(`This item cannot be sold`)
						return
					}
					let removeThisItem = pushItem.find(item => item.id == itemSold.id)
					let removedItemIndex = pushItem.indexOf(removeThisItem)
					player.gold = player.gold + itemSold.sellValue
					pushItem.splice(removedItemIndex, 1)
					//quickMessage(`You sold your ${itemSold.name} for ${itemSold.sellValue} gold`)
					sellItemDialog(itemSold.name, itemSold.sellValue)
				}
			} else {
				let itemSold = itemSoldArray[0]
				if (itemSold == undefined) {
					quickMessage(`You do not have that item to sell`)
				} else {
					if (itemSold.sellValue == 0) {
						quickMessage(`This item cannot be sold`)
						return
					}
					console.log('2 THIS IS WHERE SOLD')
					sellItemDialog(itemSold.name, itemSold.sellValue)
					let removeThisItem = pushItem.find(item => item.id == itemSold.id)
					let removedItemIndex = pushItem.indexOf(removeThisItem)
					player.gold = player.gold + itemSold.sellValue
					pushItem.splice(removedItemIndex, 1)
					//quickMessage(`You sold your ${itemSold.name} for ${itemSold.sellValue} gold`)
				}
			}
		} else {
			console.log('nobody selling anything here')
		}
	}
}

function showQuest(thirdCommand) {
	let line1 = lineFunc()
	let questNpcs = currentArea.npc.filter(npc => npc?.questStage > 0)
	if (questNpcs.length == 0) {
		blankSpace()
		customizeEachWord(`There is nobody here offering quests.`, 'white', line1)
		blankSpace()
		return
	}
	if (!thirdCommand) {
		if (questNpcs.length == 1) {
			//only 1 quest npc
			questNpcs[0].quest()
		} else {
			//multiple quest npcs
			blankSpace()
			customizeEachWord(`You must specify who's quest you want to see.`, 'white', line1)
			blankSpace()
		}
		return
	}
	let specifiedNpc = currentArea.npc.find(({ keywords }) => keywords.some(keyword => keyword == thirdCommand))
	if (!specifiedNpc) {
		blankSpace()
		customizeEachWord(`There is nobody by the name ${thirdCommand} offering quests.`, 'white', line1)
		blankSpace()
	} else {
		specifiedNpc.quest()
	}
}

function offerQuest(secondCommand) {
	let line1 = lineFunc()
	let questNpcs = currentArea.npc.filter(npc => npc?.questStage > 0)
	if (questNpcs.length == 0) {
		blankSpace()
		customizeEachWord(`There is nobody here accepting a quest offering.`, 'white', line1)
		blankSpace()
		return
	}
	if (!secondCommand) {
		if (questNpcs.length == 1) {
			//only 1 quest npc
			questNpcs[0].offer()
		} else {
			//multiple quest npcs
			blankSpace()
			customizeEachWord(`You must specify who's quest you want to complete.`, 'white', line1)
			blankSpace()
		}
		return
	}
	let specifiedNpc = currentArea.npc.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	if (!specifiedNpc) {
		blankSpace()
		customizeEachWord(`There is nobody by the name ${secondCommand} accepting a quest offering.`, 'white', line1)
		blankSpace()
	} else {
		specifiedNpc.offer()
	}
}

function showSkills(thirdCommand) {
	let line1 = lineFunc()
	let skillNpcs = currentArea.npc.filter(npc => npc?.skillsOffered)
	if (skillNpcs.length == 0) {
		blankSpace()
		customizeEachWord(`There is nobody here teaching skills.`, 'white', line1)
		blankSpace()
		return
	}
	if (!thirdCommand) {
		if (skillNpcs.length == 1) {
			//only 1 quest npc
			skillNpcs[0].displayShop('skills')
		} else {
			//multiple quest npcs
			blankSpace()
			customizeEachWord(`You must specify who's skills you want to see.`, 'white', line1)
			blankSpace()
		}
		return
	}
	let specifiedNpc = currentArea.npc.find(({ keywords }) => keywords.some(keyword => keyword == thirdCommand))
	if (!specifiedNpc) {
		blankSpace()
		customizeEachWord(`There is nobody by the name ${thirdCommand} teaching skills.`, 'white', line1)
		blankSpace()
	} else {
		specifiedNpc.displayShop('skills')
	}
}

function showSpells(thirdCommand) {
	let line1 = lineFunc()
	let spellNpcs = currentArea.npc.filter(npc => npc?.spellsOffered)
	if (spellNpcs.length == 0) {
		blankSpace()
		customizeEachWord(`There is nobody here teaching spells.`, 'white', line1)
		blankSpace()
		return
	}
	if (!thirdCommand) {
		if (spellNpcs.length == 1) {
			//only 1 quest npc
			spellNpcs[0].displayShop('spells')
		} else {
			//multiple quest npcs
			blankSpace()
			customizeEachWord(`You must specify who's spells you want to see.`, 'white', line1)
			blankSpace()
		}
		return
	}
	let specifiedNpc = currentArea.npc.find(({ keywords }) => keywords.some(keyword => keyword == thirdCommand))
	if (!specifiedNpc) {
		blankSpace()
		customizeEachWord(`There is nobody by the name ${thirdCommand} teaching spells.`, 'white', line1)
		blankSpace()
	} else {
		specifiedNpc.displayShop('spells')
	}
}
function showItems(thirdCommand) {
	let line1 = lineFunc()
	let itemNpcs = currentArea.npc.filter(npc => npc?.itemsOffered)
	if (itemNpcs.length == 0) {
		blankSpace()
		customizeEachWord(`There is nobody here selling anything.`, 'white', line1)
		blankSpace()
		return
	}
	if (!thirdCommand) {
		if (itemNpcs.length == 1) {
			//only 1 quest npc
			itemNpcs[0].displayShop('items')
		} else {
			//multiple quest npcs
			blankSpace()
			customizeEachWord(`You must specify who's items you want to see.`, 'white', line1)
			blankSpace()
		}
		return
	}
	let specifiedNpc = currentArea.npc.find(({ keywords }) => keywords.some(keyword => keyword == thirdCommand))
	if (!specifiedNpc) {
		blankSpace()
		customizeEachWord(`There is nobody by the name ${thirdCommand} selling anything.`, 'white', line1)
		blankSpace()
	} else {
		specifiedNpc.displayShop('items')
	}
}


function show(secondCommand, thirdCommand) {
	let showWhat = secondCommand == 'skills' ? showSkills : secondCommand == 'items' ? showItems : secondCommand == 'spells' ? showSpells : secondCommand == 'quest' ? showQuest : undefined
	if (showWhat == undefined) {
		console.log(1)
		quickMessage(`You must specify either skills, items, spells or quest after the SHOW command`)
		return
	} else {
		showWhat(thirdCommand)
	}
}

function trainSkill(secondCommand, thirdCommand) {
	if (isNaN(secondCommand)) {
		quickMessage(`You must specify the number of skill to train before the teacher's name.`)
		return
	}
	const validSkillsNpc = currentArea.npc.filter(npc => npc.skillsOffered).length > 0 ? currentArea.npc.filter(npc => npc.skillsOffered) : currentArea.npc.find(npc => npc.skillsOffered)
	if (!validSkillsNpc) {
		quickMessage(`There is nobody here teaching skills`)
		return
	}
	if (!secondCommand) {
		quickMessage(`You must specify what skill you want to train`)
		return
	}
	if (validSkillsNpc.length > 1 && !thirdCommand) {
		quickMessage(`There are more than one trainers here. You must specify who you wish to train skills from. (Example: train 1 egbert)`)
		return
	}
	let npc
	if (!thirdCommand) {
		npc = validSkillsNpc[0]
	} else {
		npc = npcByName(thirdCommand)
	}
	console.log(npc)
	npc.train(secondCommand, npc)
}

function increaseStat(secondCommand) {
	let stat
	let attributeWord
	switch (secondCommand) {
		case 'strength':
		case 'str':
			stat = 'str'
			attributeWord = 'strength'
			break
		case 'dexterity':
		case 'dex':
			stat = 'dex'
			attributeWord = 'dexterity'
			break
		case 'agility':
		case 'agi':
			stat = 'agi'
			attributeWord = 'agility'
			break
		case 'intelligence':
		case 'int':
			stat = 'int'
			attributeWord = 'intelligence'
			break
		case 'wisdom':
		case 'wis':
			stat = 'wis'
			attributeWord = 'wisdom'
			break
		case 'constitution':
		case 'con':
			stat = 'con'
			attributeWord = 'constitution'
			break
		case 'mysticism':
		case 'mys':
			stat = 'mys'
			attributeWord = 'mysticism'
			break
	}
	if (player[stat] == undefined) {
		quickMessage(`You do not have the stat ${secondCommand} to increase.`)
	} else if (player.attributePoints > 0) {
		let line1 = document.createElement('div')
		customizeEachWord(`You have increased your `, 'white', line1)
		customizeEachWord(`${capitalizeFirstLetter(attributeWord)} `, 'green', line1)
		customizeEachWord(`by `, 'white', line1)
		customizeEachWord(`1`, 'light-blue', line1)
		customizeEachWord(`!`, 'white', line1)
		player.attributePoints = player.attributePoints - 1
		player.baseStats[stat]++
		updatePlayerStats()
	} else {
		quickMessage(`You do not have enough stat points.`)
	}
}

function learnSpell(secondCommand, thirdCommand) {
	if (isNaN(secondCommand)) {
		quickMessage(`You must specify the number of spell to learn before the teacher's name.`)
		return
	}
	const validSpellsNpc = currentArea.npc.filter(npc => npc.spellsOffered).length > 0 ? currentArea.npc.filter(npc => npc.spellsOffered) : currentArea.npc.find(npc => npc.spellsOffered)
	if (!validSpellsNpc) {
		quickMessage(`There is nobody here teaching spells`)
		return
	}
	if (!secondCommand) {
		quickMessage(`You must specify what spell you want to train`)
		return
	}
	if (validSpellsNpc.length > 1 && !thirdCommand) {
		quickMessage(`There are more than one teachers here. You must specify who you wish to learn spells from.`)
		return
	}
	let npc
	if (!thirdCommand) {
		npc = validSpellsNpc[0]
	} else {
		npc = npcByName(thirdCommand)
	}
	console.log(npc)
	npc.learn(secondCommand, npc)
}

function specialShop() {
	
}

function displayShopSkillsOrSpells(targetNpc, ssoi) {
	// const targetNpc = currentArea.npc ? currentArea.npc.find(x => x.name == headerName.toLowerCase()) : undefined
	let skillNumber = 1
	let spellNumber = 1
	let itemNumber = 1
	if (ssoi == 'skills') {
		if (targetNpc.skillsOffered[0]) {
			const mainWindowDiv = document.createElement('div')
			const headingContainer = document.createElement('div')
			const headingDiv = document.createElement('div')
			const headingNode = document.createElement('div')
			headingNode.classList.add('orange')
			headingNode.textContent = `Skills`
			const skillsContainerContainer = document.createElement('div')
			const skillsContainer = document.createElement(`div`)
			const priceContainer = document.createElement('div')
			const informationContainer = document.createElement('div')
			const informationSkillsContainer = document.createElement('div')
			const informationSpellsContainer = document.createElement('div')
			const informationAbilitiesContainer = document.createElement('div')
			const informationSkillsNode = document.createTextNode(`Train skill example: train 1 or train 1 ${targetNpc.name}`)
			// const informationAbilitiesNode = document.createTextNode(`Abilities: Train #`)
			const informationSpellsNode = document.createTextNode(`Learn spell example: learn 1 or learn 1 ${targetNpc.name}`)
			informationSkillsContainer.appendChild(informationSkillsNode)
			// informationAbilitiesContainer.appendChild(informationAbilitiesNode)
			informationSpellsContainer.appendChild(informationSpellsNode)
			informationContainer.appendChild(informationSkillsContainer)
			informationContainer.appendChild(informationAbilitiesContainer)
			informationContainer.appendChild(informationSpellsContainer)

			headingDiv.appendChild(headingNode)
			headingContainer.appendChild(headingDiv)
			mainWindowDiv.appendChild(headingContainer)
			skillsContainerContainer.appendChild(skillsContainer)
			skillsContainerContainer.appendChild(priceContainer)
			skillsContainerContainer.appendChild(informationContainer)
			mainWindowDiv.appendChild(skillsContainerContainer)
			skillsContainerContainer.classList.add('shop-skills-container-container')
			mainWindowDiv.classList.add(`shop-main`)
			headingDiv.classList.add(`shop-heading`)
			skillsContainer.classList.add(`shop-skills-container`)
			priceContainer.classList.add('shop-price-container')
			informationContainer.classList.add('shop-information-container') //change this
			headingContainer.classList.add(`shop-heading-container`)
			let skills = targetNpc.skillsOffered
			skills.forEach(skill => {
				if (player[skill.refName] != undefined) {
					skill = player[skill.refName]
				}
				const itemContainer = document.createElement(`div`)

				const priceAndBuildPointsContainer = document.createElement('div')
				priceAndBuildPointsContainer.classList.add('price-build-points-container')

				const itemNode = document.createElement('div')
				itemNode.textContent = skill.name
				const priceDiv = document.createElement('div')
				const priceNode = document.createElement('div')
				const g = document.createElement('div')

				const skillPointsDiv = document.createElement('div')
				const skillPointsNumber = document.createElement('div')
				const skillPointsString = document.createElement('div')



				skillPointsString.classList.add('build-points-string')
				skillPointsNumber.classList.add('light-blue')
				itemContainer.classList.add(`shop-skills-number-container`)
				skillPointsDiv.classList.add('price-g')
				skillPointsDiv.classList.add('shop-column-2')
				priceDiv.classList.add('price-g')
				priceDiv.classList.add('shop-column-1')
				itemNode.classList.add(skill.color)
				itemNode.classList.add('item-node')
				priceNode.classList.add('shop-price-amount')
				console.log(skill)
				skillPointsNumber.textContent = skill.pointsToUpgrade ? skill.pointsToUpgrade() : 'fix this skill'
				skillPointsString.textContent = 'skill point(s)'
				g.textContent = 'g'
				priceNode.textContent = `${skill.goldToUpgrade ? skill.goldToUpgrade() : 'fix this skill'}`
				let numberNode = document.createElement(`div`) //Ex. skill 1: skill 2: skill 3:
				numberNode.textContent = `${skillNumber}) `
				skillNumber++
				priceAndBuildPointsContainer.appendChild(priceDiv)
				priceAndBuildPointsContainer.appendChild(skillPointsDiv)
				itemContainer.appendChild(numberNode)
				itemContainer.appendChild(itemNode)
				priceDiv.appendChild(priceNode)
				priceDiv.appendChild(g)
				if (skill.level == targetNpc.skillsMaxLevel[skill.refName]) {
					const maxTrainedDiv = document.createElement('div')
					const maxTrainedString = document.createElement('div')
					maxTrainedString.textContent = 'You have learned all they can teach!'
					maxTrainedDiv.classList.add('price-g')
					maxTrainedString.classList.add('build-points-string')
					maxTrainedDiv.appendChild(maxTrainedString)
					priceAndBuildPointsContainer.appendChild(maxTrainedDiv)
				} else 	if (skill.requiredPlayerLevel) {
					const requiredLevelDiv = document.createElement('div')
					const requiredLevelString = document.createElement('div')
					const requiredLevelNumber = document.createElement('div')
					requiredLevelString.classList.add('build-points-string')
					requiredLevelNumber.classList.add('red')
					requiredLevelDiv.classList.add('price-g')
					// requiredLevelNumber.textContent = skill.requiredPlayerLevel()
					requiredLevelString.textContent = 'Required level'
					requiredLevelDiv.appendChild(requiredLevelString)
					requiredLevelDiv.appendChild(requiredLevelNumber)
					priceAndBuildPointsContainer.appendChild(requiredLevelDiv)
					}
				skillPointsDiv.appendChild(skillPointsNumber)
				skillPointsDiv.appendChild(skillPointsString)
				priceContainer.appendChild(priceAndBuildPointsContainer)
				skillsContainer.appendChild(itemContainer)

			})
			masterArea.appendChild(mainWindowDiv)
			updateScroll()
		}
	}
	if (ssoi == 'spells') {
		if (targetNpc.spellsOffered[0]) {
			const mainWindowDiv = document.createElement('div')
			const headingContainer = document.createElement('div')
			const headingDiv = document.createElement('div')
			const headingNode = document.createElement('div')
			headingNode.classList.add('purple')
			headingNode.textContent = `Spells`
			const spellsContainerContainer = document.createElement('div')
			
			const spellsContainer = document.createElement(`div`)
			const priceContainer = document.createElement('div')

			const informationContainer = document.createElement('div')
			const informationSkillsContainer = document.createElement('div')
			const informationSpellsContainer = document.createElement('div')
			const informationAbilitiesContainer = document.createElement('div')
			const informationSkillsNode = document.createTextNode(`Skills: Train #`)
			const informationAbilitiesNode = document.createTextNode(`Abilities: Train #`)
			const informationSpellsNode = document.createTextNode(`Spells: Learn #`)
			informationSkillsContainer.appendChild(informationSkillsNode)
			informationAbilitiesContainer.appendChild(informationAbilitiesNode)
			informationSpellsContainer.appendChild(informationSpellsNode)
			informationContainer.appendChild(informationSkillsContainer)
			informationContainer.appendChild(informationAbilitiesContainer)
			informationContainer.appendChild(informationSpellsContainer)


			headingDiv.appendChild(headingNode)
			headingContainer.appendChild(headingDiv)
			mainWindowDiv.appendChild(headingContainer)
			spellsContainerContainer.appendChild(spellsContainer)
			spellsContainerContainer.appendChild(priceContainer)
			mainWindowDiv.appendChild(spellsContainerContainer)
			spellsContainerContainer.classList.add('shop-skills-container-container')
			spellsContainerContainer.appendChild(informationContainer)
			informationContainer.classList.add('shop-information-container') //change this
			spellsContainerContainer.appendChild(spellsContainer)
			spellsContainerContainer.appendChild(priceContainer)
			spellsContainerContainer.appendChild(informationContainer)
			mainWindowDiv.appendChild(spellsContainerContainer)
			mainWindowDiv.classList.add(`shop-main`)
			headingDiv.classList.add(`shop-heading`)
			spellsContainer.classList.add(`shop-spells-container`)
			priceContainer.classList.add('shop-price-container')
			headingContainer.classList.add(`shop-heading-container`)
			let spells = targetNpc.spellsOffered
			spells.forEach(spell => {
				console.log(spell)
				if (player[spell.refName] != undefined) {
					spell = player[spell.refName]
				}
				const itemContainer = document.createElement(`div`)

				const priceAndBuildPointsContainer = document.createElement('div')
				priceAndBuildPointsContainer.classList.add('price-build-points-container')

				const itemNode = document.createElement('div')
				itemNode.textContent = spell.name
				const priceDiv = document.createElement('div')
				const priceNode = document.createElement('div')
				const g = document.createElement('div')

				const skillPointsDiv = document.createElement('div')
				const skillPointsNumber = document.createElement('div')
				const skillPointsString = document.createElement('div')

				skillPointsString.classList.add('build-points-string')
				skillPointsNumber.classList.add('light-blue')
				itemContainer.classList.add(`shop-skills-number-container`)
				skillPointsDiv.classList.add('price-g', 'shop-column-2')
				priceDiv.classList.add('price-g', 'shop-column-1')
				itemNode.classList.add(spell.color)
				itemNode.classList.add('item-node')
				priceNode.classList.add('shop-price-amount')

				skillPointsNumber.textContent = spell.pointsToUpgrade()
				skillPointsString.textContent = 'build points'
				g.textContent = 'g'
				priceNode.textContent = `${spell.goldToUpgrade()}`
				itemContainer.classList.add(`shop-skills-number-container`)
				let numberNode = document.createElement('div') //Ex. skill 1: skill 2: skill 3:
				numberNode.textContent = `${spellNumber}) `
				spellNumber++

				priceAndBuildPointsContainer.appendChild(priceDiv)
				priceAndBuildPointsContainer.appendChild(skillPointsDiv)
				itemContainer.appendChild(numberNode)
				itemContainer.appendChild(itemNode)
				priceDiv.appendChild(priceNode)
				priceDiv.appendChild(g)
				skillPointsDiv.appendChild(skillPointsNumber)
				skillPointsDiv.appendChild(skillPointsString)
				priceContainer.appendChild(priceAndBuildPointsContainer)
				spellsContainer.appendChild(itemContainer)
			})

			masterArea.appendChild(mainWindowDiv)
			updateScroll()
		}
	} else if (ssoi == 'items') {
		if (targetNpc.itemsOffered[0]) {
			const mainWindowDiv = document.createElement('div')
			const headingContainer = document.createElement('div')
			const headingDiv = document.createElement('div')
			const headingNode = document.createElement('div')
			headingNode.classList.add('green')
			headingNode.textContent = `Items`
			const itemsContainerContainer = document.createElement('div')
			const itemsContainer = document.createElement(`div`)
			const priceContainer = document.createElement('div')
			const miscContainer = document.createElement('div')
			headingDiv.appendChild(headingNode)
			headingContainer.appendChild(headingDiv)
			mainWindowDiv.appendChild(headingContainer)
			itemsContainerContainer.appendChild(itemsContainer)
			itemsContainerContainer.appendChild(priceContainer)
			itemsContainerContainer.appendChild(miscContainer)
			mainWindowDiv.appendChild(itemsContainerContainer)
			itemsContainerContainer.classList.add('shop-skills-container-container')
			mainWindowDiv.classList.add(`shop-main`)
			headingDiv.classList.add(`shop-heading`)
			itemsContainer.classList.add(`shop-spells-container`)
			priceContainer.classList.add('shop-price-container')
			miscContainer.classList.add('shop-price-container')
			headingContainer.classList.add(`shop-heading-container`)
			let items = targetNpc.itemsOffered
			items.forEach(item => {
				item = item()
				const itemContainer = document.createElement(`div`)
				const priceDiv = document.createElement('div')
				const miscDiv = document.createElement('div')
				priceDiv.classList.add('price-g')
				const itemNode = document.createElement('div')
				itemNode.classList.add(item.color)
				itemNode.classList.add('item-node')
				itemNode.textContent = item.name
				const priceNode = document.createElement('div')
				const g = document.createElement('div')
				g.textContent = item.name == '???' ? '\u00A0\u00A0' : 'g';
				priceNode.classList.add('shop-price-amount')
				priceNode.textContent = item.price
				itemContainer.classList.add(`shop-skills-number-container`)
				miscDiv.classList.add(`shop-skills-number-container`)
				let numberNode = document.createElement('div') //Ex. skill 1: skill 2: skill 3:
				numberNode.classList.add('number-node')
				numberNode.textContent = `${itemNumber}) `
				itemNumber++
				itemContainer.appendChild(numberNode)
				itemContainer.appendChild(itemNode)
				priceDiv.appendChild(priceNode)
				priceDiv.appendChild(g)
				priceContainer.appendChild(priceDiv)
				itemsContainer.appendChild(itemContainer)
				miscContainer.appendChild(miscDiv)
			})
			masterArea.appendChild(mainWindowDiv)
			updateScroll()
		}
	}
	blankSpace()
}

function trade(secondCommand) {
	if (currentArea.npc) {
		const allNpcs = currentArea.npc.map(allNpc => allNpc)
		const findNpc = allNpcs.find(x => x.name == secondCommand)
		if (findNpc && findNpc.trade != undefined) {
			findNpc.trade(secondCommand)
		} else if (findNpc == undefined && secondCommand != undefined) {
			quickMessage(`You do not see anyone named ${secondCommand} to trade with`, 'descriptions')
		} else if (findNpc.trade == undefined) {
			quickMessage(`this person does not have anything to trade`)
		} else {
			quickMessage(`You must specify who you wish to trade with`, 'descriptions')
		}
	}
}

function tradeDialog(headerName) {
	const targetNpc = currentArea.npc ? currentArea.npc.find(x => x.name == headerName.toLowerCase()) : undefined
	let itemNumber = 1
	if (targetNpc != undefined) {
		if (targetNpc.items[0]) {
			const targetNpcItems = targetNpc.items
			const topDiv = document.createElement('div')
			const topNode = document.createTextNode(`_____________________________________${targetNpc.displayName}________________________________________`)

			const itemsListDiv = document.createElement('div') //main div for items

			const itemName = targetNpcItems.map(item => npcItemsToNode(item)) //array of all the items the npc has
			itemName.forEach(itemsListNode => {
				const itemByNumberDiv = document.createTextNode(`item ${itemNumber}: `) //Ex. item 1: item 2: item 3:
				itemNumber = itemNumber + 1
				itemsListDiv.appendChild(itemByNumberDiv)
				itemsListDiv.appendChild(itemsListNode)
			})
			itemsListDiv.classList.add('descriptions')
			//itemsListDiv.appendChild(itemsListNode)
			topDiv.appendChild(topNode)

			masterArea.appendChild(topDiv)
			masterArea.appendChild(itemsListDiv)
			updateScroll()
		} // else {
		//	quickMessage(`${targetNpc.name} has nothing to trade`)
		//}
	} // else {
	//quickMessage(`You do not see ${headerName} to trade with`)
	//}
}



function playerGainKillExperience(gainedExperience) {
	player.experience += gainedExperience
	playerLevelFunc()
}
function playerGainQuestExperience(gainedExperience) {
	let line1 = lineFunc()
	player.experience += gainedExperience
	customizeEachWord(`You gain `, 'white', line1)
	customizeEachWord(`${gainedExperience} `, 'light-blue', line1)
	customizeEachWord(`experience points!`, 'white', line1)
	blankSpace()
	playerLevelFunc()
}


function questExperienceMultipleItems(questItems) {
	let count = 0
	questItems.forEach(item => {
		let questItemIndex = pushItem.indexOf(item)
		count += item.experience
		pushItem.splice(questItemIndex, 1)
		player.backpack.splice(questItemIndex, 1)
	})
	setTimeout(() => {
		playerGainQuestExperience(count)
	}, 200)
}

function questItemOffer() {
	if (player.backpack.map(x => x.toLowerCase()).find(y => y == this.questItem)) {
		let qItem = pushItem.find(x => x.name.toLowerCase() == this.questItem)
		let qItemIndex = pushItem.indexOf(qItem)
		quickMessage(`You hand a ${qItem.name} over to ${this.name}`, 'descriptions')
		pushItem.splice(qItemIndex, 1)
		player.backpack.splice(qItemIndex, 1)
	}
}

function questFindPlayerItem(npcQuestItem) {
	const playerQuestItem = pushItem.find(item => item.refName === npcQuestItem.refName)
	return playerQuestItem
}
//SKILLS++SKILLS++SKILLS++SKILLS++SKILLS++SKILLS++SKILLS++SKILLS
function oneHandedWeaponSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'one handed weapon skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function twoHandedWeaponSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'two handed weapon skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function unarmedCombatSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'unarmed combat skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel
	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function daggerSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'dagger skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	let weaponSkillModifier = 1.3 * skillLevel
	let weaponSkillCost = skillLevel * weaponSkillModifier
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
function chargeSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'charge skill'
	skillLevel = skillLevel == 0 ? 1 : skillLevel

	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}

function ripslashSkill(skillLevel, npcMaxTrainLevel) {
	trainedSkillName = 'ripslash'
	skillLevel = skillLevel == 0 ? 1 : skillLevel
	if (player.ripslash.level == 0) {
	}
	if (skillLevel == npcMaxTrainLevel) {
		return false
	} else {
		return weaponSkillCost
	}
}
//SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  SKILLS  //

//SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS SPELLS //
// function fire(spellLevel, npcMaxLearnLevel) {
// 	trainedSpellName = 'fire'
// 	spellLevel = spellLevel == 0 ? 1 : spellLevel

// 	let spellModifier = 1.3 * spellLevel
// 	let spellCost = spellLevel * spellModifier
// 	if (spellLevel == npcMaxLearnLevel) {
// 		return false
// 	} else {
// 		return spellCost
// 	}
// }
// function ice(spellLevel, npcMaxLearnLevel) {
// 	trainedSpellName = 'ice'
// 	spellLevel = spellLevel == 0 ? 1 : spellLevel

// 	let spellModifier = 1.3 * spellLevel
// 	let spellCost = spellLevel * spellModifier
// 	if (spellLevel == npcMaxLearnLevel) {
// 		return false
// 	} else {
// 		return spellCost
// 	}
// }

// function fireFist() {spellLevel}

//////////////////////// AREAS AREAS AREAS AREAS AREAS AREAS AREAS AREAS AREAS

let areaIdGenerator = function () {
	//Not using currently. This creates a unique ID based on coordinates. It's not very good for keeping IDs organized though
	allAreas[0] = allAreas[0] + 1
	return allAreas[0]
}

let allAreas = [0]
function directionRefresher() {
	let directionsArray = Object.values(currentArea.descriptions.zoneExitsBool)
	let compiledDirections = []
	for (let i = 0; i < Object.keys(currentArea.descriptions.zoneExitsBool).length; i++) {
		if (directionsArray[i] == true || directionsArray[i] == 'locked') {
			compiledDirections = `${compiledDirections} ${Object.keys(currentArea.descriptions.zoneExitsBool)[i]}`
		}
	}
	compiledDirections = compiledDirections.slice(1, compiledDirections.length)
	currentArea.descriptions.zoneExits = compiledDirections
}


function pull(secondCommand) {
	let objectBeingPulled = currentArea.interactables != undefined && currentArea.interactables[secondCommand] != undefined ? currentArea.interactables[secondCommand] : undefined
	if (objectBeingPulled != undefined && objectBeingPulled.activate != undefined) {
		objectBeingPulled.activate()
		return
	} else if (objectBeingPulled != undefined && objectBeingPulled.activate != undefined) {
		quickMessage(`You must specify what you want to pull`)
	} else if (objectBeingPulled != undefined) {
		quickMessage(`You cannot pull the ${objectBeingPulled.names[0]}`)
	} else if (!objectBeingPulled) {
		quickMessage(`You must specify what you want to pull.`)
	} else {
		quickMessage(`You do not see a ${secondCommand} to pull.`)
	}
}
function clear(secondCommand) {
	let objectBeingPulled = currentArea.interactables != undefined && currentArea.interactables[secondCommand] != undefined ? currentArea.interactables[secondCommand] : undefined
	if (objectBeingPulled != undefined && objectBeingPulled.activate != undefined) {
		objectBeingPulled.activate(secondCommand)
		return
	} else if (objectBeingPulled != undefined && objectBeingPulled.activate != undefined) {
		quickMessage(`You must specify what you want to clear`)
	} else if (objectBeingPulled != undefined) {
		quickMessage(`You cannot clear the ${objectBeingPulled.names[0]}`)
	} else if (!objectBeingPulled) {
		quickMessage(`You must specify what you want to clear.`)
	} else {
		quickMessage(`You do not see a ${secondCommand} to clear.`)
	}
}
function search(secondCommand) {
	let searchedObject = currentArea.interactables != undefined && currentArea.interactables[secondCommand] != undefined ? currentArea.interactables[secondCommand] : undefined
	if (searchedObject != undefined && searchedObject.activate != undefined) {
		searchedObject.activate(secondCommand)
		return
	} else if (searchedObject != undefined && searchedObject.activate != undefined) {
		quickMessage(`You must specify what you want to search`)
	} else if (searchedObject != undefined) {
		quickMessage(`You cannot earch the ${searchedObject.names[0]}`)
	} else if (!searchedObject) {
		quickMessage(`You must specify what you want to search.`)
	} else {
		quickMessage(`You do not see a ${secondCommand} to search.`)
	}
}


function actionWordFunction(secondCommand) {
	let action = secondCommand
	let interactable = currentArea.interactables[action]
	if (interactable.requirement) {
		for (let requirement in interactable.requirement) {
			if (player[requirement] < interactable.requirement[requirement]) {
				quickMessage(`requirement not met`)
			}
		}
	}
}

let currentRoom
let futureRoom

let olivandra = {
	name: 'Olivandra',
	refName: 'olivandra',
	nameColor: 'purple',
	color: 'mage-color',
	prefix: 'Grand Warlock, ',
	prefixColor: 'mage-color',
	keywords: ['olivandra'],
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	train: function (secondCommand, npc) {
			trainInteraction(secondCommand, npc)
		},
	learn: function (secondCommand) {
		if (player.guild != 'Mage') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Mage `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	questStage: 1,
	questSequence: {
	},
	questItem: [cultTexts],
	itemsOffered: [],
	isQuestAvailable: false,
	quest: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line1)
		customizeEachWord(`"We've received information that there have been Cultists gathering in the Graveyard. What they might be doing, we don't know, but we want to find out any details."`, 'white', line1)
		blankSpace()
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"There was a group many years ago that studied the least understood aspects of magic. Their knowledge was kept secret in the libraries of the cathedral. Some people wanted this knowledge out in the open, but the Monks and Priests wanted to completely understand the magic before allowing the public to study it. (continue)"`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"The Graveyard is on the otherside of the wall behind the Guild Plaza to the south, so you'll have to take the road east of the Galvadian Plaza. If you get lost, just read any signs you come across, and they'll point you in the right direction."`, 'white', line3)
		blankSpace()
		await dialogueWait(200)
		customizeEachWord(`${this.name}: `, this.nameColor, line4)
		customizeEachWord(`"Come back when you think you've found something."`, 'white', line4)
		blankSpace()
		return
	},
	offer: async function() {
		let line1 = lineFunc()
		let line2 = lineFunc()
		let line3 = lineFunc()
		let line4 = lineFunc()
		let qItem = getAllItemsOnPerson().find(item => item.refName == this.questItem[0]().refName)
		let qItemIndex = pushItem.indexOf(qItem)
		await dialogueWait(200)
		if (!qItem) {
			quickMessage(`You have not offered the proper item for this quest`)
			return
		}
		playerGainQuestExperience(100)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name} takes a close look at the book.`, 'white', line1)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line2)
		customizeEachWord(`"This is a good find, ${player.name}. Even better than I was hoping for. This will certainly provide us some insight into what's going on. I'm going to meet with the other Guild Leaders right away. This could take some time. Go ahead and familiarize yourself with the Guild Halls. The class trainers here have more skills to offer you. As for training, the Graveyard should suffice for a while. Once you've outgrown it, you should explore east and west of the Castle Crossroads. To the east is the Glade -- a very peaceful and relaxing place, typically teeming with townspeople. A little farther in and to the northeast, you'll find the entrance to The Shallows. To the west of the Castle Crossroads is the Kobold Caves. It's a little more dangerous than The Shallows, so make sure you're well equipped."`, 'white', line2)
		await dialogueWait(200)
		blankSpace()
		customizeEachWord(`${this.name}: `, this.nameColor, line3)
		customizeEachWord(`"I'll be in my office inside the guild once I'm finished meeting with the guild leaders. Check in after you've reached level 10. That should give me enough time. I might have a new task for you after we discuss our next move."`, 'white', line3)
		blankSpace()
		customizeEachWord(`${this.name} `, this.color, line4)
		customizeEachWord(`swiftly rushes off`, 'white', line4)
		blankSpace()
		currentArea.npc.pop()
		pushItem.splice(qItemIndex, 1)
		this.questSequence.seventh = true
		this.isQuestAvailable = false
	},
	speak: async function() {
	},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
	skillsOffered: [devotion, firePenetration, icePenetration, lightningPenetration, arcaneKnowledge, mysticismMastery, sorceryMastery, spellWeapons, magicDexterity, clearMind],
	skillsMaxLevel: {
		devotion: 10,
		firePenetration: 10,
		icePenetration: 10,
		lightningPenetration: 10,
		arcaneKnowledge: 10,
		mysticismMastery: 10,
		sorceryMastery: 10,
		spellWeapons: 10,
		magicDexterity: 10,
		clearMind: 10,
	},
	spellsOffered: [fireflames, inferno, meteor, frostfreeze, blizzard, cryoclast, flashbolt, chainLightning, gigavolt],
	spellsMaxLevel: {
		fireflames: 2,
		inferno: 2,
		meteor: 2,
		frostfreeze: 2,
		blizzard: 2,
		cryoclast: 2,
		flashbolt: 2,
		chainLightning: 2,
		gigavolt: 2,
	},
	learn: (secondCommand, npc) => {
		learnInteraction(secondCommand, npc)
	},
}
allNpcsArray.push(olivandra)

let scylla = {
	name: 'Scylla',
	prefix: 'Archmage of Ice, ',
	refName: 'scylla',
	nameColor: 'dark-blue',
	prefixColor: 'light-blue',
	keywords: ['scylla'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, spellWeapons, magicDexterity, clearMind]
		} else if (player.level < 20) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, icePenetration]

		} else if (player.level < 30) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, icePenetration, mindsEye]

		} else {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, icePenetration, mindsEye]
		}
	},	
	skillsMaxLevel: {
		get mindsEye() {return skillMaxLevel1(player.mindsEye)},
		get devotion() {return skillMaxLevel5(player.devotion)},
		get arcaneKnowledge() {return skillMaxLevel5(player.arcaneKnowledge)},
		get mysticismMastery() {return skillMaxLevel5(player.mysticismMastery)},
		get sorceryMastery() {return skillMaxLevel5(player.sorceryMastery)},
		get icePenetration() {return skillMaxLevel5(player.icePenetration)},
		get magicDexterity() {return skillMaxLevel5(player.magicDexterity)},
		get clearMind() {return skillMaxLevel5(player.clearMind)},
		get spellWeapons() {return skillMaxLevel5(player.spellWeapons)},
	},
	spellsOffered: [frostfreeze, blizzard, cryoclast, barrier, heal],
	spellsMaxLevel: {
		get frostfreeze() {return skillMaxLevel3(player.frostfreeze)},
		get blizzard() {return skillMaxLevel3(player.blizzard)},
		get cryoclast() {return skillMaxLevel3(player.cryoclast)},
		get barrier() {return skillMaxLevel3(player.barrier)},
		get heal() {return skillMaxLevel3(player.heal)},
	},
	itemsOffered: [trainingStaff, apprenticeRobes],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Cryo Mage') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Cryo Mage `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	learn: function (secondCommand) {
		if (player.playerClass.name != 'Cryo Mage') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Cryo Mage `, 'warrior-color', line1)
			customizeEachWord(`in order to study with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	desc: () => quickMessage(`A Warlock with chin length black hair`),
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
allNpcsArray.push(scylla)

let gelvander = {
	name: 'Gelvander',
	prefix: 'Archmage of Fire, ',
	refName: 'gelvander',
	nameColor: 'red',
	prefixColor: 'red-orange',
	keywords: ['gelvander'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, spellWeapons, magicDexterity, clearMind]
		} else if (player.level < 20) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, firePenetration]

		} else if (player.level < 30) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, firePenetration, mindsEye]

		} else {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, firePenetration, mindsEye]
		}
	},	
	skillsMaxLevel: {
		get mindsEye() {return skillMaxLevel1(player.mindsEye)},
		get devotion() {return skillMaxLevel5(player.devotion)},
		get arcaneKnowledge() {return skillMaxLevel5(player.arcaneKnowledge)},
		get mysticismMastery() {return skillMaxLevel5(player.mysticismMastery)},
		get sorceryMastery() {return skillMaxLevel5(player.sorceryMastery)},
		get firePenetration() {return skillMaxLevel5(player.firePenetration)},
		get magicDexterity() {return skillMaxLevel5(player.magicDexterity)},
		get clearMind() {return skillMaxLevel5(player.clearMind)},
		get spellWeapons() {return skillMaxLevel5(player.spellWeapons)},
	},
	spellsOffered: [fireflames, inferno, meteor, barrier, heal],
	spellsMaxLevel: {
		get fireflames() {return skillMaxLevel3(player.fireflames)},
		get inferno() {return skillMaxLevel3(player.inferno)},
		get meteor() {return skillMaxLevel3(player.meteor)},
		get barrier() {return skillMaxLevel3(player.barrier)},
		get heal() {return skillMaxLevel3(player.heal)},
	},
	itemsOffered: [trainingStaff, apprenticeRobes],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Pyromancer') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Pyromancer `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	learn: function (secondCommand) {
		if (player.playerClass.name != 'Pyromancer') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Pyromancer `, 'warrior-color', line1)
			customizeEachWord(`in order to study with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	desc: () => quickMessage(`A Warlock with chin length black hair`),
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
allNpcsArray.push(gelvander)

let blasphemy = {
	name: 'Blasphemy',
	prefix: 'Archmage of Lightning, ',
	refName: 'blasphemy',
	nameColor: 'light-yellow',
	prefixColor: 'yellow',
	keywords: ['blasphemy'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	get skillsOffered() {
		if (player.level < 10) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, spellWeapons, magicDexterity, clearMind]
		} else if (player.level < 20) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, lightningPenetration]

		} else if (player.level < 30) {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, lightningPenetration, mindsEye]

		} else {
			return 	[devotion, arcaneKnowledge, sorceryMastery, mysticismMastery, spellWeapons, magicDexterity, clearMind, lightningPenetration, mindsEye]
		}
	},	
	skillsMaxLevel: {
		get mindsEye() {return skillMaxLevel1(player.mindsEye)},
		get devotion() {return skillMaxLevel5(player.devotion)},
		get arcaneKnowledge() {return skillMaxLevel5(player.arcaneKnowledge)},
		get mysticismMastery() {return skillMaxLevel5(player.mysticismMastery)},
		get sorceryMastery() {return skillMaxLevel5(player.sorceryMastery)},
		get lightningPenetration() {return skillMaxLevel5(player.lightningPenetration)},
		get magicDexterity() {return skillMaxLevel5(player.magicDexterity)},
		get clearMind() {return skillMaxLevel5(player.clearMind)},
		get spellWeapons() {return skillMaxLevel5(player.spellWeapons)},
	},
	spellsOffered: [flashbolt, chainLightning, gigavolt, barrier, heal],
	spellsMaxLevel: {
		get flashbolt() {return skillMaxLevel3(player.flashbolt)},
		get chainLightning() {return skillMaxLevel3(player.chainLightning)},
		get gigavolt() {return skillMaxLevel3(player.gigavolt)},
		get barrier() {return skillMaxLevel3(player.barrier)},
		get heal() {return skillMaxLevel3(player.heal)},
	},
	itemsOffered: [trainingStaff, apprenticeRobes],
	buy: function (secondCommand) {
		buyInteraction(secondCommand, this)
	},
	learn: function (secondCommand) {
		if (player.playerClass.name != 'Lightning Magus') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Lightning Magus `, 'warrior-color', line1)
			customizeEachWord(`in order to study with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		learnInteraction(secondCommand, this)
	},
	train: function (secondCommand) {
		if (player.playerClass.name != 'Lightning Magus') {
			let line1 = lineFunc()
			customizeEachWord(`You must be a `, 'white', line1)
			customizeEachWord(`Lightning Magus `, 'warrior-color', line1)
			customizeEachWord(`in order to train with `, 'white', line1)
			customizeEachWord(`${this.name}`, this.nameColor, line1)
			return
		}
		trainInteraction(secondCommand, this)
	},
	desc: () => quickMessage(`A Warlock with chin length black hair`),
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
}
allNpcsArray.push(blasphemy)



class AreaMaker {
	constructor(enemySpawnChance, isPlayerHere, npc, hostile, id, x, y, z, gold, descriptions, interactables) {
		this.enemySpawnChance = enemySpawnChance
		this.isPlayerHere = isPlayerHere
		this.npc = npc
		this.hostile = hostile
		this.id = id
		this.x = x
		this.y = y
		this.z = z // z being 0 is normal elevation. -1 would be going down and 1 would be going up
		this.gold = gold
		this.descriptions = descriptions
		this.interactables = interactables
		this.descriptions.zoneExitsFunc()
		allAreas.push(this)
	}
}
// AreaMaker.prototype.onEntry = function() {
// 	quickMessage('enter')
// if (currentArea.enemySpawnChance == 0) {return}
// let spawnChance = currentArea.enemySpawnChance
// let spawnRoll = randomNumberRange(1, 100)
// if (spawnRoll <= spawnChance) {
// 	let monster = currentArea.enemies
// 	if (monster == undefined) {return}
// 	let index = randomNumberRange(0, monster.length - 1)
// 	monsterGen(monster[index])
// }
// }

let galvadiaWelcomeArea = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[egbert], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	0, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area`,
		zoneType: 'galvadia_basement',
		desc: `You find yourself at the end of a long hallway in the castle Training Halls basement. There are several lit sconces that line the walls. Their oscillating glow is quite comforting.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaWelcomeArea2 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	1, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Training Area 2`,
		zoneType: 'galvadia_basement',
		desc: `You see something written on the wall here.`,
		zoneExitsBool: {
			north: 'locked',
			south: true,
		},
		zoneExitsLocked: {
			north: () => {
				let line1 = lineFunc()
				customizeEachWord(`The way is actually open, but something is holding you back! Something written on the other wall might help you out.`, 'white', line1)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['wall'],
	}),
	{
		wall: {
			names: ['wall'],
			color: function () {
				return 'blue'
			},
			desc: async function () {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
				if (egbert.questStage < 3) {
					galvadiaWelcomeArea2.descriptions.zoneExitsBool.north = true
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You take a closer look at the wall and see that there is something written on it.`, 'white', line1)
					blankSpace()
					await dialogueWait(200)
					customizeEachWord(`The wall reads: `, 'blue', line2)
					customizeEachWord(`"Refresh your view of the room with the LOOK or L command to see if anything changed."`, 'white', line2)
					blankSpace()
					dialogueChangeStage(egbert, 2)
					if (!currentArea.npc[0]) {
						await dialogueWait(200)
						npcEntersFromADirection('south', egbert)
					}
					egbert.speak()
					} else {
						await dialogueWait(200)
						blankSpace()
						customizeEachWord(`You take a closer look at the wall and see that there is something written on it.`, 'white', line1)
						await dialogueWait(200)
						blankSpace()
						customizeEachWord(`The wall reads: `, 'blue', line2)
						customizeEachWord(`"Refresh your view of the room with the LOOK or L command to see if anything changed."`, 'white', line2)
						blankSpace()
					}
			},
		},
	}
)
function calculateSupremeDodging() {
	applyBuff(player.supremeDodging.buff)
}
function calculateResilience() {
	applyBuff(player.resilience.buff)
}
function applyOnHitSkillBuffs(weaponObject) {
	if (weaponObject.doesSwingHit) {
		if (player.supremeDodging.level > 0) {calculateSupremeDodging()}
		if (player.resilience.level > 0) {calculateResilience()}
	}
}

function inspectHTML(message, classChange, div, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(classChange)
	line.appendChild(span)
	div.appendChild(line)
	masterArea.appendChild(div)
	updateScroll()
}

function inspectBlip(message, classChange, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(classChange, 'inspect-blip')
	line.appendChild(span)
	masterArea.appendChild(line)
	blankSpace()
	updateScroll()
}


function capitalizeFirstLetter(string) {
	return string.charAt(0).toUpperCase() + string.slice(1)
}
let galvadiaWelcomeArea3 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	2, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 4`,
		zoneType: 'galvadia_basement',
		desc: `There is a very conspicuous lever sticking out of the wall.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['lever'],
	}),
	{
		lever: {
			names: ['lever'],
			color: function () {
				return 'red'
			},
			desc: async function () {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You see a conspicuous lever on the wall. Try pulling it with the PULL command by typing "pull lever".`, 'white', line1)
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`NOTE: You will always use two word commands to interact with a room's keyword. You will never have to use commands like "move the branches", "clear all the grass", "dig a hole", or "pull the lever". If the action (first word) was valid to interact with a keyword, those commands would instead be "move branches", "clear grass", "dig hole", or "pull lever". There will usually be context clues to hint at what action should be taken.`, 'white', line2)
				blankSpace()
			},
			activate: async function () {
				if (!currentArea.descriptions.zoneExitsBool.north) {
					let line1 = document.createElement('div')
					let line2 = document.createElement('div')
					let line3 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You hear a deep rumbling sound as the wall in front of you begins to move.`, 'gray', line1)
					blankSpace()
					await dialogueWait(200)
					customizeEachWord('A way has opened to the north!', 'white', line2)
					blankSpace()
					currentArea.descriptions.zoneExitsBool.north = true
					currentArea.descriptions.zoneExitsFunc()
					if (!currentArea.npc[0]) {
						await dialogueWait(200)
						npcEntersFromADirection('south', egbert)
						dialogueChangeStage(egbert, 4)
						egbert.speak()
					} else {
						dialogueChangeStage(egbert, 5)
						egbert.speak()
					}

				} else if (currentArea.descriptions.zoneExitsBool.north == true) {
					let line1 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You pull the lever again. Nothing happens.`, 'white', line1)
				}
			},
		},

	}
)

let galvadiaWelcomeArea4 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	4, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 5`,
		zoneType: 'galvadia_basement',
		desc: `Locked doors are indicated by yellow text which can be unlocked by using the right key. You can use the key you found in the previous room to unlock this door by using the UNLOCK command follwed by the direction you want to unlock. When you have done this, you can move on to the next room.`,
		zoneExitsBool: {
			north: 'locked',
			south: true,
		},
		zoneExitsLocked: {
			north: function () {
				if (galvadiaWelcomeArea4.descriptions.zoneExitsBool.north == 'locked') {
					let line1 = document.createElement('div')
					customizeEachWord(`The door has a simple lock attached to it.`, 'white', line1)
				}
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaWelcomeArea5 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	3, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Training Area 3`,
		zoneType: 'galvadia_basement',
		desc: `Heading down a corridor.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let galvadiaWelcomeArea6 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 6`,
		zoneType: 'galvadia_basement',
		desc: `Direction that are red cannot be opened with a key, and must instead be opened by completing quests or being a certain level. Sometimes attempting to move in that direction will tell you what you need to do to open the way forward.
		
		You will come across a lot of people in your travels. You can interact with them by using the TALK or SPEAK command followed by their name. Talk to Egbert to see what he has to say. Use the OFFER command to complete the quest once you've finished the objective.
		`,
		didEventRun: false,
		onEntry: async function() {
			if (this.didEventRun == false) {
				this.didEventRun = true
				dialogueChangeStage(egbert, 8)
				if (!currentArea.npc[0]) {
					await dialogueWait(200)
					blankSpace()
					npcEntersFromADirection('north', egbert)
				}
				npcRemoveFromTheirCurrentRoom(egbert)
				npcAddToRoom(galvadiaWelcomeArea6, egbert)
			}
		},
		zoneExitsBool: {
			east: 'blocked',
			south: true,
			west: true,
		},
		east: async function () {
			let line1 = lineFunc()
			customizeEachWord(`You need to complete Egbert's quest before you can go here.`, 'white', line1)
		},
		zoneExitsLocked: {
			east: () => {
				let line1 = lineFunc()
				customizeEachWord(`You need to complete Egbert's quest before you can go here.`, 'white', line1)			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

galvadiaWelcomeArea6.quests = {
	quests: {
		complete: false,
	},
}

let galvadiaWelcomeArea7 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Welcome Area 7`,
		zoneType: 'galvadia_basement',
		desc: `You enter into Egbert's office. There are scrolls and papers littered about the room. On the far wall is a desk illuminated by candle light. You see something sticking out from underneath the stacks of parchment on the desk.
		
		Tip: (Use the EXAMINE or EX command you learned about earlier!)`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['parchment'],
	}),
	{
		parchment: {
			names: ['parchment'],
			color: function () {
				return 'light-orange'
			},
			desc: async function () {
				let line1 = lineFunc()
				let line2 = lineFunc()
				if (galvadiaWelcomeArea7.quests.glassesComplete == false) {
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`Lifting up the parchment, you accidentally knock to the ground what was lying underneath. You look down to see a pair of glasses on the floor.`, 'grey', line1)
					blankSpace()
					await dialogueWait(200)
					customizeEachWord(`Tip: Use the LOOK command to refresh your view of the room.`, 'white', line2)
					blankSpace()
					questItemGen(pairOfGlasses())
					galvadiaWelcomeArea7.quests.glassesComplete = true
				} else {
					customizeEachWord(`You look at the scattered parchment and wonder how anyone could function with such a mess.`, 'grey', line1)
				}
				blankSpace()
			},
		},
	}
)

galvadiaWelcomeArea7.quests = {
	glassesComplete: false,
}

let galvadiaWelcomeArea8 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Galvadia Training Area 8`,
		zoneType: 'galvadia_basement',
		desc: `You stand in a large, circular room.
		There is a sign here.`,
		// onEntry: async function() {
		// 	if (egbert.questSequence.second == false) {
		// 		egbert.speak()
		// 	}
		// },
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'brown', line1)
			customizeEachWord(`North: Next Lesson`, 'white', line2)
			customizeEachWord(`East: Armor Room`, 'white', line3)
			customizeEachWord(`South: Weapon Room`, 'white', line4)
			customizeEachWord(`West: Egbert's Office`, 'white', line5)
			blankSpace()
		},
		zoneExitsBool: {
			north: 'blocked',
			east: true,
			south: true,
			west: true,
		},
		north: function() {
			quickMessage(`Speak to Egbert first.`)
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign']
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let galvadiaWelcomeArea9 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	4, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Beginner's Weapon Room`,
		zoneType: 'galvadia_basement',
		get desc() {
			let warriorDescription = `To equip a weapon, you must wield it by holding it in your hand. To do this, use the UNPACK command followed by the item's name. You can also unpack anything by specifying the item slot number that you see in your backpack. You will notice your stats in the offense panel change when you wield or unwield a weapon. This is because only your current weapon skill stats are reflected in the offense panel. 
			\nTo unwield your weapon or to put away any item in your hand, use the PACK command followed by either RIGHT, LEFT, or ALL. Note that two-handed weapons require both hands to wield, so unpacking one requires that both hands be empty before using the UNPACK command.`
			let rogueDescription = `To equip a weapon, you must wield it by holding it in your hand. To do this, use the UNPACK command followed by the item's name. You can also unpack anything by specifying the item slot number that you see in your backpack. You will notice your stats in the offense panel change when you wield or unwield a weapon. This is because only your current weapon skill stats are reflected in the offense panel. 
			\nTo unwield your weapon or to put away any item in your hand, use the PACK command followed by either RIGHT, LEFT, or ALL. Note that Rogue classes can dual wield. Having a weapon in each hand will allow you to attack twice when you swing.`
			let monkDescription = `To equip a weapon, you must wield it by holding it in your hand. To do this, use the UNPACK command followed by the item's name. You can also unpack anything by specifying the item slot number that you see in your backpack. You will notice your stats in the offense panel change when you wield or unwield a weapon. This is because only your current weapon skill stats are reflected in the offense panel. 
			\nTo unwield your weapon or to put away any item in your hand, use the PACK command followed by either RIGHT, LEFT, or ALL. Note that two-handed weapons require both hands to wield, so unpacking one requires that both hands be empty before using the UNPACK command.`
			let rangerDescription = `To equip a weapon, must to wield it by holding it in your hand. To do this, use the UNPACK command followed by the item's name. You can also unpack anything by specifying the item slot number that you see in your backpack. You will notice your stats in the offense panel change when you wield or unwield a weapon. This is because only your current weapon skill stats are reflected in the offense panel. 
			\nTo unwield your weapon or to put away any item in your hand, use the PACK command followed by either RIGHT, LEFT, or ALL. Note that two-handed weapons require both hands to wield, so unpacking one requires that both hands be empty before using the UNPACK command.`
			let mageDescription = `To equip a weapon, must to wield it by holding it in your hand. To do this, use the UNPACK command followed by the item's name. You can also unpack anything by specifying the item slot number that you see in your backpack. You will notice your stats in the offense panel change when you wield or unwield a weapon. This is because only your current weapon skill stats are reflected in the offense panel. 
			\nTo unwield your weapon or to put away any item in your hand, use the PACK command followed by either RIGHT, LEFT, or ALL. Note that two-handed weapons require both hands to wield, so unpacking one requires that both hands be empty before using the UNPACK command.`
			let tip = `\n\nTIP: Remember you can see an item's information that's on the ground by using the EXAMINE command, and you can see an item's information in your backback by using the INSPECT command.`
			if (player.guild == 'Warrior') {return warriorDescription + tip}
			if (player.guild == 'Sinistral') {return rogueDescription + tip}
			if (player.guild == 'Monk') {return monkDescription + tip}
			if (player.guild == 'Ranger') {return rangerDescription + tip}
			if (player.guild == 'Mage') {return mageDescription + tip}
		},
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
// let galvadiaWelcomeArea10 = new AreaMaker(
// 	0, //SPAWN RATE
// 	true, //IS PLAYER HERE
// 	[], // NPC
// 	false, // IS HOSTILE
// 	areaIdGenerator(), //ROOM ID
// 	2, // X
// 	4, // Y
// 	-2, // Z
// 	0, //GOLD
// 	(descriptions = {
// 		areaNameClass: yellow,
// 		areaName: `Equipping Armor`,
// 		zoneType: 'galvadia_basement',
// 		desc: `When you pick up a piece of armor that you want to use, you must "equip" it. To do this, you must wield it in either hand by first "unpacking" it, then equip it by typing "equip" followed by the name of the item. Try "unpack jerkin" followed by "equip jerkin". To remove a piece of armor, use the "remove" command followed by the name of the armor you wish to remove. You will need to remove a piece of armor before equipping another piece of armor of the same type.`,
// 		zoneExitsBool: {
// 			northwest: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let galvadiaWelcomeArea11 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	2, // X
	5, // Y
	-2, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: yellow,
		areaName: `Beginner's Armor Room`,
		desc: `To equip a piece of armor, first hold it in either hand using the UNPACK command followed by the item's name (or any word in the name) or the inventory slot number. Once you're holding the armor, use DON, WEAR, or EQUIP followed by the item's name or slot number. To unequip a piece of armor, use the REMOVE command followed by the name of the armor. This will remove the armor and place it into one of your free hands.
		
		TIP: Remember you can see an item's information that's on the ground by using the EXAMINE command, and you can see an item's information in your backback by using the INSPECT command.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

// let galvadiaWelcomeArea13 = new AreaMaker(
// 	0, //SPAWN RATE
// 	true, //IS PLAYER HERE
// 	[crutches], // NPC
// 	false, // IS HOSTILE
// 	areaIdGenerator(), //ROOM ID
// 	1, // X
// 	6, // Y
// 	-2, // Z
// 	0, //GOLD
// 	(descriptions = {
// 		areaNameClass: yellow,
// 		areaName: `Training Halls Basement Entrance`,
// 		desc: `Above are the combat training rooms. Once you are ready, proceed above. You can come back to these rooms any time.`,
// 		zoneExitsBool: {
// 			north: true,
// 			south: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let galvadiaWelcomeArea14 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	6, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Combat Training Halls: Physical Fighting and Magic Fighting`, //change area name
		zoneType: 'galvadia_basement',
		desc: `You find yourself in the well worn halls of the Combat Training Halls. Countless adventurer's have made their way through these halls. The stone floors are worn smooth from use. The walls are decorated with knicks and scratches. 
		There is a sign here.`,
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'brown', line1)
			customizeEachWord(`East: Magic combat room`, 'white', line2)
			customizeEachWord(`West: Physical combat room`, 'white', line3)
			blankSpace()
			egbert.questSequence.second = true
		},
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneChange: {
			north: function () {
				player.x = 1
				player.y = 8
				player.z = -2
			},
		},
		// onEntry: function() {
		// 	if (egbert.questSequence.fourth == false) {
		// 		egbert.speak()
		// 	}
		// },
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign']
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
// let galvadiaWelcomeArea15 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	1, //change x coord
// 	8, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Training Dummy Training Halls`, //change area name
// 		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
// 		zoneExitsBool: {
// 			north: true,
// 			east: true,
// 			south: true,
// 			west: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
// let galvadiaWelcomeArea16 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	1, //change x coord
// 	7, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		questSequence: {
// 			first: false
// 		},
// 		// onEntry: function() {
// 		// 	if (this.questSequence.first == false) {
// 		// 		this.questSequence.first = true
// 		// 		monsterGen(woundedGoblinScout(currentArea))
// 		// 	}
// 		// },
// 		areaNameClass: castleGrey,
// 		areaName: `Training Dummy Training Halls`, //change area name
// 		zoneType: 'galvadia_basement',
// 		desc: `Welcome to combat training! There is a lot to learn when it comes to combat, so we will start with the basics here. You will learn more advanced combat techniques as you progress and join a guild. To the west, you can learn how attacking with weapons work. To the east, you can learn how to fight using magic if you are a magic user. `,
// 		zoneExitsBool: {
// 			north: true,
// 			south: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let th_b_center_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	8, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `In Front Of A Large Door`, //change area name
		zoneType: 'galvadia_basement',
		desc: `A large door dominates the room. The room itself is small, making the door appear even larger.`,
		zoneExitsBool: {
			north: 'blocked',
			east: true,
			south: true,
			west: true,
		},
		zoneChange: {
			south: function () {
				player.x = 1
				player.y = 6
				player.z = -2
			},
		},
		zoneExitsLocked: {
			north: () => {
				quickMessage(`The door won't budge.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let th_b_center_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	1, //change x coord
	9, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `At The Bottom Of A Staircase`, //change area name
		zoneType: 'galvadia_basement',
		desc: `The light from the south illuminates the bottom of the staircase. At the top is a door that you can only make out by the light that seeps through its borders.`,
		zoneExitsBool: {
			south: true,
			up: true,
		},
		zoneChange: {
			up: function () {
				player.x = -7
				player.y = 3
				player.z = 0
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let th_b_w_wing_2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	0, //change x coord
	8, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `A Darkened Room`, //change area name
		zoneType: 'galvadia_basement',
		desc: `The room is dark, and no bigger than a closet. There's just enough light from the other room to see something that looks like a lever sticking out of the wall.`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
			actionWord: ['lever'],
	}),
	{
	lever: {
		names: ['lever'],
		pulled: false,
		color: function () {
			return 'brown'
		},
		desc: function () {
			let line1 = document.createElement('div')
			customizeEachWord(`You see a large lever sticking out of the wall.`, 'white', line1)
		},
		activate: async function () {
			if (th_b_w_wing_2.interactables.lever.pulled == false) {
				th_b_w_wing_2.interactables.lever.pulled = true
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You hear the distant sound of a latch flipping open.`, ['white', 'italic'], line1)
				blankSpace()
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You hear the light clinking of gold coins bouncing to the ground.`, ['white', 'italic'], line2)
				currentArea.gold = randomNumberRange(5, 8)
				blankSpace()
				if (th_b_w_wing_2.interactables.lever.pulled == true && th_b_e_wing_2.interactables.lever.pulled == true) {
					th_b_center_1.descriptions.zoneExitsBool.north = true
					dialogueChangeStage(egbert, 12)
				}
			} else if (th_b_w_wing_2.interactables.lever.pulled == true) {
				let line1 = document.createElement('div')
				await dialogueWait(200)
				customizeEachWord(`You pull the lever again. Nothing happens.`, 'white', line1)
			}
		},
	},
}
)

let th_b_e_wing_2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	2, //change x coord
	8, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `A Darkened Room`, //change area name
		zoneType: 'galvadia_basement',
		desc: `The room is dark, and no bigger than a closet. There's just enough light from the other room to see something that looks like a lever sticking out of the wall.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
			actionWord: ['lever'],
	}),
	{
		lever: {
			names: ['lever'],
			pulled: false,
			color: function () {
				return 'brown'
			},
			desc: function () {
				let line1 = document.createElement('div')
				customizeEachWord(`You see a large lever sticking out of the wall.`, 'white', line1)
			},
			activate: async function () {
				if (th_b_e_wing_2.interactables.lever.pulled == false) {
					th_b_e_wing_2.interactables.lever.pulled = true
					let line1 = document.createElement('div')
					let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You hear the distant sound of a latch flipping open`, ['italic', 'white'], line1)
					blankSpace()
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You hear the light clinking of gold coins bouncing to the ground.`, ['white', 'italic'], line2)
					currentArea.gold = randomNumberRange(5, 8)
					blankSpace()
					if (th_b_e_wing_2.interactables.lever.pulled == true && th_b_w_wing_2.interactables.lever.pulled == true) {
						th_b_center_1.descriptions.zoneExitsBool.north = true
						dialogueChangeStage(egbert, 12)
					}
				} else if (th_b_e_wing_2.interactables.lever.pulled == true) {
					let line1 = document.createElement('div')
					await dialogueWait(200)
					customizeEachWord(`You pull the lever again. Nothing happens.`, 'white', line1)
				}
			},
		},
	}
)

let galvadiaWelcomeArea17_combatRoom1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	0, //change x coord
	6, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Combat Training Room`, //change area name
		zoneType: 'galvadia_basement',
		get desc() {
			let preInfo = `The training dummies here are harmless and will not attack you. Enemy colors indicate their level relative to yours. Red indicates the enemy is 5 levels above or below you. Light-red means the enemy is more than 5 levels below you, and dark-red means the enemy is more than 5 levels higher than you.\n\n`
			let meleeAdvancingText = `[ ENGAGING COMBAT ] In order for you or an enemy to deal melee damage, you must be engaged in combat. You can engage combat with an enemy by using the ADVANCE or AD command, or you can wait for an enemy to advance you. Enemies will always advance you whenever they can. Lower level enemies take longer to advance and attack while higher level enemies advance and attack much faster. Some classes have abilities that allow them to engage combat while simultaneously dealing damage. Using the AD command will make you unbalanced and unable to swing for a couple seconds, so using combat engaging abilities or waiting for an enemy to advance you first is usually a better choice. However, some classes can gain bonuses by advancing enemies with the AD command. You'll gain a better understanding of when each of these engage tools will be most appropriate for you.\n\n`
			let meleeAttackText = `[ ATTACKING ] As a ${player.playerClass.name}, you need to be engaged with an enemy before being able to attack it. To do this, use the ADVANCE or AD command. Once in combat, use the ATTACK or A command to deal damage. Combat actions take time to recover before you can perform them again. When you are engaged in combat, you cannot move until you kill the enemy or you retreat. NOTE: NPCs cannot attack or be attacked. Enemies that can be attacked are listed by "Monsters:".\n\n`
			let rangedAdvancingText = `[ ENGAGING COMBAT ] As a ranged class, you don't need to engage combat before attacking as you can attack enemies at range with your bow. However, enemies that can't attack from will always engage combat with you every chance they get. Hitting an enemy with an attack and retreating to another room is a good tactic to avoiding enemies hitting you.\n\n`
			let rangedAttackText = `[ ATTACKING ] As a ${player.playerClass.name}, you can attack enemies without needing to engage them as long as you have a bow equipped. To attack an enemy, use the ATTACK or A command to deal damage. \nNOTE: NPCs cannot attack or be attacked. Enemies that can be attacked are listed by "Monsters:".\n\n`
			let mageAdvancingText = `[ ENGAGING COMBAT ] As a Mage class, you don't need to engage combat to hit enemies with your spells. However, enemies that can't attack from range will always engage combat with you every chance they get. Hitting an enemy with a spell and retreating to another room is a good tactic to avoiding enemies hitting you.\n\n`
			let mageCastingText = `[ CASTING SPELLS ] As a ${player.playerClass.name}, you will conjure and cast spells to damage your enemies. To conjure a spell, press the / key on the NumPad. You will see one of your bars filling up, indicating that your spell is conjuring. During this time, you can move around freely. Once your spell is fully conjured, it will remain conjured until you cast it. To cast the spell, press the / key on the NumPad a second time, and it will beging channeling. While the spell is channeling, you cannot move or perform any actions. Once the spell finishes channeling, it is considered cast and will hit your target. Spells cannot be dodged and will always hit, but some of the damage can be resisted based on the enemy's magic resist. Non-Mage classes use the ATTACK or A command to deal damage, but Mages should avoid using this command. A Mage's physical attacks do little damage, and your swing speed is slow which will leave you vulnerable to enemy attacks.\nNOTE: NPCs cannot attack or be attacked. Enemies that can be attacked are listed by "Monsters:".\n\n`
			let retreatingText = `[ RETREATING ] Enemies will always attempt to engage you (unless they are ranged or magic users). You can sill attack enemies while engaged, but they will also be able to hit you. As a ${player.playerClass.name}, you want to stay avoid enemies engaging you to minimize the damage you take. You can also utilize a tactical way of retreating by retreating in a direction. You can do this by using the REATREAT command followed by the direction you want to go. This will cause you to disengage combat while simulataneously moving in a direction, putting more space between you and the enemy. Try getting into combat with one of the training dummies here then using the RE E command to see how it works.\n`
			if (player.guild == 'Warrior' || player.guild == 'Sinistral' || player.guild == 'Monk') {
				return preInfo + meleeAdvancingText + meleeAttackText + retreatingText
			} else if (player.guild == 'Ranger') {	
				return preInfo + rangedAdvancingText + rangedAttackText + retreatingText
			} else if (player.guild == 'Mage') {
				return preInfo + mageAdvancingText + mageCastingText + retreatingText
			}
		},
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		get actionWord() {
			let actionWordArray = []
			if (player.guild == 'Warrior' || player.guild == 'Sinistral' || player.guild == 'Monk') {
				actionWordArray.push('ENGAGING', 'COMBAT', 'ATTACKING', 'RETREATING')
			} else if (player.guild == 'Ranger') {
				actionWordArray.push('ENGAGING', 'COMBAT', 'ATTACKING', 'RETREATING')
			} else if (player.guild == 'Mage') {
				actionWordArray.push('ENGAGING', 'COMBAT', 'CASTING', 'SPELLS', 'RETREATING')
			}
			return actionWordArray
		},
	}),
	{
		'ATTACKING': {
			names: ['ATTACKING'],
			color: function () {
				return 'yellow'
			},
		},
		'CASTING': {
			names: ['CASTING'],
			desc: function() {
			},
			color: function () {
				return 'yellow'
			},
		},
		'SPELLS': {
			names: ['SPELLS'],
			desc: function() {
			},
			color: function () {
				return 'yellow'
			},
		},
		'RETREATING': {
			names: ['RETREATING'],
			color: function () {
				return 'yellow'
			},
		},
		'ENGAGING': {
			names: ['ENGAGING'],
			color: function () {
				return 'yellow'
			},
		},
		'COMBAT': {
			names: ['COMBAT'],
			color: function () {
				return 'yellow'
			},
		},
	}
)

let galvadiaWelcomeArea18_combatRoom2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	2, //change x coord
	6, //change y coord
	-2,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Enemy Behavior`, //change area name
		zoneType: 'galvadia_basement',
		get desc() {
			let spawning = `[ ENEMY ENCOUNTERS ] Enemies have a chance to spawn whenever you enter a room in a hostile area. Hostile areas are not explicitly defined, but there are context indicators that will suggest when an area might be hostile. Towns and cities are safe from enemies. They cannot spawn in these areas nor can they follow you from a hostile area into a non-hostile area. When a room description heading changes color, this usually indicates changing areas which will sometimes mean moving into or out of a hostile area. Normal enemies will only spawn one at a time. Sometimes you might have to move quickly between rooms in order to get them to appear. Boss enemies usually spawn in one specific location within an area, and are typically accompanied by several other enemies.\n\n`
			let movementAndEngagement = `[ ENGAGEMENT AND ATTACKING ] Each enemy has a defined action speed that will determine how fast it moves and attacks. When an enemy spawns, it will first attempt to engage combat with you after a duration. It will then attempt to attack you at the same rate. A ranged enemy will not engage combat with you and will instead attack as soon as it can.\n\n`
			let attacking = `[ MOVEMENT ] Enemies will attempt to attack you as long as you're in the same room, but if you're in different rooms, they will roam freely. However, if you're within one room of an enemy, it will know you're there and will follow you.\n`
			return spawning + movementAndEngagement + attacking
		},
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['ENEMY', 'ENCOUNTERS', 'ENGAGEMENT', 'AND', 'ATTACKING', 'MOVEMENT']
	}),
	{
		'ENEMY': {
			names: ['ENEMY'],
			color: function () {
				return 'yellow'
			},
		},
		'ENCOUNTERS': {
			names: ['ENCOUNTERS'],
			desc: function() {
			},
			color: function () {
				return 'yellow'
			},
		},
		'ENGAGEMENT': {
			names: ['ENGAGEMENT'],
			desc: function() {
			},
			color: function () {
				return 'yellow'
			},
		},
		'AND': {
			names: ['AND'],
			color: function () {
				return 'yellow'
			},
		},
		'ATTACKING': {
			names: ['ATTACKING'],
			color: function () {
				return 'yellow'
			},
		},
		'MOVEMENT': {
			names: ['MOVEMENT'],
			color: function () {
				return 'yellow'
			},
		},
	}
)
// let galvadiaWelcomeArea19_combatRoom3 = new AreaMaker(
// 	5,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	0, //change x coord
// 	8, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Combat Room 3`,
// 		desc: `Combat Room 3`,
// 		zoneExitsBool: {
// 			east: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )

// let galvadiaWelcomeArea20_combatRoom4 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	2, //change x coord
// 	8, //change y coord
// 	-2,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Combat Room 4`, //change area name
// 		desc: `Combat Room 4`,
// 		zoneExitsBool: {
// 			west: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )

let centralBeginnersRoom = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-7, // X
	2, // Y
	-1, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Training Hall`,
		desc: `This is the central training room for warrior prospects.`,
		zoneExitsBool: {
			north: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

centralBeginnersRoom.quests = {
	startComplete: false,
	seComplete: false,
	sComplete: false,
	swComplete: false,
	wComplete: false,
	nwComplete: false,
	nComplete: false,
	neComplete: false,
	eComplete: false,
	onEntry: function () {
		if (previousArea.x == -7 && previousArea.y == 2 && previousArea.z == 0 && this.startComplete == false) {
			gameDialogue(`Welcome to the training halls. Here, you will train how to perform basic actions. Once you have completed each task, you will be prompted onward.`)
			gameDialogue(`Directions that are red indicate a locked door, or in other circumstances, may require a special item to unlock.`)
			gameDialogue(`For your first task, pick up the key from the ground and unlock the door to the north.`)
			gameDialogue(`To pick up something from the ground, use the GET command. Try "get key" or "g key", and then "unlock north" or "unlock n".`)
			startComplete = true
		}
		if (previousArea.x == -8 && previousArea.y == 3 && previousArea.z == -1 && this.seComplete == false) {
			this.seComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.north = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head north for your next task.`)
		}
		if (previousArea.id == 3 && this.sComplete == false) {
			this.sComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.northeast = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head northeast for your next task.`)
		}
		if (previousArea.id == 4 && this.swComplete == false) {
			this.swComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.east = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head east for your next task.`)
		}
		if (previousArea.id == 5 && this.wComplete == false) {
			this.wComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.southeast = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head southeast for your next task.`)
		}
		if (previousArea.id == 6 && this.nwComplete == false) {
			this.nwComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.south = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head south for your next task.`)
		}
		if (previousArea.id == 7 && this.nComplete == false) {
			this.nComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.southwest = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head southwest for your next task.`)
		}
		if (previousArea.id == 8 && this.neComplete == false) {
			this.neComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.west = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head west for your next task.`)
		}
		if (previousArea.id == 9 && this.eComplete == false) {
			this.eComplete = true
			centralBeginnersRoom.descriptions.zoneExitsBool.up = true
			centralBeginnersRoom.descriptions.zoneExitsFunc()
			gameDialogue(`Head UP the stairs for your next task.`)
		}
	},
}

centralBeginnersRoom.roomDialogue = `To move, type the direction you wish to go. You can check the available directions you can move by looking at the room's "Obvious Exits". If your view gets too cluttered, you can refresh your view of the room by using the LOOK command (or just 'L'). Once you are ready, travel to the NORTHWEST for your next task.`

let grassfields_entrance = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance To The Festival Grounds`,
		desc: `As you stand in front of your home, you find yourself on a well-traveled road that winds its way to the north and south. The road is made of smooth, worn down cobblestone from the countless passage of castlefolk. Rows of houses line the streets, smoke curling from their chimneys. To the west, the main road leads directly to the castle gates. Before the castle, you see the colorful jumble of stalls and tents of the marketplace. A large grassy field sprawls for acres across from the busy market.`,
		zoneExitsBool: {
			west: true,
			east: true,
		},
		north: () => gameDialogue(`This will take you farther into the residential district. For now, you need to keep heading west to the Castle Training Halls.`),
		south: () => gameDialogue(`This will take you farther into the residential district. For now, you need to keep heading west to the Castle Training Halls.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${capitalizeFirstLetter(Object.keys(this.zoneExitsBool)[i])}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let crossroads_shops_and_fields = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: `training-fields`,
		areaName: `Training Fields Central`,
		zoneType: 'galvadia_training_fields',
		get desc() {
			if (player.level < 5) {
				return `You stand in a large, open area surrounded by golden yellow fields. Guild instructors are here teaching students how to use their skills and abilities. Some of the prospects look eager to get into action while others look on nervously toward the fields.`
			} else {
				return `You stand in a large, open area surrounded by golden yellow fields. Guild instructors are here teaching students how to use their skills and abilities. Some of the prospects look eager to get into action while others look on nervously toward the fields. To the south, the grass along the river bank has grown up very high. Something moving deep in the grass has drawn your attention.`
			}
		},
		zoneExitsBool: {
			north: 'blocked',
			south: 'blocked',
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['grass'],
	}),
	{
		grass: {
			names: ['grass'],
			color: function () {
				return 'light-green'
			},
			desc: async function (secondCommand) {
				if (player.level < 4) {
					quickMessage(`You do not see any ${secondCommand} to examine.`)
					return
				}
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`The grass here has grown to over 10 feet in places. 
						You can make out something moving in the grass. 
						You might be able to go through if you cleared a 
						path through the grass.`, 'white', line1)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`Tip: Activating keywords in room descriptions, like pulling the levers in the Training Halls Basement, will always be two word commands like "pull lever". The first word will always be an action while the second word will be the object you're trying to affect. In this room, you can see that you need to clear something.`, 'white', line2)
					blankSpace()
			},
			activate: async function (secondCommand) {
				if (player.level < 4) {
					quickMessage(`You do not see a ${secondCommand} to clear.`)
					return
				}
				if (currentArea.descriptions.zoneExitsBool.south == 'blocked') {
					let line1 = document.createElement('div')
					let line2 = document.createElement('div')
					let line3 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`(You manage to clear a path in the tall grass)`, 'white', line1)
					blankSpace()
					await dialogueWait(200)
					customizeEachWord('A way has opened to the south!', 'white', line2)
					blankSpace()
					player.stasis = false
					currentArea.descriptions.zoneExitsBool.south = true
					currentArea.descriptions.zoneExitsFunc()
				} else if (currentArea.descriptions.zoneExitsBool.south == true) {
					let line1 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`The grass here has already been cleared.`, 'white', line1)
				}
			},
		},
	}
)
let mud_elemental_field = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	3, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: `training-fields`,
		areaName: `Entrance to the Market`,
		zoneType: 'galvadia_training_fields',
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
mud_elemental_field.onEntry = function() {
	// let doAnyExist = pushMonster.some(monster => monster.refName == 'littleMudElemental' || monster.refName == 'littleWaterElemental' || monster.refName == 'littleGrassElemental')
	if (!bossTimeouts.littleElemental) {
		let randomNumber = randomNumberRange(1, 3)
		if (randomNumber == 1) {
			monsterGen(littleMudElemental(currentArea))
			monsterGen(mudlet(currentArea))
			monsterGen(mudling(currentArea))
		} else if (randomNumber == 2) {
			monsterGen(littleGrassElemental(currentArea))
			monsterGen(grasslet(currentArea))
			monsterGen(grassling(currentArea))
		} else {
			monsterGen(littleWaterElemental(currentArea))
			monsterGen(waterlet(currentArea))
			monsterGen(waterling(currentArea))
		}
		bossTimeouts.littleElemental = setTimeout(() => {
			delete bossTimeouts.littleElemental
		}, 600000)
	}
}
let marketplace_bazaar = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	2, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance to the Market`,
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			east: true,
		},
		north: () => gameDialogue(`You'll want to explore the fields later, but for now you need to get to the castle`),
		south: () => gameDialogue(`The marketplace is currently closed. Check back later.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let marketplace_bazaar3 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	2, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Entrance to the Market`,
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		north: () => gameDialogue(`You'll want to explore the fields later, but for now you need to get to the castle`),
		south: () => gameDialogue(`The marketplace is currently closed. Check back later.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let marketplace_bazaar_south_exit = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	1, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Market South Exit`,
		desc: `Market South Exit`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let marketplace_bazaar_4 = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	2, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `East Market`,
		desc: `Entrance to the Market`,
		zoneExitsBool: {
			west: true,
		},
		north: () => gameDialogue(`You'll want to explore the fields later, but for now you need to get to the castle`),
		south: () => gameDialogue(`The marketplace is currently closed. Check back later.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let fieldsEntrance = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	5, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: `training-fields`,
		areaName: `Entrance To The Training Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `The wide path into the fields is blotted with water, mud, and grass shreds. A few prospects are hiding here, just around the corner and out of sight of monsters.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields1 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	6, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `By The Castle Moat In The Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `By The Castle Moat In The Fields`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

function spawnMonsterOnEntry(enemyArray) {
	// Define an array of possible monsters with their spawn probabilities
	const enemies = enemyArray
  
	// Generate a random number between 1 and 100
	let randomNumber = randomNumberRange(1, 100);
  
	// Initialize a variable to keep track of the cumulative probability
	let cumulativeProbability = 0;
  
	// Iterate through the monsters and check their spawn probabilities
	for (const entry of enemies) {
		console.log(entry, ' ENTRY')
	  cumulativeProbability += entry.probability;
	  if (randomNumber <= cumulativeProbability) {
		let enemyExtracted = entry.enemy
		monsterGen(enemyExtracted(currentArea));
		return; // Exit the loop and function after spawning a monster
	  }
	}
  
	// If no monster has been spawned, you can add an action here
	// For example, a message indicating no monsters spawned.
  }


let fields2 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	6, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Entering Into the Large Expanse Of The Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `The fields stretch out before you in all directions. To the west, the field borders the castle moat as it extends to the north. To the east, the fields are ushered northward by the shallow cliffside.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields3 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	6, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `By The Cliffside`,
		zoneType: 'galvadia_training_fields',
		desc: `The forest glade, high on the cliffside to the east, casts a shadow over the eastern edge of the field. To climb the cliff would be impossible, unless of course you were athletic enough.`,
		zoneExitsBool: {
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let fields4 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	7, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Along The Castle Moat`,
		zoneType: 'galvadia_training_fields',
		desc: `As you continue through the field, the sun shows no signs of letting up.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let fields5 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	7, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Amidst A Small Glade In The Middle Of The Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `As you step farther into the field, you cross into a small glade of sorts. A tree in the middle provides shade for anyone in need of a rest. Flowers cover the ground here, as it's the only area around that's not too overgrown to blossom. You see something shiny next to the tree among the roots.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['shiny'],
	}),
	{
		shiny: {
			names: ['shiny'],
			color: function() {
				return 'green'
			},
			desc: async function() {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You take a closer look at the object and see that it's a coin wedged into the roots. You reach down and pry the coin from the roots.`, 'grey', line1)
					questItemGen(luckyCoin())
					blankSpace()
			},
		}
	}
)
let fields6 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	7, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Along The Cliffside`,
		zoneType: 'galvadia_training_fields',
		desc: `The cracked rockface of the cliff has dotted the ground near the base with small boulders and piles of stone. Behind the stone, you can barely make out what looks like intentionally shaped rock embedded into the rock wall.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields7 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	8, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Nestled Grove`,
		zoneType: 'galvadia_training_fields',
		desc: `As you explore the field, you come across a hidden grove nestled among the tall grass. The trees here are lush and verdant, their branches intertwined to form a natural canopy. Sunlight filters through the foliage, casting dappled shadows on the ground below.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields8 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	8, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Roaming Through a Patch of Mushrooms`,
		zoneType: 'galvadia_training_fields',
		desc: `In the heart of the field, you stumble upon a patch of wild mushrooms of various shapes and colors. Some glow softly, emitting an otherworldly luminescence. The air is thick with an earthy scent, hinting at the mystical properties these mushrooms possess.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let fields9 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[till, sylas, krista, gaelwyn, lessa], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-1, // X
	8, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `At The End Of The Cliffside`,
		zoneType: 'galvadia_training_fields',
		desc: `The fields end in a steep dropoff, revealing a steep cliffside of its own that extends far below. The forest glade rockface extends beyond the edge of the fields to the north, sloping downward until it meets the ground several miles away.`,
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields1 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	5, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields2 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	5, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields3 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields4 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[sylas], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields5 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	0, // X
	3, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let lette_fields6 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	1, // X
	3, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-fields',
		areaName: `Trekking far Into the Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `A gentle breeze sweeps across the field, causing the tall grass to ripple like waves on a vast green sea. The whispering sound it creates is both soothing and invigorating, filling you with a sense of vitality and connection to nature.`,
		zoneExitsBool: {
			north: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let underFields1 = new AreaMaker(
	50, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	true, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-2, // X
	9, // Y
	-1, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: brown,
		areaName: `Fields Room 11`,
		desc: `Fields Room 11`,
		zoneExitsBool: {
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

fields1.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 33}, {enemy: waterling, probability: 33}, {enemy: grassling, probability: 34}])}
fields2.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields3.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields4.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields5.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields6.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields7.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields8.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}
fields9.onEntry = function() {spawnMonsterOnEntry([{enemy: mudling, probability: 3}, {enemy: waterling, probability: 3}, {enemy: grassling, probability: 3}])}

lette_fields1.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields2.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields3.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields4.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields5.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}
lette_fields6.onEntry = function() {spawnMonsterOnEntry([{enemy: mudlet, probability: 3}, {enemy: waterlet, probability: 3}, {enemy: grasslet, probability: 3}])}






function enemyGoldDrops(goldObject) {
	const keys = Object.keys(goldObject);
	const randomKey = keys[randomNumberRange(0, keys.length - 1)]
	const randomValue = goldObject[randomKey];
	console.log(keys)
	console.log(randomKey)
	console.log(randomValue)
	return randomValue
}

function enemyItemDrops(itemDrops, probability, enemy) {
	for (let i = 0; i < itemDrops.length; i++) {
		if (probability[i] >= randomNumberRange(1, 100)) {
			enemy.itemDrops.push(itemDrops[i]())
		}
	}
}

let just_outside_the_castle_east = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-3, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: `training-fields`,
		areaName: `Path To The Training Fields`,
		zoneType: 'galvadia_training_fields',
		desc: `Golden fields stretch out in every direction, reaching the river to the south, the rock face to the east, and the cliff edge to the north.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

function lineFunc(addClass) {
	const classOrClassArray = addClass
	let line = document.createElement('div')
	if (Array.isArray(classOrClassArray)) {
		classOrClassArray.forEach(classToAdd => line.classList.add(classToAdd))
	} else {
		line.classList.add(classOrClassArray)
	}
	return line
}
function gameLine(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent', 'game-dialogue', optionalClass)
	return line
}
function paragraphFunc(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent', optionalClass)
	return line
}
function inspectLine(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent', optionalClass)
	return line
}
function indentLine(optionalClass) {
	blankSpace()
	let line = document.createElement('div')
	line.classList.add('indent')
	return line
}

function line() {
	let line1 = document.createElement('div')
	return line1
}

// async function delayedDialogue(arr) {

// 	let delayTime = 1000;

// 	customizeEachWord(`${arr[0]}`);
// 	await wait(delayTime);

// 	console.log("Velthash says, 'Good morning! It's a fine day today, isn't it?'");
// 	await wait(delayTime);

// 	console.log("Without another word, Velthash goes over to the castle gate to unlock the door.");
// 	await wait(delayTime);

// 	console.log("Velthash says, 'Have a good rest of your day!'");
//   }

//   function wait(ms) {
// 	return new Promise(resolve => setTimeout(resolve, ms));
//   }

let zalbane = {
	x: -10,
	y: -10,
	z: 0,
	name: 'Zalbane',
	refName: 'zalbane',
	nameColor: 'zalbane-name',
	prefix: 'Lord of War, ',
	prefixColor: 'zalbane-title',
	keywords: ['zalbane'],
	occupation: `Guild Master of the Warrior's Guild`,
	race: `Human`,
	description: `Guild Master Warrior`,
	desc: function () {
		npcDescription(this)
	},
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)
	},
	speak: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx `, this.nameColor, line1)
			customizeEachWord(`looks you over`, 'white', line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, this.nameColor, line1)
			customizeEachWord(`Do you think you have what it takes to be a Warrior?`, this.prefixColor, line1)
			blankSpace()
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`Threx: `, this.nameColor, line1)
			customizeEachWord(`Come back with proof that you've slain a kobold, then I'll know that you're serious`, this.prefixColor, line1)
			blankSpace()
		} else {
			await dialogueWait(200)
			blankSpace()
			blankSpace()
		}
	},
	questSequence: {
		first: false,
	},
	questItem: 'kobold skull',
	quest: async function () {
		let line1 = lineFunc()
		if (this.questSequence.first == false) {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`${this.name}: `, this.nameColor, line1)
			customizeEachWord(`"Drats! I'm all out of Mudballs. I can't cook any more Mudpies without Mudballs. All I need is one Mudball to get me through the day.`, this.suffixColor, line1)
			blankSpace()
			return
		} else {
			await dialogueWait(200)
			blankSpace()
			customizeEachWord(`You have already completed this quest.`, 'white', line1)
			blankSpace()
		}
	},
	offer: async function() {
		let questItem = pushItem.find(item => (item.roomId == 'backpack' || item.roomId == 'right hand' || item.roomId == 'left hand') && item.keywords.some(keyword => keyword == this.questItem))
		let questItemIndex = pushItem.indexOf(questItem)
		let line1 = lineFunc()
		let line2 = lineFunc()
		if (!this.questSequence.first && questItem) {
		} 
	},
}
allNpcsArray.push(zalbane)

let vezzlethrax = {
	name: 'Vezzlethrax',
	refName: 'vezzlethrax',
	prefix: "Night's Venom, ",
	nameColor: 'vezzlethrax-name',
	prefixColor: 'dark-green',
	keywords: ['vezzlethrax'],
	displayName: function (peopleDiv) {
		displayNPCName(peopleDiv, this)

	},
	train: function (secondCommand, npc) {
		if (player.className.name != 'Thief') {
				let line1 = lineFunc()
				customizeEachWord(`You must be a member of the `, 'white', line1)
				customizeEachWord(`Sinistral's Guild`, 'sinistral-color', line1)
				customizeEachWord(`in order to train with `, 'white', line1)
				customizeEachWord(`${this.name}`, this.nameColor, line1)
				return
			}
			trainInteraction(secondCommand, npc)
		},
		get skillsOffered() {
			if (player.level < 10) {
				return [venomBlade, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance]
			} else if (player.level < 20) {
				return [venomBlade, contagion, bane, smokeBomb, stealth, daggers, oneHanded, dodging, fleetFooted, vigilance, vigor, precision, multipleStrikes, poison]
			} else if (player.level < 30) {
				return [venomBlade, contagion, bane, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, poison]
			} else {
				return [venomBlade, contagion, bane, smokeBomb, stealth, daggers, oneHanded, dodging, dodgeStrike, supremeDodging, backstabbing, fleetFooted, vigilance, vigor, warcraft, precision, multipleStrikes, poison]
			}
		},
		skillsMaxLevel: {
			get venomBlade() {return skillMaxLevel2(player.venomBlade)},
			get contagion() {return skillMaxLevel2(player.contagion)},
			get bane() {return skillMaxLevel2(player.bane)},
			get smokeBomb() {return skillMaxLevel5(player.smokeBomb)},
			get daggers() {return weaponSkillMaxLevel(player.daggers)},
			get oneHanded() {return weaponSkillMaxLevel(player.oneHanded)},
			get stealth() {return skillMaxLevel5(player.stealth)},
			get dodging() {return skillMaxLevel5(player.dodging)},
			get dodgeStrike() {return skillMaxLevel3(player.dodgeStrike)},
			get supremeDodging() {return skillMaxLevel5(player.supremeDodging)},
			get backstabbing() {return skillMaxLevel5(player.backstabbing)},
			get fleetFooted() {return skillMaxLevel5(player.fleetFooted)},
			get vigilance() {return skillMaxLevel5(player.vigilance)},
			get vigor() {return skillMaxLevel3(player.vigor)},
			get warcraft() {return skillMaxLevel3(player.warcraft)},
			get precision() {return skillMaxLevel3(player.precision)},
			get multipleStrikes() {return skillMaxLevel3(player.multipleStrikes)},
			get poison() {return skillMaxLevel5(player.poison)},
		},
	displayShop: function (ssiq) {
		displayShopSkillsOrSpells(this, ssiq)
	},
	desc: () => quickMessage(`Velthash towers over you, but his kind demeanor is calming yet intimidating. He's clad in full plate armor except for his helmet which he holds at his hip.`),
	speak: async function() {
	},
}
allNpcsArray.push(vezzlethrax)

let castle_gates_east = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-4, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: `training-fields`,
		areaName: `Passing Through The East Castle Gatehouse`,
		zoneType: 'galvadia_training_fields',
		desc: `The warm air shifts to a refreshing cool as you pass through the stone walls of the gatehouse. The guards nod at and greet students and instructors as they pass.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		west: () => gameDialogue(`There is a large guard blocking your way to the west. Perhaps you should speak to him.`),
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_gates_e_inside = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-5, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: `training-fields`,
		areaName: `Training Halls Back Courtyard`,
		zoneType: 'galvadia_training_fields',
		desc: `The back courtyard is a large area, walled off to the north and south with the only exit being east through the castle gates. A large tree towers in the middle of the courtyard, casting shade over the entire area.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let back_training_halls_entrance = new AreaMaker(
	0, //SPAWN RATE
	true, //IS PLAYER HERE
	[], // NPC
	false, // IS HOSTILE
	areaIdGenerator(), //ROOM ID
	-6, // X
	4, // Y
	0, // Z
	0, //GOLD
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Halls Back Foyer`,
		zoneType: 'galvadia_training_halls_common_room',
		desc: `The large doors of the back foyer are left open during the day due to their frequent use. Just beyond the doors are a set of stone stairs leading down into the back courtyard.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsCommonRoom = new AreaMaker( //change name
	0,
	true,
	[allSkillsMan, allAbilitiesMan],
	false,
	areaIdGenerator(),
	-7, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Hall Common Room`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `You find yourself in the large, crowded room of the Training Halls. The room is full of students preparing themselves, while others resting from their training.`, //`CENTRAL TRAINING ROOM - new recruits practicing their stances and strikes. A burly guard stands at the western door`, //change area desc
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExitsLocked: {
			west: () => gameDialogue(`You can't go here until you finish your preliminary training`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		fishMods: {
			levelRequirement: 1,
			fishList: [mudSucker, 'Leaf Perch', 'Corn Wallup'],
			mudSucker: 50,
			leafPerch: 30,
			cornWallup: 20,
			fishPicker: function() {
				let randomNumber = randomNumberRange(1, 100)
				if (randomNumber <= 50) {return mudSucker}
				if (randomNumber <= 80) {return leafPerch}
				if (randomNumber <= 100) {return cornWallup}
			}
		}
	})
)

let trainingHallsBasementEntrance = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Basement Entrance`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `.`,
		zoneExitsBool: {
			north: true,
			down: true,
		},
		zoneChange: {
			down: function () {
				player.x = 1
				player.y = 9
				player.z = -2
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsOutside = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Passing By The Castle Groves`, //change area name
		desc: `To the east and west along the path are beautifully manicured groves. Various, fruit trees grow in rows that fill the acres of lawn on each side.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `On The Path To The Castle Circle`, //change area name
		//The road here is spacious and adorned with intricately inlaid cobblestones arranged in large, circular patterns.
		desc: `As you walk along the path, you see the Adventurer's Guild off in the distance to the northwest and the Training Halls to the northeast. The road here is wide and adorned with inlaid cobblestones arranged in large, circular patterns.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'brown', line1)
			customizeEachWord(`East: Granery`, 'bold', line2)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


// let castle_courtyard_granery_path_2 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	-10, //change x coord
// 	1, //change y coord
// 	0,
// 	0,
// 	(descriptions = {
// 		areaNameClass: 'courtyardGreen',
// 		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
// 		desc: `Approaching the Training Halls.`,
// 		zoneExitsBool: {
// 			east: true,
// 			west: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )
let castle_courtyard_granery_path_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_courtyard_granery_path_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-6, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			northeast: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_path_8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-5, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_building = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-5, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_granery_mill = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-5, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Courtyard Path 1 Area 1`, //change area name
		desc: `Approaching the Training Halls.`,
		zoneExitsBool: {
			west: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyardNearMonksGuild = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Circle South`, //change area name
		desc: `The road connects to the Castle Circle and continues all the way around. In the middle is a tree large enough to shade the grass of the inner circle. Small stone paths branch from the road, meandering inward to an assortment of seating areas.`,
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			customizeEachWord(`The sign reads:`, 'white', line1)
			customizeEachWord(`Northeast: Training Halls`, 'white', line2)
			customizeEachWord(`Northwest: Adventurer's Guild`, 'white', line3)
			blankSpace()
		},
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			south: true,
		},
		zoneExitsLocked: {
			northwest: () => {
				let line1 = lineFunc()
				customizeEachWord(`You must be level 10 or higher to enter here.`, 'white', line1)			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castleGateway = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `South Castle Gatehouse`, //change area name
		desc: `Passing through the gatehouse are those with castle grounds business. Travelers from abroad seek the Adventurer's Guild to congregate with other travelers and adventurers or they might seek Rites of Passage if they intend to stay for a while. Guild prospects, and castle and guild officials are the most frequent passersby.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleMoat = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'bridge',
		areaName: `North Castle Crossroads In Front Of The Castle Moat Bridge`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `Two guards stand at the entrance to the moat bridge, eyeing people closely as they pass.
		There is a sign here.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
			southwest: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`North: Castle`, 'white', line2)
			customizeEachWord(`Southeast: Glade of Galvadia`, 'white', line3)
			customizeEachWord(`Southwest: Galvadian Fields`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let junction_castle_town_fields = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'bridge',
		areaName: `West Castle Crossroads`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `This is the start of the path that leads away fraom both the castle and town. It follows the castle moat to the west, and extends beyond it far into the distance well into the Galvadian Fields.
		There is a sign here.`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
			get west() {
				return player.level < 10 ? 'blocked' : true
			},
		},
		zoneExitsLocked: {
			west: () => quickMessage(`You need to be level 10 or higher to pass through here.`),
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`Northeast: Castle`, 'white', line2)
			customizeEachWord(`Southeast: Town Square`, 'white', line3)
			customizeEachWord(`West: Galvadian Fields, Kobold Caves`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let toGalvadiaFields1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Start Of The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `The sounds of town are faint. You can just see the tips of buildings and blacksmith smoke above the trees in the distance to the east. The west continues along the castle moat bank.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Passing The Southwest Bend Of The Moat`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `Rounding the southwest bend of the moat, you pass by a few travelling carts and patrol guards. A few children playing by the moat are being scolded by guards for being too close to the water.`,
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing On The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `On the south side of the path, the trees are getting denser as they extend to the west. Far to the north, you can make out the outer castle bailey. `,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing On The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `As there is not much on the path, you focus your eyes on the distance. Garrisons and guard towers line the road after it splits north. Carts bringing supplies to the castle are inspected before they pass through.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing On The Western Road`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: `You can barely make out the Castle Crossroads to the east. The forest south of the path gets denser as you travel west. The rough terrain makes it impossible to enter the woods. The entrance must be far on the other side.`,
		zoneExitsBool: {
			east: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-17, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Approaching The Western Road Junction`, //change area name
		zoneType: "galvadia_exterior_north",
		desc: ``,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Western Road South Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `The road to the north leads to the West Castle Road that leads directly to the castle, and is also the only road that leads out of the kingdom. It borders the northern edge of Lake Lily that you can see in the distance to the west.`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			customizeEachWord(`North - West Castle Gates`, ['white', 'bold'], line1)
			customizeEachWord(`West - Galvadia Fields, town`, ['white', 'bold'], line2)
			customizeEachWord(`East - South Castle Gates, town`, ['white', 'bold'], line3)
		},
	})
)
let toGalvadiaFields8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `You see a lake in the distance to the west. With only the forest bordering on the southern edge, you can see it in its entirety. In the middle of the lake is a small island clustered with trees. The west castle road paths its way along the northern side of the lake, extending to the outer walls as far to the west as you can see.`, //change area name
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On Path To The Fields`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `Continuing along the forest edge, you see what looks like vague movements through the leaves and brush. But then again, maybe it's just the wind.`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields10 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-21, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			west: true,
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let toGalvadiaFields11 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-22, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Southeast Edge Of The Lake`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-24, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Strolling The South Lakeside Path`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Pathway Hugging The Lake`, //change area name
		desc: ``,
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-26, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Following The Lakeside Trail`, //change area name
		desc: `On`,
		zoneExitsBool: {
			west: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Continuing Along The Lake Path`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-28, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Skirting The Dense Thicket`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-29, // x coord
	-2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `By The Overgrown Thicket Near An Opening`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southeast: 'locked',
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-30, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Rocky Path On The Southwest Side Of The Lake`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_10 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-29, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_11 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-29, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_12 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-28, // x coord
	2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_13 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	3, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	4, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	5, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-27, // x coord
	6, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_to_castle_path4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-26, // x coord
	7, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-24, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-22, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let west_castle_main_path3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-21, // x coord
	8, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_14 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-26, // x coord
	3, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_15 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	3, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_16 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	2, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_17 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-25, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_18 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-24, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			west: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_19 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_lake_20 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-22, // x coord
	0, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On path to fields 7`, //change area name
		desc: `On path to fields 7`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCaveEntrance = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-23, // x coord
	-1, // y coord
	0, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Entrance to the Kobold Caves`, //change area name
		desc: `You stand in front of a large cave mouth. Animal skulls litter the ground with some decoratively strung up across the entrance and other still fresh heads stuck on pikes. The area is quiet with no animals in sight - you can only imagine why. You hear the occasional, crazed yelping coming from within the caves.`,
		zoneType: "galvadia_fields_main",
		zoneExitsBool: {
			east: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom1 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Dark Damp Cave`, //change area name
		desc: `A steep slope extends upward toward the mouth of the cave. Tunnels wind in several directions. Through dimly lit torch light, you can see that the northern and southern tunnels curve around. To the west, you hear much more loudly the yips and yelps of kobolds. To the east is quiet, and seemingly less active.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Through A Narrow Passage`, //change area name
		desc: `You can see a spotlight of sunshine to the south that illuminates the ground. The north tunnel extends farther into the caves.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom3 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn in the Caves`, //change area name
		desc: `Crumbled stone litters the area. It's hard to gain footing with all the rubble under your feet. Torches are dotted around the walls at least making it easier to see. Large chunks of colored stone jut out from the walls in what looks like a copper vein.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		actionWord: ['copper', 'vein'],
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		copper: {
			names: ['copper'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					quickMessage(`vein reset`)
					this.empty = false
				}, 10000) //10 second respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!koboldCavesRoom3.interactables.copper.empty) {
					customizeEachWord(`A copper vein that looks like it could be mined with a pickaxe`, 'white', line1)
				} else {
					customizeEachWord(`This copper vein is empty`, 'white', line1)
				}
			},
			color: function() {
				if (koboldCavesRoom3.interactables.copper.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
		vein: {
			names: ['vein'],
			desc: function() {
				let line1 = lineFunc()
				if (!koboldCavesRoom3.interactables.copper.empty) {
					customizeEachWord(`A copper vein that looks like it could be mined with a pickaxe`, 'white', line1)
				} else {
					customizeEachWord(`This copper vein is empty`, 'white', line1)
				}
			},
			color: function() {
				if (koboldCavesRoom3.interactables.copper.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		}
	}
)
let koboldCavesRoom4 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn In The Caves`, //change area name
		desc: `Winding through the turn, you see light coming from the southeast. More crumbled stone starts to crunch under your feet.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom5 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Through The Cave Tunnels`, //change area name
		desc: `You see dim light to the east and west, but you can barely see anything in front of you.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom6 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn In The Caves`, //change area name
		desc: `Little Kobold torches line the walls here and to the southwest. They must have a reason for wanting to see better here at this part of the tunnels.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom7 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Winding Through The Tunnels`, //change area name
		desc: `Boulders, rocks, and dirt have been pushed and piled in such a way as to make way for traffic. Footprints show in the thick dust on the floor`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom8 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Heading Down The Narrow Tunnels`, //change area name
		desc: `The tunnel has been cleared of rocks and dirt. Slender planks have been braced against the walls and ceiling to keep the roof from creating a cave-in.  A glowing moss that emits enough light to see grows along the
		walls.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom9 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Branch In The Tunnels`, //change area name
		desc: `There is extra light coming from the east. You can also hear clatterings and excited yips coming from that direction. To the south, the dark tunnels continue.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom10 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Travelling Through The Narrow Tunnels`, //change area name
		desc: `Faint light can be seen illuminating the turn to the south. With what light there is in this room, you can see little footsteps making their way to the north and curving around to the east.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom11 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, // x coord
	-3, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Turn In The Tunnels`, //change area name
		desc: `The walls have been recently reinforced with old wood and other stolen materials from nearby buildings above ground. You can smell the mildew emitting from the materials.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom12 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	-4, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Winding Through The Tunnels`, //change area name
		desc: `The passage narrows, the rocky walls closing in on all sides, and the ceiling is only a few feet high. Dim light of torches from the other end of the tunnel flicker on the tunnel walls.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom13 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	-4, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `In The Middle Of A Tunnel`, //change area name
		desc: `The only sounds you hear are the dripping of damp stone, and the scuff of your steps.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom14 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-4, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Rounding A Bend In The Tunnels`, //change area name
		desc: `As you round the bend, torches line the walls, most of which are unlit.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom15 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-3, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Rubble Filled Tunnels`, //change area name
		desc: `Broken mining picks and rubble is strewn about. The kobolds don't seem to care about maintaining areas that have been completely mined.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom16 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `A Jagged Pathway`, //change area name
		desc: `The walls here are jagged and damp, making it difficult to pass through at any sort of pace.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom17 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Heading Down A Well Worn Tunnel`, //change area name
		desc: `The tunnel here is well worn and smooth. To the west, the sounds of yipping kobolds grows. It looks to be their living quarters. The light from their torches illuminate a sizeable pond in the middle of the room. Around the rest of the room, you see small shapes bouncing around to and fro.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom18 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'blue',
		areaName: `In The Middle Of The Kobold's Living Quarters`, //change area name
		desc: `A large pond sits in the middle of the room with numerous utensils for containing water skittered about the waters edge. Pathways are laid out to the north and south leading to individual sleeping rooms.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom19 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `On A Lit Path Through The Tunnels`, //change area name
		desc: `The path exits the kobold's main living quarters to the west. Pickaxes and crude mining tools are laid against the wall.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom20 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Living Area`, //change area name
		desc: `Makeshift pelt beds are scattered all around. Against the wall is a small cage made from sticks. Inside the cage are the bones of a rat.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom21 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Living Area`, //change area name
		desc: `The walls come closer together only allowing a couple to pass through at a time. The walls have been scraped and scratched by equipment being dragged through the hallway. Small bits of fabric, fur, arrowheads, and other items can be seen scattered along the passageway.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom22 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	0, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Dwelling`, //change area name
		desc: `Carved into the wall is a large enclave for a Kobold Family. Scraggled animal pelts have been stacked up for what look to be beds. Skinned rat carcassed hang from the ceiling. Makeshift weapons and armor are stacked to one side.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['pelts'],
	}),
	{
		pelts: {
			names: ['pelts'],
			questSequence: {
				first: false
			},
			color: function() {
				let obstacle = 6
				if (player.perception.check(obstacle) && !koboldCavesRoom22.interactables.pelts.questSequence.first) {
					return 'green'
				} else {
					return 'white'
				}
			},
			desc: async function() {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let obstacle = 6
				if (player.perception.check(obstacle) && !this.questSequence.first) {
					this.questSequence.first = true
					let item
					if (player.playerClass.name == 'Berserker') {item = boneTippedSpear}
					if (player.playerClass.name == 'Fighter') {item = rustySword}
					if (player.playerClass.name == 'Knight') {item = rustySword}
					if (player.guild == 'Sinistral') {item = boneDagger}
					if (player.guild == 'Monk') {item = leatherGrips}
					if (player.guild == 'Ranger') {item = crudelyCarvedBow}
					if (player.guild == 'Mage') {item = woodenStaff}
					weaponGen(item(currentArea))
					console.log(item)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You see something sticking out from beneath the pelts. Upon closer inspection, it looks to be some type of weapon. Despite not wanting to touch the smelly kobold pelts, you lift them up to pull out what was underneath.`, 'white', line1)
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You find a `, 'white', line2)
					customizeEachWord(`${item().name} `, item().color, line2)
					customizeEachWord(`beneath the pelts`, 'white', line2)
					blankSpace()
				} else {
					blankSpace()
					customizeEachWord(`You see a messy stack of Kobold Pelts stacked up`, 'white', line1)
					blankSpace()
				}
			}
		}
	}
)
let koboldCavesRoom23 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Dwelling`, //change area name
		desc: `A lit fire is at the center of this enclave. Critter bones lay strewn about near the fire.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['bones'],
	}),
	{
		bones: {
			names: ['bones'],
			questSequence: {
				first: false
			},
			color: function() {
				let obstacle = 6
				if (player.perception.check(obstacle) && !koboldCavesRoom23.interactables.bones.questSequence.first) {
					return 'green'
				} else {
					return 'white'
				}
			},
			desc: async function() {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let obstacle = 6
				if (player.perception.check(obstacle) && !this.questSequence.first) {
					this.questSequence.first = true
					questItemGen(ratHide())
					questItemGen(ratTail())
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`Among the litter of bones you spot something that you could make use of`, 'white', line1)
					blankSpace()
					await dialogueWait(200)
					customizeEachWord(`You find a `, 'white', line2)
					customizeEachWord(`${ratHide().name} `, ratHide().color, line2)
					customizeEachWord(`laying on the ground`, 'white', line2)
					blankSpace()
				} else {
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You see critter bones all over the place`, 'white', line1)
					blankSpace()
				}
			}
		}
	}
)
let koboldCavesRoom24 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Living Area`, //change area name
		desc: `The stone floor has been smoothed out from the many years of use. There's no telling how many generations of kobolds have lived and died here.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom25 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Dwelling`, //change area name
		desc: `A few makeshift bows and arrows are laying on the ground here. Their craftsmanship is so poor that they're not even worth using or selling.`,
		zoneType: "kobold_cave_main",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom26 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Heading Down A Dark Tunnel`, //change area name
		desc: `The tunnel here is barely lit. Though, the ground is much cleaner than the rest of the tunnels.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom27 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-21, // x coord
	-1, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Rounding A Dark Tunnel`, //change area name
		desc: `You have to feel your way through the tunnel as it curves around. You can hear kobold activity in what sounds like is coming from below you.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesRoom28 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-20, // x coord
	-2, // y coord
	-1, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At The Top Of A Steep Incline`, //change area name
		desc: `You stand at the top of a steep incline. At the bottom, you see flickering torchlight and low murmers of kobolds.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			northwest: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room1 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-20, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Cave Floor 2 Entrance`, //change area name
		desc: `The cave on this lower level is much better lit. The paths are wider and better kept. You hear the sounds of an underwater stream flowing from somewhere on this lower level.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-21, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Heading Down A Wide Tunnel`, //change area name
		desc: `The tunnel widens even further, and the walls here are decorated with small skulls in a variety of shapes. Most appear to be smaller creatures, but a few look to be humanoid.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room3 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Branch In The Cave`, //change area name
		desc: `The sound of flowing water grows as you are met with its source to the north. A shoddily stitched patchwork pelt rug covers the entire floor here and extends westward.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room4 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, // x coord
	-1, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Overlooking The Cave Creek`, //change area name
		desc: `The water is too deep to wade through, and too dark past a certain point to swim through. Across the creek is a platform of stone. Perhaps if you were agile enough, you could jump across to the other side.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room5 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, // x coord
	-2, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `At A Bend In The Cave`, //change area name
		desc: `The light grows brighter as do the sounds of kobolds as you trek westward. With the sounds of water flowing in the background, you can't get a good read on how close you might be to the kobolds.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			east: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room6 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	-1, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Outside A Large Chamber`, //change area name
		desc: `You now see the source of the noises. To the north, you see a much larger kobold, decorated with a skull headdress, colored rags, and a human sized spear, sitting at the back of the chamber.`,
		desc: `You can only see as much of the room to the north as the tunnel walls allow you to see, but it appears to be the chambers of a kobold of higher importance. The pelt rugs on the floor are cleaner than the other ones you've seen, and the walls are adorned with several bone necklaces and figurines.`,
		zoneType: "kobold_cave_tunnels",
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let koboldCavesFloor2Room7 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, // x coord
	0, // y coord
	-2, // z coord
	0,
	(descriptions = {
		areaNameClass: 'buildingWood',
		areaName: `Kobold Chief Chambers`, //change area name
		desc: `As you enter the room, you realize that this is in fact the chambers of the kobold chief. Along the walls are scavenged weapons and various pieces of armor scraps. On the back wall is the mounted head of a gnoll, likely a display of the toughest creature they've killed. The Kobold Chief is twice the size of any other kobold you've seen. It has equipped a decorated skull headdress, colored rags, and a human sized spear.`,
		zoneType: "kobold_cave_chief_room",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
//tunnels
koboldCavesRoom1.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom2.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom3.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom4.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom5.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom6.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom7.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom8.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom9.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom10.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom11.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom12.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom13.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom14.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom15.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom16.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom17.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom27.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
koboldCavesRoom28.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldArcher, probability: 3}, {enemy: koboldScoundrel, probability: 3}, {enemy: koboldSpearthrower, probability: 3}])}
//main
koboldCavesRoom18.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom20.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom21.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom22.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom23.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom24.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom25.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
koboldCavesRoom26.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldChild, probability: 3}, {enemy: koboldScoundrel, probability: 3}])}
//floor 2
koboldCavesFloor2Room1.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room2.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room3.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room4.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room5.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room6.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
koboldCavesFloor2Room7.onEntry = function() {spawnMonsterOnEntry([{enemy: koboldDigger, probability: 5}, {enemy: koboldArcher, probability: 2}, {enemy: koboldSpearthrower, probability: 2}, {enemy: koboldScoundrel, probability: 2}])}
//CHIEF ROOM
koboldCavesFloor2Room7.onEntry = function() {
	let doAnyExist = pushMonster.some(monster => monster.refName == 'koboldChief')
	if (!bossTimeouts.koboldChief && !doAnyExist) {
		monsterGen(koboldChief(currentArea))
		bossTimeouts.koboldChief = setTimeout(() => {
			delete bossTimeouts.koboldChief
		}, 600000)
	}
}

let trainingHallsCombatHalls1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Advanced Combat Study Halls`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `Paintings and drawings line the hall, each one showing a series of movements to illustrate proper technique. A rectangular column stands in the middle of the hall, displaying information about the what each room covers.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		column: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			blankSpace()
			customizeEachWord(`The column reads: `, 'red', line1)
			customizeEachWord(`The room to the west explains in detail how attributes work and what all they have an effect on.`, 'white', line2)
			customizeEachWord(`The room to the east provides advanced information about weapon skills and what they do.`, 'white', line3)
			customizeEachWord(`The hall to the north leads to a room that details information about swing types, armor types, armor penetration, and weight and burden.`, 'white', line4)
			blankSpace()
		},
		actionWord: ['column']
	}),
	{
		column: {
			names: ['column'],
			color: function() {
				return 'red'
			},
			desc: function() {
				let line1 = lineFunc()
				let line2 = lineFunc()
				let line3 = lineFunc()
				let line4 = lineFunc()
				blankSpace()
				customizeEachWord(`The column reads: `, 'red', line1)
				customizeEachWord(`The room to the west explains in detail how attributes work and what all they have an effect on.`, 'white', line2)
				customizeEachWord(`The room to the east provides advanced information about weapon skills and what they do.`, 'white', line3)
				customizeEachWord(`The hall to the north leads to a room that details information about swing types, armor types, armor penetration, and weight and burden.`, 'white', line4)
				blankSpace()
			}
		}
	}
)

let trainingHallsCombatHalls2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Advanced Combat Study Halls`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `You see more higher level guild prospects and even recently inducted guild members studying here. There are statues stanced in specific combat poses, demonstrating proper technique of various abilities.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
)

let training_halls3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Live Monsters Training Halls 2`, //change area name
		desc: `The goblins to the east and west are a little stronger than before. Speak to Commander Levins before fighting them. He has some useful items for you.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let training_halls3_room3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'blue',
		areaName: `Mage Initiate Room`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: ``,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallEntryMessHall = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'training-halls',
		areaName: `Training Halls Entrance`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `The entrance of the Training Halls is surrounded on three sides by the building itself. A set of statues depicting fighting and spell casting poses line the way leading to the stairs. Atop the stairs, you are met with a heavy wooden door.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let trainingHallEntry34525234 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: castleGrey,
		areaName: `Nearing The Training Halls`, //change area name
		zoneType: 'galvadia_training_halls_common_room',
		desc: `Rounding the circle to the east, the road splits off and leads to the entrance of the Training Halls. Rows of small trees line the path as it leads into the alcoved courtyard.`,
		zoneExitsBool: {
			northwest: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_courtyard_south_junction = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway. There is a large SIGN here`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction231 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			northeast: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction232 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction233 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_south_junction23 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_bath_house_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_bath_house_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_bath_house_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castleCourtyardCrossInThePath1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Cross in the path`, //change area name
		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
		zoneExitsBool: {
			north: true,
			southeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyardNearingWestGateJunction = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing the West Gate Junction`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_court_fountain_SE = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Southeast`, //change area name
		desc: `This corner of the courtyard is covered in shade from the surrounding high walls. People line the benches, some chatting, some enjoying the music from one of the castle bards.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_E = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain East`, //change area name
		desc: `The Chapel can be seen to the northeast, attached to the east castle wing. The path to the east curves around to the entrance.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_NE = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-10, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Northeast`, //change area name
		desc: `Castle Officials line the walls, sitting at tables covered in stacks of parchment. Most of the people approaching the tables look to be younger, fresh guild inductees.`,
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_N = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain North`, //change area name
		desc: `You stand in front of a wide set of stone stairs leading up to the castle doors. There are several landings before reaching the top. Guards of various ranks keep watch over the area. Some stand like motionless sentinels while other patrol.`,
		zoneExitsBool: {
			north: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_castle_entrance = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing the West Gate Junction`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: 'locked',
			south: true,
		},
		zoneExitsLocked: {
			north: function () {
				if (castle_court_castle_entrance.descriptions.zoneExitsBool.north == 'locked') {
					let line1 = document.createElement('div')
					customizeEachWord(`The way to the north is locked. The lock looks to be pretty simple.`, 'white', line1)
				}
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'blue',
		areaName: `Castle Courtyard Fountain`, //change area name
		desc: `An enormous marble fountain stands as the centerpiece of the courtyard. Its shape is that of a mana tree. Water cascades from its leaves, like a tree during a heavy downpour.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},

		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_w = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain West`, //change area name
		desc: `This area has the heaviest flow of people with the west leading to the West Castle Gates, the primary entrance to the castle grounds for Galvadian Soldiers and anything going directly to and from the castle.`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_court_fountain_nw = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Northwest`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castle_court_fountain_s = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-11, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain South`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n12_sw = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-12, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Castle Court Fountain Southwest`, //change area name
		desc: `West Gate Junction. South is the Monk's guild, west is the West Exit, east is the Castle Pond, north is the Castle`,
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n13_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Nearing The Castle Court Fountain`, //change area name
		desc: `You can smell the mixture of food and animals in the air coming from the nearby kitchen and stables. To the east, the gentle sound of water invites you to the captivating Castle Courtyard Fountain.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n14_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `West Gate Junction`, //change area name
		desc: `West Gate Junction. South is the Monk's guild, west is the West Exit, east is the Castle Pond, north is the Castle`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_split_to_tower_and_kitchen = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `A Split To The Tower And Castle Kitchen`, //change area name
		desc: ``,
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_northwest_tower = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `At The Footsteps Of The Northwest Guard Tower`, //change area name
		desc: ``,
		zoneExitsBool: {
			southeast: true,
			northwest: 'locked',
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_kitchen = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-13, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Just Outside The Castle Kitchen`, //change area name
		desc: ``,
		zoneExitsBool: {
			north: 'locked',
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_passing_stables_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Passing By The Stables`, //change area name
		desc: `As you pass by the Castle Stables, you catch glimpses of the majestic horses within their stalls. The rhythmic sounds of hooves against the stable floor echo through the air, reminding you of the strength and grace that resides within these gentle creatures.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castleCourtyard_n16_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `Just Inside The Western Gate Near The Stables`, //change area name
		desc: `Stepping inside the West Castle Gates, you find yourself surrounded by a bustling atmosphere. Soldiers march with purpose, while merchants set up their wares. The air carries the scent of freshly baked bread and the sound of cheerful greetings.`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_w_gatehouse = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-17, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'courtyardGreen',
		areaName: `West Castle Gatehouse`, //change area name
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExitsLocked: {
			west: () => quickMessage(`can't go here yet`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_moat_west = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'brown',
		areaName: `Standing on the West Gate Drawbridge`, //change area name
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.
		There is a sign here.`,
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`Northeast: Goblin Hills`, 'bold', line2)
			customizeEachWord(`Northwest: Gnoll Plains`, 'bold', line3)
			blankSpace()
		},
		zoneExitsBool: {
			northeast: true,
			south: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let gnollPlains1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-21, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 1`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `The path here looks lightly travelled. It slopes slightly downward between two hills for nearly a mile until it meets the entrance to the plains.`,
		zoneExitsBool: {
			northwest: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains Entrance`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `The grass here grows up higher than your head as you enter deep into the Gnoll Plains. If you were to wander off the trail into the grass, you could get lost for days. The trails north and west are jaggedly cut to knee height of a Human and wide enough for several wagons.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains4 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, //change x coord
	12, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `On A Wide Trail Through The Plains`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Streaks of red stripe their way through the trail. The the middle of the trail is matted, as if something large has been dragged through.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains5 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Continuing On A Trail Deep In The Plains`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As the grass waves with the wind, you see shapes appear and disappear through the grass..`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains6 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-22, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `At A Bend In The Trail`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll footprints embedded in the matted grass mark along the path. On the north side, a section of the grass wall is beaten down, showing signs of activity leading into the depths of the plains.`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let gnollPlains11 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, //change x coord
	15, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 11`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `The streaks of blood in the grass continue. The trail looks to be a highway of sorts for the Gnolls, possibly for transporting their kills from the plains to their camps.`,
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains12 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, //change x coord
	15, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 12`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: ``,
		zoneExitsBool: {
			northwest: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains13 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	17, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 13`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 13.`,
		zoneExitsBool: {
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains14 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, //change x coord
	17, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 14`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 14.`,
		zoneExitsBool: {
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let gnollPlains1_5 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 15`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 15.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let gnollPlains17 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 16`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 16.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains18 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, //change x coord
	12, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 16`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 16.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains19 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-28, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 16`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 16.`,
		zoneExitsBool: {
			northeast: true,
			east: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains20 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-27, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 16`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 16.`,
		zoneExitsBool: {
			south: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains21 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	16, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 13`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 13.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let gnollPlains24 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 24`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 24.`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains25 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 25`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 25.`,
		zoneExitsBool: {
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains26 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	12, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 26`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 26.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains27 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 26`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 26.`,
		zoneExitsBool: {
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains28 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 26`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 26.`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains32 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 26`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 26.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains29 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-25, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 26`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 26.`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains30 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-24, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 30`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 30.`,
		zoneExitsBool: {
			northwest: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains31 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-23, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Gnoll Plains 31`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `Gnoll Plains 31.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gnollPlains33 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-26, //change x coord
	16, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `North Gnoll Camp`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `In the center of the camp is a large fire.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


gnollPlains1.onEntry = function() {spawnMonsterOnEntry([{enemy: gnollSkirmisher, probability: 10}, {enemy: gnollBrawler, probability: 10}, {enemy: gnollBrute, probability: 10}, {enemy: gnollPackLeader, probability: 10}])}
gnollPlains2.onEntry = function() {spawnMonsterOnEntry([{enemy: gnollSkirmisher, probability: 10}, {enemy: gnollBrawler, probability: 10}, {enemy: gnollBrute, probability: 10}, {enemy: gnollPackLeader, probability: 10}])}
gnollPlains4.onEntry = function() {spawnMonsterOnEntry([{enemy: gnollSkirmisher, probability: 10}, {enemy: gnollBrawler, probability: 10}, {enemy: gnollBrute, probability: 10}, {enemy: gnollPackLeader, probability: 10}])}
gnollPlains5.onEntry = function() {spawnMonsterOnEntry([{enemy: gnollSkirmisher, probability: 10}, {enemy: gnollBrawler, probability: 10}, {enemy: gnollBrute, probability: 10}, {enemy: gnollPackLeader, probability: 10}])}

let galvadia_fields_north_2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.
		There is a sign here.`,
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`North -> Northeast: Goblin Hills`, 'white', line2)
			customizeEachWord(`North -> Northwest: Gnoll Plains`, 'white', line3)
			blankSpace()
		},
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign']
	})
)
let galvadia_fields_north_3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	12, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	13, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-17, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-16, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields_north_9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-14, //change x coord
	14, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_north',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: 'locked',
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `Standing on the West Gate Drawbridge`, //change area name
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	7, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-20, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields5 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields6 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	4, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields7 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-19, //change x coord
	3, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields8 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	2, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_fields9 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-18, //change x coord
	1, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-brown',
		areaName: `West Castle Junction`, //change area name
		zoneType: 'galvadia_fields_main',
		desc: `As you approach the West Castle Gatehouse, towering stone walls rise before you. The heavy wooden gates stand tall, adorned with intricate ironwork. Guards in shining armor keep a watchful eye, ensuring the security of the castle grounds.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_courtyard_stables_1 = new AreaMaker( //change name
	0,
	true,
	[sevrox],
	false,
	areaIdGenerator(),
	-16, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'stables-orange',
		areaName: `Castle Stables`, //change area name
		desc: `North of the castle gates, you discover the Castle Stables. Neat rows of sturdy wooden stalls house majestic horses, their manes brushed and hooves cared for. The gentle nickering of the horses creates a soothing melody within the stables.`,
		zoneExitsBool: {
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let castle_stables_stall_1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-15, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'stables-orange',
		areaName: `Stable Stalls`, //change area name
		desc: `Within the Castle Stables, you find yourself amidst a symphony of equine energy. Each stall shelters a magnificent steed, their glossy coats gleaming under the warm sunlight. Hay fills the air with its earthy scent, inviting you to explore further.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
// let castleCourtyardPath1Area4 = new AreaMaker( //change name
// 	0,
// 	true,
// 	[],
// 	false,
// 	areaIdGenerator(),
// 	-10, //change x coord
// 	4, //change y coord
// 	0,
// 	0,
// 	(descriptions = {
// 		areaNameClass: castleGrey,
// 		areaName: `Castle Courtyard Path 1 Area 4`, //change area name
// 		desc: `North is the Light Seeker's guild, east is the Training Halls, west is toward the castle, south leads to the castle gateway`,
// 		zoneExitsBool: {
// 			east: true,
// 			southwest: true,
// 		},
// 		zoneExits: [],
// 		zoneExitsFunc: function () {
// 			let directionsArray = Object.values(this.zoneExitsBool)
// 			let compiledDirections = []
// 			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
// 				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
// 					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
// 				}
// 			}
// 			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
// 			this.zoneExits = compiledDirections
// 		},
// 	})
// )


let holy_light_chapel_path1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path`, //change area name
		desc: `Passing through a wide opening in the wall, you see two statues facing eachother on each wall's edge above you. The statues are nearly identical, one dark and the other light, both depicting a woman in pose with an outstretched arm, their palms coming together over the pathway.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_path2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	8, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 2`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_path3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	9, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 3`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_path4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	10, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Path 4`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_interior1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Interior 1`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_interior3 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-7, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Interior 3`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let holy_light_chapel_interior2 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-9, //change x coord
	11, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'yellow',
		areaName: `Holy Light Chapel Interior 2`, //change area name
		desc: `Nearing the West Gate Junction`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let trainingHallsCombatRoom3 = new AreaMaker(
	5,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Swing Types | Armor Types | Armor Penetration | Weight and Burden`,
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `There are various plaques around the room with detailed information about armor, weight, and burden.
		There is a Swing-Types plaque here.
		There is an Armor-Types plaque here.
		There is an Damage-Types plaque here.
		There is a Weight plaque here.
		`,
		"swing-types": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`SWING TYPES`, 'yellow', line2)
			customizeEachWord(`There are 3 swing types: slashing, piercing, and blunt. You can inspect your weapon to see its available swing types. If your weapon is a slashing weapon, you can only perform slashing attacks. If your weapon is slashing/piercing, you can perform both slashing and piercing attacks. Your swing type is chosen at random from your weapon each time you swing. Enemies also have the ability to use different swing types. Their swing types are predetermined and will always be the same for each enemy type. For example, a Grassling will always have only a slashing swing while Mudlings will only ever have a blunt swing.`, 'white', line3)
			blankSpace()
		},
		"armor-types": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plauqe reads: `, 'white', line1)
			customizeEachWord(`ARMOR TYPES`, 'yellow', line2)
			customizeEachWord(`There are 3 types of armor: plate, leather, and cloth.`, 'white', line3)
			customizeEachWord(`Warrior classes should always wear plate armor when available, but they can make use of leather armor if they need to.`, 'white', line4)
			customizeEachWord(`Rogue classes should always wear leather armor. Plate armor is very heavy, and Rogues do not invest in enough Strength to be able to offset the burden penalty.`, 'white', line5)
			customizeEachWord(`Monk classes have the most variability in the armor they can wear because their attack power benefits equally from Strength, Dexterity, and Agility allowing Monks who invest in Strength to wear some plate armor (shouldn't invest everything into it). Mystic Monks and Elemental Monks can wear a mix of leather and cloth armor because they utilize Mysticism which can be found on cloth armor.`, 'white', line6)
			customizeEachWord(`Ranger classes should always wear leather armor. Plate armor is very heavy, and Rangers should not invest attribute points into Strength.`, 'white', line7)
			customizeEachWord(`Mage classes should always wear cloth armor, but they can wear the occasional leather piece if they need to fill a slot. Cloth armor is an important source of Mage stats.`, 'white', line8)
			blankSpace()
		},
		"damage-types": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`DAMAGE TYPES:`, 'yellow', line2)
			customizeEachWord(`There are 3 damage types: slashing, piercing, and blunt. When a slashing, piercing, or blunt swing lands, its damage is matched against the armor of its type. For example, if you swing a slashing/piercing weapon at an enemy that has 100 slashing armor and 0 piercing armor and the slashing swing type is chosen, the damage dealt to the enemy will be matched against the enemy's slashing armor. If you swing again and the piercing swing type is chosen, it will be matched against the enemy's piercing armor. In this case, the enemy has 0 piercing armor and will not mitigate any damage.`, 'white', line3)
			customizeEachWord(`There are 3 armor penetration types: slashing, piercing, and blunt. Each point of penetration will negate the enemy's armor type by that amount. If an enemy has 15 slashing armor, and you have 15 slashing penetration, that will reduce their slashing armor to 0. `, 'white', line4)
			blankSpace()
		},
		"weight": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`WEIGHT AND BURDEN`, 'yellow', line2)
			customizeEachWord(`Weight is how heavy you are when adding up the weight of all your equipped weapons and armor (inventory is not factored into weight). Weight on its own is not penalizing, but if you don't have enough Strength, you will receive a Burden penalty. Having a Burden penalty will decrease your dodge, accuracy, and your swing speed. So it's very important to make sure you avoid having any Burden.`, 'white', line3)
			customizeEachWord(`Warrior classes naturally invest attribute points into Strength to increase their damage, so they don't have to worry as much about Burden as other classes.`, 'white', line4)
			customizeEachWord(`Rogue and Ranger classes should only invest in Strength enough to offset a burden penalty, if there is one. Daggers and leather armor is light enough to not need to invest very much Strength to offset the penalty.`, 'white', line5)
			customizeEachWord(`Because cloth armor has no weight, Mage classes only need to invest a few points into Strength to offset the burden penalty of their weapon if they have one.`, 'white', line6)
			blankSpace()
		},
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: [
			'Swing-Types',
			'Armor-Types', 
			'Damage-Types',
			'Weight'
		]
	}),
	{
		"Swing-Types": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Armor-Types": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Damage-Types": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Weight": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
	},
)
let trainingHallsCombatRoom4 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-6, //change x coord
	6, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Defense Weight and Burden`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `Attack, armor, and penetration types: 
		There are three attack types that are possible for both you and enemies: slashing, piercing, and blunt swings. Your attack type is determined by your weapon. You can check what type a weapon is by examining or inspecting it. If you swing with a weapon that has only one swing type, you will always swing that type, and your weapon's damage will be matched against the enemy's armor of that type. This works the same for an enemy attacking you. If an enemy swings at you with a slashing attack, its damage will be matched against your slashing armor: piercing attack against piercing armor, and blunt attack against blunt armor. The way in which your attack type is determined if your weapon has multiple swing types, say it's a slashing and piercing type, is random. If it's a slashing and piercing type, there is a 50/50 chance of swinging either type. If your weapon happens to have three swing types (very rare circumstances), then there would be an even split chance amongst all three types.

		Armor value: Armor value is very effective in that it prevents 1 damage per point of armor. An attack with 10 damage against an armor value of 10 would be completely negated. There is also a damage percent negation for every point of damage beyond that, making armor very effective for both you and enemies. You will eventually come across weapons, skills, and abilities that increase your armor penetration that will allow you to deal more damage to heavily armored enemies. Each point of penetration will negate the value of the coresponding type by 1. If an enemy has 10 slashing armor, and you have 5 slashing penetration, its slashing armor will be reduced to 5. The swing type is always matched against the enemy's armor type. That is to say, if an enemy has 10 slashing armor, and you have 10 slashing penetration, but your weapon swing is a blunt attack, the damage will be matched against the enemy's blunt armor, so your slashing penetration will have no effect for that swing.`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let trainingHallsCombatRoom1 = new AreaMaker( //change name
	0,
	true,
	[],
	false,
	areaIdGenerator(),
	-8, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Advanced Attributes Room`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `There are various plaques around the room with detailed information about attributes.
		There is an Attributes plaque here.
		There is a Strength plaque here.
		There is a Dexterity plaque here.
		There is an Agility plaque here.
		There is an Intelligence plaque here.
		There is a Wisdom plaque here.
		There is a Mysticism plaque here.
		There is a Constitution plaque here.
		`,
		"attributes": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			let line6 = document.createElement('div')
			let line7 = document.createElement('div')
			let line8 = document.createElement('div')
			let line9 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`ATTRIBUTES OVERVIEW`, 'yellow', line2)
			customizeEachWord(`Attributes directly influence the values of your combat and defense stats. Most attributes have a secondary benefit which is an important factor in deciding which stat you want to increase. See each individual plaque to read about their secondary benefits.`, 'white', line3)
			blankSpace()
			customizeEachWord(`Physical damage classes`, 'white', line4)
			customizeEachWord(`Strength, Dexterity, and Agility will increase your attack power by varying amounts for all weapon skill types. For example, Strength is the primary stat to increase your attack power when using two-handed weapons. Dexterity and Agility will also increase your attack power for two-handed weapons, but it requires raising them a few times before you will see an increase in attack power. To learn more about what stats influence weapon skill types, visit the Advanced Weapon Skills room.`, 'white', line5)
			blankSpace()
			customizeEachWord(`Magic damage classes`, 'white', line6)
			customizeEachWord(`Intelligence is the primary stat that increases your Spellpower for Mage classes.`, 'white', line7)
			customizeEachWord(`Mysticism is the primary stat that increases your Mysticpower which incresases the healing amount of your spells, the effectiveness of defensive spells, and the strength of magic attacks from Monks.`, 'white', line8)
			customizeEachWord(`Wisdom is the primary stat for increasing your mana resource. It also increases your Spellpower and Mysticpower by a small amount.`, 'white', line9)
			blankSpace()
		},
		"strength": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plauqe reads: `, 'white', line1)
			customizeEachWord(`STRENGTH: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`Strength `, 'white', line4)
			customizeEachWord(`reduces your `, 'white', line4)
			customizeEachWord(`burden `, 'white', line4)
			customizeEachWord(`(read burden-plaque to the east) allowing you to wear heavier armor without penalty. Each point of `, 'white', line4)
			customizeEachWord(`Strength `, 'white', line4)
			customizeEachWord(`will reduce your burden by 5.`, 'white', line4)
			blankSpace()
		},
		"dexterity": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`DEXTERITY: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`Dexterity increases your accuracy equally for all weapon types.`, 'white', line3)
			blankSpace()
		},
		"agility": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`AGILITY: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`Agility increases your dodge equally for all classes.`, 'white', line3)
			blankSpace()
		},
		"intelligence": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`INTELLIGENCE: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`There are no direct secondary benefits from Intelligence. Some non-Mage spells may benefit some from Intelligence, but that will be explicitly stated in the spell's description.`, 'white', line3)
			blankSpace()
		},
		"wisdom": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`WISDOM: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`Wisdom increases Spellpower and Mysticpower by a small amount.`, 'white', line3)
			blankSpace()
			blankSpace()
		},
		"mysticism": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`MYSTICISM: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`There are no direct secondary benefits from Mysticism.`, 'white', line3)
			blankSpace()
		},
		"constitution": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`CONSTITUTION: Secondary Benefits`, 'yellow', line2)
			customizeEachWord(`There are no direct secondary benefits from Constitution.`, 'white', line3)
			blankSpace()
			blankSpace()
		},
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: [
			'Attributes',
			'Strength', 
			'Dexterity', 
			'Agility', 
			'Intelligence', 
			'Wisdom', 
			'Mysticism', 
			'Constitution', 
		]
	}),
	{
		"Attributes": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Strength": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Dexterity": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Agility": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Intelligence": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Wisdom": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Mysticism": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Constitution": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		}
	},
)

let trainingHallsCombatRoom2 = new AreaMaker( //change name
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	-6, //change x coord
	5, //change y coord
	0,
	0,
	(descriptions = {
		areaNameClass: 'light-blue',
		areaName: `Advanced Weapon Skill Room`, //change area name
		zoneType: 'galvadia_advanced_training_rooms',
		desc: `There are various plaques around the room with detailed information about weapon skills.
		There is a Weapon-Skill plaque here.
		There is a Two-Handed weapons plaque here.
		There is a One-Handed weapons plaque here.
		There is a Daggers plaque here.
		There is a Unarmed plaque here.
		There is a Bows plaque here.
		`,
		"weapon-skill": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The plaque reads: `, 'white', line1)
			customizeEachWord(`WEAPON SKILLS OVERVIEW`, 'yellow', line2)
			customizeEachWord(`Your current weapon skill is determined by the weapons you're wielding. If you're wielding a two-handed weapon, your attacks will based on your two-handed weapon skill level. If you are wielding a single dagger or dual wielding daggers, your attacks will be based on your Daggers skill. To use the Unarmed weapon skill, you must either equip fist weapons or both hands must be empty. If you dual wield two different weapon types (you should never do this), your weapon skill will be based on the weapon you're wielding in your right hand.`, 'white', line3)
			blankSpace()
		},
		"two-handed": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`Two-handed `, 'green', line1)
			customizeEachWord(`weapon skill`, 'white', line1)
			customizeEachWord(`Attack Power: The primary attribute for raising your attack power with two-handed weapons is Strength. You will gain 1 point of attack power for each point of Strength. You will gain 1 attack power for every 4 Dexterity or Agility combined (i.e. 1 Dex and 3 Agi, 2 Dex and 2 Agi, etc).`, 'white', line2)
			customizeEachWord(`Speed: Weapon skill is the only skill that increases your attack speed making it one of the most important skills you can learn. This should be learned as high as possible before learning any other skills.`, 'white', line3)
			customizeEachWord(`Accuracy: Increasing your weapon skill level will also increase your accuracy for that skill by a small amount.`, 'white', line4)
			customizeEachWord(`Berserkers are the only class to utilize two-handed weapons. Because they wear heavy armor and are geared towards dealing damage while taking damage, Dexterity should take priority over Agility as a secondary stat. Dexterity provides an increase in accuracy for all weapon skills and Agility provides a bonus to dodge rating.`, 'white', line5)
			blankSpace()
		},
		"one-handed": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`One-handed `, 'green', line1)
			customizeEachWord(`weapon skill`, 'white', line1)
			customizeEachWord(`Attack Power: The primary attributes for raising your attack power with one-handed weapons is both Strength and Dexterity equally. You will gain 1 point of attack power for every 2 points of Strength or Dexterity combined (i.e. 1 points of Strength and 1 point of Dexterity will raise your attack power by 1). You will gain 1 attack power for every 4 points of Agility.`, 'white', line2)
			customizeEachWord(`Speed: Weapon skill is the only skill that increases your attack speed making it one of the most important skills you can learn. This should be learned as high as possible before learning any other skills.`, 'white', line3)
			customizeEachWord(`Accuracy: Increasing your weapon skill level will also increase your accuracy for that skill by a small amount.`, 'white', line4)
			customizeEachWord(`Determining which stat to raise can be situational. If you can wear the armor you want to wear without a burden penalty, then you will get more benefit from raising Dexterity. If you have any burden penalty, you will want to raise your Strength enough to negate the penalty before increasing your Dexterity. If you're a class that dual wields one-handed weapons, Dexterity is even more important because of the 10% accuracy penalty.`, 'white', line5)
			blankSpace()
		},
		"daggers": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`Daggers `, 'green', line1)
			customizeEachWord(`weapon skill`, 'white', line1)
			customizeEachWord(`Attack Power: The primary attributes for raising your attack power with Daggers is both Dexterity and Agility equally. You will gain 1 point of attack power for every 2 points of Dexterity or Agility combined (i.e. 1 points of Dexterity and 1 point of Agility will raise your attack power by 1). You will gain 1 attack power for every 4 points of Strength.`, 'white', line2)
			customizeEachWord(`Speed: Weapon skill is the only skill that increases your attack speed making it one of the most important skills you can learn. This should be learned as high as possible before learning any other skills.`, 'white', line3)
			customizeEachWord(`Accuracy: Increasing your weapon skill level will also increase your accuracy for that skill by a small amount.`, 'white', line4)
			customizeEachWord(`Rogue classes benefit well from both Dexterity and Agility. As a Rogue class, it's important to dodge attacks to mitigate damage. Rogue classes also learn skills that grant them offensive and defensive bonuses when they dodge. For this reason, Agility can be more important than Dexterity if you're not hurting for accuracy. If you can wear the armor you want to wear without a burden penalty, then you will get more benefit from raising Dexterity. Strength should only be raised to negate burden penalties, but a properly built Rogue will likely never need to increase their Strength.`, 'white', line5)
			blankSpace()
		},
		"unarmed": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`Unarmed `, 'green', line1)
			customizeEachWord(`weapon skill`, 'white', line1)
			customizeEachWord(`Attack Power: The primary attributes for raising your attack power with Unarmed is Strength, Dexterity, and Agility equally. You will gain 1 point of attack power for every 2 points of Dexterity or Agility combined (i.e. 1 points of Dexterity and 1 point of Agility will raise your attack power by 1). You will gain 1 attack power for every 4 points of Strength.`, 'white', line2)
			customizeEachWord(`Speed: Weapon skill is the only skill that increases your attack speed making it one of the most important skills you can learn. This should be learned as high as possible before learning any other skills.`, 'white', line3)
			customizeEachWord(`Accuracy: Increasing your weapon skill level will also increase your accuracy for that skill by a small amount.`, 'white', line4)
			customizeEachWord(`Rogue classes benefit well from both Dexterity and Agility. As a Rogue class, it's important to dodge attacks to mitigate damage. Rogue classes also learn skills that grant them offensive and defensive bonuses when they dodge. For this reason, Agility can be more important than Dexterity if you're not hurting for accuracy. If you can wear the armor you want to wear without a burden penalty, then you will get more benefit from raising Dexterity. Strength should only be raised to negate burden penalties, but a properly built Rogue will likely never need to increase their Strength.`, 'white', line5)
			blankSpace()
		},
		"bows": function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			blankSpace()
			customizeEachWord(`Bows `, 'green', line1)
			customizeEachWord(`weapon skill`, 'white', line1)
			customizeEachWord(`Attack Power: The primary attributes for raising your attack power with Bows is Agility and Dexterity equally. You will gain 1 point of attack power for every 2 points of Agility or Dexterity combined (i.e. 1 points of Agility and 1 point of Dexterity will raise your attack power by 1). You will gain 1 attack power for every 4 points of Strength.`, 'white', line2)
			customizeEachWord(`Speed: Weapon skill is the only skill that increases your attack speed making it one of the most important skills you can learn. This should be learned as high as possible before learning any other skills.`, 'white', line3)
			customizeEachWord(`Accuracy: Increasing your weapon skill level will also increase your accuracy for that skill by a small amount.`, 'white', line4)
			customizeEachWord(`Rangers benefit equally from the secondary benefits of Agiliy and Dexterity. As a Ranger, it's important to dodge attacks to mitigate damage. You can do this by evading and attacking enemies at range, but you'll find yourself in situations where enemies swinging at you is unavoidable. In those situations, dodging their attacks is very important. Rangers have access to skills that grant them bonuses to their offense and defense when they dodge attacks.`, 'white', line5)
			blankSpace()
		},
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: [
			'Weapon-Skill',
			'Two-Handed', 
			'One-Handed', 
			'Daggers', 
			'Bows', 
			'Unarmed', 
			'Mysticism', 
			'Constitution', 
		]
	}),
	{
		"Weapon-Skill": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Two-Handed": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"One-Handed": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Daggers": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Bows": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Unarmed": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
		"Mysticism": {
			names: ['sign'],
			color: function() {
				return 'light-green'
			},
		},
	},
)

////////////////////////////////////////////////////////OLD STARTING AREA BELOW////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////OLD STARTING AREA BELOW////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////GALVADIA FOREST////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////OLD STARTING AREA////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////OLD STARTING AREA////////////////////////////////////////////////////////////////////////////////////////
let theShallowsEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	2,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	3,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	5,
	4,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows3 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows24 = new AreaMaker(
	0,
	true,
	[],
	true,
	areaIdGenerator(),
	5,
	6,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			south: true,
			northwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows25 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	4,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows26 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows4 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows5 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows6 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	8,
	6,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows7 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	8,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade.',
		desc: 'NORTHEAST PART. There is a clover here.',
		zoneExitsBool: {
			west: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['clover']
	}),
	{
		clover: {
			names: ['clover'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					this.empty = false
				}, 900000) //15 minute respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!theShallows7.interactables.clover.empty) {
					customizeEachWord(`A blossom of clover that looks ripe for the pickins`, 'white', line1)
				} else {
					customizeEachWord(`There is no blossom to pick`, 'white', line1)
				}
			},
			color: function() {
				if (theShallows7.interactables.clover.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
	}
)
let theShallows8 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows9 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows10 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	8,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows11 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	7,
	9,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northwest: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows12 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	6,
	10,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade.',
		desc: 'NORTHEAST PART. There is a clover here.',
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['clover']
	}),
	{
		clover: {
			names: ['clover'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					this.empty = false
				}, 900000) //15 minute respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!theShallows12.interactables.clover.empty) {
					customizeEachWord(`A blossom of clover that looks ripe for the pickins`, 'white', line1)
				} else {
					customizeEachWord(`There is no clover to pick`, 'white', line1)
				}
			},
			color: function() {
				if (theShallows12.interactables.clover.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
	}
)
let theShallows13 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	10,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows14 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	9,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows15 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	5,
	8,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows16 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	4,
	10,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade.',
		desc: 'NORTHEAST PART. There is a clover here.',
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['clover']
	}),
	{
		clover: {
			names: ['clover'],
			empty: false,
			respawn: function() {
				setTimeout(() => {
					this.empty = false
				}, 900000) //15 minute respawn timer just to test
			},
			desc: function() {
				let line1 = lineFunc()
				if (!theShallows16.interactables.clover.empty) {
					customizeEachWord(`A blossom of clover that looks ripe for the pickins`, 'white', line1)
				} else {
					customizeEachWord(`There is no clover to pick`, 'white', line1)
				}
			},
			color: function() {
				if (theShallows16.interactables.clover.empty) {
					return 'white'
				} else {
					return 'green'
				}
			},
		},
	}
)
let theShallows17 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	9,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows18 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	8,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows19 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows20 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	2,
	7,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			east: true,
			south: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows21 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	2,
	6,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows22 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	3,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			northwest: true,
			east: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let theShallows23 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	4,
	5,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: 'NORTHEAST PART',
		zoneExitsBool: {
			west: true,
			east: true,
		},
		zoneType: 'the_shallows',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
theShallows1.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows2.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows3.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows4.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows5.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows6.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows7.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows8.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows9.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows7.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows11.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows12.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows13.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows14.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows15.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows16.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows17.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows18.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows19.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows20.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows21.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows22.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows23.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows24.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows25.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}
theShallows26.onEntry = function() {spawnMonsterOnEntry([{enemy: wildBoar, probability: 7}, {enemy: stag, probability: 7}, {enemy: impling, probability: 7}, {enemy: bandit, probability: 7}])}


let centralGlade = new AreaMaker(
	0,
	false,
	[kasia],
	true,
	areaIdGenerator(),
	2, //x
	0, //y
	0, //z
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `The Central Glade of Galvadia`,
		desc: `The roots extend from the central tree like tendrils. A its trunk extends through the top of the forest canopy, the crown blossoms beyond the glade itself. Bits of light that make its way through the branches cast soft spotlights around the glade. Despite the lack of direct light, the forest itself pulses a comforting amber glow.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let westGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Traveling to the west of the Glade',
		desc: 'The entrance opens up to reveal a massive glade the size of the town square. In the middle, a tree rises above the surrounding forest, its leaves spreading across the entire expanse of the glade.',
		zoneExitsBool: {
			north: true,
			northeast: false,
			east: true,
			southeast: false,
			south: true,
			west: true,
		},
		zoneChange: {
			west: function() {
				player.x = -1
				player.y = 0
				player.z = 0
			}
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let northwestGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northwestern Area Of The Glade',
		desc: 'A narrow creek winds through this part of the glade, with a small wooden bridge arching over it. The sound of water gently flowing over the rocks creates a feeling of serenity that captures the overall feel of the glade.',
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let northGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Traveling to the north side of the Glade',
		//A few birds flit between the branches overhead, their chirping a cheerful contrast to the quiet murmur of the water. The air is cool, with a faint scent of pine from the nearby forest.
		desc: `A few birds flit between the branches overhead, their chirping a gentle warning to others as your presence startles them. In the forest to the north, you catch sight of movement, possibly an animal stirring in the underbrush.`,
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let northeastGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Northeastern edge of the Glade',
		desc: `As you enter the area, you catch the brief scent of animal dung. To the north, a path opens up in the wall of trees.
		There is a sign here.`,
		zoneExitsBool: {
			north: true,
			south: true,
			southwest: true,
			west: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'brown', line1)
			customizeEachWord(`To the north is The Shallows. Beware of wild animals and other devious creatures!`, 'white', line2)
			blankSpace()
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign']
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			}
		}
	}
)

let eastGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Eastern side of the Glade',
		desc: 'This area is quieter, the sounds of the nearby creek fading into the background. A few flat stones are scattered across the ground that are often used as places to sit.',
		zoneExitsBool: {
			northwest: true,
			north: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let southeastGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Southeastern Edge Of The Glade',
		desc: 'The collection of streams all merge here into a confluence and flows out of the glade southward.',
		zoneExitsBool: {
			northwest: true,
			north: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		fishMods: {
			levelRequirement: 1,
			fishList: ['Mud Sucker', 'Leaf Perch', 'Corn Wallup'],
			mudSucker: 50,
			leafPerch: 30,
			cornWallup: 20,
			fishPicker: function() {
				let randomNumber = randomNumberRange(1, 100)
				if (randomNumber <= 50) {return mudSucker}
				if (randomNumber <= 80) {return leafPerch}
				if (randomNumber <= 100) {return cornWallup}
			}
		},
		actionWord: ['confluence']
	}),
	{
		confluence: {
			names: ['confluence'],
			color: function() {
				return 'river-blue'
			},
			desc: async function () {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`Before the creek flows deeper into the untrekkable foliage, it widens into a pond-like shape. The stream appears to pause here, its flow nearly still, before continuing as it exits the glade. You can see a variety of fish swimming below the surface.`, 'white', line1)
					blankSpace()
			},
		}
	}
)

let southGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'South Part of the Glade',
		desc: 'Several streams meander through here, many with their own little footbridges. The landscape looks like many tiny islands, each created by the winding and intercecting streams.',
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			west: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let southwestGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Southwestern Part of the Glade',
		desc: 'A creek flows through this part of the glade with a small wooden bridge arching over it. The creek splits into several smaller streams as it winds to the east.',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneType: 'galvadian_glade_center',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let entranceToGladeOfGalvadia2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-1,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Entrance to the Galvadian Forest',
		desc: 'The branches intertwine to form an arc high above the forest path.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneChange: {
			east: function() {
				player.x = 1
				player.y = 0
				player.z = 0
			}
		},
		zoneType: 'galvadian_glade_entrance',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let entranceToGladeOfGalvadia1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-2,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Entrance To The Galvadian Forest',
		desc: `Two giant trees standing opposite each other marks the start of the path. The path inward is walled by a tunnel of trees that leads to the glade.`,
		// desc: `Heading away from the glade is a tunnel of trees extending out of sight. The branches intertwine to form an arc high above the forest path. To the west is the path back to town. To the east is the Glade of Galvadia - a massive glade the size of a small town resting inside the bowl of a very shallow crater. Though the Central Glade is a safe haven, the outskirts are known to have bandits and hostile creatures skittering about.`,
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
		},
		zoneType: 'galvadian_glade_entrance',
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let outsideEntranceToGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: 'Approaching The Entrance To The Glade Of Galvadia',
		zoneType: "galvadian_glade_entrance",
		//You feel as though the forest can recognize your presence
		desc: `As you approach the glade entrance, the trees grow noticeably larger. Apart from the path behind you, your view is dominated by towering trees.`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let pathNearingEntranceToGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-4,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'Nearing the Entrance to the Glade of Galvadia',
		zoneType: "galvadia_exterior_north",
		desc: 'Looking off the path to the north, you have a spectacular view of the Training Fields far in the distance. To the south, trees obscure the view of the ground, but you can still see some of the houses in Glen Alley Grove.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let onPathToGladeOfGalvadia = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'On An Inclined Path To The Glade',
		zoneType: "galvadia_exterior_north",
		desc: `The path follows a steady incline that extends a few kilometers from the bottom of the hill to the shallow plateau where the glade entrance is.`,
		zoneExitsBool: {
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let wellWornPathToTheGlade = new AreaMaker(
	0,
	false,
	[frederickGregory],
	false,
	areaIdGenerator(),
	-6,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'At A Bend In The Road',
		zoneType: "galvadia_exterior_north",
		desc: `The road bends to the northeast, creating a small plot of land between the river and road. The water here is calm and yet flowing steadily, making it a nice spot to fish or relax. The water's surface is disturbed only by the occasional fish gulping an insect from the surface.`,
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		fishMods: {
			levelRequirement: 1,
			fishList: ['Mud Sucker', 'Leaf Perch', 'Corn Wallup'],
			mudSucker: 50,
			leafPerch: 30,
			cornWallup: 20,
			fishPicker: function() {
				let randomNumber = randomNumberRange(1, 100)
				if (randomNumber <= 50) {return mudSucker}
				if (randomNumber <= 80) {return leafPerch}
				if (randomNumber <= 100) {return cornWallup}
			}
		},
		actionWord: ['water'],
	}),
	{
		water: {
			names: ['water'],
			color: function () {
				return 'river-blue'
			},
			desc: async function () {
				let line1 = document.createElement('div')
				let line2 = document.createElement('div')
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`The water here is teeming with fish. You see a man fishing at the far edge of the bend.`, 'white', line1)
					blankSpace()
			},
		},
	}
)

let bridgeOverTheRiver = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'On the bridge overlooking the river',
		zoneType: "galvadia_exterior_north",
		desc: `The fortified river flows into the castle moat to the north, supplying all the water that flows around the castle. A few passersby stop to look over the bridge.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let castlePathNearRiver = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'By The Edge Of The River Bank Near The Bridge',
		zoneType: "galvadia_exterior_north",
		desc: ``,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let offTheCastlePath = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-2,
	0,
	0,
	(descriptions = {
		areaNameClass: dirtPath,
		areaName: 'East Castle Crossroads',
		zoneType: "galvadia_exterior_north",
		desc: `The business of the town square can be heard as you stand at the East Castle Crossroads. The eastern path is a long, dirt road that borders the castle moat. It extends past the moat up a long, steady incline toward the forest. Townspeople travel this road often to visit the glade.
		There is a sign here.`,
		zoneExitsBool: {
			northwest: true,
			east: 'locked',
			southwest: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'brown', line1)
			customizeEachWord(`Northwest: Castle`, 'white', line2)
			customizeEachWord(`East: Glade of Galvadia`, 'white', line3)
			customizeEachWord(`Southwest: Town Square`, 'white', line4)
			blankSpace()
		},
		zoneExitsLocked: {
			east: () => {
				let line1 = lineFunc()
				customizeEachWord(`You should probably visit the ${player.guild}'s Guild before doing anything else.`, 'white', line1)
			}
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)

let startingAreaEastSecretDown = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	0,
	-1,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `In a hole beneath a fallen tree`,
		desc: `Secret rooms like this will often disappear soon after you leave. You can always rediscover the entrance, so be sure to remember where and how you discovered it.`,
		zoneExitsBool: {
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaSoutheast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Southeast of the Starting Area`,
		desc: `Here you will train about stats, spells, skills, and abilities. Stats influence your skills and your skills influence your spells and abilities. Depending on your race and class, you will gain a small number of stats each time you gain a level. You will also be awarded a few stat points to allocate yourself along with some build points. Build Points are used to train your skills and abilities at a guild trainer. Guild trianers are only availble to guild members, and you can only be part of one guild. You will train more about skills and abilities once you get to a guild trainer. `,
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let startingAreaSouth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `South of the Starting Area`,
		desc: `Oh no, a blob! Don't worry, this enemy is harmless and is only here to teach you combat! Firstly, you cannot attack a enemy unless you are ENGAGED with it. Engaging is simple, and in most cases, hostile enemys will engage you automatically. If you wish to engage an enemy, you must ADVANCE, or 'ad', followed by the enemy name. Once engaged, both you and the enemy can deal damage to one another. But be careful, ranged enemies can attack you without being engaged! However, if you have the ranged skill you can do this too. Once you are engaged with an enemy, you need to ATTACK, or 'a' the enemy. Simply typing 'a' will attack the first enemy you are engaged with. If there are multiple enemies you are engaged with, you can type 'a' followed by a number to indicate which enemy in the room you wish to attack. Typing 'a' followed by the enemy name will single out that enemy and you will only attack the enemy with that name. When you are engaged, you will not be able to move until you are no longer engaged. For that to happen, you need to either kill all the enemys you are engaged with, or an easier way is to simply RETREAT As far as defense goes, you will train more about that when training your defensive skills. For now, and mostly throughout your journey, you will be using the RETREAT, or 're', command. Retreating will disengage you from all enemys in the room allowing you to perform non-combat actions again. If you retreat, the enemy will engage you again as soon as it can. If you're trying to run away, you'll probably want to use the RETREAT command followed by a direction. This will disengage you from the enemy while also moving you into another room creating more distance! This is very useful, but be careful because moving into another room might spawn another enemy for you to deal with. Go ahead and test out the commands you trained on this blob before heading to the southwest of the Starting Area.`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaSouthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	-1,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Southwest of the Starting Area`,
		desc: `Here you will train about some general game information. Monsters are encountered in hostile areas and will only have a chance of spawning when you enter that particular area, so moving from room to room will eventually cause a enemy to spawn. Monsters will also have a chance to drop a variety of items from weapons and armor to quest items. Another way to obtain items is from a shop. These will typically be found in towns and cities. You will be able to buy and sell once you find one. `,
		zoneExitsBool: {
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaWest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	0,
	0,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `West of the Starting Area`,
		desc: `A little tunnel of trees connecting the starting area glade to the main glade`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let startingAreaUp = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator,
	3,
	0,
	1,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Above the Starting Area`,
		desc: `Here you will train about how shops work.`,
		zoneExitsBool: {
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let startingAreaBelow = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	0,
	-1,
	0,
	(descriptions = {
		areaNameClass: galvadianGreen,
		areaName: `Underneath the starting area`,
		desc: `You find yourself in an underground, dirt cave. The sounds of a lightly crackling fire accompany the smell of roasting meat. an old man sits behind the fire, working something in his hands.`,
		zoneExitsBool: {
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let northTownGate = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-3,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Passing through the town gates',
		desc: `Many people travelling through the gates, to and from the castle. Citizens passing through on their way to the forest.
		There is a sign here.`,
		zoneType: "galvadia_town",
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			south: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`Northwest: Galvadian Fields`, 'white', line2)
			customizeEachWord(`Northeast: Glade of Galvadia`, 'white', line3)
			customizeEachWord(`South: Town Square`, 'white', line4)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let galvadiaTownSquareNorth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `North Side Of The Square`,
		desc: `The northern part of the square sits between the bakery shops and the blacksmith making it one of the busiest areas. Everyone heading to and from the Glade pass through here, as well as anyone making any last purchases before leaving town.`,
		zoneType: "galvadia_town",
		zoneExits: [],
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaTownSquareNorthwest = new AreaMaker(
	0,
	false,
	[benjamin],
	false,
	areaIdGenerator(),
	-11,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Town Square Bakery`,
		desc: `The bakery draws a large crowd as the only food shop in the square. Many large tables, each almost fully seated, dominate this area of the square. The sound of conversation, and clattering plates drowns out most other sounds. `,
		zoneType: "galvadia_town",
		fire: true,
		zoneExits: [],
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaTownSquareNortheast = new AreaMaker(
	0,
	false,
	[joch, clyde],
	false,
	areaIdGenerator(),
	-9,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `The Blacksmith Shop`,
		desc: `An assortment of blades and armor are on display behind the vendor stalls of the blacksmith. The heat of the furnace blows through, bringing a sweat to your brow. The smiths here are known for their crafts. You recognize the craftsmanship to be the same as much of the weapons and armor you've seen worn by castle guards.`,
		zoneType: "galvadia_town",
		zoneExits: [],
		zoneExitsBool: {
			east: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaForge = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `The Forge`,
		desc: `A large, black anvil takes up most of the area. At the back of the room is the smelter.`,
		zoneType: "galvadia_town",
		zoneExits: [],
		zoneExitsBool: {
			west: true,
		},
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaTownSquare = new AreaMaker(
	0,
	false,
	[rissah, deylani, timtim, sally, travellingWagon, strayKitty, kasia, allSkillsMan],
	false,
	areaIdGenerator(),
	-10,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Town Square Of Galvadia',
		zoneType: "galvadia_town",
		desc: `The town square is the largest and busiest area in Galvadia. The streets are full of people shopping for wares and wandering about leisurely. The sounds of children's laughter can be heard as they chase each other through the alleys. The clangs and tinks of metal echo from the blacksmith. Colorful stalls line the cobblestone paths with the largest shops at each corner of the square. The smells of smoked meat and fish in the air changes to the curious smells of brewing potions with each shift of the wind.
		There is a sign here.`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			let line5 = document.createElement('div')
			let line6 = document.createElement('div')
			let line7 = document.createElement('div')
			let line8 = document.createElement('div')
			let line9 = document.createElement('div')
			let line10 = document.createElement('div')
			let line11 = document.createElement('div')
			let line12 = document.createElement('div')
			let line13 = document.createElement('div')
			let line14 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`SHOPS `, 'white', line2)
			customizeEachWord(`Northwest: Bakery`, 'white', line3)
			customizeEachWord(`Northeast: Blacksmith and Armorsmith`, 'white', line4)
			customizeEachWord(`Southwest: Bows, Daggers, and Leathers`, 'white', line5)
			customizeEachWord(`Southeast: Magic Shop`, 'white', line6)
			customizeEachWord(`\nDIRECTIONS `, 'white', line7)
			customizeEachWord(`North: Castle Crossroads`, 'white', line8)
			customizeEachWord(`East: East Residential, Graveyard`, 'white', line9)
			customizeEachWord(`South: Guild Plaza`, 'white', line10)
			customizeEachWord(`West: Tavern, Profession Buildings`, 'white', line11)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign']
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			}
		}
	}
)
let galvadiaTownSquareEast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Side Of The Square',
		desc: `The blacksmith and magic shop stand opposite each other, north and south. Each shop is busy with Warrior's and Mage's checking out the equipment they can upgrade to. The road leading eastward grows quieter as it stretches toward the town's residential district, Glenhaven.`,
		zoneType: "galvadia_town",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCity_East2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'By The East Residential Bridge',
		desc: 'This is the only road to and from Glenhaven which serves as the main residential area. The bridge to the east is busiest in the mornings and a night when the townsfolk are flowing in and out of town.',
		zoneType: "galvadia_town",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCity_East3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'On A Bridge Overlooking The River',
		desc: 'The river flows northward, winding past the castle and continuing on far to the north until it reaches its waterfall. The river enters from the south, meandering through the canals that weave around the Guild Plaza and Town Square.',
		zoneType: "galvadia_town",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaCity_East4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Just Outside Glenhaven',
		desc: `The cobblestone street curves to the southeast, shaded completely by trees from both sides.
		There is a sign here.`,
		zoneType: "galvadia_town",
		zoneExitsBool: {
			southeast: true,
			west: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let line4 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'light-brown', line1)
			customizeEachWord(`Graveyard: SE SE SE S S S S SW SW SW W W`, 'white', line2)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let galvadia_city_east_residential_path1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down Lavish Lane',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down Lavish Lane',
		zoneExitsBool: {
			northwest: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-4,
	-7,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down Lavish Lane 2',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down Lavish Lane 2',
		zoneExitsBool: {
			northwest: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadia_residential_east_entrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-2,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North Entrance',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North Entrance',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-1,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_house_1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-1,
	-7,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'In Front Of The House Of Armastadt',
		zoneType: "galvadia_residential_east",
		desc: `The first in the row is a dark brick house with a full deck the size of a play house stage. Ornate shutters accent each window.`,
		zoneChange: {
			north: function() {
				player.x = 0
				player.y = 0
				player.z = 100
			}
		},
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaHouse1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	0,
	0,
	100,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneChange: {
			south: function() {
				player.x = -1
				player.y = -7
				player.z = 0
			}
		},
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadia_residential_east_2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	0,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	1,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	2,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_5 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	3,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_6 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	4,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_7 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	5,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_residential_east_8 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	6,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'East Residential District - North',
		zoneType: "galvadia_residential_east",
		desc: 'East Residential District - North',
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadia_city_east_residential_path3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Entrance To The East Residential Neighborhood',
		zoneType: "galvadia_residential_east",
		desc: `Around the bend to the east is a row of houses. Each house large and unique in its build.
		There is a sign here`,
		zoneExitsBool: {
			northwest: true,
			east: true,
			south: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`East: Eastern Residential District - North`, 'white', line2)
			customizeEachWord(`South: Graveyard and Eastern Residential District - South`, 'white', line3)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path5 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 2',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 2',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path6 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 3',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 3',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path7 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-3,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 4',
		zoneType: "galvadia_residential_east",
		desc: `Heading Down The South Side Of Lavish Lane 4. 
		There is a SIGN here.`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		sign: function() {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			blankSpace()
			customizeEachWord(`The sign reads: `, 'white', line1)
			customizeEachWord(`East: Eastern Residential District - South`, 'white', line2)
			customizeEachWord(`Southwest: Graveyard`, 'white', line3)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path8 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-4,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 5',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 5',
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path9 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Heading Down The South Side Of Lavish Lane 6',
		zoneType: "galvadia_residential_east",
		desc: 'Heading Down The South Side Of Lavish Lane 6',
		zoneExitsBool: {
			northeast: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path10 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'On The South Side Of Lavish Lane Nearing The Graveyard',
		zoneType: "galvadia_residential_east",
		desc: 'On The South Side Of Lavish Lane Nearing The Graveyard',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadia_city_east_residential_path11 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Just Outside The Graveyard',
		desc: 'Just Outside The Graveyard',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard1 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-8,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Graveyard Entrance',
		zoneType: "galvadia_graveyard",
		desc: 'Tall trees and fog surround the graveyard. Through the fog and tree branches, you can barely make out the top of the Guild Hall that towers high above the cemetery wall.  A straight cobblestone path goes straight ahead. Two dirt paths branch offone goes north along the graveyard wall, the other south along the river bank.',
		zoneExitsBool: {
			north: true,
			east: true,
			south: 'blocked',
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard2 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'On a Straight Path Through the Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'The graveyard is connected by cobbled pathways that extend throughout the area. To the east, you see the graveyard entrance. To the west are hundreds of grave sites.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard3 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'In The Graveyard By A Marked Grave',
		zoneType: "galvadia_graveyard",
		desc: 'To the north, you see an ivy-covered stone archway. A small, dirt path leads straight to a headstone. There are Vilolets growing on both sides of the path.',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone1 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'At A Gravestone Surrounded By Violets',
		zoneType: "galvadia_graveyard",
		desc: 'A single violet has been placed upon the gravestone.',
		zoneExitsBool: {
			south: true,
		},
		actionWord: ['headstone'],
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		headstone: {
			names: ['headstone'],
			requirement: {
				level: 4,
			},
			color: function() {
				if (gravestone1.interactables.headstone.requirement) {
					for (let requirement in gravestone1.interactables.headstone.requirement) {
						if (player[requirement] < gravestone1.interactables.headstone.requirement[requirement]) {
							return 'red'
						} else {
							return 'blue'
						}
					}
				}
			}
		}
	}
)
let graveyard4 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Northside Graveyard Junction',
		zoneType: "galvadia_graveyard",
		desc: 'You stand at a junction in the graveyard. More graves lie to the west and south. The western path extends passed several more graves before nearing the river. The path to the south leads to a gloomier side of the cemetery with larger, more entricately engraved tombs.',
		zoneExitsBool: {
			east: true,
			south: 'blocked',
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard5 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'By A Marked Grave',
		zoneType: "galvadia_graveyard",
		desc: 'To the north, you see a simple gravestone embedded into the ground. A stone pedestal stands behind it. Several objects that look like offerings have been placed upon it.',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone2 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'At A Gravestone Surrounded By Roses',
		zoneType: "galvadia_graveyard",
		desc: 'A single Rose has been placed on the tombstone.',
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard6 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Nearing The West End Of The Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'You can see the path in front of you split to the north and south. The south path rounds several dead trees before disappearing into the gloom of the south graveyard. The path to the north curves around to the east, passing by several more graves.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard7 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-14,
	-15,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Far End Of The Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'Peering into the distance, across the river, you can see the western residential area of Galvadia. You spot a few wagons travelling up and down the road, smoke piping out of the house chimneys.',
		zoneExitsBool: {
			north: true,
			east: true,
			south: 'blocked',
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard8 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-14,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'On A Path To The North Side Of The Graveyard',
		zoneType: "galvadia_graveyard",
		desc: 'You round the graveyard path to the north, heading toward the northern row of graves.',
		zoneExitsBool: {
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard9 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Nearing A Large Dead Tree',
		zoneType: "galvadia_graveyard",
		desc: 'In the northwest corner of the graveyard stands a large, leafless tree.',
		zoneExitsBool: {
			north: true,
			east: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone3 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'Beneath A Large Tree',
		zoneType: "galvadia_graveyard",
		desc: `You stand just beneath a massive tree. It is completely leafless. Other than that, it appears to be very healthy. There is an archway in the roots that look like a door leading into it.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard10 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'graveyard',
		areaName: 'North Graveyard Path',
		zoneType: "galvadia_graveyard",
		desc: 'You pass by a gated portion of the graveyard to the south. To the west, the end of the path is marked by a large tree. A decorated gravestone lies just to the east.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard11 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'On The North Graveyard Path',
		zoneType: "galvadia_graveyard",
		desc: 'A little farther beyond the graveyard fence is the enormous walls of the Guild Halls that separates the two. You think you see a shadowy figure dart behind one of the nearby graves.',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone4 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'At A Gravestone',
		zoneType: "galvadia_graveyard",
		desc: `The gravestone here is huge with several engravings written in a language you can't read. The headstone and surrounding area is kept very clean. It somehow feels less sullen than the other gravestones.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['gravestone']
	}),
	{
		gravestone: {
			names: ['gravestone'],
			color: function() {
				return 'sinistral-color'
			},
			desc: async function() {
				let line1 = lineFunc()
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You see a shadow sticking out from behind the gravestone. You wonder if you should search the gravestone..`, 'white', line1)
				blankSpace()
			},
			activate: async function() {
				if (!gravestone4.interactables.gravestone.isQuestComplete) {
				let line1 = lineFunc()
				await dialogueWait(200)
				blankSpace()
				customizeEachWord(`You search around the gravestone and find a `, 'white', line1)
				customizeEachWord(`Shadowy Figure `, 'shadowyDealer-name', line1)
				customizeEachWord(`lurking behind it. `, 'white', line1)
				blankSpace()
				npcAddToRoom(currentArea, shadowyDealer)
				gravestone4.interactables.gravestone.isQuestComplete = true
				} else {
					let line1 = lineFunc()
					await dialogueWait(200)
					blankSpace()
					customizeEachWord(`You take a look around the gravestone, but find nothing noteworthy. `, 'white', line1)
					blankSpace()
				}
			}
		}
	}
)
let graveyard12 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Between Gravesites On The North Graveyard Path',
		zoneType: "galvadia_graveyard",
		desc: 'Off the path and far ahead, you see shadowy figures moving hastely together.',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard13 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-13,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone5 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard14 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-8,
	-14,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			south: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard15 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-8,
	-16,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard16 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			northeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard17 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard18 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard19 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-16,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard20 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard21 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-17,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard26 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-14,
	-16,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard22 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard23 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-19,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone7 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-11,
	-20,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard24 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-12,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone6 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-13,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let graveyard25 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-10,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Nearing',
		zoneType: "galvadia_graveyard",
		desc: 'Just Outside The Residential District',
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let gravestone8 = new AreaMaker(
	0,
	false,
	[],
	true,
	areaIdGenerator(),
	-9,
	-18,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Tombstone',
		zoneType: "galvadia_graveyard",
		desc: "Just Outside The Residential District - tombstone with markings of the Sinistral's Guild",
		zoneExitsBool: {
			west: true,
		},
		actionWord: ['tombstone'],
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	}),
	{
		tombstone: {
			names: ['tombstone'],
			requirement: {
				playerClass: 'Sinistral',
				playerGuidl: 'Sinistral',
			},
			color: function() {
				return 'sinistral-color'
			},
			desc: function() {
				let doesPlayerHaveJewel = pushItem.some(item => item.refName == 'thievesJewel')
				let line1 = lineFunc()
				if (player.guild == 'Sinistral' && !doesPlayerHaveJewel){
					customizeEachWord(`Inspecting the tombstone, you spot something shiny just under a leaf. You clear away the leaves to see an engraved jewel in the soil.`, 'white', line1)
					questItemGen(thievesJewel(currentArea))
				} else {
					customizeEachWord(`You see that the tombstone is fresh. The engraving reads, "Here lies Gulard"`, 'white', line1)
				}
			},
			activate: function() {
				quickMessage(`test`)
			}
		}
	}
)
graveyard1.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard2.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard3.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard4.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard5.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard6.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard7.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard8.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard9.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard10.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard11.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard12.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard13.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard14.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard15.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard16.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard17.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard18.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard19.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard20.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard21.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard22.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard23.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard24.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard25.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}
graveyard26.onEntry = function() {spawnMonsterOnEntry([{enemy: cultist, probability: 3}, {enemy: skeleton, probability: 3}, {enemy: giantRat, probability: 3}, {enemy: graveWorm, probability: 3}])}



let galvadiaCitySoutheast = new AreaMaker(
	0,
	false,
	[lyra, faffa],
	false,
	areaIdGenerator(),
	-9,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'The Magic Shop',
		zoneType: "galvadia_town",
		desc: 'The smell of brewing potions drifts through the air outside the Magic Shop. Mage apprentices can be seen through the windows sitting at tables studying. The outdoor stalls are hosted by a young mage weaving strange fabrics, and an unorganized yet happy looking gnome holding a staff twice his size.',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaMagicWeave = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'The Magic Weave',
		zoneType: "galvadia_town",
		desc: '',
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaTownSquareWest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Galvadia Square West',
		zoneType: "galvadia_town",
		desc: `Standing between the bakery and leatherworking shop, you can smell the rich smells of cooked meat and baked goods and hear the sounds of wood whittling and bows being strung. There are lots of Rangers and Rogues inspecting weapons to purchase.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExitsLocked: {
			west: () => quickMessage(`This direction is locked`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlleyEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Starting Down Ambler's Alley`,
		zoneType: "amblers_alley",
		desc: `The street here opens up wwide as it stretches into Ambler Alley. You can hear shouts and laughs coming from the tavern. Small groups of people cluster around the shops on the street. The joy and comradery is enticing.`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExitsLocked: {
			west: () => quickMessage(`This direction is locked`),
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlley1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'amblers-alley',
		areaName: `Ambler's Alley By The Blacksmith And Magic Weaving Professions Building`,
		zoneType: "amblers_alley",
		desc: `Ambler's Alley is filled with all manner of people from townsfolk to powerful looking figures. The gambling house attracts many as does the tavern. On each side of the road are the pforessions shops. Those leaving look eager to use their new skills to enhance their gear.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		// zoneExitsLocked: {
		// 	west: () => quickMessage(`This direction is locked`),
		// },
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlley2BlacksmithingProfessionsShop = new AreaMaker(
	0,
	false,
	[blacksmithingProfessionTrainer],
	false,
	areaIdGenerator(),
	-13,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'amblers-alley',
		areaName: `Blacksmithing Professions Shop`,
		zoneType: "amblers_alley",
		desc: `This shop is more of a workshop than a forge. There are several stations each with their own anvil and tools. You can see the teachers adjusting the posture and grip of the students to improve their striking technique.`,
		zoneExitsBool: {
			south: true,
		},
		// zoneExitsLocked: {
		// 	west: () => quickMessage(`This direction is locked`),
		// },
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlley3MagicWeavingProfessionsShop = new AreaMaker(
	0,
	false,
	[magicWeavingProfessionTrainer],
	false,
	areaIdGenerator(),
	-13,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'amblers-alley',
		areaName: `Magic Weaving Professions Shop`,
		zoneType: "amblers_alley",
		desc: `Inside the Magic Weaving shop is a tapestry of color. Students are seen practicing their weaves on the many looms before applying what they learn to weapons and armor. Scraps of string litter the ground.`,
		zoneExitsBool: {
			north: true,
		},
		// zoneExitsLocked: {
		// 	west: () => quickMessage(`This direction is locked`),
		// },
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlley4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'amblers-alley',
		areaName: `Ambler's Alley By The Leatherworking Profession Building`,
		zoneType: "amblers_alley",
		desc: `Outside the leatherworking building, you can hear the sounds of hides being tanned and the ripping and tearing of leather. Above the doorframe is a large mounted Stag head with enormous antlers.`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		// zoneExitsLocked: {
		// 	west: () => quickMessage(`This direction is locked`),
		// },
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlley5LeatherworkingProfessionsBuilding = new AreaMaker(
	0,
	false,
	[leatherworkingProfessionTrainer],
	false,
	areaIdGenerator(),
	-14,
	-4,
	0,
	0,
	(descriptions = {
		areaNameClass: 'amblers-alley',
		areaName: `Leatherworking Professions Shop`,
		zoneType: "amblers_alley",
		desc: `.`,
		zoneExitsBool: {
			south: true,
		},
		// zoneExitsLocked: {
		// 	west: () => quickMessage(`This direction is locked`),
		// },
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersAlley6 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-5,
	0,
	0,
	(descriptions = {
		areaNameClass: 'amblers-alley',
		areaName: `Standing In Front Of Ambler's Tavern`,
		zoneType: "amblers_alley",
		desc: `The large double doors of the Tavern stand before you. During the day, the doors are propped open. At night, the doors stay shut.`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneChange: {
			north: function () {
				player.x = -15
				player.y = -4
				player.z = -100
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern1 = new AreaMaker(
	0,
	false,
	[bromwelBoulderbash, telgremGreyhorn, ulfregSnagdril],
	false,
	areaIdGenerator(),
	-15,
	-4,
	-100,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Ambler's Tavern`,
		zoneType: "amblers_alley",
		desc: `Opposite the entrance against the far wall is the bar. The counter spans thirty feet with several bartenders to tend to all the customers. Nearly all the barstools are occupied. Placed around the tavern hall are dozens of large tables to accomodate groups. Even with the tavern packed, there's enough space in front of the bar to navigate to and from the seating area.
		There is a sign here.`,
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneChange: {
			south: function () {
				player.x = -15
				player.y = -5
				player.z = 0
			},
		},
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			customizeEachWord(`The sign reads:`, 'white', line1)
			customizeEachWord(`West`, 'green', line2)
			customizeEachWord(`: Lounge`, 'white', line2)
			customizeEachWord(`East: `, 'white', line3)
			customizeEachWord(`Game And Gambling Rooms`, 'white', line3)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern2 = new AreaMaker(
	0,
	false,
	[gulthradGreenbeard, seltathSilverwood, arlasSilverwood],
	false,
	areaIdGenerator(),
	-16,
	-4,
	-100,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Tavern Lounge`,
		zoneType: "amblers_alley",
		desc: `The lounge is spacious room with couch seating around the perimeter and small tables scattered around. A group of Dwarves seat one of the tables while a group of mostly Elf and Half-Elf looking mages seat a table on the far wall. There are some classic billiard games set up along with some magic games around the room.`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-16,
	-3,
	-100,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Backroom Of The Tavern`,
		zoneType: "amblers_alley",
		desc: `The backroom is for those who want to avoid the loud rambunctiousness of the main tavern hall and the lounge. The seating is more isolated to allow for private conversation. Each table has circular booth seating.`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-4,
	-100,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Bottom Landing Of The Tavern`,
		zoneType: "amblers_alley",
		desc: `Just through the doorway of the tavern hall is a large staircase leading up to the second floor.`,
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern5 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-4,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Upstairs Landing Of The Tavern`,
		zoneType: "amblers_alley",
		desc: `At the top of the stairs, the sounds of drunken chatter begins to mix with the sounds of feint cheering dotted with exasperation.`,
		zoneExitsBool: {
			north: true,
			south: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern6 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-3,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `North Hall 1`,
		zoneType: "amblers_alley",
		desc: `North Hall 1`,
		zoneExitsBool: {
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern7 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-3,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `North Hall 2`,
		zoneType: "amblers_alley",
		desc: `North Hall 2`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGameRoom1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-2,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Snail Racing Room`,
		zoneType: "amblers_alley",
		desc: `Game Room 1`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let amblersTavern8 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-3,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `North Hall 3`,
		zoneType: "amblers_alley",
		desc: `North Hall 3`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGameRoom2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-2,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Game Room 2`,
		zoneType: "amblers_alley",
		desc: `Game Room 2`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern9 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-3,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `North Hall 4`,
		zoneType: "amblers_alley",
		desc: `North Hall 4`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGameRoom3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-2,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Game Room 3`,
		zoneType: "amblers_alley",
		desc: `Game Room 3`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern10 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-3,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `North Hall 5`,
		zoneType: "amblers_alley",
		desc: `North Hall 5`,
		zoneExitsBool: {
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGameRoom4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-2,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Game Room 4`,
		zoneType: "amblers_alley",
		desc: `Game Room 4`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern11 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-5,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `South Hall 1`,
		zoneType: "amblers_alley",
		desc: `South Hall 1`,
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern12 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-5,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `South Hall 2`,
		zoneType: "amblers_alley",
		desc: `South Hall 2`,
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGamblingRoom1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-6,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Gambling Room 1`,
		zoneType: "amblers_alley",
		desc: `Gambling Room 1`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern13 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-5,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `South Hall 3`,
		zoneType: "amblers_alley",
		desc: `South Hall 3`,
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGamblingRoom2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-6,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Gambling Room 2`,
		zoneType: "amblers_alley",
		desc: `Gambling Room 2`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern14 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-5,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `South Hall 4`,
		zoneType: "amblers_alley",
		desc: `South Hall 4`,
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGamblingRoom3 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-6,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Gambling Room 3`,
		zoneType: "amblers_alley",
		desc: `Gambling Room 3`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavern15 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-5,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `South Hall 5`,
		zoneType: "amblers_alley",
		desc: `South Hall 5`,
		zoneExitsBool: {
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let amblersTavernGamblingRoom4 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-6,
	-99,
	0,
	(descriptions = {
		areaNameClass: 'amblers-tavern',
		areaName: `Gambling Room 4`,
		zoneType: "amblers_alley",
		desc: `Gambling Room 4`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true) {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaCitySouthwest = new AreaMaker(
	0,
	false,
	[dolf, todlin],
	false,
	areaIdGenerator(),
	-11,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Bows, Daggers, and Leathers Shop',
		zoneType: "galvadia_town",
		desc: 'Tanned leather is strung up all around on racks, and wood shavings litter the ground. A shopkeep looks up and gives you a nod as he continues stringing a bow without missing a beat.',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaTanner = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'The Tanner',
		zoneType: "galvadia_town",
		desc: '.',
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaTownSquareSouth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-6,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'South Of The Square Nearing The Guild Plaza Bridge',
		zoneType: "galvadia_town",
		desc: 'Just a little farther to the south is the main bridge connecting the Guild Plaza to the Town Square, with a steady stream of people to and from. Across the bridge is the Guild Plaza. The view beyond the bridge is taken up entirely by the massive buildings of the Guild Halls. ',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaSouthBridge = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-7,
	0,
	0,
	(descriptions = {
		areaNameClass: 'bridge',
		areaName: 'Crossing The Guild Plaza Bridge',
		zoneType: "galvadia_town",
		desc: `The bridge connecting the town square and guild plaza stretches across the canals. The bridge is almost as wide as it is long to accommodate the busy flow between the town square and guild plaza. A variety of wizardly clothed students to fully clad, plate armored knights occupy the bridge.`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaGuildPlaza = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'North Side Of The Guild Plaza',
		zoneType: "galvadia_guild_square",
		desc: 'The view to the south from this side of the Guild Plaza is taken up entirely by the Guild Halls that tower over the plaza from every side.',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let galvadiaGuildSquare = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: 'Guild Square',
		zoneType: "galvadia_guild_square",
		desc: 'At The very center of the plaza is a large fountain encircled by five enormous statues. Students are dotted around the fountain steps taking a rest inbetween classes.',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let rangersGuildOutside = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Outside the Ranger's Guild`,
		zoneType: "galvadia_guild_square",
		desc: `The Ranger's Guild is covered from top to bottom in thick vines.`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Entrance`,
		zoneType: "galvadia_guild_square",
		desc: `Ranger's Guild Entrance`,
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildStaircase = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			north: true,
			east: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildTilwinOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-8,
	1,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Tilwin's Office`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildStaircase2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildCommonRoom = new AreaMaker(
	0,
	false,
	[talon],
	false,
	areaIdGenerator(),
	-7,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Level 10 Room`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	4,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Level 10 Room`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let rangersGuildLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	5,
	0,
	(descriptions = {
		areaNameClass: 'ranger-color',
		areaName: `Ranger's Guild Level 30 Room`,
		zoneType: "galvadia_guild_square",
		desc: '',
		zoneExitsBool: {
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let sinistralsGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Entrance`,
		desc: `Sinistral's Guild Entrance`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
			southeast: true,
			// southeast: 'blocked',

		},
		zoneExitsLocked: {
			southeast: function() {
				quickMessage(`Only members of the Sinistral's Guild are allowed through here.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildEntranceRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Darkened Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
			east: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildOfficeHallway = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Outside Zell's Office`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildZellOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Zell's Office`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildEntranceStaircase = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Guild Staircase`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildCommonRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-11,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Sinistral's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeCommonRoom = new AreaMaker(
	0,
	false,
	[shallox],
	false,
	areaIdGenerator(),
	-7,
	-12,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			southeast: true,
			south: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-13,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Level 10 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-13,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Level 20 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildShadowbladeLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-13,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Shadowblade's Level 30 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let sinistralsGuildThiefCommonRoom = new AreaMaker(
	0,
	false,
	[vezzlethrax],
	false,
	areaIdGenerator(),
	-6,
	-11,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northeast: true,
			east: true,
			southeast: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildThiefLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-10,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief Level 10 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildThiefLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-11,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief Level 20 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildThiefLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-5,
	-12,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Thief Level 30 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsCommonRoom = new AreaMaker(
	0,
	false,
	[daggslain],
	false,
	areaIdGenerator(),
	-7,
	-10,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Common Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-9,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Level 10 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-9,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Level 20 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralsGuildAssassinsLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-6,
	-9,
	-2,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Assassin's Level 30 Room`,
		desc: `Sinistral's Guild darkened room`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let galvadiaWarriorsGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside The Warrior's Guild`,
		desc: `Outside The Warrior's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let newmageentrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Outside The Mage's Guild`,
		desc: `Outside The Mage's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let sinistralnewentrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'sinistral-color',
		areaName: `Outside The Sinistral's Guild`,
		desc: `Outside The Sinistral's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildEntrance = new AreaMaker( //possible new entrance
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Entrance Hall`,
		desc: `You stand at the top of a large staircase that extends down below into a larger common room. The walkways to the east and west cut south along the walls creating a balcony that overlooks the common room below.`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			south: true,
			// south: 'blocked',

		},
		zoneExitsLocked: {
			south: () => {
				quickMessage(`Only members of the Warrior's Guild are allowed through.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkerEntrance = new AreaMaker( //possible new entrance
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Entrance Hall`,
		desc: `Large common room of the Warrior's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: 'blocked',
			west: 'blocked',
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildDownstairsInterior2 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Main Room`,
		desc: `Large common room of the Warrior's Guild. 
		There is a sign here.`,
		zoneExitsBool: {
			northwest: true,
			northeast: true,
			east: true,
			south: true,
			west: true,
			up: true,
		},
		sign: function() {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let line4 = lineFunc()
			let line5 = lineFunc()
			customizeEachWord(`The sign reads:`, 'white', line1)
			customizeEachWord(`Northwest`, 'green', line2)
			customizeEachWord(`/`, 'white', line2)
			customizeEachWord(`Northeast`, 'green', line2)
			customizeEachWord(`: Guild Leader Offices`, 'yellow', line2)
			customizeEachWord(`East`, 'green', line3)
			customizeEachWord(`: Knight's Wing`, 'yellow', line3)
			customizeEachWord(`South`, 'green', line4)
			customizeEachWord(`: Berserker's Wing`, 'yellow', line4)
			customizeEachWord(`West`, 'green', line5)
			customizeEachWord(`: Fighter's Wing`, 'yellow', line5)
			blankSpace()
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		actionWord: ['sign'],
	}),
	{
		sign: {
			names: ['sign'],
			color: function() {
				return 'light-brown'
			},
		}
	}
)
let warriorsGuildBerserkersWingEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-13,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Wing Entrance`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersCommonRoom = new AreaMaker(
	0,
	false,
	[magvello, noviceBerserkerTrainer, apprenticeBerserkerTrainer, adeptBerserkerTrainer, skilledBerserkerTrainer],
	false,
	areaIdGenerator(),
	-10,
	-14,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Common Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			get east() {return player.level >= 10 || 'blocked'},
			get south() {return player.level >= 15 || 'blocked'},
			get west() {return player.level >= 20 || 'blocked'},
			get down() {return player.level >= 30 || 'blocked'},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
		zoneExitsLocked: {
			east: function() {quickMessage(`You must be level 10 or higher to pass through here`)},
			south: function() {quickMessage(`You must be level 15 or higher to pass through here`)},
			west: function() {quickMessage(`You must be level 20 or higher to pass through here`)},
			down: function() {quickMessage(`You must be level 30 or higher to pass through here`)},
		}
	})
)
let warriorsGuildBerserkersLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-14,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Level 10 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-15,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Level 20 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildBerserkersLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-14,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Berserker's Level 30 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let warriorsGuildFightersWingEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Wing Entrance`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersCommonRoom = new AreaMaker(
	0,
	false,
	[ragnar],
	false,
	areaIdGenerator(),
	-12,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Common Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-13,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Level 10 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Level 20 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildFightersLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Fighter's Level 30 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildKnightsWingEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Wing Entrance`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsCommonRoom = new AreaMaker(
	0,
	false,
	[greaves],
	false,
	areaIdGenerator(),
	-8,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Common Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Level 10 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-7,
	-12,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Level 20 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildKnightsLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-13,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Knight's Level 30 Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildOfficerHallNorthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Officer Hall`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildOfficerHallRagnar = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside Ragnar's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildRagnarsOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-9,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Ragnar's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildOfficerHallMagvello = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside Magvello's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildMagvellosOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-10,
	-9,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Magvello's Office`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildOfficeHallGreaves = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Outside Greave's And Velthash's Office`,
		desc: `Outside Greave's And Velthash's Office`,
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildOfficeHallVelthash = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-8,
	-10,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Velthash's Office`,
		desc: `Velthash's Office`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let warriorsGuildGreavesOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-9,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Greave's Office`,
		desc: `Greave's Office`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let warriorsGuildDownstairsInterior23 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-11,
	-1,
	0,
	(descriptions = {
		areaNameClass: 'warrior-color',
		areaName: `Warrior's Guild Main Room`,
		desc: `Large common room of the Warrior's Guild`,
		zoneExitsBool: {
			north: true,
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let monksGuildOutside = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Outside The Monk's Guild`,
		desc: `Outside The Monk's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Entrance To The Monk's Guild`,
		desc: `Entrance To The Monk's Guild`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			west: true,
			// west: 'blocked',
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildCommonRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Monk's Guild Room 1`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildBaseLevel1 = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Monk's Guild Room 1`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildSitoriaOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Sitoria's Office`,
		desc: `Sitoria's Office`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkCommonRoom = new AreaMaker(
	0,
	false,
	[delverick],
	false,
	areaIdGenerator(),
	-13,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk's Common Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-8,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk Level 10 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk Level 20 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMartialMonkLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Martial Monk Level 30 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkCommonRoom = new AreaMaker(
	0,
	false,
	[maelius],
	false,
	areaIdGenerator(),
	-13,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk Common Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			up: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-8,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk's Level 10 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk's Level 20 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildMysticMonkLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	2,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Mystic Monk's Level 30 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkCommonRoom = new AreaMaker(
	0,
	false,
	[fearecia],
	false,
	areaIdGenerator(),
	-13,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk Common Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-8,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk's Level 10 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk's Level 20 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let monksGuildElementalMonkLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	3,
	0,
	(descriptions = {
		areaNameClass: 'monk-color',
		areaName: `Elemental Monk's Level 30 Room`,
		desc: `Monk's Guild Room 1`,
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)


let guild_plaza_northwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Northwest Section Of The Guild Plaza Along The Canals`,
		desc: 'The water in the canals flow westward.',
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let guild_plaza_northeast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-9,
	-8,
	0,
	0,
	(descriptions = {
		areaNameClass: 'galvadian-green',
		areaName: `Northeast Section Of The Guild Plaza`,
		desc: 'A few small groups of students are hanging out here away from the business of the Plaza.',
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Mage Guild Entrance Corridor`,
		desc: 'Mage Guild Entrance Corridor',
		zoneType: "galvadia_guild_square",
		zoneExitsBool: {
			east: true,
			southwest: true,
			// southwest: 'blocked',
		},
		zoneExitsLocked: {
			southwest: function() {
				quickMessage(`Only members of the Mage's Guild are allowed through here.`)
			},
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCommonRoom = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Mage's Guild Common Room`,
		desc: 'Mage Guild Common Room',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildOlivandraOffice = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-12,
	0,
	0,
	(descriptions = {
		areaNameClass: 'mage-color',
		areaName: `Olivandra's Office`,
		desc: 'Mage Guild Common Room',
		zoneExitsBool: {
			north: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-10,
	0,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Quarters Entrance`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			south: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerCommonRoom = new AreaMaker(
	0,
	false,
	[gelvander],
	false,
	areaIdGenerator(),
	-13,
	-10,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Tower Common Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Level 10 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-13,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Level 20 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildPyromancerTowerLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-9,
	1,
	0,
	(descriptions = {
		areaNameClass: 'pyromancer-color',
		areaName: `Pyromancer Level 30 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-14,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Quarters Entrance`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			east: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerCommonRoom = new AreaMaker(
	0,
	false,
	[scylla],
	false,
	areaIdGenerator(),
	-14,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Tower Common Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			northwest: true,
			southwest: true,
			west: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-12,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Level 10 Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			northeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Level 20 Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildCryoMageTowerLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-15,
	-10,
	1,
	0,
	(descriptions = {
		areaNameClass: 'cryo-mage-color',
		areaName: `Cryo Mage Level 30 Room`,
		desc: `Cryo Mage Entrance`,
		zoneExitsBool: {
			southeast: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let mageGuildLightningMagusEntrance = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-12,
	-11,
	0,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Quarters Entrance`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			west: true,
			up: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerCommonRoom = new AreaMaker(
	0,
	false,
	[blasphemy],
	false,
	areaIdGenerator(),
	-12,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Common Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			northeast: true,
			east: true,
			southeast: true,
			down: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerLevel10Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-10,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Level 10 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			southwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerLevel20Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-11,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Level 20 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let mageGuildLightningMagusTowerLevel30Room = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	-11,
	-12,
	1,
	0,
	(descriptions = {
		areaNameClass: 'lightning-magus-color',
		areaName: `Lightning Magus Tower Level 30 Room`,
		desc: `Pyromancer Entrance`,
		zoneExitsBool: {
			northwest: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)

let arenaCenter = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	100,
	100,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			northwest: true,
			north: true,
			northeast: true,
			east: true,
			southeast: true,
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaNorthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	99,
	101,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			east: true,
			southeast: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaNorth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	100,
	101,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			east: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaNortheast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	101,
	101,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			south: true,
			southwest: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaEast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	101,
	100,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			south: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaSoutheast = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	101,
	99,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			northwest: true,
			north: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaSouth = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	100,
	99,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			east: true,
			west: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaSouthwest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	99,
	99,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			northeast: true,
			east: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
let arenaWest = new AreaMaker(
	0,
	false,
	[],
	false,
	areaIdGenerator(),
	99,
	100,
	0,
	0,
	(descriptions = {
		areaNameClass: 'arena',
		areaName: `ARENA`,
		desc: 'THE ARENA',
		zoneExitsBool: {
			north: true,
			east: true,
			south: true,
		},
		zoneExits: [],
		zoneExitsFunc: function () {
			let directionsArray = Object.values(this.zoneExitsBool)
			let compiledDirections = []
			for (let i = 0; i < Object.keys(this.zoneExitsBool).length; i++) {
				if (directionsArray[i] == true || directionsArray[i] == 'locked') {
					compiledDirections = `${compiledDirections} ${Object.keys(this.zoneExitsBool)[i]}`
				}
			}
			compiledDirections = compiledDirections.slice(1, compiledDirections.length)
			this.zoneExits = compiledDirections
		},
	})
)
//KEEP THIS BELOW ALL AreaMaker rooms!!!
//KEEP THIS BELOW ALL AreaMaker rooms!!!
let areaHandler = {
	get: (target, key) => {
		if (typeof target[key] === 'object' && target[key] !== null) {
			return new Proxy(target[key], handler)
		}
		return target[key]
	},
	set: (target, prop, value) => {
		target[prop] = value
	},
}
let proxy = new Proxy(currentArea, areaHandler)
//KEEP THIS BELOW ALL AreaMaker rooms!!!
//KEEP THIS BELOW ALL AreaMaker rooms!!!
////////////////////////////////ABILITIES////////////////////////////////



function help(secondCommand) {
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	let line4 = lineFunc()
	let line5 = lineFunc()
	let line6 = lineFunc()
	let line7 = lineFunc()
	let line8 = lineFunc()
	let line9 = lineFunc()
	let line10 = lineFunc()
	let line11 = lineFunc()
	let line12 = lineFunc()
	let line13 = lineFunc()
	let line14 = lineFunc()
	let line15 = lineFunc()
	if (!secondCommand) {
		customizeEachWord(`+HELP DIRECTORY+ `, 'yellow', line1)
		customizeEachWord(`To use the help directory, type HELP followed by any of the topics listed below.`, 'white', line1)
		blankSpace()
		customizeEachWord(`BASICS`, 'yellow', line13)
		customizeEachWord(` (This topic will go over every command learned with Egbert)`, 'white', line13)
		customizeEachWord(`COMBAT`, 'yellow', line3)
		customizeEachWord(`UNPACK`, 'yellow', line4)
		customizeEachWord(`PACK`, 'yellow', line5)
		customizeEachWord(`MOVEMENT / DIRECTIONS`, 'yellow', line6)
		customizeEachWord(`ADVANCE`, 'yellow', line7)
		customizeEachWord(`RETREAT`, 'yellow', line8)
		customizeEachWord(`ATTACK`, 'yellow', line9)
		customizeEachWord(`CAST`, 'yellow', line10)
		customizeEachWord(`CONJURE`, 'yellow', line11)
		customizeEachWord(`CHANNEL`, 'yellow', line12)
		customizeEachWord(`EXAMINE`, 'yellow', line14)
		customizeEachWord(`INSPECT`, 'yellow', line15)
		customizeEachWord(`COMBAT`, 'yellow', line16)
		customizeEachWord(`COMBAT`, 'yellow', line17)
		customizeEachWord(`COMBAT`, 'yellow', line18)
		customizeEachWord(`COMBAT`, 'yellow', line19)
		return
	}
	if (secondCommand == 'basics') {
		helpBasics()
		return
	}
	if (secondCommand == 'movement' || secondCommand == 'directions') {
		helpMovement()
		return
	}
	for (let skill in player) {
		if (skill.toLowerCase() == secondCommand) {
			player[skill].description()
			return
		}
	}
	blankSpace()
	customizeEachWord(`I'm sorry, but ${secondCommand} is not a valid skill to search for`, 'white', line1)
	blankSpace()
	return
}

function helpBasics() {
	let line1 = lineFunc()
	let line2 = lineFunc()
	let line3 = lineFunc()
	let line4 = lineFunc()
	let line5 = lineFunc()
	let line6 = lineFunc()
	let line7 = lineFunc()
	let line8 = lineFunc()
	let line9 = lineFunc()
	let line10 = lineFunc()
	let line11 = lineFunc()
	let line12 = lineFunc()
	let line13 = lineFunc()
	let line14 = lineFunc()
	let line15 = lineFunc()
	let line16 = lineFunc()
	let line17 = lineFunc()
	let line18 = lineFunc()
	let line19 = lineFunc()
	blankSpace()
	customizeEachWord(`BASIC COMMANDS`, 'yellow', line1)
	blankSpace()
	customizeEachWord(`MOVEMENT: `, 'yellow', line3)
	customizeEachWord(`To move in a direction, type the direction you wish to move. You can shorthand any direction instead of typing out the entire word. For even quicker movement, you can use the NumPad. For more information, use HELP MOVEMENT.`, 'white', line3)
	blankSpace()
	customizeEachWord(`EXAMINE: `, 'yellow', line4)
	customizeEachWord(`You can use the EXAMINE command (ex for short) to find out more information about an enemy, npc, or and item that's on the ground. To find out more information about an item you have equipped or in your backpack, use the INSPECT command.`, 'white', line4)
	blankSpace()
	customizeEachWord(`INSPECT: `, 'yellow', line5)
	customizeEachWord(`Use the inspect command to find out more information about any item on your person. This includes equipped armor, items in your hand, and any items in your backpack.`, 'white', line5)
	blankSpace()
	customizeEachWord(`GET: `, 'yellow', line6)
	customizeEachWord(`To pick up an item off the ground, type GET followed by any word in the item's name. You can also use the GET ALL command to pick up all the items and gold in the room.`, 'white', line6)
	blankSpace()
	customizeEachWord(`UNPACK: `, 'yellow', line7)
	customizeEachWord(`The UNPACK command will take an item out of your inventory and put it into one of your free hands. To unpack an item, type 'unpack' followed by any word in the item's name. If you have multiple items with similar names like "small hunting knife" or "small carving knife", you should type the entire name of the item to make sure you don't unpack the other item that you don't want to unpack. You can also specify the item that you want to unpack by the inventory slot number.`, 'white', line7)
	blankSpace()
	customizeEachWord(`PACK: `, 'yellow', line8)
	customizeEachWord(`Use the PACK command to put away an item that you're holding. To pack an item, you must specify whichever hand it is that's holding the item you want to pack. Use either "pack right" or "pack left" to do this.`, 'white', line8)
	blankSpace()
	customizeEachWord(`UNLOCK: `, 'yellow', line9)
	customizeEachWord(`The UNLOCK command is for attempting to unlock a locked door with a key, or with the lockpicking skill if you are a Sinistral class. To unlock a door, type 'unlock' followed by the direction of the door that is locked.`, 'white', line9)
	blankSpace()
	customizeEachWord(`SPEAK: `, 'yellow', line10)
	customizeEachWord(`You can use either SPEAK or TALK followed by the name of the person you wish to talk to (example: 'speak egbert' or 'talk egbert').`, 'white', line10)
	blankSpace()
	customizeEachWord(`SHOW QUEST: `, 'yellow', line11)
	customizeEachWord(`To see a quest that someone has available, type 'show quest'. If there are multiple people in the same room who are offering a quest, you must specify their name after the command (for example: 'show quest egbert').`, 'white', line11)
	blankSpace()
	customizeEachWord(`OFFER: `, 'yellow', line12)
	customizeEachWord(`Use the OFFER command to complete a quest while in the same room as the quest giver. If the quest requires an item, it will automatically be removed from your inventory upon completion.`, 'white', line12)
	blankSpace()
	customizeEachWord(`DON, WEAR, EQUIP: `, 'yellow', line13)
	customizeEachWord(`You can use any of DON WEAR or EQUIP to put on a piece of armor. First, you must make sure you are holding the piece of armor in either hand. Then, use DON, WEAR, or EQUIP followed by any word in the item's name. For example, to equip a "Slick Leather Tunic", you could do any of these: don slick, wear leather tunic, equip slick leather tunic. As long as you use one of the three commands followed by a word in the item's name, you will equip the item.
		A weapon is considered equipped just by holding it in either hand. You do not need to use DON WEAR or EQUIP. Once you have used UNPACK to unpack a weapon into your hand, it will be equipped.`, 'white', line13)
	blankSpace()
	customizeEachWord(`REMOVE: `, 'yellow', line14)
	customizeEachWord(`To unequip an item, use the REMOVE command followed by any word in the armor's name. You need at least one free hand to hold the armor when you remove it.`, 'white', line14)
	blankSpace()
	customizeEachWord(`ADVANCE: `, 'yellow', line15)
	customizeEachWord(`The ADVANCE or AD command is used to engage in melee combat with an enemy. This will allow you to hit an enemy with the ATTACK command.
		Note: Rangers and Mage classes do not need to advance an enemy to attack them. Bows can hit enemies without engaging in combat, and spells can hit enemies from range too.`, 'white', line15)
	blankSpace()
	customizeEachWord(`ATTACK: `, 'yellow', line16)
	customizeEachWord(`Using the ATTACK or A command will swing your weapon, or fire an arrow, at an enemy. If you are a melee class (every class except Rangers and Mages), you must be in combat with an enemy to attack. If you are a Ranger, you can attack an enemy without needing to engage it. Mages never want to use the attack command.`, 'white', line16)
	blankSpace()
	customizeEachWord(`RETREAT: `, 'yellow', line17)
	customizeEachWord(`Use the RETREAT or RE command to disengage combat from an enemy. You can also RETREAT in a direction which is a very useful tactic when fighting. To do this, use the RETREAT or RE command followed by the direction you want to retreat in (example: re e).`, 'white', line17)
	blankSpace()


}

function helpMovement() {
	let line1 = lineFunc()
	customizeEachWord(`MOVEMENT: `, 'yellow', line1)
	customizeEachWord(`To move in a direction, type the direction you wish to move. You can shorthand any direction instead of typing out the entire word. For even quicker movement, you can use the NumPad.`, 'white', line1)
	quickMessage(`All possible directions (shorthand): NW N NE E SE S SW W U (up) D (down)`)
	quickMessage(`Numpad directions:`)
	quickMessage(`NW: 7`)
	quickMessage(`N: 8`)
	quickMessage(`NE: 9`)
	quickMessage(`E: 6`)
	quickMessage(`SE: 3`)
	quickMessage(`S: 2`)
	quickMessage(`SW: 1`)
	quickMessage(`W: 4`)
}

// function abilityWeaponsCheck(weaponTypes, weapon1, weapon2) {
// 	if (weapon1 != undefined) {return false}
// 	if (weapon2 != undefined) {return false}
// 	if (weapon1 == undefined && getWeapon1().skillUsed == 'twoHanded') {
// 		let line1 = lineFunc()
// 		customizeEachWord(`You cannot perform this ability with these weapons`, 'white', line1)
// 		return true	
// 	}
// 	if (weapon2 != undefined) {
// 		if (weaponTypes.some(types => weapon2.skillUsed.includes(types))) {return false}
// 	}
// 	else {
// 		let line1 = lineFunc()
// 		customizeEachWord(`You cannot perform this ability with these weapons`, 'white', line1)
// 		return true
// 	}
// }

function dualWieldAbilityTemplate(secondCommand) {
	let rightWeapon = pushItem.find(weapon => weapon.roomId == 'right hand')
	let leftWeapon = pushItem.find(weapon => weapon.roomId == 'left hand')
}

function initiateSpellConjure(spell) {
	if (spell.chambered == false) {
		spell.queued = true
		spell.flavorTextChannel()
	}
}

// function initiateAbilityWindup(ability) {
// 	if (ability.onCooldown != true) {
// 		ability.queued = true
// 		let count = ability.windUp
// 		const abilityInterval = setInterval(() => {
// 			if (count <= 0) {
// 				ability.queued = false
// 				clearInterval(abilityInterval)
// 			}
// 			count--
// 			if (count <= 0 && ability.onCooldown != true) {
// 				ability.queued = false
// 			}
// 		}, 1000)
// 	}
// }
function initiateAbilityWindup(ability) {
	const conjureBar = document.querySelector('.bar-1')
	conjureBar.classList.add('warrior-resource-bar')
	let windUpTime = Math.floor(ability.windUp * 1000)
	let remainingTime = windUpTime
	let width = 0
	if (ability.onCooldown != true) {
		player.warriorAbilityQueue = true
		ability.queued = true
		const intervalId = setInterval(() => {
			if (remainingTime <= -1) {
				player.warriorAbilityQueue = false
				ability.queued = false
				conjureBar.style.width = 0
				clearInterval(intervalId)
				return
			}
			width = ((windUpTime - remainingTime) / windUpTime) * 100
			conjureBar.style.width = `${width}%`
			remainingTime -= 10
		}, 10)
	}
}
function initiateTimedAbility(ability) {
	const conjureBar = document.querySelector('.bar-1')
	conjureBar.classList.add('ranger-resource-bar')
	let windUpTime = Math.floor(ability.windUp * 1000)
	let remainingTime = windUpTime
	let width = 0
	if (ability.onCooldown == false && ability.queued == false) {
		ability.queued = true
		const intervalId = setInterval(() => {
			if (remainingTime <= -1) {
				player.warriorAbilityQueue = false
				ability.queued = false
				conjureBar.style.width = 0
				clearInterval(intervalId)
				return
			}
			width = ((windUpTime - remainingTime) / windUpTime) * 100
			conjureBar.style.width = `${width}%`
			remainingTime -= 10
		}, 10)
	}
}
function releaseTimedAbility(ability) {
	const conjureBar = document.querySelector('.bar-1')
	let windUpTime = Math.floor(ability.windUp * 1000)
	let remainingTime = windUpTime
	let width = 0
	if (ability.onCooldown == false && ability.queued == false) {
		ability.queued = true
		const intervalId = setInterval(() => {
			if (remainingTime <= -1) {
				player.warriorAbilityQueue = false
				ability.queued = false
				conjureBar.style.width = 0
				clearInterval(intervalId)
				return
			}
			width = ((windUpTime - remainingTime) / windUpTime) * 100
			conjureBar.style.width = `${width}%`
			remainingTime -= 10
		}, 10)
	}
}

function initiateAbilityCooldown(ability) {
	if (ability.hasOwnProperty('windUp')) {
		let line1 = lineFunc()
		customizeEachWord(`You burn the energy that you gathered for `, 'white', line1)
		customizeEachWord(`${ability.name} `, ability.color, line1)
		customizeEachWord(`and must wait `, 'white', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${ability.cooldownSet / 1000}`, 'yellow', line1)
		customizeEachWord(`] seconds`, 'white', line1)
		player.isAbilityQueued = false
		ability.queued = false
		blankSpace()
	}
	const cooldownBar = document.querySelector('.bar-1')
	cooldownBar.style.width = '100%'
	let castTime = ability.cooldown
	let remainingTime = castTime
	ability.onCooldown = true
	ability.queued = false
	const abilityInterval = setInterval(() => {
		if (remainingTime <= 0) {
			ability.onCooldown = false
			ability.cooldown = ability.cooldownSet
			cooldownBar.style.width = 0
			clearInterval(abilityInterval)
		} else {
		let width = (remainingTime / ability.cooldownSet) * 100
		cooldownBar.style.width = `${width}%`
		ability.cooldown -= 10
		remainingTime -= 10
		}
	}, 10)
}

function sinistralAbilities(ability, weaponUsed, targetEnemy) {
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (!targetEnemy) {
		quickMessage(`There is no enemy for you to attack`)
		return
	}
	stealthBreak()
	player.combat = true
	targetEnemy.combat = true
	let hitChance = playerAbilityHitChance(targetEnemy)
	player.isAbilityQueued = false
	ability.queued = false
	resourceConsumed(ability)
	if (hitChance == false) {
		ability.flavorTextMiss(targetEnemy, weaponUsed)
	} else if (hitChance == true) {
		console.log(ability, ' ABILITY')
		let baseDamage = player[ability.refName].damage(targetEnemy)
		let penetrationType = calculatePenetrationRoll()
		let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
		let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
		let damageBlocked = baseDamage - damageAfterArmor
		ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
		applyDamageToEnemy(targetEnemy, damageAfterArmor)
		if (ability.debuff) {applyDebuff(targetEnemy, ability.debuff)}
		if (ability.refName == 'bane') {
			if (targetEnemy.debuffs?.poison) {
				let weapon1 = getWeapon1()
				let weapon2 = getWeapon2()
				// let weaponArray = [weapon1, weapon2]
				applyEnchantmentToWeapon(weapon1, weapon2, targetEnemy.debuffs.poison)
				removeDebuff(targetEnemy, targetEnemy.debuffs.poison)
			}
		}

		if (ability.refName == 'guillotine') {
			if (targetEnemy.health <= 0) {
				if (targetEnemy?.debuffs?.sinisterMark) {
					let adrenalineGained = targetEnemy.debuffs.sinisterMark.stacks * player.sinisterMark.adrenalineBonus()
					ability.flavorTextAdrenalineGain()
					resourceGained(ability, adrenalineGained, 'maxAdrenaline')
				}
			}
		}
		if (ability.refName == 'ambush') {
			if (targetEnemy.health <= 0) {
				ability.flavorTextSpecial()
				player.isStealthed = true
			}
		}

	}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	applyRetreatPenalty(ability)
	updateScroll()
}
function applyRetreatPenalty(ability) {
	player.debuffMods.retreatTimer = ability.cooldownSet / 1000
	let remainingTime = ability.cooldownSet
	const abilityInterval = setInterval(() => {
		if (remainingTime <= 0) {
			player.debuffMods.retreatTimer = 0
			clearInterval(abilityInterval)
		} else {
		player.debuffMods.retreatTimer = player.debuffMods.retreatTimer - 0.01
		remainingTime -= 10
		// console.log(player.debuffMods.retreatTimer)
		}
	}, 10)
}

function stealthBreak() {
	if (player.isStealthed) {
		player.isStealthed = false
		player.stealth.flavorTextStealthBreak()
		applyBuff(player.stealth.buff)
	}
}

function chargeEffect() {
	if (player.charge.level == player.charge.maxLevel) {return}
	applyBuff(player.charge.buff)
}
function chargeFunction(secondCommand) {
	let targetMonster = pushMonster.find(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
	chargeEffect()
	if (player.charge.level == 0) {
		quickMessage(`You have not learned the charge skill`)
	} else if (player.combat == true) {
		// handleInputs('attack')
		attack()
	} else if (targetMonster != undefined && player.combat == false) {
		let line1 = document.createElement('div')
		player.combat = true
		targetMonster.combat = true
		player.charge.cooldown = player.charge.cooldownSet
		customizeEachWord(`Letting out a thundering battlecry, you charge the ${targetMonster.name}!`, 'white', line1)
		// handleInputs('attack')
		attack()
	} else {
		quickMessage(`Charge function not working properly`)
	}
}


function buildUpThenRelease(targetByFirst, targetByNumber, targetByName, targetsName) {
	let target
	if (targetByFirst != undefined) {
		target = targetByFirst
	} else if (targetByNumber != undefined) {
		target = targetByNumber
	} else if (targetByName != undefined) {
		target = targetByName
	} else if (targetsName != undefined) {
		target = targetsName
	}
	console.log(target)
	if (player.buildUpThenRelease && target != undefined) {
		if (target.buildUpCount == undefined) {
			target.buildUpCount = 1
		} else {
			target.buildUpCount++
		}
		if (target.buildUpCount % 5 == 0) {
			quickMessage(`Every 4th attack is double attacking`)
			setTimeout(() => {
				if (target.health > 0) {
					attack()
				}
			}, 100)
		}
	}
}
function stealthAbility() {
	if (player.stealth.level == 0) {
		quickMessage(`You must be trained in stealth in order to hide`)
		return
	}
	const areThereMonsters = pushMonster.some(enemy => enemy.x == player.x && enemy.y == player.y && enemy.z == player.z)
	let stealth = player.stealth
	if ((!areThereMonsters || player.stealth.level >= 5) && player.isStealthed == false) {
		player.isStealthed = true
		let line1 = document.createElement('div')
		let line2 = document.createElement('div')
		combatCount(stealth.cooldown())
		customizeEachWord(`You are now hidden. `, 'gray', line1)
		customizeEachWord(`Seconds until you can act [`, 'white', line2)
		customizeEachWord(`${stealth.cooldown()}`, 'yellow', line2)
		customizeEachWord(`]`, 'white', line2)
		blankSpace()
	} else if (player.isStealthed == true) {
		quickMessage(`You are already hidden!`)
	} else {
		quickMessage(`You cannot hide with enemies in the room!`)
	}
}

// function block() {
// 	let line1 = document.createElement('div')
// 	let playerShield = pushItem.find(shield => shield.roomId == 'right hand' || shield.roomId == 'left hand')
// 	if (player.block.level == 0) {
// 		customizeEachWord(`You do not know the `, 'white', line1)
// 		customizeEachWord(`Block `, 'green', line1)
// 		customizeEachWord(`skill`, 'white', line1)
// 	} else if (playerShield != undefined) {
// 		quickMessage(`You throw up your shield to block the next attack`)
// 		player.blocking = true
// 		let blockTimeout = setTimeout(() => {
// 			if (player.blocking == true) {
// 				player.blocking = false
// 				quickMessage(`You lower your shield`)
// 			} else {
// 				clearTimeout(blockTimeout)
// 			}
// 		}, 5000)
// 	} else {
// 		quickMessage(`You must be wielding a shield to use this ability!`)
// 	}
// }

// function enemyBlockCheck() {
// 	if (player.blocking == true) {
// 		let playerShield = pushItem.find(shield => shield.roomId == 'right hand' || shield.roomId == 'left hand')
// 	}
// }

function unhide() {
	if (player.isStealthed == true) {
		player.isStealthed = false
		quickMessage(`You are no longer hidden`)
	} else {
		quickMessage(`You are already not hidden`)
	}
}

function eat(secondCommand) {
	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack')
	let foodItem
	if (isNaN(secondCommand)) {
		foodItem = allItemsInBackpack.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	}else if (!isNaN(secondCommand)) {
		foodItem = allItemsInBackpack.filter(item => item.roomId == 'backpack')[secondCommand - 1]
	}
	if (!foodItem) {
	quickMessage(`You do not have that in your backpack to eat`)
	return
	} else if (!foodItem.type.food) {
		quickMessage(`You cannot eat that!`)
		return
	}
	let line1 = lineFunc()
	if (foodItem.type.food) {
		customizeEachWord(`You ate a `, 'white', line1)
		customizeEachWord(`${foodItem.name}`, foodItem.color, line1)
		applyBuff(foodItem.buff)
		player.rest.healthBonus = foodItem.buff.healthBonus
		player.rest.manaBonus = foodItem.buff.manaBonus
		setTimeout(() => {
			player.rest.healthBonus = 0
			player.rest.manaBonus = 0
			quickMessage(`You are no longer full`)
		}, foodItem.buff.duration)
		let foodIndex = pushItem.indexOf(foodItem)
		pushItem.splice(foodIndex, 1)
		player.backpack.splice(foodIndex, 1)
	} else if (foodItem.type.food) {
		customizeEachWord(`You ate a `, 'white', line1)
		customizeEachWord(`${foodItem.name}`, foodItem.color, line1)
		applyBuff(foodItem.buff)
		player.rest.healthBonus = foodItem.buff.healthBonus
		player.rest.manaBonus = foodItem.buff.manaBonus
		setTimeout(() => {
			player.rest.healthBonus = 0
			player.rest.manaBonus = 0
			quickMessage(`You are no longer full`)
		}, foodItem.buff.duration)
		let foodIndex = pushItem.indexOf(foodItem)
		pushItem.splice(foodIndex, 1)
		player.backpack.splice(foodIndex, 1)
	}
}

function playerAbilityHitChance(monster) {

	let playerLevel = player.level
	let playerAccuracy = player.currentWeaponSkill.accuracy
	let monsterLevel = monster.level
	let monsterDodge = monster.dodge
	let hitChance = playerLevel + playerAccuracy - (monsterDodge + monsterLevel) + 75 <= 0 ? 0 : playerLevel + playerAccuracy - (monsterDodge + monsterLevel) + 75 >= 100 ? 100 : playerLevel + playerAccuracy - (monsterDodge + monsterLevel) + 75
	console.log(hitChance, ' PLAYER HIT CHANCE')
	if (hitChance >= randomNumberRange(1, 100)) {
		return true
	} else {
		return false
	}
}

function smokeBombFunction() {
	let allEnemies = getAllEnemiesInRoom()
	let ability = player.smokeBomb
	player.combat = false
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	for (let i = 0; i < allEnemies.length; i++) {
		allEnemies[i].combat = false
	}
	quickMessage(`POOF`)
	resourceConsumed(ability)
}

function ambushFunction(secondCommand, thirdCommand) {
	if (!player.isStealthed) {
		quickMessage(`You must be stealthed in order to use this ability!`)
		return
	}
	let ability = player.ambush
	let weapon1 = player.currentWeaponRight()
	let weapon2 = player.currentWeaponLeft()
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (weaponUsed[0]) {
		if (weaponUsed[0].skillUsed != 'daggers' || weaponUsed[1].skillUsed != 'daggers') {
			quickMessage(`This ability requires two daggers!`)
			return
		}
	}
	if (!player.combat && ability.cooldown == ability.cooldownSet) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} 
}

function backstabFunction(secondCommand, thirdCommand) {
	let ability = player.backstab
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? weapon1 : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (player.isStealthed || player.combat) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat or stealthed in order to use this ability`, 'white', line1)
	}
}


function guillotineFunction(secondCommand, thirdCommand) {
	let ability = player.guillotine
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (player.isStealthed || player.combat) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat or stealthed in order to use this ability`, 'white', line1)
	}
}
function venomBladeFunction(secondCommand, thirdCommand) {
	let ability = player.venomBlade
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (player.isStealthed || player.combat) {
		sinistralAbilities(ability, weaponUsed, targetEnemy)
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat or stealthed in order to use this ability`, 'white', line1)
	}
}
function contagionFunction(secondCommand, thirdCommand) {
	let ability = player.contagion
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	// let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon2 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let weaponUsed = weapon2
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityCombatCheck()) {return}
	resourceConsumed(ability)
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	const hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else {
			baseDamage = player[ability.refName].damage(targetEnemy)
			penetrationType = calculatePenetrationRoll()
			penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, player.poison)
			applyDebuff(targetEnemy, player.poison)
		}
	resourceConsumed(ability)
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function baneFunction(secondCommand, thirdCommand) {
	let ability = player.bane
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (abilityCombatCheck()) {return}
	sinistralAbilities(ability, weaponUsed, targetEnemy)
}

function shadowVenomFunction(secondCommand, thirdCommand) {
	let ability = player.shadowVenom
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? [weapon1, weapon2] : weapon1 != undefined && weapon2 == undefined ? [weapon1] : weapon1 == undefined && weapon2 != undefined ? [weapon2] : undefined
	if (actionWait()) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	console.log(weaponUsed)
	resourceConsumed(ability)
	applyEnchantmentToWeapon(weaponUsed[0], weaponUsed[1], ability.buff)
}
// function poisonFunction(secondCommand, thirdCommand) {
// 	let ability = player.poison
// 	let abilityName = ability.refName
// 	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
// 	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
// 	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
// 	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? [weapon1, weapon2] : weapon1 != undefined && weapon2 == undefined ? [weapon1] : weapon1 == undefined && weapon2 != undefined ? [weapon2] : undefined
// 	if (actionWait()) {return}
// 	if (doesPlayerHaveAbility(ability)) {return}
// 	if (abilityResourceCheck(ability)) {return}
// 	console.log(weaponUsed)
// 	resourceConsumed(ability)
// 	applyEnchantmentToWeapon(weaponUsed[0], weaponUsed[1], ability.buff)
// }

function shadowDaggersFunction(secondCommand, thirdCommand) {
	let ability = player.shadowDaggers
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	// let doesApplyShadowMark = false
	let allEnemies = getAllEnemiesInRoom()
	if (checkAvailableEnemy(allEnemies[0])) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	resourceConsumed(ability)
	// if (player.isStealthed) {
	// 	// player.isStealthed = false
	// 	doesApplyShadowMark = true
	// }
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	let enemiesInRoom = getAllEnemiesInRoom()
	let numberOfEnemiesToHit = Math.min(enemiesInRoom.length, ability.numberOfHits())
	for (let i = 0; i < numberOfEnemiesToHit; i++) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(enemiesInRoom[i], weaponUsed)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			baseDamage = player[ability.refName].damage(enemiesInRoom[i])
			penetrationType = calculatePenetrationRoll()
			penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemiesInRoom[i], baseDamage, penetrationType)
			damageBlocked = baseDamage - damageAfterArmor
			applyDebuff(enemiesInRoom[i], player.shadowMark.debuff)
			ability.flavorText(enemiesInRoom[i], weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, 0)
			applyDamageToEnemy(enemiesInRoom[i], damageAfterArmor)				
			// combatCount(weaponSkillSpeed)
			}
	}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()

}

function shadowsurgeFunction(secondCommand, thirdCommand) {
	let ability = player.shadowsurge
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = getAllEnemiesInRoom()[0]
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	resourceConsumed(ability)
	let doesPlayerShadowStep = false
	if (player.combat == false && targetEnemy) {
		player.combat = true
		targetEnemy.combat = true
		doesPlayerShadowStep = true
	}
	if (doesPlayerShadowStep) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed, doesPlayerShadowStep)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			let baseDamage = player[ability.refName].damage(targetEnemy, doesPlayerShadowStep)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, doesPlayerShadowStep)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, player.shadowMark.debuff)
			// combatCount(weaponSkillSpeed)
		}
	}
	if (!doesPlayerShadowStep) {
		let enemiesInRoom = getAllEnemiesInCombat()
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed, doesPlayerShadowStep)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			let baseRegularDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseRegularDamage, penetrationType)
			let damageBlocked = baseRegularDamage - damageAfterArmor
			ability.flavorTextRegularHit(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, doesPlayerShadowStep)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			// ability.flavorTextRegularHit(targetEnemy, weaponUsed, regularDamage, doesPlayerShadowStep)
			// applyDamageToEnemy(targetEnemy, regularDamage)
			let shadowMarkedEnemies = enemiesInRoom.filter(enemy => enemy.debuffs?.shadowMark)
			for (let i = 0; i < shadowMarkedEnemies.length; i++) {
				//THIS CALCULATES THE SHADOW MAGIC DAMAGE FROM THE CONSUMED STACKS
				let baseDamage = player[ability.refName].damage(targetEnemy, doesPlayerShadowStep)
				let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy.shadowResist, player.shadowPen)
				let damageResisted = baseDamage - damageAfterResist
				ability.flavorText(targetEnemy, weaponUsed, damageAfterResist, penetrationFlavorText, damageResisted, doesPlayerShadowStep)
				applyDamageToEnemy(targetEnemy, damageAfterResist)

				// let damageObject = calculateMagicDamage(enemy, spell)
				// let { damageBeforeMagicResist, damageAfterMagicResist, damageResisted } = damageObject
				// spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
				// applyDamageToEnemy(enemy, damageAfterMagicResist)

				let enemyStacks = shadowMarkedEnemies[i].debuffs.shadowMark.stacks
				removeDebuff(shadowMarkedEnemies[i], shadowMarkedEnemies[i].debuffs.shadowMark)
				for (let i = 0; i < enemyStacks; i++) {
					// if (player?.buffs?.shadowsurge?.stacks)
						applyBuff(player.shadowsurge.buff)
				}
				// player.buffs.shadowbane.stacks = (enemyStacks - 1)  + player.buffs.shadowbane.stacks > player.buffs.shadowbane.maxStacks() ? player.buffs.shadowbane.maxStacks() : (enemyStacks - 1) + player.buffs.shadowbane.stacks
			}
		}

	}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}

function shadowNovaFunction(secondCommand, thirdCommand) {
	let ability = player.shadowNova
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let allEnemies = getAllEnemiesInRoom()
	if (checkAvailableEnemy(allEnemies[0])) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	resourceConsumed(ability)
		let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
			// combatCount(weaponSkillSpeed)
		} else if (hitChance == true) {
			baseDamage = player[ability.refName].damage(targetEnemy)
			penetrationType = calculatePenetrationRoll()
			penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			damageBlocked = baseDamage - damageAfterArmor

			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked, 0)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)				
			// combatCount(weaponSkillSpeed)
			}
	removeBuff(player.buffs.shadowbane)
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}


function applyEnchantmentToWeapon(weapon1, weapon2, enchantBuff) {
	if (weapon1 && !weapon1.enchantment[0]) {
		let newBuff = {...enchantBuff}
		let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
		console.log(duration, ' DURATION')
		weapon1.enchantment.push(newBuff)
		newBuff.flavorTextApplyBuff()
		newBuff.timer = setTimeout(() => {
			weapon1.enchantment.splice(0, 1)
			newBuff.flavorTextWearsOff()
		}, duration)
	} else if (weapon1 && weapon1.enchantment[0]) {
		for (let i = 0; i < weapon1.enchantment.length; i++) {
			if (weapon1.enchantment[i].refName == enchantBuff.refName) {
				let updatedStacks = weapon1.enchantment[i].stacks > enchantBuff.stacks ? weapon1.enchantment[i].stacks : enchantBuff.stacks
				let newBuff = {...enchantBuff}
				let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
				console.log(duration, ' DURATION')

				clearTimeout(weapon1.enchantment[i].timer)
				weapon1.enchantment.splice(i, 1)
				weapon1.enchantment.push(newBuff)
				newBuff.stacks = updatedStacks
				newBuff.flavorTextApplyBuff()
				newBuff.timer = setTimeout(() => {
					weapon1.enchantment.splice(i, 1)
					newBuff.flavorTextWearsOff()
				}, duration)
			}
		}
	}
	if (weapon2 && !weapon2.enchantment[0]) {
		let newBuff = {...enchantBuff}
		weapon2.enchantment.push(newBuff)
		newBuff.flavorTextApplyBuff()
		let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
		console.log(duration, ' DURATION')

		newBuff.timer = setTimeout(() => {
			weapon2.enchantment.splice(0, 1)
			newBuff.flavorTextWearsOff()
		}, duration)
	} else if (weapon2 && weapon2.enchantment[0]) {
		for (let i = 0; i < weapon2.enchantment.length; i++) {
			if (weapon2.enchantment[i].refName == enchantBuff.refName) {
				let updatedStacks = weapon2.enchantment[i].stacks > enchantBuff.stacks ? weapon2.enchantment[i].stacks : enchantBuff.stacks
				let newBuff = {...enchantBuff}
				let duration = typeof(newBuff.duration) == 'function' ? newBuff.duration() : newBuff.duration
				console.log(duration, ' DURATION')

				clearTimeout(weapon2.enchantment[i].timer)
				weapon2.enchantment.splice(i, 1)
				weapon2.enchantment.push(newBuff)
				newBuff.stacks = updatedStacks
				newBuff.flavorTextApplyBuff()
				newBuff.timer = setTimeout(() => {
					weapon2.enchantment.splice(i, 1)
					newBuff.flavorTextWearsOff()
				}, duration)
			}
		}
	}




	// let weaponArray = [weapon1, weapon2]
	// if (Array.isArray(weaponArray)) {
	// 	weaponArray.forEach(weapon => {
	// 		if (!weapon.enchantment[0]) {
	// 			quickMessage(`first ran`)
	// 			let line1 = lineFunc()
	// 			customizeEachWord(`You enchant your `, 'white', line1)
	// 			customizeEachWord(`${weapon.name} `, weapon.color, line1)
	// 			customizeEachWord(`with `, 'white', line1)
	// 			customizeEachWord(`${enchantBuff.name}`, enchantBuff.color, line1)
	// 			customizeEachWord(`!`, 'white', line1)
	// 			weapon.enchantment.push(enchantBuff)
	// 			let index = weapon.enchantment.indexOf(enchantBuff)
	// 			weapon.enchantment[index].timer = setTimeout(() => {
	// 				let line1 = lineFunc()
	// 				customizeEachWord(`${enchantBuff.name} `, enchantBuff.color, line1)
	// 				customizeEachWord(`wears off first`, `white`, line1)
	// 				weapon.enchantment.splice(index, 1)
	// 			}, enchantBuff.duration)

	// 		} else {
	// 			quickMessage(`second ran`)
	// 			console.log(weapon)
	// 			weapon.enchantment.forEach((enchant, ind) => {
	// 				console.log(enchant, ' enchant')
	// 				console.log(enchantBuff, ' ENCHANT BUFF ENCHANT BUFF')
	// 				quickMessage(`Index foreach: ${ind}`)
	// 				quickMessage(`Enchant name of second application: ${enchant.name}`)
	// 				if (enchant.refName == 'poison') {
	// 					clearTimeout(enchant.timer)
	// 					let previousStacks = enchant.stacks > enchantBuff.stacks? enchant.stacks : enchantBuff.stacks
	// 					quickMessage(`You reapply ${enchantBuff.name} to your ${weapon.name}`)
	// 					let index = weapon.enchantment.indexOf(enchant)
	// 					quickMessage(`Index indexOf custom assign: ${index}`)
	// 					weapon.enchantment.splice(index, 1)
	// 					weapon.enchantment.push(enchantBuff)
	// 					enchantBuff.stacks = previousStacks
	// 					weapon.enchantment[index].timer = setTimeout(() => {
	// 						let index2 = weapon.enchantment.indexOf(enchantBuff)
	// 						let line1 = lineFunc()
	// 						customizeEachWord(`${enchantBuff.name} `, enchantBuff.color, line1)
	// 						customizeEachWord(`wears off second`, `white`, line1)
	// 						weapon.enchantment.splice(index2, 1)
	// 					}, enchantBuff.duration)
	// 				}
	// 				if (enchant.refName == 'shadowVenom') {
	// 					quickMessage(`You reapply ${enchantBuff.name} to your ${weapon.name}`)
	// 					clearTimeout(enchant.timer)
	// 					let index = weapon.enchantment.indexOf(enchant)
	// 					weapon.enchantment.splice(index, 1)
	// 					weapon.enchantment.push(enchantBuff)
	// 					weapon.enchantment[index].timer = setTimeout(() => {
	// 						let line1 = lineFunc()
	// 						customizeEachWord(`${enchantBuff.name} `, enchantBuff.color, line1)
	// 						customizeEachWord(`wears off`, `white`, line1)
	// 						weapon.enchantment.splice(index, 1)
	// 					}, enchantBuff.duration)
	// 				}
	// 			})
	// 		}
	// 	})
	
	// } else {
	// 	quickMessage(`You are not wielding the proper weapons to enchant`)
	// }
}



function abilityQueueCheck() {
		if (player.isAbilityQueued) {
			let line1 = lineFunc()
			customizeEachWord(`You are currently gathering energy for another ability!`, 'white', line1)
			updateScroll()
			return true
		} else {
			return false
		}
}

function abilityCooldownCheck(ability) {
	let isAnyAbilityOnCooldown = false
	let abilityOnCooldown = ability
	for (let property in player) {
		if (player?.[property]?.onCooldown) {
			isAnyAbilityOnCooldown = true
			abilityOnCooldown = player[property]
		}
	}
	let cooldown = abilityOnCooldown.cooldown / 1000
	if (isAnyAbilityOnCooldown) {
		let line1 = lineFunc()
		customizeEachWord(`Your abilities are still on cooldown for `, 'white', line1)
		customizeEachWord(`[`, 'white', line1)
		customizeEachWord(`${(Math.ceil(cooldown * 10) / 10).toFixed(1)}`, 'yellow', line1)
		customizeEachWord(`] `, 'white', line1)
		customizeEachWord(`seconds!`, 'white', line1)
		return true
	}
}

function abilityCombatCheck() {
	if (player.combat != true) {
		let line1 = lineFunc()
		customizeEachWord(`You must be in combat to use this ability`, 'white', line1)
		return true
	}
}
function doesPlayerHaveAbility(ability) {
	if (ability.level == 0) {
		let line1 = lineFunc()
		customizeEachWord(`You do not know this ability`, 'white', line1)
		return true
	}
}
function abilityResourceCheck(ability) {
	let line1 = lineFunc()
	if (typeof(ability.resourceCost) == 'function' && player[ability.resourceName] - ability.resourceCost() < 0) {
		blankSpace()
		customizeEachWord(`You do not have enough ${capitalizeFirstLetter(ability.resourceName)} to perform this ability`, 'white', line1)
		return true
	} else if (player[ability.resourceName] - ability.resourceCost < 0) {
		customizeEachWord(`You do not have enough ${capitalizeFirstLetter(ability.resourceName)} to perform this ability`, 'white', line1)
		blankSpace()
		return true
	}
}



function loseResource(resourceName, resourceCost) {
	player[resourceName] = player[resourceName] - resourceCost
	updateResource()
}

function resourceConsumed(ability) {
	if (typeof(ability.resourceCost) == 'function') {
		player[ability.resourceName] -= ability.resourceCost()
	} else {
		player[ability.resourceName] -= ability.resourceCost
	}
	updateResource()
}
function resourceGained(ability, amountGained, maxResource) {
	if (player[ability.resourceName] + amountGained > player[maxResource]) {
		player[ability.resourceName] = player[maxResource]
	} else {
		player[ability.resourceName] += amountGained
	}
	updateResource()
}


function gainClassResourceOnAttack(doesSwingHit) {
	if (!doesSwingHit) {
		return
	}
	let resource
	let maxResource
	let resourceGain
	if (player.guild == 'Warrior') {
		resource = 'might'
		maxResource = 'maxMight'
		resourceGain = 1
	}
	if (player.guild == 'Monk') {
		resource = 'focus'
		maxResource = 'maxFocus'
		resourceGain = 2
	}
	if (player.guild == 'Ranger') {
		resource = 'focus'
		maxResource = 'maxFocus'
		resourceGain = 3
	}
	if (player.guild == 'Sinistral') {
		resource = 'adrenaline'
		maxResource = 'maxAdrenaline'
		resourceGain = 5
	}
	player[resource] + resourceGain > player[maxResource] ? player[maxResource] : player[resource] += resourceGain
	updateResource()
}

function addSinisterMark(monster) {
	let sinisterMarks = 'sinisterMarks'
	if (player.playerClass.name == 'Thief') {
		if (monster.hasOwnProperty(sinisterMarks)) {
			if (monster.sinisterMarks != player.sinisterMarksMax) {
			monster[sinisterMarks]++
			}
		} else {
			monster[sinisterMarks] = 1
		}
	}
	console.log(`${monster.sinisterMarks} SINISTER MARKS`)
}


function abilityWindUpText(ability) {
	let line1 = lineFunc()
	customizeEachWord(`You begin gathering energy for `, 'white', line1)
	customizeEachWord(`${ability.name}`, ability.color, line1)
}

function abilityWeaponsCheck(ability, weaponUsed) {
	let weaponSkillsUsed = []
	if (Array.isArray(weaponUsed)) {
		for (let i = 0; i < weaponUsed.length; i++) {
			weaponSkillsUsed.push(weaponUsed[i].skillUsed)
		}
	}
	console.log(weaponUsed)
	if (Array.isArray(weaponUsed)) {
		if (!ability.weaponTypesUsed.some(element => weaponSkillsUsed.includes(element))) {
			let line1 = lineFunc()
			customizeEachWord(`You must be wielding the appropriate weapons to perform `, 'white', line1)
			customizeEachWord(`${ability.name}`, ability.color, line1)
			blankSpace()
			return true
		}
	} else if (!weaponUsed || !ability.weaponTypesUsed.some(element => weaponUsed.skillUsed.includes(element))) {
		let line1 = lineFunc()
		customizeEachWord(`You must be wielding the appropriate weapons to perform `, 'white', line1)
		customizeEachWord(`${ability.name}`, ability.color, line1)
		blankSpace()
		return true
	}
}

function tauntingShoutFunction() {
	let ability = player.tauntingShout
	if (ability.level > 0) {
		player.combat = true
		resourceConsumed(ability)
		let allEnemiesInRoom = getAllEnemiesInRoom()
		allEnemiesInRoom.forEach(enemy => {
			enemy.combat = true
		})
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You let out a `, 'white', line1)
		customizeEachWord(`Taunting Shout`, ability.color, line1)
		customizeEachWord(`, taunting every enemy to attack you!`, 'white', line1)
		blankSpace()
	} else {
		let line1 = lineFunc()
		customizeEachWord(`You do not know the ability `, 'white', line1)
		customizeEachWord(`Taunting Shout`, ability.color, line1)
		customizeEachWord(`.`, 'white', line1)
	}
}

function ripslashFunction(secondCommand, thirdCommand) {
	let ability = player.ripslash
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
	//windup
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				resourceConsumed(ability)
				initiateAbilityCooldown(ability)
				return
			}
			if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let numberOfSwings = ability.numberOfSwings()
				let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
				player.isAbilityQueued = false
				player[abilityName].queued = false
				resourceConsumed(ability)
				for (let i = 0; i < numberOfSwings; i++) {
					let hitChance = playerAbilityHitChance(targetEnemy)
					if (hitChance == false) {
						ability.flavorTextMiss(targetEnemy, weaponUsed)
					} else if (hitChance == true && targetEnemy.health > 0) {
					let	baseDamage = player[abilityName].damage(targetEnemy)
					let	penetrationType = calculatePenetrationRoll()
					let	penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					let	damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					let	damageBlocked = baseDamage - damageAfterArmor
					ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
					applyDamageToEnemy(targetEnemy, damageAfterArmor)
						if (targetEnemy?.debuffs?.bleed) {
							applyDebuff(targetEnemy, player.bleed)
						}
					}
				}
			} else {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(ability)
				}
			updateScroll()
		}, ability.windUp * 1000)
}

function cycloneFunction() {
		let ability = player.cyclone
		let abilityName = player.cyclone.refName
		let weaponTypesToCheck = player[abilityName].weaponTypesUsed
		let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
		let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
		let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
		if (doesPlayerHaveAbility(ability)) {return}
		if (abilityWeaponsCheck(ability, weaponUsed)) {return}
		if (abilityResourceCheck(ability)) {return}
		if (abilityCooldownCheck(ability)) {return}
		if (abilityQueueCheck(ability)) {return}
		ability.windUpText()
		player.isAbilityQueued = true
		initiateAbilityWindup(ability)
			setTimeout(() => {
				if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(ability)
					return
				}
				if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
					let meleeCombatMonsters = getAllEnemiesInCombat()
					let numberOfTargets = Math.min(ability.numberOfTargets(), meleeCombatMonsters.length)
					resourceConsumed(ability)
					console.log(numberOfTargets, ' NUMBER OF TARGETS')
					player[abilityName].queued = false
					player.isAbilityQueued = false
					ability.flavorText2(weaponUsed) //This flavor text is for abilities that hit multiple enemies
					for (let i = 0; i < numberOfTargets; i++) {
						let targetEnemy = meleeCombatMonsters[i]
						let hitChance = playerAbilityHitChance(targetEnemy)
						if (hitChance == false) {
							ability.flavorTextMiss(targetEnemy, weaponUsed)
						} else if (hitChance == true) {
							baseDamage = player[abilityName].damage(targetEnemy)
							penetrationType = calculatePenetrationRoll()
							penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
							damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
							damageBlocked = baseDamage - damageAfterArmor
							ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
							applyDamageToEnemy(targetEnemy, damageAfterArmor)
							applyDebuff(targetEnemy, player.bleed)
						}
					}
				} else {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(player[abilityName])
				}
				updateScroll()
			}, ability.windUp * 1000)
	}

function cataclysmFunction(secondCommand, thirdCommand) {
	let ability = player.cataclysm
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			let enemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(enemy)
			resourceConsumed(ability)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			if (hitChance == false) {
				ability.flavorTextMiss(enemy, weaponUsed)
			} else if (hitChance == true) {
				let allEnemiesInRoom = getAllEnemiesInRoom()
				let mainEnemyIndex = allEnemiesInRoom.indexOf(enemy)
				let additionalEnemy1
				let additionalEnemy2
				let baseDamage = ability.damage(enemy)
				let additionalEnemyBaseDamage = Math.ceil(baseDamage * 0.5)
				let penetrationType = calculatePenetrationRoll()
				let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
				let damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(enemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(enemy, damageAfterArmor)
				applyDebuff(enemy, ability.debuff)
				if (allEnemiesInRoom[2]) {
					if (mainEnemyIndex == 0) {
						//Additional enemies are the two after the main target
						additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex + 1]
						additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 2]
					} else if (mainEnemyIndex == allEnemiesInRoom.length - 1) {
						//additional enemies are the two before the main target
						additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
						additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex - 2]
					} else {
						//additional enemies are ones before and one after the main target
						additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
						additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 1]
					}
					let additionalDamage1 = calculateAbilityDamageAgainstEnemyArmor(enemy, additionalEnemyBaseDamage, penetrationType)
					let damageBlocked1 = additionalEnemyBaseDamage - additionalDamage1
					ability.specialEffect(additionalEnemy1, additionalDamage1, penetrationFlavorText, damageBlocked1)
					applyDamageToEnemy(additionalEnemy1, additionalDamage1)
					applyDebuff(additionalEnemy1, ability.debuff)
					let additionalDamage2 = calculateAbilityDamageAgainstEnemyArmor(enemy, additionalEnemyBaseDamage, penetrationType)
					let damageBlocked2 = additionalEnemyBaseDamage - additionalDamage2
					ability.specialEffect(additionalEnemy2, additionalDamage2, penetrationFlavorText, damageBlocked2)
					applyDamageToEnemy(additionalEnemy2, additionalDamage2)
					applyDebuff(additionalEnemy2, ability.debuff)
				} else if (allEnemiesInRoom[1]) {
					if (mainEnemyIndex == 0) {
						additionalEnemy1 = allEnemiesInRoom[1]
					} else if (mainEnemyIndex == 1) {
						additionalEnemy1 = allEnemiesInRoom[0]
					}
					let additionalDamage1 = calculateAbilityDamageAgainstEnemyArmor(enemy, additionalEnemyBaseDamage, penetrationType)
					let damageBlocked1 = additionalEnemyBaseDamage - additionalDamage1
					ability.specialEffect(additionalEnemy1, additionalDamage1, penetrationFlavorText, damageBlocked1)
					applyDamageToEnemy(additionalEnemy1, additionalDamage1)
					applyDebuff(additionalEnemy1, ability.debuff)
				}













			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, ability.windUp * 1000)
	}

function dualStrikeFunction(secondCommand, thirdCommand) {
	let ability = player.dualStrike
	if (player.currentWeaponRight().skillUsed != 'oneHanded' && player.currentWeaponLeft().skillUsed != 'oneHanded') {
		let line1 = lineFunc()
		customizeEachWord(`You must be dual wielding to use `, 'white', line1)
		customizeEachWord(`${ability.name}`, ability.color, line1)
		return
	}
	let timeoutInterval = ability.windUp * 1000
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName]) && (player.currentWeaponRight().skillUsed != 'oneHanded' && player.currentWeaponLeft().skillUsed != 'oneHanded')) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(targetEnemy)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			resourceConsumed(ability)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				baseDamage = player[abilityName].damage()
				penetrationType = calculatePenetrationRoll()
				penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				if (targetEnemy?.debuffs?.fury) {
					let stacks = targetEnemy.debuffs.fury.stacks
					removeDebuff(targetEnemy, targetEnemy.debuffs.fury)
					for (let i = 0; i < stacks; i++) {
						applyBuff(ability.buff)
					}
				}
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, timeoutInterval)
	}



function bladeBlitzFunction(secondCommand, thirdCommand) {
	let ability = player.bladeBlitz
	let abilityName = ability.refName
	let timeoutInterval = ability.windUp * 1000
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])	
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(ability)) {
			player[abilityName].cooldown = ability.cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && ability.cooldown == player[abilityName].cooldownSet) {
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			for (let i = 0; i < ability.numberOfSwings(); i++) {
				if (targetEnemy.health <= 0) {return}
				let hitChance = playerAbilityHitChance(targetEnemy)
				if (hitChance == false) {
					ability.flavorTextMiss(targetEnemy)
				} else if (hitChance == true) {
					baseDamage = player[abilityName].damage(targetEnemy)
					penetrationType = calculatePenetrationRoll()
					penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					damageBlocked = baseDamage - damageAfterArmor
					ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
					// if (Array.isArray(weaponUsed)) {
					// 		if (weaponUsed[0]?.enchantment) {
					// 			for (let enchant in weaponUsed[0].enchantment) {
					// 				let enchantmentDamage = weaponUsed[0].enchantment[enchant].damage(targetEnemy)
					// 				let resistType = weaponUsed[0].enchantment[enchant].resistType
					// 				let penType = weaponUsed[0].enchantment[enchant].penType
					// 				let element = weaponUsed[0].enchantment[enchant].element
					// 				let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, targetEnemy[resistType], player[penType])
					// 				let damageResisted = enchantmentDamage - damageAfterResist
					// 				weaponUsed[0].enchantment[enchant].flavorText(targetEnemy, damageAfterResist, element, damageResisted)
					// 			}
					// 		}
					// 		if (weaponUsed[1]?.enchantment) {
					// 			for (let enchant in weaponUsed[1].enchantment) {
					// 				let enchantmentDamage = weaponUsed[1].enchantment[enchant].damage(targetEnemy)
					// 				let resistType = weaponUsed[1].enchantment[enchant].resistType
					// 				let penType = weaponUsed[1].enchantment[enchant].penType
					// 				let element = weaponUsed[1].enchantment[enchant].element
					// 				let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, targetEnemy[resistType], player[penType])
					// 				let damageResisted = enchantmentDamage - damageAfterResist
					// 				weaponUsed[1].enchantment[enchant].flavorText(targetEnemy, damageAfterResist, element, damageResisted)
					// 			}
					// 		}
					// 	} else {
					// 		if (weaponUsed?.enchantment) {
					// 			for (let enchant in weaponUsed.enchantment) {
					// 				let enchantmentDamage = weaponUsed.enchantment[enchant].damage(targetEnemy)
					// 				let resistType = weaponUsed.enchantment[enchant].resistType
					// 				let penType = weaponUsed.enchantment[enchant].penType
					// 				let element = weaponUsed.enchantment[enchant].element
					// 				let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, targetEnemy[resistType], player[penType])
					// 				let damageResisted = enchantmentDamage - damageAfterResist
					// 				weaponUsed.enchantment[enchant].flavorText(targetEnemy, damageAfterResist, element, damageResisted)
					// 			}
					// 		}
					// 	}


					applyDamageToEnemy(targetEnemy, damageAfterArmor)
				}
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(player[abilityName])
		}
		resourceConsumed(ability)
		updateScroll()
	}, timeoutInterval)
}

function shredFunction(secondCommand, thirdCommand) {
	let ability = player.shred
	if (!player.currentWeaponRight().skillUsed == 'oneHanded' || !player.currentWeaponLeft().skillUsed == 'oneHanded') {
		let line1 = lineFunc()
		customizeEachWord(`You must be `, 'white', line1)
		customizeEachWord(`dual wielding `, 'yellow', line1)
		customizeEachWord(`to use `, 'white', line1)
		customizeEachWord(`${ability.name}`, ability.color, line1)
		return
	}
	let timeoutInterval = ability.windUp * 1000
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 && weapon2 ? [weapon1, weapon2] : weapon1 && !weapon2 ? weapon1 : !weapon1 && weapon2 ? weapon2 : undefined
	// if (actionWait()) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(player[abilityName])
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			resourceConsumed(ability)
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(targetEnemy)
			player[abilityName].queued = false
			player.isAbilityQueued = false
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
					baseDamage = player[abilityName].damage()
					penetrationType = calculatePenetrationRoll()
					penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
					damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
					damageBlocked = baseDamage - damageAfterArmor
					ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
					applyDamageToEnemy(targetEnemy, damageAfterArmor)
					applyDebuff(targetEnemy, ability.debuff)
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, timeoutInterval)
}



function valorStrikeFunction(secondCommand, thirdCommand) {
	let ability = player.valorStrike
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
	//windup
	setTimeout(() => {
		if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
			return
		}
		if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
			let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
			let hitChance = playerAbilityHitChance(targetEnemy)
			player.isAbilityQueued = false
			player[abilityName].queued = false
			resourceConsumed(ability)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				baseDamage = player[abilityName].damage()
				penetrationType = calculatePenetrationRoll()
				penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				applyBuff(ability.buff)
			}
		} else {
			player[abilityName].cooldown = player[abilityName].cooldownSet
			initiateAbilityCooldown(ability)
		}
		updateScroll()
	}, ability.windUp * 1000)
}

function shieldSlamFunction() {
	let ability = player.shieldSlam
	let abilityName = ability.refName
	let timeoutInterval = ability.windUp * 1000
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	console.log(weaponUsed)
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
				return
			}
			if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let allEnemiesInCombat = getAllEnemiesInCombat()
				let numberOfEnemies = allEnemiesInCombat.length
				let abilityTargetsMax = ability.numberOfTargets()
				let numberOfTargets = Math.min(numberOfEnemies, abilityTargetsMax)
				let baseDamage = player[abilityName].damage()
				let damagePerEnemy = Math.ceil(baseDamage / numberOfTargets)
				player[abilityName].queued = false
				player.isAbilityQueued = false
				ability.flavorText2(weaponUsed)
				for (let i = 0; i < numberOfTargets; i++) {
					let targetEnemy = allEnemiesInCombat[i]
					let hitChance = playerAbilityHitChance(targetEnemy)
					if (hitChance == false) {
						ability.flavorTextMiss(targetEnemy, weaponUsed)
					} else if (hitChance == true) {
						penetrationType = calculatePenetrationRoll()
						penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, damagePerEnemy, penetrationType)
						damageBlocked = damagePerEnemy - damageAfterArmor
						console.log(penetrationType)
						console.log(damageAfterArmor)
						console.log(damageBlocked)
						console.log(damagePerEnemy)
						console.log(baseDamage)
						ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(targetEnemy, damageAfterArmor)
						applyDebuff(targetEnemy, ability.debuff)
					}
				} 
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
			}
			resourceConsumed(ability)
		}, timeoutInterval)
	}

function boomingMightFunction() {
	let ability = player.boomingMight
	let abilityName = ability.refName
	let timeoutInterval = ability.windUp * 1000
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	console.log(weapon1, ' WEAPON 1')
	console.log(weapon2, ' WEAPON 2')
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	ability.windUpText()
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (player.combat == true && player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let allEnemiesInCombat = getAllEnemiesInCombat()
				let numberOfEnemies = allEnemiesInCombat.length
				let baseDamage = player[abilityName].damage()
				// let damagePerEnemy = Math.ceil(baseDamage / numberOfEnemies)
				player[abilityName].queued = false
				player.isAbilityQueued = false
				ability.flavorText2()
				allEnemiesInCombat.forEach(enemy => {
					let hitChance = playerAbilityHitChance(enemy)
					if (hitChance == false) {
						ability.flavorTextMiss(enemy)
					} else if (hitChance == true) {
						penetrationType = calculatePenetrationRoll()
						penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(enemy, baseDamage, penetrationType)
						damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(enemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(enemy, damageAfterArmor)
						applyBuff(ability.buff)
					}
				})
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(player.boomingMight)
				updateScroll()
			}
			resourceConsumed(ability)
		}, timeoutInterval)
	}
//MONK MONK MONK MONK MONK MONK MONK MONK MONK MONK
// function empoweringStrikeFunction(secondCommand, thirdCommand) {
// 	let ability = player.empoweringStrike
// 	let abilityName = player.empoweringStrike.refName
// 	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
// 	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
// 	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
// 	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
// 	if (doesPlayerHaveAbility(player[abilityName])) {return}
// 	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
// 	if (abilityResourceCheck(player[abilityName])) {return}
// 	if (abilityCooldownCheck(player[abilityName])) {return}
// 	if (abilityCombatCheck()) {return}
// 	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
// 	let hitChance = playerAbilityHitChance(targetEnemy)
// 			if (hitChance == false) {
// 				ability.flavorTextMiss(targetEnemy, weaponUsed)
// 			} else if (hitChance == true) {
// 			let totalDamage = player[abilityName].damage(weapon1, weapon2)
// 			ability.flavorText(targetEnemy, weaponUsed, totalDamage)
// 			applyDamageToEnemy(targetEnemy, totalDamage)
// 			updateScroll()
// 			}
// 	}
function catalystFunction(secondCommand, thirdCommand) {
	let ability = player.catalyst
	let abilityName = player.catalyst.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	resourceConsumed(ability)
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
		player[abilityName].damage(targetEnemy)
		updateScroll()
		}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}

function tempestFunction(secondCommand, thirdCommand) {
	let ability = player.tempest
	let abilityName = player.tempest.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	resourceConsumed(ability)
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			player[abilityName].damage(targetEnemy)
			player.catalyst.sequence = 0
		}
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function callOfWindFunctionRanged(secondCommand, thirdCommand) {
	let ability = player.callOfWind
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityCombatCheck()) {return}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	if (player.combat) {
		let line1 = lineFunc()
		customizeEachWord(`You cannot use this ability while engaged with an enemy.`, 'white', line1)
		return
	}
	let hitChance = playerAbilityHitChance(targetEnemy)
	if (hitChance == false) {
		//miss text needs to be for throwing out call of wind
		ability.flavorTextMissRanged(targetEnemy, weaponUsed)
	} else if (hitChance == true) {
		let baseDamage = player[abilityName].damageRanged(targetEnemy)
		let penetrationType = 'wind'
		let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy.windResist, player.windPen)
		let damageResisted = baseDamage - damageAfterResist
		ability.flavorTextRanged(targetEnemy, damageAfterResist, penetrationType, damageResisted)
		applyDamageToEnemy(targetEnemy, damageAfterResist)
		applyDebuff(targetEnemy, ability.debuff)
	}
	resourceConsumed(ability)
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function callOfWindFunctionCombat(secondCommand, thirdCommand) {
	let ability = player.callOfWind
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityCombatCheck()) {return}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	let targetEnemyWithDebuff = getAllEnemiesInRoom().find(enemy => enemy?.debuffs?.['callOfWind'])
	if (!targetEnemyWithDebuff) {
		let line1 = lineFunc()
		customizeEachWord(`You can only use this ability against an enemy affected with `, 'white', line1)
		customizeEachWord(`Call Of Wind`, ability.color, line1)
		customizeEachWord(`.`, 'white', line1)
		return
	}
	if (targetEnemyWithDebuff) {
		let hitChance = playerAbilityHitChance(targetEnemyWithDebuff)
		if (hitChance == false) {
			player.combat = true
			targetEnemyWithDebuff.combat = true
			ability.flavorTextMissCombat(targetEnemyWithDebuff, weaponUsed)
		} else if (hitChance == true) {
			player.combat = true
			targetEnemyWithDebuff.combat = true
			let baseDamage = player[ability.refName].damageCombat(targetEnemyWithDebuff)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemyWithDebuff, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorTextCombat(targetEnemyWithDebuff, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemyWithDebuff, damageAfterArmor)
			removeDebuff(targetEnemy, ability.debuff)
		}
		resourceConsumed(ability)
		resourceGained(ability, ability.resourceBonus(), player.maxFocus)
	} 
	ability.cooldown = ability.cooldownSet
	initiateAbilityCooldown(ability)
	updateScroll()
}
function knuckleBlitzFunction(secondCommand, thirdCommand) {
	let ability = player.knuckleBlitz
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityCombatCheck()) {return}
	let targetEnemy = targetFirstEnemy(secondCommand, thirdCommand)
	let comboCollectorStacks = player?.buffs?.comboCollector?.stacks ? player?.buffs?.comboCollector?.stacks + 1 : 1
	for (let i = 0; i < comboCollectorStacks; i++) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else {
			let baseDamage = player[abilityName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
		}
	}
	removeBuff(player.buffs.comboCollector)
	delete player.buffs.comboCollector
	resourceConsumed(ability)
	updateScroll()
}
	
function fireSealFunction(secondCommand, thirdCommand) {
	let ability = player.fireSeal
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let baseDamage = player[ability.refName].damage(targetEnemy)
				let penetrationType = calculatePenetrationRoll()
				let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				let damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				applyDebuff(targetEnemy, ability.debuff)
			}
			resourceConsumed(ability)
			updateScroll()
	}
function waterSealFunction(secondCommand, thirdCommand) {
	let ability = player.waterSeal
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, ability.debuff)
		}
		resourceConsumed(ability)
		updateScroll()	
	}
function earthSealFunction(secondCommand, thirdCommand) {
	let ability = player.earthSeal
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			applyDebuff(targetEnemy, ability.debuff)
		}
		resourceConsumed(ability)
		updateScroll()	
	}
function mysticFistFunction(secondCommand, thirdCommand) {
	let ability = player.mysticFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let numberOfSwings = 1
	for (let buff in player.buffs) {
		if (player.buffs[buff].seal) {
			numberOfSwings++
		}
	}
	for (let i = 0; i < numberOfSwings; i++) {
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[abilityName].damage(targetEnemy)
			let penetrationType = 'lightning'
			let damageAfterMagResist = calculateMagicDamageWithResist(baseDamage, targetEnemy.lightningResist, player.lightningPen)
			let damageBlocked = baseDamage - damageAfterMagResist
			ability.flavorText(targetEnemy, weaponUsed, damageAfterMagResist, penetrationType, damageBlocked)
			applyDamageToEnemy(targetEnemy, damageAfterMagResist)
			applyBuff(ability.buff)
			}
		}
		resourceConsumed(ability)
		updateScroll()	
	}
function unleashedPowerFunction(secondCommand, thirdCommand) {
	let ability = player.unleashedPower
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemies = getAllEnemiesInRoom(secondCommand, thirdCommand)
	let numberOfTargets = 1
	for (let buff in player.buffs) {
		if (player.buffs[buff].seal) {
			numberOfTargets++
		}
	}
	numberOfTargets = numberOfTargets > targetEnemies.length ? targetEnemies.length : numberOfTargets
	for (let i = 0; i < numberOfTargets; i++) {
		let hitChance = playerAbilityHitChance(targetEnemies[i])
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemies[i], weaponUsed)
		} else if (hitChance == true) {
			let baseDamage = player[abilityName].damage(targetEnemies[i])
			let penetrationType = 'lightning'
			let damageAfterMagicResist = calculateMagicDamageWithResist(baseDamage, targetEnemies[i].lightningResist, player.lightningPen)
			let damageResisted = baseDamage - damageAfterMagicResist
			ability.flavorText(targetEnemies[i], weaponUsed, damageAfterMagicResist, penetrationType, damageResisted)
			applyDamageToEnemy(targetEnemies[i], damageAfterMagicResist)
			applyBuff(ability.buff)
			}
		}
		resourceConsumed(ability)
		updateScroll()	
	}


function blazingFistFunction(secondCommand, thirdCommand) {
	let ability = player.blazingFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
	}
function tidalFistFunction(secondCommand, thirdCommand) {
	let ability = player.tidalFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
}

function quakeFistFunction(secondCommand, thirdCommand) {
	let ability = player.quakeFist
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
}

function lightningFistFunction(secondCommand, thirdCommand) {
	let ability = player.lightningFist
	let abilityName = ability.refName
	console.log(ability)
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	console.log(weaponTypesToCheck)
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let damageObject = calculateMagicDamage(targetEnemy, ability)
				let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
				ability.flavorText(targetEnemy, damageAfterMagicResist, penetrationType, damageResisted)
				applyDebuff(targetEnemy, ability.debuff)
				monkComboHandler(targetEnemy)
				applyDamageToEnemy(targetEnemy, damageAfterMagicResist)
			}
			resourceConsumed(ability)
			updateScroll()
}
function elementalTempestFunction(secondCommand, thirdCommand) {
	let ability = player.elementalTempest
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let baseDamage = player[ability.refName].damage(targetEnemy)
				let penetrationType = calculatePenetrationRoll()
				let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
				let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
				let damageBlocked = baseDamage - damageAfterArmor
				ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
				applyDamageToEnemy(targetEnemy, damageAfterArmor)
				if (targetEnemy?.debuffs?.hydroplosion) {
					//splash aoe
					let line1 = lineFunc()
					let combatEnemies = getAllEnemiesInCombat()
					let baseDamage = player[abilityName].hydroplosionDamage()
					let penetrationType = targetEnemy.debuffs.hydroplosion.element
					let enemyResistType = penetrationType == 'fire' ? 'fireResist' : 'waterResist'
					let playerPenType = penetrationType == 'fire' ? 'firePen' : 'waterPen'
					let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy[enemyResistType], player[playerPenType])
					let damageResisted = baseDamage - damageAfterResist
					applyDamageToEnemy(targetEnemy, damageAfterResist)
					customizeEachWord(`Elemental Tempest reacts with the energy from Hydroplosion!`, `monk-ability-text-color`, line1)	
					ability.flavorTextHydroplosion(targetEnemy, damageAfterResist, penetrationType, damageResisted)
					applyBuff(targetEnemy.debuffs.hydroplosion)	
					removeDebuff(targetEnemy, targetEnemy.debuffs.hydroplosion)
					delete targetEnemy.debuffs.hydroplosion
					let mainEnemyIndex = combatEnemies.indexOf(targetEnemy)
					let additionalEnemyIndex1 = mainEnemyIndex == 0 ? 2 : mainEnemyIndex - 1
					let additionalEnemyIndex2 = mainEnemyIndex + 1
					if (combatEnemies[additionalEnemyIndex2]) {
						let splitDamage = Math.ceil(baseDamage / 2)
						let damageAfterResist = calculateMagicDamageWithResist(splitDamage, combatEnemies[additionalEnemyIndex2][enemyResistType], player[playerPenType])
						let damageResisted = splitDamage - damageAfterResist
						ability.flavorTextHydroplosionAdditionalTargets(combatEnemies[additionalEnemyIndex2], damageAfterResist, penetrationType, damageResisted)
						applyDamageToEnemy(combatEnemies[additionalEnemyIndex2], damageAfterResist)
					}
					if (combatEnemies[additionalEnemyIndex1]) {
						let splitDamage = Math.ceil(baseDamage / 2)
						let damageAfterResist = calculateMagicDamageWithResist(splitDamage, combatEnemies[additionalEnemyIndex1][enemyResistType], player[playerPenType])
						let damageResisted = splitDamage - damageAfterResist
						ability.flavorTextHydroplosionAdditionalTargets(combatEnemies[additionalEnemyIndex1], damageAfterResist, penetrationType, damageResisted)
						applyDamageToEnemy(combatEnemies[additionalEnemyIndex1], damageAfterResist)
					}
				}
				if (targetEnemy?.debuffs?.thunderBlaze) {
					//combat aoe
					let line1 = lineFunc()
					customizeEachWord(`Elemental Tempest reacts with the energy from Thunder Blaze!`, `monk-ability-text-color`, line1)
					let baseDamage = player[abilityName].thunderBlazeDamage()
					let allEnemies = getAllEnemiesInCombat()
					let damageSplit = baseDamage / allEnemies.length
					for (let i = 0; i < allEnemies.length; i++) {
						let penetrationType = targetEnemy.debuffs.thunderBlaze.element
						let enemyResistType = penetrationType == 'fire' ? 'fireResist' : 'lightningResist'
						let playerPenType = penetrationType == 'fire' ? 'firePen' : 'lightningPen'
						let damageAfterResist = calculateMagicDamageWithResist(damageSplit, allEnemies[i][enemyResistType], player[playerPenType])
						let damageResisted = damageSplit - damageAfterResist
						applyDamageToEnemy(allEnemies[i], damageAfterResist)	
						ability.flavorTextThunderBlaze(allEnemies[i], damageAfterResist, penetrationType, damageResisted)
					}
					removeDebuff(targetEnemy, targetEnemy.debuffs.thunderBlaze)
					applyBuff(thunderBlazeBuff)			
					delete targetEnemy.debuffs.thunderBlaze
				}
				if (targetEnemy?.debuffs?.aquaVolt) {
					//single target
					let baseDamage = player[abilityName].aquaVoltDamage()
					let penetrationType = targetEnemy.debuffs.aquaVolt.element
					let enemyResistType = penetrationType == 'water' ? 'waterResist' : 'lightningResist'
					let playerPenType = penetrationType == 'water' ? 'waterPen' : 'lightningPen'
					let damageAfterResist = calculateMagicDamageWithResist(baseDamage, targetEnemy[enemyResistType], player[playerPenType])
					let damageResisted = baseDamage - damageAfterResist
					ability.flavorTextAquaVolt(targetEnemy, damageAfterResist, penetrationType, damageResisted)
					removeDebuff(targetEnemy, targetEnemy.debuffs.aquaVolt)
					applyBuff(aquaVoltBuff)			
					delete targetEnemy.debuffs.aquaVolt
					applyDamageToEnemy(targetEnemy, damageAfterResist)
				}
		
			}
			resourceConsumed(ability)
			updateScroll()
}

function transcendenceFunction(secondCommand, thirdCommand) {
	let ability = player.transcendence
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityQueueCheck(ability)) {return}
	//does player
	for (let buff in player.buffs) {
		if (player.buffs.hydroplosion) {
			applySkillBuff(ability.hydroplosionFire)
			if (player.buffs.hydroplosion.element == 'fire') {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.hydroplosionFire)
				ability.flavorTextHydroplosion(`a flaming avatar!`)
			} else {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.hydroplosionWater)
				ability.flavorTextHydroplosion(`a water avatar!`)
			}
			removeBuff(player.buffs[buff])
			delete player.buffs[buff]
		} 
		if (player.buffs.thunderBlaze) {
			if (player.buffs.thunderBlaze.element == 'fire') {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.thunderBlazeFire)
				ability.flavorTextThunderBlaze(`a flaming avatar!`)
			} else {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.thunderBlazeLightning)
				ability.flavorTextThunderBlaze(`a lightning avatar!`)
			}
			removeBuff(player.buffs[buff])
			delete player.buffs[buff]
		} 
		if (player.buffs.aquaVolt) {
			if (player.buffs.aquaVolt.element == 'water') {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.aquaVoltWater)
				ability.flavorTextThunderBlaze(`a water avatar!`)
			} else {
				applyWeaponEnchant([player.rightFist, player.leftFist], ability.aquaVoltLightning)
				ability.flavorTextThunderBlaze(`a lightning avatar!`)
			}
			removeBuff(player.buffs[buff])
			delete player.buffs[buff]
		} 
	}
	resourceConsumed(ability)
	updateScroll()
}


function applyMonkSeal(enemy, seal) {
		if (enemy.debuffs) {
			console.log(enemy.debuffs)
			if (enemy.debuffs[seal.refName]) {
				let enemySealDebuff = enemy.debuffs[seal.refName]
				let maxStacks = player[seal.refName].debuff.maxStacks()
				enemySealDebuff.stacks == maxStacks ? enemySealDebuff.stacks : enemySealDebuff.stacks++
			  } else {
				enemy.debuffs[seal.refName] = {
				stacks: 1
				}
			}
		} 
		if (!enemy.debuffs) {
			enemy.debuffs = {}
			if (!enemy.debuffs[seal.refName]) {
				enemy.debuffs[seal.refName] = {}
				enemy.debuffs[seal.refName].stacks = 1
			}
	
		} 
		enemy.debuffs[seal.refName].timeout = setTimeout(() => {
			delete enemy.debuffs[seal.refName];
			}, seal.duration)
	}
function monkComboHandler(enemy) {
	let seals = []
	for (let seal in enemy.debuffs) {
		if (enemy.debuffs[seal].type == 'seal') {
		seals.push(player[seal])
		}
	}
	console.log(seals)
	if (seals.length > 1) {
		return monkComboCombiner(enemy, seals)
	} else {
		return 0
	}
}
function monkComboCombiner(enemy, sealsArray) {
	//HYDROPLOSION
	if (sealsArray[0].refName == 'blazingFist' &&
		sealsArray[1].refName == 'tidalFist') {
		hydroplosion(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'tidalFist' &&
		sealsArray[1].refName == 'blazingFist') {
		hydroplosion(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'blazingFist' &&
		sealsArray[1].refName == 'quakeFist') {
		moltenQuake(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'quakeFist' &&
		sealsArray[1].refName == 'blazingFist') {
		moltenQuake(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'tidalFist' &&
		sealsArray[1].refName == 'quakeFist') {
		earthTide(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'quakeFist' &&
		sealsArray[1].refName == 'tidalFist') {
		earthTide(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'lightningFist' &&
		sealsArray[1].refName == 'blazingFist') {
		thunderBlaze(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'blazingFist' &&
		sealsArray[1].refName == 'lightningFist') {
		thunderBlaze(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'lightningFist' &&
		sealsArray[1].refName == 'tidalFist') {
		aquaVolt(enemy, sealsArray)
	} else if (sealsArray[0].refName == 'tidalFist' &&
		sealsArray[1].refName == 'lightningFist') {
		aquaVolt(enemy, sealsArray)
	} 
}

function earthTide(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	earthTideFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	earthTideDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, earthTideDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function earthTideFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Earth Tide'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}


function moltenQuake(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	moltenQuakeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	moltenQuakeDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, moltenQuakeDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function moltenQuakeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Molten Quake'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}

function hydroplosion(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	hydroplosionFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	hydroplosionDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, hydroplosionDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function hydroplosionFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Hydroplosion'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}

function thunderBlaze(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	thunderBlazeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	thunderBlazeDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, thunderBlazeDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function thunderBlazeFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Thunder Blaze'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}
function aquaVolt(enemy, sealsArray) {
	let damageObject = calculateMagicDamage(enemy, sealsArray[1].sealCombo)
	let {damageBeforeMagicResist, damageAfterMagicResist, penetrationType, damageResisted} = damageObject
	console.log(damageObject, ' DAMAGE OBJECT')
	aquaVoltFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted)
	applyDamageToEnemy(enemy, damageAfterMagicResist)
	aquaVoltDebuff.element = sealsArray[1].sealCombo.element
	applyDebuff(enemy, aquaVoltDebuff)
	removeDebuff(enemy, enemy.debuffs[sealsArray[0].refName])
	removeDebuff(enemy, enemy.debuffs[sealsArray[1].refName])
	delete enemy.debuffs[sealsArray[0].refName]
	delete enemy.debuffs[sealsArray[1].refName]
}

function aquaVoltFlavorText(enemy, sealsArray, damageAfterMagicResist, damageResisted) {
	let receivingSeal = sealsArray[0].name
	let applyingSeal = sealsArray[1].name
	let combinedAbility = 'Aqua Volt'
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`${applyingSeal} `, sealsArray[1].color, line1)
	customizeEachWord(`combines with `, 'white', line1)
	customizeEachWord(`${receivingSeal} `, sealsArray[0].color, line1)
	customizeEachWord(`creating `, 'white', line1)
	customizeEachWord(`${combinedAbility}`, sealsArray[1].sealCombo.color, line1)
	customizeEachWord(`!`, 'white', line1)
	customizeEachWord(`${combinedAbility} `, sealsArray[1].sealCombo.color, line2)
	customizeEachWord(`hits for `, 'green', line2)
	customizeEachWord(`${damageAfterMagicResist} `, 'light-blue', line2)
	customizeEachWord(`${sealsArray[1].sealCombo.color} `, sealsArray[1].sealCombo.element, line2)
	customizeEachWord(`damage. `, 'green', line2)
	customizeEachWord(`(Enemy resists `, 'white', line2)
	customizeEachWord(`${damageResisted}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
}





function flameStrikeFunction(secondCommand, thirdCommand) {
	let ability = player.flameStrike
	let abilityName = player.flameStrike.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let totalDamage = player[abilityName].damage(weapon1, weapon2)
				ability.flavorText(targetEnemy, weaponUsed, totalDamage)
				targetEnemy.health = targetEnemy.health - totalDamage
				targetEnemy.death()
			if (player.buffs.fireSeal) {
				delete player.buffs.fireSeal
				let getEnemiesInCombat = getAllEnemiesInCombat()
				getEnemiesInCombat.forEach(enemy => {
					let totalDamage = player.flameStrike.sealBreakerDamage()
					ability.sealBreakerFlavorText(enemy, totalDamage)
					enemy.health -= totalDamage
					enemy.death()
			})
			}
			updateScroll()
			}
	}

function waveFistFunction(secondCommand, thirdCommand) {
	let ability = player.waveFist
	let abilityName = player.waveFist.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	if (abilityCombatCheck()) {return}
	let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
	let hitChance = playerAbilityHitChance(targetEnemy)
			if (hitChance == false) {
				ability.flavorTextMiss(targetEnemy, weaponUsed)
			} else if (hitChance == true) {
				let totalDamage = player[abilityName].damage(weapon1, weapon2)
				ability.flavorText(targetEnemy, weaponUsed, totalDamage)
				targetEnemy.health = targetEnemy.health - totalDamage
				targetEnemy.death()
			if (player.buffs.waterSeal) {
				delete player.buffs.waterSeal
				let heal = ability.heal()
				if (player.health + heal > player.maxHealth) {
					heal = player.maxHealth - player.health
				}
				player.health += heal
				ability.sealBreakerFlavorText(heal)
				updatePlayerStats()
			}
			updateScroll()
			}
	}


	function riptideFistFunction(secondCommand, thirdCommand) {
		let ability = player.riptideFist
		let abilityName = player.riptideFist.refName
		let weaponTypesToCheck = player[abilityName].weaponTypesUsed
		let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
		let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
		let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
		if (doesPlayerHaveAbility(player[abilityName])) {return}
		if (abilityWeaponsCheck(ability, weapon1, weapon2)) {return}
		if (abilityResourceCheck(player[abilityName])) {return}
		if (abilityCooldownCheck(player[abilityName])) {return}
		if (abilityCombatCheck()) {return}
		let targetEnemy = targetCombatEnemy(secondCommand, thirdCommand)
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) {
			ability.flavorTextMiss(targetEnemy, weaponUsed)
		} else if (hitChance == true) {
			let sealAbilities = ['blazingFist', 'riptideFist']
			for (let i = 0; i < sealAbilities.length; i++) {
				if (player[sealAbilities[i]].stacks > 0 && player[sealAbilities[i]] != player[abilityName]) {
					player[sealAbilities[i]].stacks = 0
					player[abilityName].stacks = 0
					let comboDamage = player[abilityName].combo()
					player[abilityName].comboFlavorText(targetEnemy, comboDamage)
					targetEnemy.health = targetEnemy.health - comboDamage
					targetEnemy.death()
					updateScroll()
					return
				}
			}
					let totalDamage = player[abilityName].damage(weapon1, weapon2)
					ability.flavorText(targetEnemy, weaponUsed, totalDamage)
					targetEnemy.health = targetEnemy.health - totalDamage
					targetEnemy.death()
					updateScroll()
					if (player[abilityName].stacks < player[abilityName].level) {
						player[abilityName].stacks++
			}
				}
			}
function piercingArrowFunction(secondCommand, thirdCommand) {
	let ability = player.piercingArrow
	let abilityName = player.piercingArrow.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weaponUsed = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(player[abilityName])) {return}
	if (abilityResourceCheck(player[abilityName])) {return}
	if (abilityCooldownCheck(player[abilityName])) {return}
	// if (abilityQueueCheck()) {return}
	if (ability.queued && player.isAbilityQueued) { //TIMEDSHOT GETS EXECUTED
		player[abilityName].queued = false
		player.isAbilityQueued = false
		let hitChance = playerAbilityHitChance(targetEnemy)
		if (hitChance == false) { //MISSES
			player[abilityName].releaseTimer()
			player[abilityName].flavorTextMiss(targetEnemy, weaponUsed)
			clearInterval(piercingArrowInterval)
		} else if (hitChance == true) { //HITS
			let baseDamage = player[ability.refName].damage(targetEnemy)
			let penetrationType = calculatePenetrationRoll()
			let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
			let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
			let damageBlocked = baseDamage - damageAfterArmor
			console.log(penetrationType, 'PENETRATION TYPE')
			console.log(penetrationFlavorText, 'PENETRATION FLAVOR TEXT')
			ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
			player[abilityName].releaseTimer(weaponUsed)
			applyDamageToEnemy(targetEnemy, damageAfterArmor)
			// applyDebuff(targetEnemy, ability.debuff)
			// applyDebuff(targetEnemy, ability.debuff)
			// applyDamageToEnemy(targetEnemy, totalDamage)
			updateScroll()
		}
		resourceConsumed(ability)
	} else if (abilityQueueCheck()) {
		return
	} else if (!ability.queued) { 
		//TIMEDSHOT WINDS UP
		// initiateAbilityWindup(ability)
		player[abilityName].queued = true
		player.isAbilityQueued = true
		ability.windUpText()
		player[abilityName].initiateTimer(secondCommand, thirdCommand)
		}
}

function hydraArrowFunction(secondCommand, thirdCommand) {
	let ability = player.hydraArrow
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy()
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	abilityWindUpText(ability)
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName]) || checkAvailableEnemy(targetEnemy)) {
				quickMessage(`ability should no longer be queued`)
				player.isAbilityQueued = false
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
				return
			}
			if (player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let allCombatEnemies = getAllEnemiesInRoom(secondCommand, thirdCommand)
				for (let i = 0; i < ability.shotCount(); i++) {
					if (checkAvailableEnemy2(allCombatEnemies[i])) {break}
					let hitChance = playerAbilityHitChance(allCombatEnemies[i])
					if (hitChance == false) {
						ability.flavorTextMiss(allCombatEnemies[i], weaponUsed)
					} else if (hitChance == true) {
						let baseDamage = ability.damage()
						let penetrationType = calculatePenetrationRoll()
						let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(allCombatEnemies[i], baseDamage, penetrationType)
						let damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(allCombatEnemies[i], weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(allCombatEnemies[i], damageAfterArmor)
						applyDebuff(allCombatEnemies[i], ability.debuff)
						updateScroll()
						}
				}
				resourceConsumed(ability)
				player[abilityName].queued = false
				player.isAbilityQueued = false
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(player.hydraArrow)
				updateScroll()
			}
		}, player.hydraArrow.windUp * 1000)
	}

function rapidFireShotFunction(secondCommand, thirdCommand) {
	let ability = player.rapidFireShot
	let abilityName = ability.refName
	let weaponTypesToCheck = ability.weaponTypesUsed
	let weapon1 = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	let weapon2 = weaponTypesToCheck.some(types => getWeapon2().skillUsed.includes(types)) == true ? getWeapon2() : undefined
	let weaponUsed = weapon1 != undefined && weapon2 != undefined ? weapon1 : weapon1 != undefined && weapon2 == undefined ? weapon1 : weapon1 == undefined && weapon2 != undefined ? weapon2 : undefined
	let targetEnemy = targetAnyEnemy()
	if (abilityWeaponsCheck(ability, weaponUsed)) {return}
	if (checkAvailableEnemy(targetEnemy)) {return}
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	abilityWindUpText(ability)
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (abilityWeaponsCheck(ability, weaponUsed) || abilityResourceCheck(player[abilityName])) {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(ability)
				return
			}
			if (player[abilityName].cooldown == player[abilityName].cooldownSet) {
				for (let i = 0; i < player[abilityName].shotCount(); i++) {
					let targetEnemy = targetAnyEnemy()
					if (checkAvailableEnemy(targetEnemy)) {break}
					let hitChance = playerAbilityHitChance(targetEnemy)
					//apply
					player[abilityName].queued = false
					player.isAbilityQueued = false
					if (hitChance == false) {
						ability.flavorTextMiss(targetEnemy, weaponUsed)
					} else if (hitChance == true) {
						let baseDamage = ability.damage()
						let penetrationType = calculatePenetrationRoll()
						let penetrationFlavorText = penetrationType == 'slashingPen' ? 'slashing' : penetrationType == 'piercingPen' ? 'piercing' : 'blunt'
						let damageAfterArmor = calculateAbilityDamageAgainstEnemyArmor(targetEnemy, baseDamage, penetrationType)
						let damageBlocked = baseDamage - damageAfterArmor
						ability.flavorText(targetEnemy, weaponUsed, damageAfterArmor, penetrationFlavorText, damageBlocked)
						applyDamageToEnemy(targetEnemy, damageAfterArmor)
						rangerRegularAttackApplyMark(targetEnemy)
						updateScroll()
						}
				}
				resourceConsumed(ability)
				player[abilityName].queued = false
				player.isAbilityQueued = false
				} else {
					player[abilityName].cooldown = player[abilityName].cooldownSet
					initiateAbilityCooldown(player.rapidFireShot)
					updateScroll()
				}
			}, player.rapidFireShot.windUp * 1000)
			updateMonsterBox()
		}

function aimedShotFunction(secondCommand, thirdCommand) {
	let ability = player.aimedShot
	let abilityName = ability.refName
	let weaponTypesToCheck = player[abilityName].weaponTypesUsed
	let weapon = weaponTypesToCheck.some(types => getWeapon1().skillUsed.includes(types)) == true ? getWeapon1() : undefined
	if (doesPlayerHaveAbility(ability)) {return}
	if (abilityWeaponsCheck(ability, weapon)) {return}
	if (abilityResourceCheck(ability)) {return}
	if (abilityCooldownCheck(ability)) {return}
	if (abilityQueueCheck(ability)) {return}
	abilityWindUpText(ability)
	player.isAbilityQueued = true
	initiateAbilityWindup(ability)
		setTimeout(() => {
			if (player[abilityName].cooldown == player[abilityName].cooldownSet) {
				let targetEnemy = targetAnyEnemy(secondCommand, thirdCommand)
				let hitChance = playerAbilityHitChance(targetEnemy)
				let totalDamage = player[abilityName].damage(weapon, targetEnemy)
				if (hitChance == false) {
					ability.flavorTextMiss(targetEnemy, weapon)
				} else if (hitChance == true) {
					rangerRegularAttackConsumeMark(targetEnemy)
					ability.flavorText(targetEnemy, weapon, totalDamage)
					applyDamageToEnemy(targetEnemy, totalDamage)
				}
			
				player[abilityName].queued = false
				player.isAbilityQueued = false
			} else {
				player[abilityName].cooldown = player[abilityName].cooldownSet
				initiateAbilityCooldown(player.aimedShot)
			}
			updateScroll()
		}, player.aimedShot.windUp * 1000)
	}
		
function evasiveRollFunction() {
	let ability = player.evasiveRoll
	if (player.evasiveRoll.level <= 0) {
		let line1 = lineFunc()
		blankSpace()
		customizeEachWord(`You do not know the ability `, 'white', line1)
		customizeEachWord(`Evasive Roll `, 'ranger-color', line1)
		blankSpace()	
		return
	}
	if (abilityResourceCheck(ability)) {return}
	let allCombatEnemies = getAllEnemiesInCombat()
	player.combat = false
	allCombatEnemies.forEach(enemy => {
		enemy.combat = false
	})
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`You perform an `, 'white', line1)
	customizeEachWord(`Evasive Roll `, 'ranger-color', line1)
	customizeEachWord(`and break combat!`, 'white', line1)
	blankSpace()
	resourceConsumed(ability)
}

function calculateOnHitDamage(enemy, swingObject) {
	let damage = 0
	switch (player.guild) {
		case 'Warrior':
			damage += calculateBleedDamage(enemy, swingObject)
			// damage += calculateFuryBonus(enemy, swingObject)
			damage += calculateKnightsResolveBonus()
			break;
		case 'Monk':
			// damage = calculateSealBreakerDamage(enemy, swingObject)	
			// swingObject.onHitOrBonusDamage = 'on hit'
			break;
		case 'Sinistral':
			applyShadowMark(enemy, swingObject)
			damage = calculateStealthDamage()
			break;
		case 'Ranger':
			damage = rangerRegularAttackConsumeMarkDamage(enemy, swingObject)
			// swingObject.onHitOrBonusDamage = 'bonus'
			rangerRegularAttackConsumeMark(enemy, swingObject)
			rangerRegularAttackApplyMark(enemy)
			calculateWeakSpot(enemy)
	}
	return damage
}
function calculateWeakSpot(enemy) {
	let procChance = player.weakSpot.chance()
	let roll = randomNumberRange(1, 100)
	if (procChance >= roll) {
	quickMessage(`weak spot applied`)
		applyDebuff(enemy, player.weakSpot.debuff)
	} 
}
function calculateStunningBlow() {
	let chanceToStun = player.stunningBlows.chanceToStun()
	let roll = randomNumberRange(1, 100)
	return chanceToStun >= randomNumberRange(1, 100)
}

function applyShadowMark(enemy, swingObject) {
	console.log(swingObject)
	if (!swingObject.weapon.enchantment[0]) {return}
	swingObject.weapon.enchantment.forEach(enchant => {
		if (enchant.refName == 'shadowVenom') {
			applyDebuff(enemy, player.shadowMark.debuff)
		}
	})
}

function calculateBuffDamage(enemy, swingObject) {
	let damage = 0
	for (let buff in player.buffs) {
		if (player.buffs[buff].onHit) {
			let buffDamage = player.buffs[buff].damage ? player.buffs[buff].damage() : 0
			damage += buffDamage
			swingObject.playerBuffOnHit[buff] = {
				flavorText: player.buffs[buff].flavorText,
				damage: buffDamage
			}
		}
	}
	return damage
}
function calculateWeaponEnchantmentDamage(enemy, swingObject) {
	let damage = 0
	for (let enchantment in swingObject.weapon.enchantment) {
		if (swingObject.weapon.enchantment[enchantment].damage) {
			let enchantmentDamage = swingObject.weapon.enchantment[enchantment].damage(enemy)
			let resistType = swingObject.weapon.enchantment[enchantment].resistType
			console.log(resistType, ' RESIST TYPE ON ENCHANTMENT OBJECT')
			console.log(enchantment, ' ENCHANTMENT')
			let penType = swingObject.weapon.enchantment[enchantment].penType
			let element = swingObject.weapon.enchantment[enchantment].element
			let damageAfterResist = calculateMagicDamageWithResist(enchantmentDamage, enemy[resistType], player[penType])
			let damageResisted = enchantmentDamage - damageAfterResist

			damage += enchantmentDamage
			swingObject.weaponEnchantment[enchantment] = {
				flavorText: swingObject.weapon.enchantment[enchantment].flavorText,
				damage: enchantmentDamage,
				resistType: resistType,
				element: element,
				damageAfterResist: damageAfterResist,
				damageResisted: damageResisted
			}
		}
	}
	return damage
}

function calculateWeaponEnchantmentHeal(swingObject) {
	let heal = 0
	for (let enchantment in swingObject.weapon.enchantment) {
		if (swingObject.weapon.enchantment[enchantment].heal) {
			let healAmount = swingObject.weapon.enchantment[enchantment].heal()
			heal += healAmount
			swingObject.weaponHealingEnchantment[enchantment] = {
				flavorText: swingObject.weapon.enchantment[enchantment].flavorText,
				heal: healAmount
			}
		}
	}
	player.health + heal > player.maxHealth ? player.health = player.maxHealth : player.health += heal
	return heal
}

function calculateClassAdditionalEffects(enemy) {
	if (player.playerClass.name == 'Mystic Monk') {
		if (enemy.debuffs) {
			calculateFireSealBreak(enemy)
			calculateWaterSealBreak(enemy)
			calculateEarthSealBreak(enemy)
		}
	}
}

function calculateFireSealBreak(enemy) {
	if (enemy.debuffs.fireSeal) {
			enemy.debuffs.fireSeal.stacks++
			if (enemy.debuffs.fireSeal.numHitsToActivate == enemy.debuffs.fireSeal.stacks) {
				let combatEnemies = getAllEnemiesInCombat()
				let debuffToCalculateOffOf = enemy.debuffs.fireSeal
				let mainEnemyIndex = combatEnemies.indexOf(enemy)
				let additionalEnemyIndex1 = mainEnemyIndex == 0 ? 2 : mainEnemyIndex - 1
				let additionalEnemyIndex2 = mainEnemyIndex + 1

				let enemy2Index = mainEnemyIndex == combatEnemies.length -1 ? mainEnemyIndex -1 : mainEnemyIndex + 1
				let enemy3Index = mainEnemyIndex == combatEnemies.length -1 ? mainEnemyIndex -2 : mainEnemyIndex + 2

				let sealDamage = debuffToCalculateOffOf.damage()
				let resistType = debuffToCalculateOffOf.resistType
				let damageAfterResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player.firePen)
				let damageResisted = sealDamage - damageAfterResist
				let element = debuffToCalculateOffOf.element
				debuffToCalculateOffOf.flavorText(enemy, damageAfterResist, element, damageResisted)
				applyDamageToEnemy(enemy, damageAfterResist)
				if (combatEnemies[enemy2Index] && player.fireSeal.level >= 3) {
					let sealDamage = debuffToCalculateOffOf.damage()
					let resistType = debuffToCalculateOffOf.resistType
					let damageAfterResist = calculateMagicDamageWithResist(sealDamage, combatEnemies[enemy2Index][resistType], player.firePen)
					let damageResisted = sealDamage - damageAfterResist
					let element = debuffToCalculateOffOf.element
					debuffToCalculateOffOf.flavorTextCleave(combatEnemies[enemy2Index], damageAfterResist, element, damageResisted)
					applyDamageToEnemy(combatEnemies[enemy2Index], damageAfterResist)
				}
				if (combatEnemies[enemy3Index] && player.fireSeal.level >= 7) {
					let sealDamage = debuffToCalculateOffOf.damage()
					let resistType = debuffToCalculateOffOf.resistType
					let damageAfterResist = calculateMagicDamageWithResist(sealDamage, combatEnemies[enemy3Index][resistType], player.firePen)
					let damageResisted = sealDamage - damageAfterResist
					let element = debuffToCalculateOffOf.element
					debuffToCalculateOffOf.flavorTextCleave(combatEnemies[enemy3Index], damageAfterResist, element, damageResisted)
					applyDamageToEnemy(combatEnemies[enemy3Index], damageAfterResist)
				}
				enemy.debuffs.fireSeal.stacks = 0
				if (player.fireSeal.buff) {
					if (player.fireSeal.buff.type == 'enchantment') {
						applyWeaponEnchant([player.rightFist, player.leftFist], player.fireSeal.buff)
					}
					if (player.fireSeal.buff.seal) {
						applyBuff(player.fireSeal.buff)
					}
				}
				removeDebuff(enemy, enemy.debuffs.fireSeal)
			}
	}
}

function calculateWaterSealBreak(enemy) {
		if (enemy.debuffs.waterSeal) {
			enemy.debuffs.waterSeal.stacks++
			if (enemy.debuffs.waterSeal.numHitsToActivate == enemy.debuffs.waterSeal.stacks) {
				let debuffToCalculateOffOf = enemy.debuffs.waterSeal
				let sealDamage = debuffToCalculateOffOf.damage()
				let resistType = debuffToCalculateOffOf.resistType
				let damageAfterResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player.waterPen)
				let damageResisted = sealDamage - damageAfterResist
				let element = debuffToCalculateOffOf.element
				debuffToCalculateOffOf.flavorText(enemy, damageAfterResist, element, damageResisted)
				applyDamageToEnemy(enemy, damageAfterResist)
				enemy.debuffs.waterSeal.stacks = 0
				if (player.waterSeal.buff) {
					if (player.waterSeal.buff.type == 'enchantment') {
						applyWeaponEnchant([player.rightFist, player.leftFist], player.waterSeal.buff)
					}
					if (player.waterSeal.buff.seal) {
						applyBuff(player.waterSeal.buff)
					}
				}
				removeDebuff(enemy, enemy.debuffs.waterSeal)
			}
		}
}
function calculateEarthSealBreak(enemy) {
		if (enemy.debuffs.earthSeal) {
			enemy.debuffs.earthSeal.stacks++
			if (enemy.debuffs.earthSeal.numHitsToActivate == enemy.debuffs.earthSeal.stacks) {
				let debuffToCalculateOffOf = enemy.debuffs.earthSeal
				let sealDamage = debuffToCalculateOffOf.damage()
				let resistType = debuffToCalculateOffOf.resistType
				let damageAfterResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player.earthPen)
				let damageResisted = sealDamage - damageAfterResist
				let element = debuffToCalculateOffOf.element
				debuffToCalculateOffOf.flavorText(enemy, damageAfterResist, element, damageResisted)
				applyDamageToEnemy(enemy, damageAfterResist)
				enemy.debuffs.earthSeal.stacks = 0
				if (player.earthSeal.buff) {
					if (player.earthSeal.buff.type == 'enchantment') {
						// applyWeaponEnchant([player.rightFist, player.leftFist], player.earthSeal.buff)
					}
					if (player.earthSeal.buff.seal) {
						applyBuff(player.earthSeal.buff)
						applyMagicShieldToPlayer()
					}
				}
				removeDebuff(enemy, enemy.debuffs.earthSeal)
			}
		}
}

function calculateSealBreakerDamage(enemy, swingObject) {
	let damage = 0
	for (let sealBreaker in enemy.debuffs) {
		if (enemy.debuffs[sealBreaker]) {
			enemy.debuffs[sealBreaker].stacks++
			if (enemy.debuffs[sealBreaker].numHitsToActivate == enemy.debuffs[sealBreaker].stacks) {
				let sealDamage = enemy.debuffs[sealBreaker].damage(swingObject)
				let resistType = enemy.debuffs[sealBreaker].resistType
				let penType = enemy.debuffs[sealBreaker].penType
				let damageAfterMagResist = calculateMagicDamageWithResist(sealDamage, enemy[resistType], player[penType])
				let damageResisted = sealDamage - damageAfterMagResist
				let element = enemy.debuffs[sealBreaker].element
				enemy.debuffs[sealBreaker].stacks = 0
				damage += damageAfterMagResist
				swingObject.classOnHitDisplay[sealBreaker] = {
					buffToApply: {},
					flavorText: enemy.debuffs[sealBreaker].flavorText,
					damage: sealDamage,
					resistType: resistType,
					element: element,
					damageAfterResist: damageAfterMagResist,
					damageResisted: damageResisted
				}
				if (player[sealBreaker].buff) {
					if (player[sealBreaker].buff.type == 'enchantment') {
						applyWeaponEnchant([player.rightFist, player.leftFist], player[sealBreaker].buff)
					}
					if (player[sealBreaker].buff.seal) {
						applyBuff(player[sealBreaker].buff)
					}
				}
				removeDebuff(enemy, enemy.debuffs[sealBreaker])
			}
		}
	}
	return damage
}
function applyBuffForReal(swingObject) {
	for (let buff in swingObject.classOnHitDisplay) {
		// applyBuff(swingObject.classOnHitDisplay[buff].buffToApply)
	}
}

// function displayOnHitDamage(enemy, swingObject) {
// 	if (swingObject.onHitOrBonusDamage == 'on hit') {
// 		swingObject.onHitFlavorText.forEach(display => {
// 			// display(enemy, swingObject)
// 		})
// 	}
// }
// function collectOnHitFlavorText(swingObject) {
// 	if (!swingObject.consumedMark) {
// 		return
// 	}
// 	let array = []
// 	for (const mark of swingObject.consumedMark) {
// 		if (!mark) {
// 			continue
// 		}
// 		array.push(mark.flavorText)
// 	}
// 	return array
// }
function displaySwing(enemy, rightOrLeftObject) {
	//onhit
	console.log(rightOrLeftObject)
	if (player.isStealthed) {
		sneakAttack(enemy)
	}
	if (rightOrLeftObject.weapon) {
		if (rightOrLeftObject.doesSwingHit) {
			if (player.playerClass.name == 'Mystic Monk') {
				rightOrLeftObject.realTotalDamage -= rightOrLeftObject.onHitDamage
			}
			rightOrLeftObject.weapon.swing(enemy, rightOrLeftObject)
			for (let enchantment in rightOrLeftObject.weaponEnchantment) {
				rightOrLeftObject.weaponEnchantment[enchantment].flavorText(enemy, rightOrLeftObject.weaponEnchantment[enchantment].damageAfterResist, rightOrLeftObject.weaponEnchantment[enchantment].element, rightOrLeftObject.weaponEnchantment[enchantment].damageResisted)
			}
			for (let playerBuff in rightOrLeftObject.playerBuffOnHit) {
				rightOrLeftObject.playerBuffOnHit[playerBuff].flavorText(enemy, rightOrLeftObject.playerBuffOnHit[playerBuff].damage)
			}
			for (let classOnHitEffect in rightOrLeftObject.classOnHitDisplay) {
				rightOrLeftObject.classOnHitDisplay[classOnHitEffect].flavorText(enemy, rightOrLeftObject.classOnHitDisplay[classOnHitEffect].damageAfterResist, rightOrLeftObject.classOnHitDisplay[classOnHitEffect].element, rightOrLeftObject.classOnHitDisplay[classOnHitEffect].damageResisted)
			}
			if (rightOrLeftObject.doesPlayerStun) {
				player.stunningBlows.flavorText(enemy)
			}
			for (let enchantment in rightOrLeftObject.weaponHealingEnchantment) {
				rightOrLeftObject.weaponHealingEnchantment[enchantment].flavorText(enemy, rightOrLeftObject.weaponHealingEnchantment[enchantment].heal)
			}
			if (player.thrillOfTheKill.level > 0) {
				thrillOfTheKillProc()
			}
			if (rightOrLeftObject.critDamage > 0) {
				quickMessage(`You crit`)
			}

		} else {
			rightOrLeftObject.weapon.miss(enemy, rightOrLeftObject)
		}
	}
	blankSpace()
}
function calculateBleedDamage(enemy, swingObject) {
	let damage = 0
	if (enemy?.debuffs?.bleed) {
		let debuff = enemy.debuffs.bleed
		damage = debuff.damage(enemy, swingObject)
	}
	return damage
}

function calculateBleedBonus(enemy, baseDamage) {
	let bleedBonus = 0
	if (enemy?.debuffs?.bleed) {
		console.log(baseDamage, ' BASE DAMAGE')
		console.log(enemy.debuffs.bleed.stacks, ' ENEMY DEBUFFS STACKS')
		console.log(player.bleed.bonusModifier(), ' PLAYER BLEED BONUS MOD')
		bleedBonus = (player.bleed.bonusModifier() * enemy.debuffs.bleed.stacks) * baseDamage
		console.log(bleedBonus, ' BLEED BONUS')
	}
	return bleedBonus
}
// function calculateFuryBonus(enemy, swingObject) {
// 	let furyBonus = 0
// 	if (!enemy?.debuffs?.fury) {return furyBonus}
// 	if (enemy?.debuffs?.fury) {
// 		furyBonus = (player?.dualStrike?.debuff?.bonusModifier * enemy.debuffs.fury.stacks) * swingObject.totalDamage
// 		let stacks = enemy.debuffs.fury.stacks
// 		let ability = player.dualStrike
// 		resourceGained(ability, stacks, 'maxMight')
// 		removeDebuff(enemy, enemy.debuffs.fury)
// 	}
// 	console.log(furyBonus, ' FURY BONUS 50% OF DAMAGE')
// 	return Math.ceil(furyBonus)
// }
function calculateKnightsResolveBonus() {
	let knightsResolveBonus = 0
	if (player.knightsResolve.level <= 0) {return knightsResolveBonus}
	knightsResolveBonus = player.knightsResolve.bonusDamage()
	console.log(knightsResolveBonus, ' KNIGHTS RESOLVE BONUS DAMAGE')
	return Math.ceil(knightsResolveBonus)
}

function calculateStealthDamage(enemy, swingObject) {
	//stealth check happens inside player.stealth.damageBonus
	//the player.stealth.damageBonus method also returns 0 if not stealthed
	return player.stealth.damageBonus()
}

function rangerRegularAttackConsumeMark(enemy, swingObject) {
	swingObject.consumedMark = []
	if (enemy.debuffs && enemy.debuffs.hydraArrow) {
		swingObject.consumedMark.push(enemy.debuffs.hydraArrow)
		removeDebuff(enemy, enemy.debuffs.hydraArrow)
		updateMonsterBox()
		delete enemy.debuffs.hydraArrow
	}
	if (enemy.debuffs && enemy.debuffs.piercingArrow) {
		swingObject.consumedMark.push(enemy.debuffs.piercingArrow)
		removeDebuff(enemy, enemy.debuffs.piercingArrow)
		updateMonsterBox()
		delete enemy.debuffs.piercingArrow
	}
}
function rangerRegularAttackConsumeMarkDamage(enemy, swingObject) {
	let damageToAddToTotal = 0
	if (enemy.debuffs && enemy.debuffs.hydraArrow) {
		let debuff = enemy.debuffs.hydraArrow
		let damage = debuff.damage(swingObject)
		damageToAddToTotal += damage
		console.log(damage + ' Hydra Arrow')
		// debuff.flavorText(enemy, damage)
	}
	if (enemy.debuffs && enemy.debuffs.piercingArrow) {
		let debuff = enemy.debuffs.piercingArrow
		let damage = debuff.damage(swingObject)
		damageToAddToTotal += damage
		console.log(damage + ' Piercing Arrow')
		// debuff.flavorText(enemy, damage)
	}
	if (enemy.debuffs && enemy.debuffs.markOfTheBeast) {
		let debuff = enemy.debuffs.markOfTheBeast
		let damage = debuff.damage(enemy, swingObject)
		damageToAddToTotal += damage
		console.log(damage, ' MARK OF THE BEAST BONUS DAMAGE')
		// debuff.flavorText(enemy, damage)
	}
	return Math.ceil(damageToAddToTotal)
}

function rangerRegularAttackApplyMark(enemy) {
	if (player.markOfTheBeast.level > 0) {
		applyDebuff(enemy, player.markOfTheBeast.debuff)
	}
}

function removeDebuff(enemy, debuff) {
	if (!enemy.debuffs) {
		return
	}
	if (enemy.health <= 0) {
		for (let item in enemy.debuffs) {
			clearTimeout(enemy.debuffs[item].timeout)
			// removeDebuffIcon(enemy, enemy.debuffs[item])
			delete enemy.debuffs[item]
		}
	}
	if (enemy.debuffs[debuff.refName]) {
		clearTimeout(enemy.debuffs[debuff.refName].timeout)
	} 
	delete enemy.debuffs[debuff.refName]
	updateMonsterBox()
}

function gameStageEvents(stageOfTheGame) {
	//Object passed through is player.gameStages."whatever game stage needs to run"
	let { isComplete, haveEventsRun, gameEvent } = stageOfTheGame
	//This checks to make sure the gameStage has been completed AND the gameStageEvent has not executed.
	//Once the gameStageEvent executes, it's marked as true so that event will never happen again.
	if (isComplete && !haveEventsRun) {
		gameEvent()
		haveEventsRun = true
	}
}

function displayBuffTextAndTimer(buff, duration) {
    const buffContainer = document.getElementById('buffs-container');
    const buffElements = buffContainer.getElementsByClassName('buff');
	const durationElements = buffContainer.getElementsByClassName('duration')
	let chosenElement
	let chosenDurationElement
	let stacks = 1
	for (let i = 0; i < buffElements.length; i++) {
		const elementToCheck = buffElements[i]
		const durationElementToCheck = durationElements[i]
		if (elementToCheck.classList.contains(buff.refName)) {
			chosenElement = elementToCheck
			chosenDurationElement = durationElementToCheck
			stacks = player?.buffs[buff.refName] ? player?.buffs[buff.refName].stacks : 1
			break;
		} else {
		}
	}
    for (let i = 0; i < buffElements.length; i++) {
      const currentBuff = buffElements[i];
	  const currentDurationElement = durationElements[i]
	  if (chosenElement) {
		clearInterval(playerBuffIntervals[buff.refName])
		delete playerBuffIntervals[buff.refName]
		let durationStartTime = duration / 1000
		chosenDurationElement.innerHTML = `${durationStartTime}`;
		chosenElement.innerHTML = `${buff.name} [${stacks}]`;
		playerBuffIntervals[buff.refName] = setInterval(() => {
			const currentDuration = chosenDurationElement.innerHTML;
			if (durationStartTime > 1) {
			  durationStartTime--;
			  chosenDurationElement.innerHTML = `${durationStartTime}`;
			} else {
			  chosenElement.innerHTML = ''
			  chosenDurationElement.innerHTML = ``
			  chosenElement.classList.remove('occupied');
			  chosenElement.classList.remove(buff.refName)
			  clearInterval(playerBuffIntervals[buff.refName])
			  delete playerBuffIntervals[buff.refName]
			}
		  }, 1000)
		  return
	}
      if (!currentBuff.classList.contains('occupied')) {
        // Apply the buff
        currentBuff.innerHTML = `${buff.name} [${stacks}]`;
        currentBuff.classList.add('occupied');
		currentBuff.classList.add(buff.refName)
        // Simulate duration countdown
		let durationStartTime = duration / 1000
		currentDurationElement.innerHTML = `${durationStartTime}`;
        playerBuffIntervals[buff.refName] = setInterval(() => {
          const currentDuration = currentDurationElement.innerHTML;
          if (durationStartTime > 1) {
            durationStartTime--;
            currentDurationElement.innerHTML = `${durationStartTime}`;
          } else {
            currentBuff.innerHTML = ''
			currentDurationElement.innerHTML = ``
            currentBuff.classList.remove('occupied');
			currentBuff.classList.remove(buff.refName)
			clearInterval(playerBuffIntervals[buff.refName])
			delete playerBuffIntervals[buff.refName]
          }
        }, 1000);
        break
      }
    }
  }

function removeBuff(buff) {
	if (!buff) {return}
    const buffContainer = document.getElementById('buffs-container');
    const buffElement = buffContainer.querySelector(`.${buff.refName}`);
	const durationElement = buffElement.nextElementSibling
	//buff1interval
	buffElement.innerHTML = ''
	durationElement.innerHTML = ``
	buffElement.classList.remove('occupied');
	buffElement.classList.remove(buff.refName)
	removeBuffStats(buff)
	clearTimeout(player.buffs[buff.refName].timeout)
	clearInterval(playerBuffIntervals[buff.refName])
	delete playerBuffIntervals[buff.refName]
	delete player.buffs[buff.refName]
}
function removeBuffStats(buff) {
	console.log(buff, ' BUFF')
	if (buff.mods) {
		let modKeys = Object.keys(buff.mods)
		for (const key of modKeys) {
			console.log(player.buffs)
			player.buffMods[key] -= buff.mods[key]
			console.log(player.buffs)
		}
	}
}

function applyWeaponEnchant(weaponOrWeapons, enchantment) {
	console.log(enchantment, ' ENCHANTMENT')
	let duration = enchantment.duration
	console.log(weaponOrWeapons, ' SINGLE WEAPON GETTING ENCHANTED')
	console.log(weaponOrWeapons[0], ' ARRAY WEAPON ITEM 1')
	console.log(weaponOrWeapons[1], ' ARRAY WEAPON ITEM 2')
	let enchantmentName = enchantment.refName
	let enchantmentToApply = enchantment
	if (Array.isArray(weaponOrWeapons)) {
		//weapon 1
		let previousStacks1 = weaponOrWeapons[0]?.enchantment[enchantmentName]?.stacks
		let previousStacks2 = weaponOrWeapons[1]?.enchantment[enchantmentName]?.stacks
		//////////////////////////////////////////////////////////////////////////////
		weaponOrWeapons[0].enchantment[enchantmentName] = enchantmentToApply
		if (previousStacks1 > weaponOrWeapons[0].enchantment[enchantmentName].stacks) {
			weaponOrWeapons[0].enchantment[enchantmentName].stacks = previousStacks1
		}
		clearTimeout(weaponOrWeapons[0].enchantment[enchantmentName].timeoute)
		weaponOrWeapons[0].enchantment[enchantmentName].timeoute = setTimeout(() => {
			clearTimeout(weaponOrWeapons[0].enchantment[enchantmentName].timeoute)
			delete weaponOrWeapons[0].enchantment[enchantmentName]
			let line1 = lineFunc()
			customizeEachWord(`${enchantment.name} `, enchantment.color, line1)
			customizeEachWord(`has worn off`, 'white', line1)
		}, duration)
		//weapon 2
		//////////////////////////////////////////////////////////////////////////////
		weaponOrWeapons[1].enchantment[enchantmentName] = enchantmentToApply
		if (previousStacks2 > weaponOrWeapons[1].enchantment[enchantmentName].stacks) {
			weaponOrWeapons[1].enchantment[enchantmentName].stacks = previousStacks2
		}
		clearTimeout(weaponOrWeapons[1].enchantment[enchantmentName].timeout)
		quickMessage(`Timeout is set just below`)
		weaponOrWeapons[1].enchantment[enchantmentName].timeout = setTimeout(() => {
			clearTimeout(weaponOrWeapons[1].enchantment[enchantmentName].timeout)
			delete weaponOrWeapons[1].enchantment[enchantmentName]
			let line1 = lineFunc()
			customizeEachWord(`${enchantment.name} `, enchantment.color, line1)
			customizeEachWord(`has worn off`, 'white', line1)		
		}, duration)
	} else {
		let previousStacks = weaponOrWeapons?.enchantment[enchantmentName]?.stacks
		weaponOrWeapons.enchantment[enchantmentName] = enchantmentToApply
		if (previousStacks > weaponOrWeapons.enchantment[enchantmentName].stacks) {
			weaponOrWeapons.enchantment[enchantmentName].stacks = previousStacks
		}
		clearTimeout(weaponOrWeapons.enchantment[enchantmentName].timeout)
		weaponOrWeapons.enchantment[enchantmentName].timeout = setTimeout(() => {
			clearTimeout(weaponOrWeapons.enchantment[enchantmentName].timeout)
			delete weaponOrWeapons.enchantment[enchantmentName]
			let line1 = lineFunc()
			customizeEachWord(`${enchantment.name} `, enchantment.color, line1)
			customizeEachWord(`has worn off`, 'white', line1)
		}, duration)
	}
}

function applyBuff(buff) {
	console.log(buff)
	let duration = typeof(buff.duration) == 'function' ? buff.duration() : buff.duration
	//stacks
	let counter = duration / 1000
	clearInterval(buff1Interval)
	buff1Interval = setInterval(() => {
		counter--
		// buff1.textContent = counter
		if (counter == 0) {
			clearInterval(buff1Interval)
			updatePlayerStats()
		}
	}, 1000)
	//if player buff does not exist, apply it
	if (!player.buffs[buff.refName]) {
		player.buffs[buff.refName] = {
		...buff,
		timeout: setTimeout(() => {
			delete player.buffs[buff.refName];
			delete player.sealCounter[buff.refName];
			updatePlayerStats()
			}, duration),
		}
	}

	//if the player buff does exist, replace it to refresh the duration
	if (player.buffs[buff.refName]) {
		clearInterval(buff1Interval)
		updatePlayerStats()
		// buff1.textContent = counter
			buff1Interval = setInterval(() => {
			counter--
			// buff1.textContent = counter
			if (counter == 0) {
				clearInterval(buff1Interval)
				updatePlayerStats()
			}
		}, 1000)
		if (player.buffs[buff.refName].stacks != undefined) {
			player.buffs[buff.refName].stacks < player.buffs[buff.refName].maxStacks() ? player.buffs[buff.refName].stacks++ : player.buffs[buff.refName].stacks
		}
		clearTimeout(player.buffs[buff.refName].timeout)
		player.buffs[buff.refName].timeout =  setTimeout(() => {
			delete player.buffs[buff.refName];
			delete player.sealCounter[buff.refName]
			updatePlayerStats()
			}, duration)
		} 
	displayBuffTextAndTimer(buff, duration)
	updatePlayerStats()
  }

function applyDebuff(enemy, debuff) {
	if (!enemy.debuffs) {
		enemy.debuffs = {};
	}
	
	if (enemy.debuffs[debuff.refName] && enemy.debuffs[debuff.refName].duration) {
		clearTimeout(enemy.debuffs[debuff.refName].timeout);
	}

	if (!enemy.debuffs[debuff.refName]) {
		enemy.debuffs[debuff.refName] = { ...debuff };
		if (debuff.maxStacks) {enemy.debuffs[debuff.refName].stacks++}
		applyModifiedStats(enemy, debuff)

	} else if (debuff.maxStacks) {
			if (enemy.debuffs[debuff.refName].stacks < debuff.maxStacks()) {
				enemy.debuffs[debuff.refName].stacks++
				// addDebuffIcon(enemy, debuff);
				applyModifiedStats(enemy, debuff)

			}
		}
		// Apply modified stats immediately upon debuff application
		// addDebuffIcon(enemy, debuff);
	if (debuff.duration) {
		let duration = typeof(debuff.duration) == 'function' ? debuff.duration() : debuff.duration
		enemy.debuffs[debuff.refName].timeout = setTimeout(() => {
		if (enemy.health > 0) {
			let line1 = lineFunc()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`is no longer suffering from `, 'white', line1)
			customizeEachWord(`${debuff.name}`, debuff.color, line1)
			revertModifiedStats(enemy, debuff);
			removeDebuff(enemy, debuff);
			updateMonsterBox()
		}
		}, duration)
	}
	updateMonsterBox()
}

function applyModifiedStats(enemy, debuff) {
	if (debuff.modifiedStats) {
		for (let i = 0; i < debuff.modifiedStats.length; i++) {
			if (debuff.maxStacks) {
				if (enemy.debuffs[debuff.refName].stacks <= debuff.maxStacks()) {
					enemy[debuff.modifiedStats[i]] += debuff[debuff.modifiedStats[i]]
				}
			} else {
					enemy[debuff.modifiedStats[i]] += debuff[debuff.modifiedStats[i]]
			}
		}
	}
}
function revertModifiedStats(enemy, debuff) {
	if (debuff.modifiedStats) {
		for (let i = 0; i < debuff.modifiedStats.length; i++) {
			let enemyStacks = enemy.debuffs[debuff.refName].stacks ? enemy.debuffs[debuff.refName].stacks : 1
			let debuffValue = debuff[debuff.modifiedStats[i]] * enemyStacks
			enemy[debuff.modifiedStats[i]] -= debuffValue
		}
	}
}

function updateDebuffIcons(enemy, debuff) {
	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate');
	let allEnemiesInRoom = getAllEnemiesInRoom()
	// let enemyIndex = allEnemiesInRoom.indexOf(enemy);
	let statusEffectsBoxes = allMonsterBoxes.querySelectorAll('#monster-status-effects');
	for (let i = 0; i < allMonsterBoxes.length; i++) {
		console.log(i)
	}
}

function addDebuffIcon(enemy, debuff) {
	if (enemy.health <= 0) {return}
	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate');
	let allEnemiesInRoom = getAllEnemiesInRoom()
	let enemyIndex = allEnemiesInRoom.indexOf(enemy);
	let statusBoxes = allMonsterBoxes[enemyIndex].querySelectorAll('#monster-status-effects');
	// Check if any of the status boxes already have the debuff class
	let alreadyHasDebuff = Array.from(statusBoxes).some(box => box.classList.contains(debuff.refName));
	// If no debuff class found, add it to the first empty slot
	if (!alreadyHasDebuff) {
		let emptySlot = Array.from(statusBoxes).find(box => box.classList.length === 0);
		if (emptySlot) {
			emptySlot.classList.add(debuff.refName);
			let stacks = enemy.debuffs[debuff.refName].stacks ? enemy.debuffs[debuff.refName].stacks : ``
			emptySlot.innerHTML = `${stacks}`
		}
	} else if (alreadyHasDebuff) {
		let debuffSlot = Array.from(statusBoxes).find(box => box.classList == debuff.refName)
		let stacks = enemy.debuffs[debuff.refName].stacks ? enemy.debuffs[debuff.refName].stacks : ``
		debuffSlot.innerHTML = `${stacks}`
	}
}

function grantBonusOnEnemyDeath(enemy) {
	if (!enemy) {
		quickMessage(`grant bonus`)
	}
}
// function removeDebuffIcon(enemy, debuff) {
// 	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate')
// 	let allEnemiesInRoom = getAllEnemiesInRoom()
// 	let enemyIndex = allEnemiesInRoom.indexOf(enemy)
// 	let statusBoxes = allMonsterBoxes[enemyIndex].querySelectorAll('#monster-status-effects')
// 	console.log(allMonsterBoxes)
// 	console.log(enemyIndex)
// 	console.log(allMonsterBoxes[enemyIndex])
// 	for (let i = 0; i < statusBoxes.length; i++) {
// 		if (statusBoxes[i].classList.length >= 0 && statusBoxes[i].classList.contains(debuff.refName)) {
// 			statusBoxes[i].classList.remove(debuff.refName)
// 			statusBoxes[i].innerHTML = ``
// 			return
// 		}
// 	}
// }




let macro = []

function setMacro(number, secondCommand) {
	if (secondCommand == 'ripslash') {
		macro[number - 1] = ripslash
	}
	quickMessage(`${secondCommand} set to macro ${number}`)
}

function useAbilityByNumber(number) {
	if (macro[number - 1] == undefined) {
		quickMessage(`You do not have an ability stored in this macro`)
	} else {
		macro[number - 1]()
	}
}

function checkConjuring() {
	if (player.isConjuring) {
		let line1 = lineFunc()
		customizeEachWord(`You are currently conjuring a spell [`, 'white', line1)
		customizeEachWord(`${Number(player.conjureTimer).toFixed(1)}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		return true
	}
}
function checkChanneling() {
	if (player.isChanneling) {
		let line1 = lineFunc()
		customizeEachWord(`You are currently channeling a spell [`, 'white', line1)
		customizeEachWord(`${Number(player.conjureTimer).toFixed(2)}`, 'yellow', line1)
		customizeEachWord(`]`, 'white', line1)
		return true
	}
}
function checkAvailableEnemy(enemy) {
	if (!enemy) {
		let line1 = lineFunc()
		customizeEachWord(`There is no enemy in the room for you to target`, 'white', line1)
		return true
	}
}
function checkAvailableEnemy2(enemy) {
	if (!enemy) {
		return true
	}
}

function checkMaxSpellsConjured() {
	if (player.spellsConjured.length == 1 && player.mindsEye.level == 0) {
		let line1 = lineFunc()
		customizeEachWord(`You already have the maximium number of spells conjured`, 'white', line1)
		return true
	}
	if (player.spellsConjured.length == 2 && player.mindsEye.level == 1) {
		let line1 = lineFunc()
		customizeEachWord(`You already have the maximium number of spells conjured`, 'white', line1)
		return true
	}
	if (player.spellsConjured.length == 3 && player.mindsEye.level == 2) {
		let line1 = lineFunc()
		customizeEachWord(`You already have the maximium number of spells conjured`, 'white', line1)
		return true
	}
}



function fireFunction() {
	let spell = player.fireflames
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}
function fire2Function() {
	let spell = player.inferno
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}
function fire3Function() {
	let spell = player.meteor
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}
function iceFunction() {
	let spell = player.frostfreeze
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
		return
	} else {
		handleSpellConjure(spell)
	}
}
function blizzardFunction() {
	let spell = player.blizzard
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
		return
	} else {
		handleSpellConjure(spell)
	}
}
function ice3Function() {
	let spell = player.cryoclast
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
		return
	} else {
		handleSpellConjure(spell)
	}
}
function boltFunction() {
	let spell = player.flashbolt
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		handleSpellConjure(spell)
	}
}

//handles the summoning of the spell
function spellFunction(spell) {
	let secondCommand = spell
	spell = typeof(spell) == 'string' ? player[spell] : spell
	if (!spell) {
		quickMessage(`You do not know the spell, ${secondCommand}.`)
		return
	}
	if (actionWait()) {return}
	if (checkIfDuplicateSpell(spell)) {
		handleSpellChannel(spell)
	} else {
		if (abilityResourceCheck(spell)) {return}
			handleSpellConjure(spell)
	}
	updatePlayerStats()
}
function handleSpellConjure(spell) {
	if (actionWait()) {return}
	if (checkConjuring()) {return}
	if (checkChanneling()) {return}
	if (checkMaxSpellsConjured()) {return}
	if (!player.isAlive) {return}
	resourceConsumed(spell)
	player.isConjuring = true
	spell.chambered = true
	if (spell.conjureAudio) {
		spell.conjureAudio()
	}
	spell.flavorTextConjure()
	player.spellsConjured.push(spell)
	initializeConjureBar(spell)
	spellConjureCount(spell)
}
//handles the channeling of the spell
async function handleSpellChannel(spell, targetedEnemy) {
	if (spell.type == 'restorative') {
		if (actionWait()) {return}
		if (checkConjuring()) {return}
		if (checkChanneling()) {return}
		player.stasis = true
		spell.flavorTextChannel()
		spellChannelCount(spell.channelTime())
		initiateCastBar(spell)
		await wait(spell.channelTime())
		player.channeling = false
		let spellIndex = player.spellsConjured.indexOf(spell)
		player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		spell.cast()
		spell.castAudio()
	} else {
		let firstEnemy = targetedEnemy ? targetedEnemy : getAnyEnemyByFirst()
		if (actionWait()) {return}
		if (checkConjuring()) {return}
		if (checkChanneling()) {return}
		if (checkAvailableEnemy(firstEnemy)) {return}
		if (!player.isAlive) {return}
		player.stasis = true
		spell.flavorTextChannel(firstEnemy)
		spellChannelCount(spell.channelTime())
		initiateCastBar(spell)
		await wait(spell.channelTime())
		player.channeling = false
		let spellIndex = player.spellsConjured.indexOf(spell)
		player.spellsConjured.splice(spellIndex, 1)
		spell.chambered = false
		// if (checkAvailableEnemy(firstEnemy)) {return}
		if (!player.isAlive) {return}
		spell.cast(firstEnemy, spell)
		spell.castAudio()
	}
}

function target(secondCommand) {
	let target = !secondCommand ? 1 : secondCommand
	let index = target - 1
	let allEnemies = getAllEnemiesInRoom()
	if (player.spellsConjured[0].type == 'restorative') {
		handleSpellChannel(player.spellsConjured[0])
	} else if (!player.spellsConjured[0]) {
		quickMessage(`You don't have any spells conjured to cast`)
	} else if (!allEnemies[index]) {
		quickMessage(`There is no enemy by that number to target`)
	} else if (allEnemies[index]) {
		quickMessage(`${allEnemies[index].name} is being targeted`)
		if (player.spellsConjured[0]) {
			handleSpellChannel(player.spellsConjured[0], allEnemies[index])
		}
	}
}

function calculateBurnEffect(enemy, spell, damage, allEnemiesFromMethod) {
	let allEnemiesInRoom = allEnemiesFromMethod
	console.log(allEnemiesInRoom, ' ALL ENEMIES IN ROOM FIRST')
	console.log(allEnemiesFromMethod, ' ALL ENEMIES IN ROOM FIRST')
	let explosionDamage = Math.ceil(damage * 0.5) //AoE damage from Fire 2 hitting a burning target. It does 50% of Fire 2's damage
	if (enemy?.debuffs?.burn?.stacks >= 3 && spell.refName == 'meteor') {
		let damageBeforeResist = damage
		let damageAfterResist = calculateMagicDamageWithResist(damageBeforeResist, enemy.fireResist, player.firePen)
		let damageResisted = damageBeforeResist - damageAfterResist
		spell.specialEffect(enemy, damageAfterResist, damageResisted)
		applyDamageToEnemy(enemy, damageAfterResist)
		removeDebuff(enemy, enemy.debuffs.burn)
	}
	if (enemy?.debuffs?.burn && spell.refName == 'inferno') {
		let mainEnemyIndex = allEnemiesInRoom.indexOf(enemy)
		let additionalEnemy1
		let additionalEnemy2
		let debuffToApply = { ...enemy.debuffs.burn }
		debuffToApply.stacks--
		if (allEnemiesInRoom[2]) {
			if (mainEnemyIndex == 0) {
				//Additional enemies are the two after the main target
				additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex + 1]
				additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 2]
			} else if (mainEnemyIndex == allEnemiesInRoom.length - 1) {
				//additional enemies are the two before the main target
				additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
				additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex - 2]
			} else {
				//additional enemies are ones before and one after the main target
				additionalEnemy1 = allEnemiesInRoom[mainEnemyIndex - 1]
				additionalEnemy2 = allEnemiesInRoom[mainEnemyIndex + 1]
			}
			let additionalDamage1 = calculateMagicDamageWithResist(explosionDamage, additionalEnemy1.fireResist, player.firePen)
			let damageResisted1 = explosionDamage - additionalDamage1
			spell.specialEffect(additionalEnemy1, additionalDamage1, damageResisted1)
			applyDebuff(additionalEnemy1, debuffToApply)
			applyDamageToEnemy(additionalEnemy1, additionalDamage1)
	
			let additionalDamage2 = calculateMagicDamageWithResist(explosionDamage, additionalEnemy2.fireResist, player.firePen)
			let damageResisted2 = explosionDamage - additionalDamage2
			spell.specialEffect(additionalEnemy2, additionalDamage2, damageResisted2)
			applyDebuff(additionalEnemy2, debuffToApply)
			applyDamageToEnemy(additionalEnemy2, additionalDamage2)
		} else if (allEnemiesInRoom[1]) {
			if (mainEnemyIndex == 0) {
				additionalEnemy1 = allEnemiesInRoom[1]
			} else if (mainEnemyIndex == 1) {
				additionalEnemy1 = allEnemiesInRoom[0]
			}
			let additionalDamage1 = calculateMagicDamageWithResist(explosionDamage, additionalEnemy1.fireResist, player.firePen)
			let damageResisted1 = explosionDamage - additionalDamage1
			spell.specialEffect(additionalEnemy1, additionalDamage1, damageResisted1)
			applyDebuff(additionalEnemy1, debuffToApply)
			applyDamageToEnemy(additionalEnemy1, additionalDamage1)
		}
	}
}

function calculateFrostbiteEffect(enemy, spell, damageObject) {
	let mainDamage = damageObject.damageBeforeMagicResist
	let mainAllEnemies = getAllEnemiesInRoom()
	let allEnemies = mainAllEnemies.slice(0, mainAllEnemies.length);
	if (spell.refName == 'cryoclast' && enemy?.debuffs?.frostbite?.stacks == 1) {
		quickMessage(`This should activate the Ice 3 AoE`)
		removeDebuff(enemy, player.frostfreeze.debuff)


		let damage = Math.ceil(mainDamage / allEnemies.length) //damage is split among all monsters in the room
		let mainEnemyIndex = allEnemies.indexOf(enemy)
		for (let i = 0; i < allEnemies.length; i++) {
			//maybe add removeDebuff(allEnemies[i], spell.debuff)
			//the above would activate ice 3s explosion AND remove all the debuffs from all enemies
			if (allEnemies[i].health > 0 && i != mainEnemyIndex) {
				let damageAfterResist = calculateMagicDamageWithResist(damage, enemy.iceResist, player.icePen)
				let damageResisted = damage - damageAfterResist
				spell.specialEffect2(allEnemies[i], damageAfterResist, damageResisted)
				applyDamageToEnemy(allEnemies[i], damageAfterResist)
				applyDebuff(allEnemies[i], spell.debuff)
			}
		}
	} else if (spell.refName == 'cryoclast' && enemy?.debuffs?.frostbite?.stacks == 2) {
		let damage = Math.ceil(mainDamage * 0.5) //damage is half that of the main spell
		let damageAfterResist = calculateMagicDamageWithResist(damage, enemy.iceResist, player.icePen)
		let damageResisted = damage - damageAfterResist
		removeDebuff(enemy, player.frostfreeze.debuff)
		if (enemy.health > 0) {
			spell.specialEffect(enemy, damageAfterResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterResist)
		}
	} else if (spell.refName == 'frostfreeze' && enemy?.debuffs?.frostbite?.stacks == 3) {
		let mainEnemyIndex = allEnemies.indexOf(enemy)
		let additionalEnemyIndex1 = mainEnemyIndex == 0 ? 2 : mainEnemyIndex - 1
		let additionalEnemyIndex2 = mainEnemyIndex + 1
		let splitDamage = Math.ceil(mainDamage * 0.5) //damage is half that of the main spell
		let damageAfterResist = calculateMagicDamageWithResist(splitDamage, enemy.iceResist, player.icePen)
		let damageResisted = splitDamage - damageAfterResist
		removeDebuff(enemy, player.frostfreeze.debuff)
		if (enemy.health > 0) {
			spell.specialEffect(enemy)
			spell.specialEffect2(enemy, damageAfterResist, damageResisted)
			applyDamageToEnemy(enemy, damageAfterResist)
		}
		if (allEnemies[additionalEnemyIndex2]) {
			let damageAfterResist = calculateMagicDamageWithResist(splitDamage, allEnemies[additionalEnemyIndex2].iceResist, player.icePen)
			let damageResisted = splitDamage - damageAfterResist
			spell.specialEffect2(allEnemies[additionalEnemyIndex2], damageAfterResist, damageResisted)
			applyDamageToEnemy(allEnemies[additionalEnemyIndex2], damageAfterResist)
			if (allEnemies[additionalEnemyIndex2]?.debuffs?.frostbite?.stacks < 2 || !allEnemies[additionalEnemyIndex2].debuffs) {
			applyDebuff(allEnemies[additionalEnemyIndex2], spell.debuff)
			}
		}
		if (allEnemies[additionalEnemyIndex1]) {
			let damageAfterResist = calculateMagicDamageWithResist(splitDamage, allEnemies[additionalEnemyIndex1].iceResist, player.icePen)
			let damageResisted = splitDamage - damageAfterResist
			spell.specialEffect2(allEnemies[additionalEnemyIndex1], damageAfterResist, damageResisted)
			applyDamageToEnemy(allEnemies[additionalEnemyIndex1], damageAfterResist)
			if (allEnemies[additionalEnemyIndex1]?.debuffs?.frostbite?.stacks < 2 || !allEnemies[additionalEnemyIndex1].debuffs) {
				applyDebuff(allEnemies[additionalEnemyIndex1], spell.debuff)
				}		
			}
	}
}

function calculateShockEffect(enemy, spell, damageObject) {
	let mainDamage = damageObject.damageBeforeMagicResist
	if (spell.refName == 'bolt') {}
	if (spell.refName == 'chainLightning') {
		let bonusDamage = mainDamage * 0.5
		return Math.ceil(bonusDamage)
	}
}

// function handleSpellCast(enemy, spell) {
// 	if (!player.isAlive) {return}
// 	if (checkAvailableEnemy(enemy)) {return}
// 	if (spell.debuff) {applyDebuff(enemy, spell.debuff)}
// 	let spellIndex = player.spellsConjured.indexOf(spell)
// 	let damageBeforeMagicResist = spell.damage(enemy)
// 	let damageAfterMagicResist = calculateMagicDamageWithResist(damageBeforeMagicResist, enemyFireResist)
// 	let damageResisted = damageBeforeMagicResist - damageAfterMagicResist
// 	player.spellsConjured.splice(spellIndex, 1)
// 	spell.chambered = false
// 	spell.flavorTextCast(enemy, damageAfterMagicResist, damageResisted)
// 	applyDamageToEnemy(enemy, damageAfterMagicResist)
// 	//put bonus functions here
// 	calculateBurnEffect(enemy, spell, damageBeforeMagicResist)
// 	calculateFrostbiteEffect(enemy, spell, damageAfterMagicResist)
// 	//put bonus functions here
// }
// function handleSpellCastAoE(spell) {
// 	if (!player.isAlive) {return}
// 	let allEnemies = getAllEnemiesInRoom()
// 	let numberOfTargets = spell.numberOfTargets == 'all' ? allEnemies.length : spell.numberOfTargets
// 	console.log(numberOfTargets, ' NUMBER OF TARGETS')
// 	for (let i = 0; i < numberOfTargets; i++) {
// 		if (checkAvailableEnemy(allEnemies[i])) {return}
// 		if (spell.debuff) {applyDebuff(allEnemies[i], spell.debuff)}
// 		// let damageBeforeMagicResist = spell.damage(allEnemies[i])
// 		let damageBeforeMagicResist = spell.damage(numberOfTargets, allEnemies[i])

// 		let damageAfterMagicResist = calculateMagicDamageWithResist(damageBeforeMagicResist, enemyMagicResist)
// 		let damageResisted = damageBeforeMagicResist - damageAfterMagicResist
// 		quickMessage(`${damageBeforeMagicResist} before MR`)
// 		quickMessage(`${damageAfterMagicResist} after MR`)
// 		quickMessage(`${damageResisted} amount resisted`)
// 		spell.flavorTextCast(allEnemies[i], damageAfterMagicResist, damageResisted)
// 		applyDamageToEnemy(allEnemies[i], damageAfterMagicResist)
// 		//put bonus functions here
// 		calculateBurnEffect(allEnemies[i], spell, damageBeforeMagicResist)
// 		calculateFrostbiteEffect(allEnemies[i], spell, damageAfterMagicResist)
// 		//put bonus functions here
// 	}
// 	let spellIndex = player.spellsConjured.indexOf(spell)
// 	player.spellsConjured.splice(spellIndex, 1)
// 	spell.chambered = false
// }

function displayKillList() {
	blankSpace()
	for (let item in player.killList) {
		let line = lineFunc()
		customizeEachWord(`${item}: `, 'red', line)
		customizeEachWord(`${player.killList[item]}`, 'light-blue', line)
	}
	blankSpace()
}

function checkIfDuplicateSpell(spell) {
	let isSpellConjured = false
	player.spellsConjured.some(chamberedSpell => {
		if (chamberedSpell.refName == spell.refName) {
			console.log(chamberedSpell)
			console.log(spell)
			isSpellConjured = true
		}
	})
	return isSpellConjured
}

function initializeConjureBar(spell) {
	let conjureBarToUse
	let fullBar
	const conjureBar1 = document.querySelector('.bar-1')
	const conjureBar2 = document.querySelector('.bar-2')
	const conjureBar3 = document.querySelector('.bar-3')
	const isConjureBar1Full = Array.from(conjureBar1.classList).some(item => item == 'bar-1-full')
	const isConjureBar2Full = Array.from(conjureBar2.classList).some(item => item == 'bar-2-full')
	const isConjureBar3Full = Array.from(conjureBar3.classList).some(item => item == 'bar-3-full')
	if (!isConjureBar1Full) {
		conjureBarToUse = conjureBar1
		fullBar = 'bar-1-full'
	} else if (!isConjureBar2Full) {
		conjureBarToUse = conjureBar2
		fullBar = 'bar-2-full'
	} else {
		conjureBarToUse = conjureBar3
		fullBar = 'bar-3-full'
	}
	conjureBarToUse.classList.add(`${spell.conjureBarColor}`)
	conjureBarToUse.classList.add(`${spell.refName}`)
	let conjureTime = Math.floor(spell.conjureTime())
	let remainingTime = conjureTime
	const intervalId = setInterval(() => {
		if (remainingTime <= 0) {
			conjureBarToUse.classList.add(`${fullBar}`)
			clearInterval(intervalId)
			return
		}
		const width = ((conjureTime - remainingTime) / conjureTime) * 100
		conjureBarToUse.style.width = `${width}%`
		remainingTime -= 10
	}, 10)
}

function initiateCastBar(spell) {
	let castBarToUse;
	const castBar1 = document.querySelector('.bar-1');
	const castBar2 = document.querySelector('.bar-2');
	const castBar3 = document.querySelector('.bar-3');
	const castBar1Array = Array.from(castBar1.classList);
	const castBar2Array = Array.from(castBar2.classList);
	const castBar3Array = Array.from(castBar3.classList);

	if (castBar1Array.some(item => item == spell.refName)) {
		castBarToUse = castBar1;
	} else if (castBar2Array.some(item => item == spell.refName)) {
		castBarToUse = castBar2;
	} else {
		castBarToUse = castBar3;
	}

	castBarToUse.style.width = '0%'; // Start from 100%
	const castTime = spell.channelTime();
	let startTime;
	let animationId;

	function animateBar(timestamp) {
		if (!startTime) {
			startTime = timestamp;
		}
		const progress = Math.max(1 - (timestamp - startTime) / castTime, 0); // Reverse progress calculation
		const width = progress * 100;
		castBarToUse.style.width = `${width}%`;

		if (progress > 0) {
			animationId = requestAnimationFrame(animateBar);
		} else {
			castBarToUse.style.width = '0%';
			let test = Array.from(castBarToUse.classList)
			castBarToUse.classList = test[0]
		}
	}

	animationId = requestAnimationFrame(animateBar);

	function stopAnimation() {
		cancelAnimationFrame(animationId);
	}

    // Stop animation if needed
    // For example, if the spell is interrupted
    // setTimeout(stopAnimation, 0); // Example usage
}

// function initiateCastBar2(spell) {
// 	let castBarToUse
// 	const castBar1 = document.querySelector('.bar-1')
// 	const castBar2 = document.querySelector('.bar-2')
// 	const castBar3 = document.querySelector('.bar-3')
// 	const castBar1Array = Array.from(castBar1.classList)
// 	const castBar2Array = Array.from(castBar2.classList)
// 	const castBar3Array = Array.from(castBar3.classList)
// 	if (castBar1Array.some(item => item == spell.refName)) {
// 		castBarToUse = castBar1
// 		// castBarToUse.classList.remove('bar-1-full')
// 	} else if (castBar2Array.some(item => item == spell.refName)) {
// 		castBarToUse = castBar2
// 		// castBarToUse.classList.remove('bar-2-full')
// 	} else {
// 		castBarToUse = castBar3
// 		// castBarToUse.classList.remove('bar-3-full')
// 	}
// 	console.log(castBarToUse)
// 	// const castingBar = document.querySelector('.bar-1')
// 	castBarToUse.style.width = '100%'
// 	let castTime = spell.channelTime()
// 	let remainingTime = castTime
// 	let intervalDuration = 10
// 	const intervalId = setInterval(() => {
// 		remainingTime -= intervalDuration
// 		quickMessage(`Cast milliseconds: ${remainingTime}`)
// 		if (remainingTime <= 0) {
// 			castBarToUse.style.width = '0%'
// 			let test = Array.from(castBarToUse.classList)
// 			castBarToUse.classList = test[0]
// 			clearInterval(intervalId)
// 		} else {
// 			const width = (remainingTime / castTime) * 100
// 			castBarToUse.style.width = `${width}%`
// 		}
// 	}, intervalDuration)
// }



///////////////////////////////////////////////////////////////////////////////////////////////
function updateScroll() {
	masterArea.scrollTop = masterArea.scrollHeight
}

const newLocation = (x, y, z, s) => {
	currentArea.isPlayerHere = false
	let newArea = allAreas.find(area => area.x == x && area.y == y && area.z == z)
	if (!newArea) {
		quickMessage(`This area does not exist`)
		return
	}
	if (player.x === x && player.y === y && player.z === z) {
		previousArea = currentArea
		currentArea = newArea
		additional.innerHTML = playerProxy.x + ', ' + playerProxy.y + ', ' + currentArea.descriptions.areaName + ' ' + currentArea.id
	}
	player.roomId = currentArea.id
	currentArea.isPlayerHere = true
}

//Changes players x, y, or z coordinate if a move is possible and is made
//the locationCheck parameter below calls the newLocation function above

//Rolls to see if a enemy will spawn
function onRoomEntry() {
	if (currentArea.descriptions.onEntry != undefined) {
		currentArea.descriptions.onEntry()
	}
	if (currentArea.onEntry != undefined) {
		currentArea.onEntry()
	}
}
function itemRoll() {
	weaponGen(crudeShiv(3, true))
	weaponGen(crudeShiv(3, true))
	weaponGen(dirk(3, true))
	weaponGen(dirk(3, true))
	weaponGen(stiletto(3, true))
	weaponGen(stiletto(3, true))
	weaponGen(crescentDagger(3, true))
	weaponGen(crescentDagger(3, true))

	weaponGen(trainingShortsword(3, true))
	weaponGen(shortsword(3, true))
	weaponGen(broadSword(3, true))
	weaponGen(gladius(3, true))
	weaponGen(sabre(3, true))

	weaponGen(trainingTwoHandedSword(3, true))
	weaponGen(longsword(3, true))
	weaponGen(claymore(3, true))
	weaponGen(bastardSword(3, true))
	weaponGen(greatsword(3, true))

	weaponGen(shortbow(3, true))
	weaponGen(longbow(3, true))
	weaponGen(battleBow(3, true))

	armorGen(clothCap(3, true))
	armorGen(apprenticeRobes(3, true))
	armorGen(clothGloves(3, true))
	armorGen(sandals(3, true))

	armorGen(mailChestGuard(3, true))
	armorGen(leatherShoulderguards(3, true))

	armorGen(leatherGloves(3, true))
	armorGen(plateLeggings(3, true))
	armorGen(plateBoots(3, true))
	armorGen(squiresShield(3, true))
	armorGen(galvadianKiteShield(3, true))
	armorGen(bronzeShield(3, true))
	armorGen(galvadianKiteShield(3, true))
	consumableGen(smallHealingPotion(3, true))
}

//Spawns a enemy if the roll === enemy spawn chance
//setInterval(enemySpawn, 5000);
//_________________________________________________________________________________________________________________________________________________________________________________________________________________
//paragraph elements
let enemy1 = document.getElementById('enemy1')
let enemy2 = document.getElementById('enemy2')
let enemy3 = document.getElementById('enemy3')

//ITEMS_________________ITEMS______________________ITEMS___________________ITEMS______________________ITEMS________________________ITEMS
//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////
function apple() {
	let apple = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Apple',
		refName: 'apple',
		color: 'green',
		keywords: ['food', 'apple'],
		type: {
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 10,
			manaBonus: 10,
			duration: 30000,
		},
		desc: function() {
			let line1 = lineFunc()
			allItemDescription(`A solid red apple. Looks delicious!`, 'white', line1)
		},
		price: 1,
		sellValue: 1,

	}
	return apple
}
function mudBall() { //eat for health
	let mudball = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mudball',
		refName: 'mudball',
		color: 'green',
		keywords: ['mud', 'ball', 'mudball'],
		type: {
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 10,
			manaBonus: 0,
			duration: 100000,
		},
		sellValue: 10,
		description: `A moist ball of mud - Try eating it or giving it to someone who likes to play with mud!`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return mudball
}

function waterBerry() { //eat for mana
	let waterBerry = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Water Berry',
		color: 'green',
		keywords: ['water', 'berry', 'water berry'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 0,
			manaBonus: 10,
			duration: 100000,
		},
		sellValue: 10,
		description: `A plump, luscious, Water Berry - Try eating it or giving it to someone who is thirsty!`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return waterBerry
}
function grassFruit() { //eat for mana
	let grassFruit = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Grass Fruit',
		color: 'green',
		keywords: ['grass', 'fruit', 'grass fruit'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 5,
			manaBonus: 5,
			duration: 100000,
		},
		sellValue: 10,
		description: `A Grass Fruit! You're not sure what it is, but it looks kinda tastey.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return grassFruit
}

function halfEatenFish() {
	let halfEatenFish = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Half Eaten Fish',
		refName: 'halfEatenFish',
		color: 'green',
		keywords: ['half', 'eaten', 'fish', 'half eaten', 'eaten fish', 'half eaten fish'],
		type: {
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 20,
			manaBonus: 20,
			duration: 30000,
		},
		price: 0,
		sellValue: 15,
		desc: function() {
			let line1 = lineFunc()
			allItemDescription(`The front half of a medium sized fish. The backbone and tail skeleton are still attached.`, 'white', line1)
		},
	}
	return halfEatenFish
}

function rawBoarMeat() {
	let rawBoarMeat = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Raw Boar Meat',
		refName: 'rawBoarMeat',
		color: 'green',
		keywords: ['raw', 'boar', 'meat', 'raw boar', 'boar meat', 'raw boar meat'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: true,
		cookedVersion: boarSteak,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 10,
			manaBonus: 10,
			duration: 10000,
		},
		sellValue: 8,
		description: `A big hunk of boar meat`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return rawBoarMeat
}

function boarSteak() {
	let boarSteak = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Boar Steak',
		refName: 'boarSteak',
		color: 'green',
		keywords: ['boar', 'steak', 'boar steak'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
			let line1 = lineFunc()
			customizeEachWord(`You sizzle up a juicy `, 'white', line1)
			customizeEachWord(`${this.name}`, 'green', line1)
			customizeEachWord(`!`, 'white', line1)
		},
		buff: {
			name: 'Sated',
			healthBonus: 30,
			manaBonus: 30,
			duration: 60000,
		},
		sellValue: 15,
		description: `A cooked boar steak`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return boarSteak
}
function applePie() {
	let applePie = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Apple Pie',
		refName: 'appliePie',
		color: 'green',
		keywords: ['apple', 'pie', 'apple pie'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
		},
		buff: {
			name: 'Sated',
			healthBonus: 80,
			manaBonus: 80,
			duration: 60000,
		},
		price: 100,
		sellValue: 12,
		description: `A scrumptious smelling apple pie!`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return applePie
}





function koboldSkull() {
	let koboldSkull = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Kobold Skull',
		refName: 'koboldSkull',
		color: 'green',
		keywords: ['kobold', 'skull', 'kobold skull'],
		type: { quest: true },
		sellValue: 2,
		description: `The small, cracked skull of a kobold`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return koboldSkull
}
function legBone() { //used in crafting to craft two-handed weapons
	let legBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leg Bone',
		refName: 'legBone',
		color: 'green',
		keywords: ['leg', 'bone', 'leg bone'],
		type: { quest: true },
		sellValue: 15,
		description: `A human femur`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return legBone
}
function crackedBone() { //used in crafting to craft one handed weapons and daggers
	let crackedBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cracked Bone',
		refName: 'crackedBone',
		color: 'green',
		keywords: ['cracked', 'bone', 'cracked bone'],
		type: { sell: true },
		sellValue: 10,
		description: `A cracked, human bone`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return crackedBone
}
function ribCage() { //used in crafting to craft one handed weapons and daggers
	let ribCage = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rib Cage',
		refName: 'ribCage',
		color: 'green',
		keywords: ['rib', 'cage', 'rib cage'],
		type: { quest: true },
		sellValue: 5,
		description: `A human ribcage`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ribCage
}


function cultTexts() {
	let cultTexts = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cult Texts',
		refName: 'cultTexts',
		color: 'green',
		keywords: ['cult', 'texts', 'text', 'cult texts'],
		type: { 
			quest: true,
			unique: true,
		},
		sellValue: 0,
		description: `A book adorned with strange symbols`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return cultTexts
}
// function thievesJewel() { 
// 	let thievesJewel = {
// 		id: function () {
// 			for (let i = 0; i < 50; i++) {
// 				if (!pushItem[i]) {
// 					return i
// 				}
// 			}
// 		},
// 		roomId: currentArea.id,
// 		name: `Thieve's Jewel`,
// 		refName: 'thievesJewel',
// 		color: 'green',
// 		keywords: [`thieve's`, 'jewel', `thieve's jewel`],
// 		type: { quest: true },
// 		sellValue: 0,
// 		description: `A beautifully cut, yellow Topaz`,
// 		desc: function () {
// 			allItemDescription(this)
// 		},
// 	}
// 	return thievesJewel
// }
// function secretText() { 
// 	let secretText = {
// 		id: function () {
// 			for (let i = 0; i < 50; i++) {
// 				if (!pushItem[i]) {
// 					return i
// 				}
// 			}
// 		},
// 		roomId: currentArea.id,
// 		name: 'Secret Text',
// 		refName: 'secretText',
// 		color: 'green',
// 		keywords: [`secret`, `text`, `secret text`],
// 		type: { quest: true },
// 		sellValue: 0,
// 		description: `A book with Monk's Guild imagery painted all over it`,
// 		desc: function () {
// 			allItemDescription(this)
// 		},
// 	}
// 	return secretText
// }




function generateId() {
	for (let i = 0; i < 50; i++) {
		if (!pushItem[i]) {
			return i
		}
	}
}




//////////////////////////////////////////////////++FISH++///////////////////////////////////////////////////
function mudSucker(level, isMonsterDrop) {
	let mudSucker = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mud Sucker',
		refName: 'mudSucker',
		color: 'green',
		keywords: ['mud', 'sucker', 'mud sucker'],
		type: {
			fish: true,
			food: true,
		},
		cookable: true,
		cookedVersion: friedMudSucker,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 20,
			manaBonus: 10,
			duration: 60000,
		},
		get sellValue() {
			let baseSellValue = 10
			let fishingLevel = player?.fishing?.level ? player.fishing.level : 1
			let totalSellValue = baseSellValue * fishingLevel
			return totalSellValue
		},
		description: `A bottom dwelling fish that helps keep bodies of water clean.`,
		desc: function () {
			allItemDescription(this)
		},
		get timeTilBite() {
			return randomNumberRange(10000, 30000)
		},
		speed: 6000,
		catchRange: 30,
	}
	return mudSucker
}

function friedMudSucker() {
	let friedMudSucker = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Fried Mud Sucker',
		refName: 'friedMudSucker',
		color: 'green',
		keywords: ['fried', 'mud', 'sucker', 'fried mud', 'fried mud sucker'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
			let line1 = lineFunc()
			customizeEachWord(`You sizzle up a juicy `, 'white', line1)
			customizeEachWord(`${this.name}`, 'green', line1)
			customizeEachWord(`!`, 'white', line1)
		},
		buff: {
			name: 'Sated',
			healthBonus: 30,
			manaBonus: 30,
			duration: 60000,
		},
		sellValue: 15,
		description: `A cooked Mud Sucker`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return friedMudSucker
}

function leafPerch(level, isMonsterDrop) {
	let leafPerch = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leaf Perch',
		refName: 'leafPerch',
		color: 'green',
		keywords: ['leaf', 'perch', 'leaf perch'],
		type: {
			fish: true,
			food: true,
		},
		cookable: true,
		cookedVersion: poachedLeafPerch,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 20,
			manaBonus: 10,
			duration: 60000,
		},
		get sellValue() {
			let baseSellValue = 25
			let fishingLevel = player?.fishing?.level ? player.fishing.level : 1
			let totalSellValue = baseSellValue * fishingLevel
			return totalSellValue
		},
		description: `This fish looks like a thin, wavy leaf.`,
		desc: function () {
			allItemDescription(this)
		},
		get timeTilBite() {
			return randomNumberRange(10000, 30000)
		},
		speed: 6000,
		catchRange: 30,
	}
	return leafPerch
}
function poachedLeafPerch() {
	let poachedLeafPerch = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Poached Leaf Perch',
		refName: 'poachedLeafPerch',
		color: 'green',
		keywords: ['poached', 'leaf', 'perch', 'poached leaf', 'poached leaf perch'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
			let line1 = lineFunc()
			customizeEachWord(`You poach up a fresh `, 'white', line1)
			customizeEachWord(`${this.name}`, 'green', line1)
			customizeEachWord(`!`, 'white', line1)
		},
		buff: {
			name: 'Sated',
			healthBonus: 30,
			manaBonus: 30,
			duration: 60000,
		},
		sellValue: 15,
		description: `A poached Leaf Perch.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return poachedLeafPerch
}
function cornWallup(level, isMonsterDrop) {
	let cornWallup = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Corn Wallup',
		refName: 'cornWallup',
		color: 'green',
		keywords: ['corn', 'wallup', 'corn wallup'],
		type: {
			fish: true,
			food: true,
		},
		cookable: true,
		cookedVersion: creamedCornWallup,
		cookPhrase: undefined,
		buff: {
			name: 'Sated',
			healthBonus: 20,
			manaBonus: 10,
			duration: 60000,
		},
		get sellValue() {
			let baseSellValue = 30
			let fishingLevel = player?.fishing?.level ? player.fishing.level : 1
			let totalSellValue = baseSellValue * fishingLevel
			return totalSellValue
		},
		description: `The Corn Wallup is a pale yet bright yellow fish. It's cylindrical shape gives it its distinctive corn cob shape.`,
		desc: function () {
			allItemDescription(this)
		},
		get timeTilBite() {
			return randomNumberRange(10000, 30000)
		},
		speed: 6000,
		catchRange: 30,
	}
	return cornWallup
}
function creamedCornWallup() {
	let creamedCornWallup = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Creamed Corn Wallup',
		refName: 'creamedCornWallup',
		color: 'green',
		keywords: ['creamed', 'wallup', 'creamed corn wallup'],
		type: { 
			quest: true,
			food: true,
		},
		cookable: false,
		cookedVersion: undefined,
		cookPhrase: function() {
			let line1 = lineFunc()
			customizeEachWord(`You chop up the fish, add a little cream, and cook up a delicious `, 'white', line1)
			customizeEachWord(`${this.name}`, 'green', line1)
			customizeEachWord(`!`, 'white', line1)
		},
		buff: {
			name: 'Sated',
			healthBonus: 30,
			manaBonus: 30,
			duration: 60000,
		},
		sellValue: 15,
		description: `A creamed up Corn Wallup.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return creamedCornWallup
}

//////////////////////////////////////////////////++FOOD ITEMS++///////////////////////////////////////////////////

//////////////////////////////////////////////////++TREASURE ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++TREASURE ITEMS++///////////////////////////////////////////////////
function quartz(level, isMonsterDrop) { 
	let smallQuartz = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Quartz',
		refName: 'quartz',
		color: 'green',
		keywords: ['quartz'],
		type: { 
			treasure: true,
		},		
		sellValue: 50,
		description: `A small, shiny quartz. This item is only for selling.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return smallQuartz
}
function topaz(level, isMonsterDrop) { 
	let topaz = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Topaz',
		refName: 'topaz',
		color: 'green',
		keywords: ['topaz'],
		type: { 
			treasure: true,
		},		
		sellValue: 78,
		description: `A pretty, yellow topaz. This item is only for selling.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return topaz
}
function opal(level, isMonsterDrop) { 
	let opal = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Opal',
		refName: 'opal',
		color: 'green',
		keywords: ['opal'],
		type: { 
			treasure: true,
		},		
		sellValue: 127,
		description: `A small, colorful opal. This item is only for selling.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return opal
}
function jade(level, isMonsterDrop) { 
	let jade = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Jade',
		refName: 'jade',
		color: 'green',
		keywords: ['jade'],
		type: { 
			treasure: true,
		},		
		sellValue: 127,
		description: `A small, green Jade. This item is only for selling.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return jade
}
//pearl
//ruby
//sapphire
//emerald
//aquamarine

//////////////////////////////////////////////////++TREASURE ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++TREASURE ITEMS++///////////////////////////////////////////////////



//////////////////////////////////////////////////++CHEST ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++CHEST ITEMS++///////////////////////////////////////////////////
function smallSackOfGold(level, isMonsterDrop) {
	let smallSackOfGold = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Sack of Gold',
		refName: 'smallSackOfGold',
		color: 'yellow',
		keywords: ['small sack', 'sack', 'small sack of gold'],
		type: { 
			openable: true,
			treasure: true,
		},
		spillContents: async function(sackOfGold) {
			let line1 = lineFunc()
			let goldAmount = randomNumberRange(30, 100)
			currentArea.gold += goldAmount
			await dialogueWait(200)
			smallChestOpen.play()
			blankSpace()
			customizeEachWord(`You open the `, 'white', line1)
			customizeEachWord(`${sackOfGold.name} `, sackOfGold.color, line1)
			customizeEachWord(`and gold drops to the ground.`, 'white', line1)
			blankSpace()
			removeItemFromPerson(sackOfGold)
		},
		sellValue: 0,
		description: `A small sack of coins`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return smallSackOfGold
}
function smallChest(level, isMonsterDrop) { //used for crafting tier 3 and 4
	let smallChest = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Chest',
		refName: 'smallChest',
		color: 'green',
		keywords: ['small', 'chest', 'small chest'],
		itemDrops: [],
		spillContents: async function(itemInHand) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			let line3 = lineFunc()
			let goldAmount = randomNumberRange(30, 100)
			currentArea.gold += goldAmount
			randomNumberRange(1, 100) <= 2 && itemInHand.itemDrops.push(quartz())
			randomNumberRange(1, 100) <= 2 && itemInHand.itemDrops.push(topaz())
			randomNumberRange(1, 100) <= 2 && itemInHand.itemDrops.push(opal())
			randomNumberRange(1, 100) <= 10 && itemInHand.itemDrops.push(healingPotion())
			randomNumberRange(1, 100) <= 10 && itemInHand.itemDrops.push(manaPotion())
			randomNumberRange(1, 100) <= 50 && itemInHand.itemDrops.push(smallHealingPotion())
			randomNumberRange(1, 100) <= 50 && itemInHand.itemDrops.push(smallManaPotion())
			await dialogueWait(200)
			smallChestOpen.play()
			blankSpace()
			customizeEachWord(`You open the `, 'white', line1)
			customizeEachWord(`${itemInHand.name}`, itemInHand.color, line1)
			customizeEachWord(` and the contents spill out onto the ground.`, 'white', line1)
			customizeEachWord(`The chest contained:`, 'white', line2)
			customizeEachWord(`${goldAmount} `, ['item-drops-margin', 'yellow'], line3)
			customizeEachWord(`gold piece(s)`, 'white', line3)
			this.itemDrops.forEach(item => {
				let line1 = lineFunc()
				line1.classList.add('item-drops-margin')
				customizeEachWord(`${item.name}`, item.color, line1)
				pushItem.push(item)
				item.roomId = currentArea.id
				removeItemFromPerson(itemInHand)
			})
			blankSpace()
		},
		type: { 
			treasure: true,
			openable: true,
		},		
		sellValue: 0,
		description: `A fuzzy patch of Gnoll fur.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return smallChest
}
//////////////////////////////////////////////////++CHEST ITEMS++///////////////////////////////////////////////////
//////////////////////////////////////////////////++CHEST ITEMS++///////////////////////////////////////////////////


//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++QUEST ITEMS++//////////////////////////////////////////////////
function gnollFur(level, isMonsterDrop) { //used for crafting tier 3 and 4
	let gnollFur = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Gnoll Fur',
		refName: 'gnollFur',
		color: 'green',
		keywords: ['gnoll', 'fur', 'gnoll fur'],
		type: { 
			quest: true ,
			crafting: true,
		},		
		sellValue: 100,
		description: `A fuzzy patch of Gnoll fur.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return gnollFur
}
function wormGuts(level, isMonsterDrop) { //QUEST FOR TIM-TIM
	let wormGuts = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Worm Guts',
		refName: 'wormGuts',
		color: 'green',
		keywords: ['worm', 'guts', 'worm guts'],
		type: { quest: true },
		sellValue: 5,
		description: `Mushy, stinky worm guts`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return wormGuts
}
function littleBoneToy(level, isMonsterDrop) { //QUEST FOR MOTHER WITH BABY
	let littleBoneToy = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Little Bone Toy',
		refName: 'littleBoneToy',
		color: 'green',
		keywords: ['little', 'bone', 'toy', 'little bone', 'bone toy', 'little bone toy'],
		type: { quest: true },
		sellValue: 5,
		description: `You can barely make out that it's a toy at all with how crudely it was crafted. Upon closer inspection, it looks to be made of small.. Human bones?`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return littleBoneToy
}

function goblinHead(monsterLevel) {
	let goblinHead = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: '',
		name: 'goblin head',
		color: 'green',
		experience: 10,
		keywords: ['goblin', 'head', 'goblin head'],
		type: { quest: true },
		sellValue: monsterLevel,
		description: `A decapitated goblin's with a pained expression frozen on its face`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return goblinHead
}
function tutorialKey() {
	let tutorialKey = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: 5,
		name: 'Simple Key',
		refName: 'simpleKey',
		color: 'green',
		keywords: ['simple', 'key', 'simple key'],
		type: { quest: true },
		roomToUnlock: 'Galvadia Welcome Area 5',
		description: `A simple looking key`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return tutorialKey
}
function pairOfGlasses() {
	let pairOfGlasses = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: 7,
		name: 'Pair of Glasses',
		refName: 'pairOfGlasses',
		color: 'green',
		keywords: ['pair', 'glasses', 'pair of glasses'],
		type: { quest: true },
		description: `A pair of silver bifocals. Perhaps they belong to Egbert?`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return pairOfGlasses
}
function ratCarcass(level, isMonsterDrop) { //used in crafting to craft leather armor
	let ratCarcass = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Carcass',
		color: 'green',
		keywords: ['rat', 'carcass', 'rat carcass'],
		type: { quest: false },
		sellValue: 1,
		description: '...The lifeless corpse of a rat... Looks like some of the parts could be salvaged for use in crafting',
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratCarcass
}
function ratHide() { //used in crafting to craft leather armor
	let ratHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Hide',
		color: 'green',
		keywords: ['rat', 'hide', 'rat hide'],
		type: { quest: false },
		sellValue: 0,
		description: 'The skinned hide of a rat',
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratHide
}
function tannedRatHide(level, isMonsterDrop) { //used in crafting to craft leather armor
	let tannedRatHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Tanned Rat Hide',
		color: 'green',
		keywords: ['tanned', 'rat', 'hide', 'tanned rat', 'rat hide', 'tanned rat hide'],
		type: { quest: false },
		sellValue: 1,
		description: 'A well tanned rat hide ready for use',
		desc: function () {
			allItemDescription(this)
		},
	}
	return tannedRatHide
}

function ratTail(level, isMonsterDrop) { //used in crafting to craft leather armor
	let ratTail = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Tail',
		refName: 'ratTail',
		color: 'green',
		keywords: ['rat', 'tail', 'rat tail'],
		type: { quest: true },
		sellValue: 20,
		description: `A thick, long rat tail`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratTail
}
function ratSkin(level, isMonsterDrop) {
	let ratSkin = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Skin',
		refName: 'ratSkin',
		color: 'green',
		keywords: ['rat', 'skin', 'rat skin'],
		type: { quest: true },
		sellValue: 10,
		description: `The thin hide of a rat`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ratSkin
}
function stagAntlers(level, isMonsterDrop) {
	let stagAntlers = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stag Antlers',
		refName: 'stagAnterls',
		color: 'green',
		keywords: ['antlers'],
		type: { sell: true },
		sellValue: 77,
		description: `A large rack of Stag Antlers.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return stagAntlers
}
function brokenAntlers(level, isMonsterDrop) {
	let brokenAntlers = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stag Antlers',
		refName: 'stagAnterls',
		color: 'green',
		keywords: ['antlers'],
		type: { sell: true },
		sellValue: 22,
		description: `Broken Stag antlers.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return brokenAntlers
}



/////////////////////////////////                  CRAFTING                    /////////////////////////////////
/////////////////////////////////                  CRAFTING                    /////////////////////////////////
/////////////////////////////////                  CLOTH                    /////////////////////////////////
function clover() {
	let clover = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Clover',
		refName: 'clover',
		color: 'green',
		keywords: ['clover'],
		tier: 1,
		increase: 1,
		type: { 
			quest: true ,
			crafting: true,
		},			
		sellValue: 10,
		description: `Thin fibrous material used for weaving cloth armor. A tailor would have use for this.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return clover
}
function orchid() {
	let orchid = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Refined Fiber',
		refName: 'orchid',
		color: 'green',
		keywords: ['refined', 'fiber', 'refined fiber'],
		tier: 2,
		increase: 2,
		type: { 
			quest: true ,
			crafting: true,
		},	
		sellValue: 38,
		description: `Thin yet refined fibers used for weaving cloth armor. Turn this in to a tailor so they can craft more items`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return orchid
}
/////////////////////////////////                  LEATHER                    /////////////////////////////////
function lightHide(level, isMonsterDrop) { //used for crafting tier 1 and 2
	let lightHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Light Hide',
		refName: 'lightHide',
		color: 'green',
		keywords: ['light', 'hide', 'light hide'],
		tier: 1,
		increase: 2,
		type: { 
			quest: true,
			crafting: true,
		},
		sellValue: 35,
		description: `The thin hide of an animal. Turn this in to a leatherworker so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return lightHide
}
function thickHide(level, isMonsterDrop) { //used for crafting tier 3 and 4
	let thickHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Thick Hide',
		refName: 'thickHide',
		color: 'green',
		keywords: ['thick', 'hide', 'thick hide'],
		tier: 2,
		increase: 4,
		type: { 
			quest: true ,
			crafting: true,
		},		
		sellValue: 55,
		description: `The thick hide of an animal. Turn this in to a leatherworker so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return thickHide
}
function gnollHide(level, isMonsterDrop) { //used for crafting tier 3 and 4
	let gnollHide = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Gnoll Hide',
		refName: 'gnollHide',
		color: 'green',
		keywords: ['gnoll', 'hide', 'gnoll hide'],
		type: { 
			quest: true ,
			crafting: true,
		},		
		sellValue: 100,
		description: `The thick hide of an animal. Turn this in to a leatherworker so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return gnollHide
}
/////////////////////////////////                  PLATE                    /////////////////////////////////
function copperOre() { //used in crafting to craft leather armor
	let copperOre = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Copper Ore',
		refName: 'copperOre',
		color: 'green',
		keywords: ['copper', 'ore', 'copper ore'],
		tier: 1,
		increase: 1,
		type: {
			quest: true ,
			crafting: true,
			copper: true,
		},
		sellValue: 47,
		description: `A small lump of copper ore. Turn this in to a blacksmith or armor smith so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return copperOre
}
function ironOre() { //used in crafting to craft leather armor
	let ironOre = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Iron Ore',
		refName: 'ironOre',
		color: 'green',
		keywords: ['iron', 'ore', 'iron ore'],
		tier: 2,
		increase: 2,
		type: { 
			quest: true ,
			crafting: true,
			iron: true,
		},		
		sellValue: 84,
		description: `A small lump of iron ore. Turn this in to a blacksmith or armor smith so they can craft more items.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return ironOre
}

function crucifix(level, isMonsterDrop) { //QUEST ITEM FOR CATHEDRAL
	let crucifix = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crucifix',
		refName: 'crucifix',
		color: 'green',
		keywords: ['crucifix'],
		type: { quest: true },
		sellValue: 22,
		description: `An ornately carved crucifix. It has dried blood around the edges..`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return crucifix
}
function emptyBucket(level, isMonsterDrop) { //QUEST ITEM FOR CATHEDRAL
	let emptyBucket = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Empty Bucket',
		refName: 'emptyBucket',
		color: 'green',
		keywords: ['bucket', 'empty bucket'],
		type: { quest: true },
		sellValue: 22,
		description: `And empty bucket.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return emptyBucket
}

function brightYellowFlower() { //QUEST ITEM FOR THE GLADE
	let brightYellowFlower = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bright Yellow Flower',
		refName: 'brightYellowFlower',
		color: 'green',
		keywords: ['bright', 'yellow', 'flower', 'bright yellow', 'yellow flower', 'bright yellow flower'],
		type: { quest: true },
		sellValue: 0,
		description: `A bright yellow flower`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return brightYellowFlower
}
function sackOfGrain() { //QUEST ITEM FOR THE WAGON IN TOWN
	let sackOfGrain = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sack of Grain',
		refName: 'sackOfGrain',
		color: 'green',
		keywords: ['sack', 'grain', 'sack of grain'],
		type: { quest: true },
		sellValue: 0,
		description: `A large sack of grain`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return sackOfGrain
}

function largeBone(level, isMonsterDrop) { //used in crafting to craft leather armor
	let largeBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Large Bone',
		refName: 'largeBone',
		color: 'green',
		keywords: ['large', 'bone', 'large bone'],
		type: { sell: true },
		sellValue: 35,
		description: `A large, human bone.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return largeBone
}
function smallBone(level, isMonsterDrop) { //used in crafting to craft leather armor
	let smallBone = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Bone',
		refName: 'smallBone',
		color: 'green',
		keywords: ['small', 'bone', 'small bone'],
		type: { sell: true },
		sellValue: 14,
		description: `A small, human bone`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return smallBone
}



function dirtyRags(level, isMonsterDrop) { //used in crafting to craft leather armor
	let dirtyRags = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Dirty Rags',
		refName: 'dirtyRags',
		color: 'green',
		keywords: ['dirty', 'rags', 'dirty rags'],
		type: { quest: true },
		sellValue: 15,
		description: `These are dirty cloth rags look to be torn pieces of various clothing items`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return dirtyRags
}


function silverOre() { //used in crafting to craft leather armor
	let silverOre = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silver Ore',
		refName: 'silverOre',
		color: 'green',
		keywords: ['silver', 'ore', 'silver ore'],
		type: { quest: true },
		sellValue: 100,
		description: `A small lump of silver ore`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return silverOre
}

function pickleLily() {//RARE FLOWER FOR KASIA
	let pickleLily = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bright Yellow Flower',
		refName: 'brightYellowFlower',
		color: 'green',
		keywords: ['bright', 'yellow', 'flower', 'bright yellow', 'yellow flower', 'bright yellow flower'],
		type: { quest: true },
		sellValue: 0,
		description: `A beautiful pink and green flower. Someone who loves flowers would absolutely love this.`,
		desc: function () {
			allItemDescription(this)
		},
	}
	return pickleLily
}

function luckyCoin() {//QUEST FOR SYLAS
	let luckyCoin = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Lucky Coin',
		refName: 'luckyCoin',
		color: 'green',
		keywords: ['lucky', 'coin', 'lucky coin'],
		type: {
			quest: true,
		},
		sellValue: 0,
		description: `The gold coin has what looks to be a tree minted on one side, and a stag on the other. Both sides are smoothed down from years of being flipped and rubbed. `,
		desc: function () {
			allItemDescription(this)
		},
	}
	return luckyCoin
}
pushItem.push(luckyCoin())
pushItem.push(tutorialKey())
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++MISC ITEMS++//////////////////////////////////////////////////
function phi() { //place holder item
	let phi = {
		roomId: currentArea.id,
		name: '???',
		color: 'white',
		keywords: [],
		mods: {},
		type: {},
		price: '',
		sellValue: 0,
	}
	return phi
}
function pieceOfBlob() {
	let pieceOfBlob = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Piece of Blob',
		color: 'green',
		keywords: ['piece', 'blob', 'piece of blob'],
		type: {
			quest: true,
		},
		sellValue: 10,
		description: '',
		desc: () => {
			quickMessage('The leftover material from a blob. Perhaps it has some use?', 'desciptions')
		},
	}
	return pieceOfBlob
}
function grassDust() {
	let grassDust = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Grass Dust',
		color: 'green',
		keywords: ['grass', 'dust', 'grass dust'],
		type: {
			sell: true,
		},
		sellValue: 10,
		description: `The remains of a low level grass elemental, in powder form..`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return grassDust
}
function waterDust() {
	let waterDust = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Water Dust',
		color: 'green',
		keywords: ['water', 'dust', 'water dust'],
		type: {
			sell: true,
		},
		sellValue: 10,
		description: `The remains of a low level water elemental, in powder form..`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return waterDust
}
function mudDust() {
	let mudDust = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mud Dust',
		color: 'green',
		keywords: ['mud', 'dust', 'mud dust'],
		type: {
			sell: true,
		},
		sellValue: 10,
		description: `The remains of a low level earth elemental, in powder form..`,
		desc: () => {
			allItemDescription(this)
		},
	}
	return mudDust
}
function flowerBasket(monsterLevel) { //tier 0.5
	let flowerBasket = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Flower Basket',
		refName: 'flowerBasket',
		picture: '',
		color: 'green',
		keywords: ['basket', 'flower basket'],
		requirements: {
			int: 3,
		},
		type: {
		},
		price: 50,
		sellValue: 15,
		description: `A basket used for collecting plants and flowers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return flowerBasket
}
function pickaxe(monsterLevel) { //tier 0.5
	let pickaxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Pickaxe',
		refName: 'pickaxe',
		picture: 'images/weapons/two handed axes/pickaxe/pickaxe.png',
		color: 'green',
		keywords: ['pickaxe'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
			blacksmithing: 1,
		},
		type: {
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 250,
		sellValue: 15,
		description: `An axe used for mining ore.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return pickaxe
}
function fishingRod(monsterLevel) { //tier 0.5
	let fishingRod = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Fishing Rod',
		refName: 'fishingRod',
		picture: 'images/weapons/two handed axes/pickaxe/pickaxe.png',
		color: 'green',
		keywords: ['pickaxe'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		type: {
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 250,
		sellValue: 15,
		description: `An fishing rod used for fishing.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return fishingRod
}
function skinningKnife(monsterLevel) { //tier 0.5
	let skinningKnife = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Skinning Knife',
		refName: 'skinningKnife',
		picture: 'images/weapons/daggers/skinning knife/skinning knife.png',
		color: 'green',
		keywords: ['pickaxe'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
			dex: 3,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 50,
		sellValue: 15,
		description: `A knife used for skinning carcassed.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return skinningKnife
}


//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////

//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////

function trainingBow(monsterLevel) { //tier 1
	if (backpack != undefined) {
	}
	let trainingBow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Bow',
		picture: 'images/weapons/bows/training bow/training bow.png',
		color: 'green',
		keywords: ['training', 'bow', 'training bow'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(5, 5),
		mods: {
			piercingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'Bow',
			damageType: `Piercing`,
			twoHanded: true,
			weapon: true,
			bow: true,
			ranged: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 0,
		sellValue: 10,
		description: `A training bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),	}
	return trainingBow
}
function crudelyCarvedBow(monsterLevel) { //tier 1.5
	if (backpack != undefined) {
	}
	let crudelyCarvedBow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crudely Carved Bow',
		color: 'green',
		keywords: ['crudely', 'carved', 'bow', 'crudely carved', 'carved bow', 'crudely carved bow'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(7, 7),
		mods: {
			str: 0,
			agi: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 0,
			bluntPen: 0,
			weight: 3,
		},
		type: {
			twoHanded: true,
			weapon: true,
			bow: true,
			ranged: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 25,
		sellValue: 9,
		description: `A bow made of animal bone with crude animal sinew for a bowstring`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),	}
	return crudelyCarvedBow
}
function shortbow(monsterLevel) { //tier 2
	let shortbow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Short Bow',
		color: 'green',
		keywords: ['short', 'bow', 'short bow'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(10, 10),
		mods: {
			piercingPen: 1,
			weight: 3,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 75,
		sellValue: 32,
		description: `Short bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),	}
	return shortbow
}
function longbow(monsterLevel) { //tier 3
	let longbow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Longbow',
		color: 'green',
		keywords: ['long', 'bow', 'long bow', 'longbow'],
		botDamage: randomNumberRange(6, 6),
		topDamage: randomNumberRange(15, 15),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 250,
		sellValue: 68,
		description: `Long Bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),
		}
	return longbow
}
function honedLongbow(monsterLevel) { //tier 4
	let honedLongbow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Honed Longbow',
		picture: 'images/weapons/bows/honed longbow/honed longbow.png',
		color: 'green',
		keywords: ['honed', 'longbow', 'honed lonbow'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(18, 18),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 750,
		sellValue: 151,
		description: `Honed Longbow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),
		}
	return honedLongbow
}
function battleBow(monsterLevel) { //tier 5
	if (backpack != undefined) {
	}
	let battleBow = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Battle Bow',
		color: 'green',
		keywords: ['battle', 'bow', 'battle bow'],
		botDamage: randomNumberRange(11, 11),
		topDamage: randomNumberRange(25, 25),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 0,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			bow: true,
			ranged: true,
			twoHanded: true,
		},
		enchantment: [],
		skillUsed: 'bows',
		price: 750,
		sellValue: 151,
		description: `Battle Bow`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => bowSwing1(enemy, weapon),
		miss: (enemy, weapon) => bowSwing1(enemy, weapon),
		}
	return battleBow
}

//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++BOWS++//////////////////////////////////////////////////

//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////

function leatherGrips(monsterLevel) { //tier 1.5
	let leatherGrips = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Leather Grips`,
		color: 'green',
		keywords: ['leather', 'grips', 'leather grips'],
		botDamage: randomNumberRange(2, 2),
		topDamage: randomNumberRange(3, 3),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 50,
		sellValue: 6,
		description: `Old leather pugilist gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return leatherGrips
}
function hardenedLeatherFists(monsterLevel) { //tier 2
	let hardenedLeatherFists = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Hardened Leather Fists`,
		picture: {
			right:'images/weapons/fist weapons/hardened leather fists/hardened leather fists right.png',
			left:'images/weapons/fist weapons/hardened leather fists/hardened leather fists left.png' ,
		},
		color: 'green',
		keywords: ['hardened', 'leather', 'fists', 'hardened leather', 'leather fists', 'hardened leather fists'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(4, 4),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 75,
		sellValue: 18,
		description: `Old leather pugilist gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return hardenedLeatherFists
}
function studdedLeatherFists(monsterLevel) { //tier 3
	let studdedLeatherFists = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Studded Leather Fists`,
		picture: {
			right:'images/weapons/fist weapons/studded leather fists/studded leather fists right.png',
			left:'images/weapons/fist weapons/studded leather fists/studded leather fists left.png' ,
		},
		color: 'green',
		keywords: ['studded', 'leather', 'fists', 'studded leather', 'leather fists', 'studded leather fists'],
		botDamage: randomNumberRange(4, 11),
		topDamage: randomNumberRange(4, 11),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 250,
		sellValue: 25,
		description: `Old leather pugilist gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return studdedLeatherFists
}
function fighterFists(monsterLevel) { //tier 4
	let fighterFists = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Fighter Fists`,
		picture: {
			right:'images/weapons/fist weapons/fighter fists/fighter fists right.png',
			left:'images/weapons/fist weapons/fighter fists/fighter fists left.png' ,
		},
		color: 'green',
		keywords: ['fighter', 'fists', 'fighter fists'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(15, 15),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 700,
		sellValue: 80,
		description: `Fighter Fists`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return fighterFists
}
function brawlersGloves(monsterLevel) { //tier 5
	let brawlersGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: `Brawler's Gloves`,
		picture: {
			right:'images/weapons/fist weapons/brawlers gloves/brawlers gloves right.png',
			left:'images/weapons/fist weapons/brawlers gloves/brawlers gloves left.png' ,
		},
		color: 'green',
		keywords: ['brawler', "brawler's", 'gloves', 'brawler gloves', "brawler's gloves"],
		botDamage: randomNumberRange(9, 5),
		topDamage: randomNumberRange(20, 20),
		mods: {
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			martialArts: true,
			fists: true,
		},
		enchantment: [],
		skillUsed: 'unarmed',
		price: 1000,
		sellValue: 80,
		description: `Brawler's Gloves`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
	}
	return brawlersGloves
}









//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////
//////////////////////////////////////////////////++UNARMED++///////////////////////////////////////////////

//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
function muddyDagger(monsterLevel) { //tier 0.5
	let muddyDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Dagger',
		picture: 'images/fake url path',
		color: 'green',
		keywords: ['muddy', 'dagger', 'muddy dagger'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(2, 2),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 0,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 0,
		sellValue: 7,
		description: `A training dagger`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	
		}
	return muddyDagger
}
function trainingDagger(monsterLevel) { //tier 1
	let trainingDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Dagger',
		picture: {
			right: 'images/weapons/daggers/training dagger/training dagger right.png',
			left: 'images/weapons/daggers/training dagger/training dagger left.png',
		},
		color: 'green',
		keywords: ['training', 'dagger', 'training dagger'],
		botDamage: randomNumberRange(2, 2),
		topDamage: randomNumberRange(3, 3),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 0,
		},
		type: {
			skillUsed: "Daggers",
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 30,
		sellValue: 10,
		description: `A training dagger`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return trainingDagger
}
function boneDagger(monsterLevel) { //tier 1.5
	let boneDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bone Dagger',
		color: 'green',
		keywords: ['bone', 'dagger', 'bone dagger'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(5, 5),
		mods: {
			weight: 1,
			slashingPen: 0,
			piercingPen: 0,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 30,
		sellValue: 5,
		description: `A dagger made entirely of bone`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return boneDagger
}

function crudeShiv(monsterLevel) { //tier 1.5
	let crudeShiv = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crude Shiv',
		color: 'green',
		keywords: ['crude', 'shiv', 'crude shiv'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(5, 5),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 20,
		sellValue: 5,
		description: `This looks like it was put together from two other broken daggers`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return crudeShiv
}
function dirk(monsterLevel) { //tier 2
	let dirk = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		picture: {
			right: "images/weapons/daggers/dirk/dirk right.png",
			left: "images/weapons/daggers/dirk/dirk left.png",
		},
		roomId: currentArea.id,
		name: 'Dirk',
		color: 'green',
		keywords: ['dagger', 'dirk'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(4, 4),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 50,
		sellValue: 8,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return dirk
}
function stiletto(monsterLevel) { //tier 3
	let stiletto = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stiletto',
		color: 'green',
		keywords: ['stilleto'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(6, 6),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 125,
		sellValue: 24,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return stiletto
}
function crescentDagger(monsterLevel) { //tier 4
	let crescentDagger = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Crescent Dagger',
		color: 'green',
		picture: {
			left: 'images/weapons/daggers/crescent dagger/crescent dagger left.png',
			right: 'images/weapons/daggers/crescent dagger/crescent dagger right.png',
		},
		keywords: ['crescent', 'dagger', 'crescent dagger'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(7, 7),
		mods: {
			agi: 5,
			dex: 5,
			slashingPen: 10,
			piercingPen: 10,
			weight: 5,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 420,
		sellValue: 55,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return crescentDagger
}
function mageMasher(monsterLevel) { //tier 5
	let mageMasher = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mage Masher',
		color: 'green',
		keywords: ['mage', 'masher', 'mage masher'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(11, 14),
		mods: {
			str: 0,
			con: 0,
			int: 0,
			slashingPen: 1,
			piercingPen: 1,
			bluntPen: 0,
			weight: 1,
		},
		type: {
			weapon: true,
			daggers: true,
			dagger: true,
		},
		enchantment: [],
		skillUsed: 'daggers',
		price: 420,
		sellValue: 55,
		description: `This looks like the blade of a dagger that was left over from a broken dagger.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => daggerSwing1(enemy, weapon),
		miss: (enemy, weapon) => daggerSwing1(enemy, weapon),	}
	return mageMasher
}
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++DAGGERS++//////////////////////////////////////////////////

//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
function muddyShortsword(monsterLevel) { //tier 0.5
	let muddyShortsword = {
		id: (() => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		  })(),
		roomId: currentArea.id,
		name: 'Muddy Shortsword',
		picture: 'images/weapons/one handed swords/training shortsword/training shortsword.png',
		color: 'green',
		keywords: ['muddy', 'shortsword', 'muddy shortsword'],
		botDamage: randomNumberRange(2, 2),
		topDamage: randomNumberRange(3, 3),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		requirements: {},
		type: {
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 25,
		sellValue: 7,
		description: `A muddy and rusted blade likely discarded long ago because of it's poor condition`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return muddyShortsword
}

function trainingShortsword(monsterLevel) { //tier 1
	let trainingShortsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Shortsword',
		picture: {
			right: "images/weapons/one handed swords/training shortsword/training shortsword right.png",
			left: "images/weapons/one handed swords/training shortsword/training shortsword left.png",
		},
		color: 'green',
		keywords: ['training', 'sword', 'short', 'shortsword', 'training shortsword'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(4, 4),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		requirements: {
		},
		type: {
			weapon: true,
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			oneHanded: true,
			sword: true,
			slashing: true,
			piercing: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 25,
		sellValue: 7,
		description: `Almost the length of a dagger, and easy enough to wield for the unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return trainingShortsword
}
function rustySword(monsterLevel) { //tier 1.5
	let rustySword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rusty Sword',
		picture: {
			right: "images/weapons/one handed swords/training shortsword/training shortsword right.png",
			left: "images/weapons/one handed swords/training shortsword/training shortsword left.png",
		},
		color: 'green',
		keywords: ['rusty', 'sword', 'rusty sword'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(6, 6),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		requirements: {
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 100,
		sellValue: 7,
		description: `A rusty sword`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return rustySword
}
function shortsword(monsterLevel) { //tier 2
	let shortsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shortsword',
		picture: {
			right: "images/weapons/one handed swords/training shortsword/training shortsword right.png",
			left: "images/weapons/one handed swords/training shortsword/training shortsword left.png",
		},		color: 'green',
		keywords: ['short', 'sword', 'shortsword', 'short sword'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(5, 5),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 50,
		sellValue: 10,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return shortsword
}
function broadSword(monsterLevel) { //tier 3
	let broadSword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Broadsword',
		picture: {
			right: "images/weapons/one handed swords/broadsword/broadsword right.png",
			left: "images/weapons/one handed swords/broadsword/broadsword left.png",
		},		
		color: 'green',
		keywords: ['broad', 'sword', 'broadsword', 'broad sword'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(12, 12),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 250,
		sellValue: 32,
		description: `A broadsword.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return broadSword
}

function gladius(monsterLevel) { //tier 4
	let gladius = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Gladius',
		picture: {
			right: "images/weapons/one handed swords/gladius/gladius right.png",
			left: "images/weapons/one handed swords/gladius/gladius left.png",
		},			color: 'green',
		keywords: ['gladius'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 600,
		sellValue: 80,
		description: `A well crafted gladius.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return gladius
}

function sabre(monsterLevel) { //tier 5
	let itemPrice = 1000
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let sabre = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sabre',
		color: 'green',
		keywords: ['sabre'],
		botDamage: randomNumberRange(8, 9),
		topDamage: randomNumberRange(17, 20),
		mods: {
			slashingPen: 1,
			piercingPen: 1,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			oneHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: itemPrice,
		sellValue: sellValue,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		}
	return sabre
}

//////////////////////////////////////////////////////////////////////////////////////////////////////AXES
//////////////////////////////////////////////////////////////////////////////////////////////////////AXES

function handAxe(monsterLevel) { //tier 2
	let handAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Hand Axe',
		picture: 'images/weapons/one handed axes/hand axe/hand axe.png',
		color: 'green',
		keywords: ['hand', 'axe', 'hand axe'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(9, 9),
		mods: {
			slashingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing`,
			weapon: true,
			oneHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 50,
		sellValue: 10,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return handAxe
}

function beardedAxe(monsterLevel) { //tier 3
	let beardedAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bearded Axe',
		picture: 'images/weapons/one handed axes/bearded axe/bearded axe.png',
		color: 'green',
		keywords: ['bearded', 'axe', 'bearded axe'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(12, 12),
		mods: {
			slashingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing`,
			weapon: true,
			oneHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 250,
		sellValue: 32,
		description: `A bearded axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return beardedAxe
}
function serratedAxe(monsterLevel) { //tier 4
	let serratedAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Serrated Axe',
		color: 'green',
		keywords: ['serrated', 'axe', 'serrated axe'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Slashing`,
			weapon: true,
			oneHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 600,
		sellValue: 80,
		description: `A well crafted bronze axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return serratedAxe
}
//////////////////////////////////////////////////////////////////MACES
//////////////////////////////////////////////////////////////////MACES
function boneClub(monsterLevel) { //tier 1.5
	let boneClub = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bone Club',
		color: 'green',
		keywords: ['bone', 'club', 'bone club'],
		botDamage: randomNumberRange(3, 3),
		topDamage: randomNumberRange(5, 5),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		requirements: {
			str: 2,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			club: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 25,
		sellValue: 7,
		description: `What looks to be a medium sized bone of an animal`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return boneClub
}

function mace(monsterLevel) { //tier 2
	let mace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mace',
		picture: {
			left: 'images/weapons/one handed maces/mace/mace left.png',
			right: 'images/weapons/one handed maces/mace/mace right.png'
		},		
		color: 'green',
		keywords: ['mace'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(9, 9),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 50,
		sellValue: 10,
		description: `Almost the length of a dagger, and easy enough to wield for the most unexperienced.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return mace
}

function stoutedMace(monsterLevel) { //tier 3
	let stoutedMace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Stouted Mace',
		picture: {
			left: 'images/weapons/one handed maces/stouted mace/stouted mace left.png',
			right: 'images/weapons/one handed maces/stouted mace/stouted mace right.png'
		},
		color: 'green',
		keywords: ['stouted', 'mace', 'stouted mace'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(12, 12),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 250,
		sellValue: 32,
		description: `A stouted mace.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return stoutedMace
}
function flangedMace(monsterLevel) { //tier 4
	let flangedMace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Flanged Mace',
		picture: 'images/weapons/one handed maces/flanged mace/flanged mace.png',
		color: 'green',
		keywords: ['flanged', 'mace', 'flanged mace'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(15, 15),
		mods: {
			bluntPen: 0,
			weight: 5,
		},
		type: {
			skillUsed: 'One Handed',
			damageType: `Blunt`,
			weapon: true,
			oneHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'oneHanded',
		price: 600,
		sellValue: 80,
		description: `A well crafted flanged mace.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),	
	}
	return flangedMace
}
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++ONE HANDED WEAPONS++///////////////////////////////////////////

//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
function trainingTwoHandedSword(monsterLevel) {//tier 1
	let trainingTwoHandedSword = {
		id: (() => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		  })(),
		roomId: currentArea.id,
		name: 'Training Two-Handed Sword',
		picture: "images/weapons/two handed swords/training two handed sword/training two handed sword.png",
		color: 'green',
		keywords: ['training', 'two-handed', 'sword', 'training sword', 'training two-handed sword', 'two handed', 'twohanded', 'two handed sword', 'training two handed sword'],
		botDamage: randomNumberRange(5, 5),
		topDamage: randomNumberRange(6, 6),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
			str: 1,
		},
		type: {
			tier: 1,
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 5,
		sellValue: 5,
		description: `A sword just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),	
	}
	return trainingTwoHandedSword
}
function largeBoneClub(monsterLevel) { //tier 1.5
	let largeBoneClub = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Large Bone Club',
		color: 'green',
		keywords: ['large', 'bone', 'club', 'large bone', 'bone club', 'large bone club'],
		botDamage: randomNumberRange(6, 6),
		topDamage: randomNumberRange(7, 7),
		mods: {
			weight: 10,
		},
		requirements: {
			str: 3,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			skillUsed: `Two Handed`,
			weapon: true,
			twoHanded: true,
			club: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 35,
		sellValue: 7,
		description: `What looks to be the large leg bone of an animal or creature`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),	
	}
	return largeBoneClub
}
function boneTippedSpear(monsterLevel) { //tier 1.5
	let boneTippedSpear = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bone-Tipped Spear',
		color: 'green',
		keywords: ['bone', 'tipped', 'spear', 'bone-tipped', 'bone-tipped spear', 'bone tipped', 'bone tipped spear'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(10, 10),
		mods: {
			weight: 10,
			piercingPen: 0,
		},
		requirements: {
			str: 3,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Piercing`,
			weapon: true,
			twoHanded: true,
			spear: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 5,
		sellValue: 7,
		description: `A long sliver of wood that looks very similar to the wood used in Galvadian buildings. It's stopped with a sharpened piece of bone`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),	
	}
	return boneTippedSpear
}
function longsword(monsterLevel) { //tier 2
	let longsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Longsword',
		picture: "images/weapons/two handed swords/longsword/longsword.png",
		color: 'green',
		keywords: ['longsword'],
		botDamage: randomNumberRange(7, 7),
		topDamage: randomNumberRange(8, 8),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 10,
		},
		requirements: {
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 100,
		sellValue: 37,
		description: `A sword just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return longsword
}

function poleAxe(monsterLevel) { //tier 2
	let poleAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Poleaxe',
		picture: 'images/weapons/two handed axes/poleaxe/poleaxe.png',
		color: 'green',
		keywords: ['pole', 'axe', 'poleaxe'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(10, 10),
		mods: {
			slashingPen: 0,
			weight: 10,
		},
		requirements: {
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 100,
		sellValue: 37,
		description: `An axe just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return poleAxe
}


function sledgehammer(monsterLevel) { //tier 2
	let sledgehammer = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sledgehammer',
		picture: 'images/weapons/two handed maces/sledgehammer/sledgehammer.png',
		color: 'green',
		keywords: ['sledgehammer'],
		botDamage: randomNumberRange(4, 4),
		topDamage: randomNumberRange(10, 10),
		mods: {
			bluntPen: 0,
			weight: 10,
		},
		requirements: {
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 100,
		sellValue: 37,
		description: `A mace just long enough to need two hands to wield.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return sledgehammer
}
function claymore(monsterLevel) { //tier 3
	let claymore = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Claymore',
		picture: "images/weapons/two handed swords/claymore/claymore.png",
		color: 'green',
		keywords: ['claymore'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(11, 11),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 20,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 500,
		sellValue: 77,
		description: `A long, double edged broadsword. You typically see these wielded by the town guards.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return claymore
}
function beardedPoleAxe(monsterLevel) { //tier 3
	let beardedPoleAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bearded Poleaxe',
		picture: "images/weapons/two handed maces/maul/maul.png",
		color: 'green',
		keywords: ['bearded', 'poleaxe', 'bearded poleaxe'],
		botDamage: randomNumberRange(8, 8),
		topDamage: randomNumberRange(17, 17),
		mods: {
			slashingPen: 0,
			weight: 20,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 500,
		sellValue: 75,
		description: `A large, sturdy two-handed axe`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return beardedPoleAxe
}
function maul(monsterLevel) { //tier 3
	let maul = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Maul',
		picture: 'images/weapons/two handed maces/maul/maul.png',
		color: 'green',
		keywords: ['maul'],
		botDamage: randomNumberRange(8, 8),
		topDamage: randomNumberRange(17, 17),
		mods: {
			bluntPen: 0,
			weight: 30,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 500,
		sellValue: 75,
		description: `A large, sturdy two-handed mace`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return maul
}
function bastardSword(monsterLevel) { //tier 4
	let bastardSword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bastard Sword',
		picture: "images/weapons/two handed swords/bastard sword/bastard sword.png",
		color: 'green',
		keywords: ['bastard', 'sword', 'bastard sword'],
		botDamage: randomNumberRange(12, 12),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 0,
			piercingPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A little shorter than the claymore, but is lighter and more wieldy for a two handed sword.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return bastardSword
}
function berserkBlade(monsterLevel) { //tier 4
	let berserkBlade = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Berserk Blade',
		picture: "images/weapons/two handed swords/berserk blade/berserk blade.png",
		color: 'green',
		keywords: ['berserk', 'blade', 'berserk blade'],
		botDamage: randomNumberRange(12, 12),
		topDamage: randomNumberRange(15, 15),
		mods: {
			slashingPen: 10,
			piercingPen: 10,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `This sword is a Warrior's Guild heirloom that is passed down only to those who have proven themselves to be fearless in the face of death.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return berserkBlade
}
function serratedPoleaxe(monsterLevel) { //tier 4
	let serratedPoleaxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Serrated Poleaxe',
		color: 'green',
		keywords: ['serrated', 'poleaxe', 'serrated poleaxe'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			slashingPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large, sturdy axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return serratedPoleaxe
}
function battleAxe(monsterLevel) { //tier 5
	let battleAxe = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Two-Handed Battle Axe',
		color: 'green',
		keywords: ['two', 'two handed', 'two-handed', 'two handed battle', 'battle axe', 'battle', 'axe', 'two handed battle axe', 'two-handed battle axe'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			slashingPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing`,
			weapon: true,
			twoHanded: true,
			axe: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large, sturdy axe.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return battleAxe
}
function flangedMaul(monsterLevel) { //tier 4
	let flangedMaul = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Flanged Maul',
		color: 'green',
		keywords: ['flanged', 'maul', 'flanged maul'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			bluntPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large maul with a just long enough to wield with two hands`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return flangedMaul
}
function warHammer(monsterLevel) { //tier 5
	let warHammer = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Warhammer',
		color: 'green',
		keywords: ['warhammer', 'hammer'],
		botDamage: randomNumberRange(9, 9),
		topDamage: randomNumberRange(23, 23),
		mods: {
			bluntPen: 0,
			weight: 15,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Blunt`,
			weapon: true,
			twoHanded: true,
			mace: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1450,
		sellValue: 124,
		description: `A large maul with a just long enough to wield with two hands`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return warHammer
}


function greatsword(monsterLevel) { //tier 5
	let itemPrice = 1000
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let greatsword = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Greatsword',
		color: 'green',
		keywords: ['greatsword'],
		botDamage: randomNumberRange(10, 12),
		topDamage: randomNumberRange(30, 34),
		mods: {
			slashingPen: 15,
			piercingPen: 7,
			bluntPen: 0,
			weight: 30,
		},
		type: {
			skillUsed: 'Two Handed',
			damageType: `Slashing/piercing`,
			weapon: true,
			twoHanded: true,
			sword: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: itemPrice,
		sellValue: sellValue,
		description: `Just as long as the claymore, but twice as wide. It has no hilt to reduce the already strenuous weight.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return greatsword
}

//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////
//////////////////////////////////////////////++TWO HANDED WEAPONS++///////////////////////////////////////////

//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////

function trainingStaff(monsterLevel) { //tier 1
	let itemPrice = 10
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let trainingStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Staff',
		color: 'green',
		keywords: ['training', 'staff', 'training staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 3,
			weight: 1,
		},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: itemPrice,
		sellValue: sellValue,
		description: `Just as long as the claymore, but twice as wide. It has no hilt to reduce the already strenuous weight.`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return trainingStaff
}
function woodenStaff(monsterLevel) { //tier 2
	let woodenStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Wooden Staff',
		color: 'green',
		keywords: ['wooden', 'staff', 'wooden staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 7,
			weight: 5,
		},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 80,
		sellValue: 150,
		description: `A long wooden staff`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => twoHandedSwing1(enemy, weapon),
		}
	return woodenStaff
}

function powerStaff(monsterLevel) { //tier 3
	let powerStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Power Staff',
		color: 'green',
		keywords: ['power', 'staff', 'power staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 18,
			weight: 5,
		},
		requirements: {},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 250,
		sellValue: 92,
		description: `A strong Mage staff`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return powerStaff
}
function runeStaff(monsterLevel) { //tier 4
	let runeStaff = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rune Staff',
		color: 'green',
		keywords: ['runed', 'staff', 'runed staff'],
		botDamage: randomNumberRange(1, 1),
		topDamage: randomNumberRange(1, 1),
		mods: {
			spellPower: 30,
			weight: 8,
		},
		requirements: {},
		type: {
			skillUsed: 'Two Handed',
			weapon: true,
			twoHanded: true,
			staff: true,
		},
		enchantment: [],
		skillUsed: 'twoHanded',
		price: 1200,
		sellValue: 140,
		description: `A strong Mage staff`,
		desc: function () {
			itemDescription(this)
		},
		swing: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
		miss: (enemy, weapon) => oneHandedSwing1(enemy, weapon),
	}
	return runeStaff
}

//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////
//////////////////////////////////////////////////++STAVES++///////////////////////////////////////////////////

//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////
//////////////////////////////////////////////////++WEAPONS++//////////////////////////////////////////////////

//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
//////////////////////////////////////////////////++ARMOR++//////////////////////////////////////////////////
function trainingMailChestpiece() {	
	let trainingMailChestpiece = {
	id: () => {
		for (let i = 0; i < 50; i++) {
			if (!pushItem[i]) {
				return i
			}
		}
	},
	roomId: currentArea.id,
	name: 'Training Mail Chestpiece',
	color: 'green',
	keywords: ['mail', 'chest', 'training chestpiece', 'training mail chestpiece', 'chestpiece'],
	mods: {
		weight: 10,
		slashingArmor: 1,
		piercingArmor: 0,
		bluntArmor: 0,
		fireResist: 10,
	},
	type: {
		tier: 1,
		armor: true,
		chest: true,
		mail: true,
		armorType: 'Mail',
	},
	price: 0,
	sellValue: 10,
	description: '',
	slot: 'chest',
	desc: function () {
		itemDescription(this)
	},
}
return trainingMailChestpiece
}
function trainingLeatherTunic() {
	let trainingLeatherTunic = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Leather Chestpiece',
		color: 'green',
		keywords: ['leather', 'chest', 'chestpiece', 'training chestpiece', 'training leather chestpiece'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 0,
			bluntArmor: 0,
		},
		type: {
			tier: 1,
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather',
		},
		price: 0,
		sellValue: 10,
		description: '',
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return trainingLeatherTunic
}
function trainingClothChestpiece() {
	let trainingClothChestpiece = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Training Cloth Chestpiece',
		color: 'green',
		keywords: ['training', 'cloth', 'chestpiece', 'chest', 'training chestpiece', 'training chest', 'training cloth chestpiece'],
		mods: {
			weight: 1,
			spellPower: 1,
			mysticPower: 1,
		},
		type: {
			tier: 1,
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 0,
		sellValue: 10,
		description: '',
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return trainingClothChestpiece
}
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
function mailChestGuard() {
	let mailChestGuard = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Chestguard',
		color: 'green',
		keywords: ['mail', 'chestguard', 'mail chestguard'],
		mods: {
			weight: 20,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 3,
			oneHanded: 10,
			str: 10,
		},
		type: {
			tier: 1,
			armor: true,
			chest: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 80,
		sellValue: 10,
		description: '',
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailChestGuard
}
function mailHelm() {
	let mailHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Helm',
		color: 'green',
		keywords: ['mail', 'helm', 'mail helm'],
		mods: {
			weight: 10,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			helm: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 80,
		sellValue: 10,
		description: 'Mail Helm',
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailHelm
}
function mailGloves() {
	let mailGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Gloves',
		color: 'green',
		keywords: ['mail', 'gloves', 'mail gloves'],
		mods: {
			weight: 10,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			hands: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Mail Gloves',
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailGloves
}
function mailBoots() {
	let mailBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Boots',
		color: 'green',
		keywords: ['mail boots', 'mail', 'boots'],
		mods: {
			weight: 10,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			feet: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Boots',
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailBoots
}
function mailLegs() {
	let mailLegs = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Legs',
		color: 'green',
		keywords: ['mail legs', 'mail', 'legs'],
		mods: {
			weight: 20,
			slashingArmor: 2,
			piercingArmor: 1,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			feet: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Mail legs.',
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailLegs
}
function mailShoulders() {
	let mailShoulders = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Shoulders',
		color: 'green',
		keywords: ['mail shoulders', 'mail', 'shoulders'],
		mods: {
			weight: 20,
			slashingArmor: 2,
			piercingArmor: 1,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			feet: true,
			mail: true,
			armorType: 'Mail',
		},
		price: 50,
		sellValue: 7,
		description: 'Mail shoulders.',
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return mailShoulders
}

function ringmailHauberk(monsterLevel) {
	let ringmailHauberk = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmamil Hauberk',
		color: 'green',
		keywords: ['ringmail', 'hauberk', 'ringmail hauberk'],
		mods: {
			weight: 15,
			slashingArmor: 5,
			piercingArmor: 5,
			bluntArmor: 5,		
		},
		type: {
			armor: true, //isArmor: 'true'
			chest: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Chestguard`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailHauberk
}
function ringmailLeggings(monsterLevel) {
	let ringmailLeggings = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Leggings',
		color: 'green',
		keywords: ['ringmail', 'leggings', 'ringmail leggings'],
		mods: {
			weight: 5,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 3,		
		},
		type: {
			armor: true, //isArmor: 'true'
			legs: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'

		},
		price: 1000,
		sellValue: 500,
		description: `Legplates`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailLeggings
}
function ringmailShoulders() {
	let ringmailShoulders = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mail Shoulderdrapes',
		color: 'green',
		keywords: ['ringmail', 'shoulders', 'ringmail shoulders'],
		mods: {
			weight: 10,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,		
		},
		type: {
			armor: true, //isArmor: 'true'
			shoulders: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Shoulderguards`,
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailShoulders
}
function ringmailHelm() { //tier 3
	let ringmailHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Helm',
		color: 'green',
		keywords: ['ringmail', 'helm', 'ringmail helm'],
		mods: {
			weight: 10,
			slashingArmor: 0,
			piercingArmor: 0,
			bluntArmor: 3,
		},
		type: {
			armor: true, //isArmor: 'true'
			helm: true, //slot: 'legs'
			plate: true, //material: 'plate'
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Plate Helmet`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailHelm
}
function ringmailGloves(monsterLevel) {
	let ringmailGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Gloves',
		color: 'green',
		keywords: ['ringmail', 'gloves', 'ringmail gloves'],
		mods: {
			weight: 5,
			slashingArmor: 3,
			piercingArmor: 0,
			bluntArmor: 0,		},
		requirements: {
			guild: 'Warrior',
		},
		type: {
			armor: true,
			feet: true,
			plate: true,
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Plate Gauntlets`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailGloves
}
function ringmailStompers(monsterLevel) {
	let ringmailStompers = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Ringmail Stompers',
		color: 'green',
		keywords: ['ringmail', 'stompers', 'ringmail stompers'],
		mods: {
			weight: 5,
			slashingArmor: 0,
			piercingArmor: 3,
			bluntArmor: 0,		
		},
		requirements: {
			guild: 'Warrior',
		},
		type: {
			armor: true,
			feet: true,
			plate: true,
			armorType: 'Plate'
		},
		price: 1000,
		sellValue: 500,
		description: `Plate boots`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return ringmailStompers
}

//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////
//////////////////////////////////////////////////++PLATE++//////////////////////////////////////////////////

////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////

function clothCap(monsterLevel) { //tier 2
	let clothCap = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Cap',
		color: 'green',
		keywords: ['cloth cap', 'cloth', 'cap'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			head: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 125,
		description: `A very light cap. Provides minimal use for defense, but you feel slightly smarter wearing it`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothCap
}
function silkHat(monsterLevel) { //tier 3
	let silkHat = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Hat',
		color: 'green',
		keywords: ['silk hat', 'cloth', 'hat'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		requirements: {
			int: 2,
		},
		type: {
			armor: true,
			head: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 120,
		sellValue: 125,
		description: `A very light cap. Provides minimal use for defense, but you feel slightly smarter wearing it`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkHat
}
function apprenticeRobes(monsterLevel) { //tier 2
	let apprenticeRobes = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Apprentice Robes',
		color: 'green',
		keywords: ['apprentice', 'robes', 'apprentice robes'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 80,
		sellValue: 8,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return apprenticeRobes
}
function silkVestments(monsterLevel) { //tier 3
	let silkVestments = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Vestments',
		color: 'green',
		keywords: ['silk', 'vestments', 'silk vestments'],
		mods: {
			weight: 1,
			wis: 2,
			spellPower: 5,
		},
		type: {
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 240,
		sellValue: 24,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkVestments
}
function clothMantle(monsterLevel) { //tier 2
	let clothMantle = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Mantle',
		color: 'green',
		keywords: ['cloth', 'mantle', 'cloth mantle'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 5,
		},
		type: {
			armor: true,
			shoulders: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 5,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothMantle
}
function silkShoulders(monsterLevel) { //tier 3
	let silkShoulders = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Shoulders',
		color: 'green',
		keywords: ['silk', 'shoulders', 'silk shoulders'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 5,
		},
		type: {
			armor: true,
			shoulders: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 150,
		sellValue: 15,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkShoulders
}
function clothPants(monsterLevel) { //tier 2
	let clothPants = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Pants',
		color: 'green',
		keywords: ['cloth', 'pants', 'cloth pants'],
		mods: {
			weight: 1,
			spellPower: 2,
		},
		type: {
			armor: true,
			legs: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 70,
		sellValue: 7,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothPants
}
function silkTrousers(monsterLevel) { //tier 3
	let silkTrousers = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Trousers',
		color: 'green',
		keywords: ['silk', 'trousers', 'silk trousers'],
		mods: {
			weight: 1,
			spellPower: 2,
		},
		type: {
			armor: true,
			legs: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 210,
		sellValue: 21,
		description: `The basic robes typically worn by magic user initiates`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkTrousers
}
function clothGloves(monsterLevel) { //tier 2
	let clothGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cloth Gloves',
		color: 'green',
		keywords: ['cloth', 'gloves', 'cloth gloves'],
		mods: {
			weight: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			hands: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 5,
		description: `Provides little defense, but allows the wearer to maintain their finger dexterity`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return clothGloves
}
function silkGloves(monsterLevel) { //tier 3
	let silkGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Gloves',
		color: 'green',
		keywords: ['silk', 'gloves', 'silk gloves'],
		mods: {
			weight: 1,
			armor: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			hands: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 150,
		sellValue: 15,
		description: `Provides little defense, but allows the wearer to maintain their finger dexterity`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkGloves
}
function sandals(monsterLevel) { //tier 2
	let sandals = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Sandals',
		color: 'green',
		keywords: ['sandals'],
		mods: {
			weight: 1,
			armor: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			feet: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 50,
		sellValue: 5,
		description: `Basic foot protection`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return sandals
}
function silkFootwraps(monsterLevel) { //tier 3
	let silkFootwraps = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Silk Footwraps',
		color: 'green',
		keywords: ['silk', 'footwraps', 'silk footwraps'],
		mods: {
			weight: 1,
			armor: 1,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			feet: true,
			cloth: true,
			armorType: 'Cloth',
		},
		price: 150,
		sellValue: 100,
		description: `Basic foot protection`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return silkFootwraps
}
function cultRobes(monsterLevel) { //tier 2.5
	let cultRobes = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Cult Robes',
		color: 'green',
		keywords: ['cult', 'robes', 'cult robes'],
		mods: {
			weight: 0,
			wis: 1,
			spellPower: 1,
		},
		type: {
			armor: true,
			chest: true,
			cloth: true,
			armorType: 'Cloth',
		},
		sellValue: 40,
		description: `The robes still smell of someone else`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return cultRobes
}

////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++CLOTH ARMOR++///////////////////////////////////////////////

////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////



////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////
////////////////////////////////////////////////++CHAIN MAIL++///////////////////////////////////////////////

////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
function muddyGloves(monsterLevel) {  //tier 0.5
	let muddyGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Muddy Gloves',
		color: 'green',
		keywords: ['muddy', 'gloves', 'muddy gloves'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 0,
			bluntArmor: 0,
		},
		type: {
			material: 'Leather',
			armor: true,
			hands: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 0,
		sellValue: 12,
		description: `Holes have been eaten into most parts of these gloves`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return muddyGloves
}

function shoddyJerkin(monsterLevel) { //tier 1
	let shoddyJerkin = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shoddy Jerkin',
		color: 'green',
		keywords: ['shoddy', 'jerkin', ' shoddy jerkin'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,		
		},
		type: {
			armor: true,
			body: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'body',
		desc: function () {
			itemDescription(this)
		},
	}
	return shoddyJerkin
}

function waterloggedBoots(monsterLevel) { //tier 1
	let waterloggedBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Waterlogged Boots',
		color: 'green',
		keywords: ['waterlogged', 'boots', 'waterlogged boots'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 1,
			bluntArmor: 0,
		},
		requirements: {
		},
		type: {
			armor: true,
			feet: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 0,
		sellValue: 12,
		description: `Ragged boots that look like they were taken off a dead body`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return waterloggedBoots
}

function grassStainedHat(monsterLevel) { //tier 0.5
	let grassStainedHat = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Grass Stained Hat',
		color: 'green',
		keywords: ['grass', 'stained', 'hat', 'grass stained', 'stained hat', 'grass stained hat'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 0,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 0,
		sellValue: 12,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return grassStainedHat
}
function leatherCap(source) { //tier 2
	let leatherCap = {
		isShopItem: source,
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Cap',
		color: 'green',
		keywords: ['leather', 'cap', 'leather cap'],
		mods: {
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
			weight: 1,
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 50,
		sellValue: 6,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherCap
}

function studdedLeatherHelm(monsterLevel) { //tier 3
	let studdedLeatherHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Helm',
		color: 'green',
		keywords: ['leather', 'helm', 'leather helm', 'studded leather', 'studded leather helm'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 180,
		sellValue: 18,
		description: `A very lightweight jerkin used by most trainees. It provides a little defense while also allowing the wearer to stay light on their feet.`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherHelm
}

function leatherTunic(monsterLevel) { //tier 2
	let leatherTunic = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Tunic',
		color: 'green',
		keywords: ['leather', 'tunic', 'leather tunic'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 80,
		sellValue: 8,
		description: `A simple tunic sturdy enough for training.`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherTunic
}
function studdedLeatherJerkin(monsterLevel) { //tier 3
	let studdedLeatherJerkin = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Jerkin',
		color: 'green',
		keywords: ['leather', 'jerkin', 'leather jerkin', 'studded leather jerkin'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 240,
		sellValue: 24,
		description: `A simple jerkin sturdy enough for training.`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherJerkin
}

function shoulderguards(monsterLevel) { //tier 2
	let shoulderguards = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shoulderguards',
		color: 'green',
		keywords: ['shoulderguards'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			shoulders: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 60,
		sellValue: 5,
		description: 'Leather shoulderguards',
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return shoulderguards
}

function studdedShoulderguards(monsterLevel) { //tier 3
	let studdedShoulderguards = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Shoulderguards',
		color: 'green',
		keywords: ['studded', 'shoulderguards', 'studded shoulderguards'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			shoulders: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 150,
		sellValue: 15,
		description: 'Leather shoulderguards',
		slot: 'shoulders',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedShoulderguards
}

function leatherPants(monsterLevel) { //tier 2
	let leatherPants = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Pants',
		color: 'green',
		keywords: ['leather ', 'pants', 'leather pants'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
		},
		type: {
			armor: true,
			legs: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 70,
		sellValue: 7,
		description: 'Leather pants',
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherPants
}
function studdedTrousers(monsterLevel) { //tier 3
	let studdedTrousers = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Trousers',
		color: 'green',
		keywords: ['studded', 'trousers', 'studded trousers'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			armor: true,
			legs: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 210,
		sellValue: 21,
		description: 'Leather pants',
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedTrousers
}

function leatherGloves(monsterLevel) { //tier 2
	let leatherGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Gloves',
		color: 'green',
		keywords: ['leather', 'gloves', 'leather gloves'],
		mods: {
			weight: 1,
			slashingArmor: 1,
			piercingArmor: 0,
			bluntArmor: 0,
		},
		type: {
			skillUsed: 'Hand Protection',
			armor: true,
			hands: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 50,
		sellValue: 5,
		description: `Gloves`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherGloves
}
function studdedLeatherGloves(monsterLevel) { //tier 3
	let studdedLeatherGloves = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Gloves',
		color: 'green',
		keywords: ['leather', 'gloves', 'leather gloves', 'studded leather gloves'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		type: {
			skillUsed: 'Hand Protection',
			armor: true,
			hands: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 200,
		sellValue: 100,
		description: `Gloves`,
		slot: 'hands',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherGloves
}

function leatherBoots(monsterLevel) { //tier 2
	let leatherBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Leather Boots',
		color: 'green',
		keywords: ['leather', 'boots', 'leather boots'],
		mods: {
			weight: 1,
			slashingArmor: 0,
			piercingArmor: 1,
			bluntArmor: 0,
		},
		requirements: {
		},
		type: {
			armor: true,
			feet: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 50,
		sellValue: 100,
		description: `A simple boots sturdy enough for training.`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return leatherBoots
}
function studdedLeatherBoots(monsterLevel) { //tier 3
	let studdedLeatherBoots = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Studded Leather Boots',
		color: 'green',
		keywords: ['leather', 'boots', 'leather boots', 'studded leather boots'],
		mods: {
			weight: 1,
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
		},
		requirements: {
		},
		type: {
			armor: true,
			feet: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 200,
		sellValue: 100,
		description: `A simple boots sturdy enough for training.`,
		slot: 'feet',
		desc: function () {
			itemDescription(this)
		},
	}
	return studdedLeatherBoots
}

function ratSkullHelm(monsterLevel) {  //tier 2.5
	let ratSkullHelm = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Skull Helm',
		color: 'green',
		keywords: ['rat', 'skull', 'helm', 'rat skull', 'skull helm', 'rat skull helm'],
		mods: {
			weight: 1,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			head: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A giant rat's skull a little larger than the size of a human head`,
		slot: 'head',
		desc: function () {
			itemDescription(this)
		},
	}
	return ratSkullHelm
}

function ratHideTunic(monsterLevel) {  //tier 2.5
	let ratHideTunic = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Hide Tunic',
		color: 'green',
		keywords: ['rat', 'hide', 'tunic', 'rat hide', 'hide tunic', 'rat hide tunic'],
		mods: {
			weight: 1,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			chest: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A tunic stitched together of what looks to be hundreds of rat skins`,
		slot: 'chest',
		desc: function () {
			itemDescription(this)
		},
	}
	return ratHideTunic
}

function ratHidePants(monsterLevel) {  //tier 2.5
	let ratHidePants = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Rat Hide Pants',
		color: 'green',
		keywords: ['rat', 'hide', 'pants', 'rat hide', 'hide pants', 'rat hide pants'],
		mods: {
			weight: 1,
			slashingArmor: 3,
			piercingArmor: 3,
			bluntArmor: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			legs: true,
			leather: true,
			armorType: 'Leather'
		},
		price: 250,
		sellValue: 125,
		description: `A pair of pants stitched together with rat skin, tails and all.`,
		slot: 'legs',
		desc: function () {
			itemDescription(this)
		},
	}
	return ratHidePants
}








////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////
////////////////////////////////////////////////++LEATHER ARMOR++///////////////////////////////////////////////

/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
/////////////////////////////////////////////////++SHIELDS SHIELDS SHIELDS++////////////////////////////////////
function trainingShield(monsterLevel) {
	let trainingShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: "Training Shield",
		picture: 'images/armor/shields/training shield/training shield.png',
		color: 'green',
		keywords: ['training shield', 'training', 'shield'],
		mods: {
			slashingArmor: 1,
			piercingArmor: 1,
			bluntArmor: 1,
			weight: 5,
		},	
		type: {
			skillUsed: 'Shields',
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 80,
		sellValue: 8,
		description: `This shield is about as sturdy as a dinner plate with a turd on it.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return trainingShield
}
function squiresShield(monsterLevel) {
	let squiresShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: "Squire's Shield",
		picture: `images/armor/shields/squire's shield/squire's shield.png`,
		color: 'green',
		keywords: ["squire's", 'shield', "squire's shield", 'squire shield'],
		mods: {
			slashingArmor: 2,
			piercingArmor: 2,
			bluntArmor: 2,
			weight: 5,		},
		requirements: {
			shields: 2,
		},
		type: {
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 50,
		sellValue: 8,
		description: `This shield is about as sturdy as a dinner plate with a turd on it.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return squiresShield
}
function bronzeShield(monsterLevel) {
	let bronzeShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Bronze Shield',
		color: 'green',
		keywords: ['bronze', 'shield', 'bronze shield'],
		mods: {
			slashingArmor: 4,
			piercingArmor: 4,
			bluntArmor: 4,
			weight: 5,
		},
		requirements: {
			shields: 3,
		},
		type: {
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 250,
		sellValue: 25,
		description: `This shield is about as sturdy as a dinner plate with a turd on it.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return bronzeShield
}

function galvadianKiteShield(monsterLevel) {
	let galvadianKiteShield = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Galvadian Kite Shield',
		color: 'green',
		keywords: ['galvadian', 'kite', 'shield', 'galvadian kite', 'kite shield', 'galvadian kite shield'],
		mods: {
			slashingArmor: 6,
			piercingArmor: 6,
			bluntArmor: 6,
			weight: 15,		
		},
		requirements: {
			shields: 4,
		},
		type: {
			armor: true,
			shield: true,
			plate: true,
		},
		skillUsed: 'shields',
		price: 2000,
		sellValue: 1000,
		description: ``,
		desc: function () {
			itemDescription(this)
		},
	}
	return galvadianKiteShield
}

///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////
///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////

function koboldToothNecklace() {
	let koboldToothNecklace = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Kobold Tooth Necklace',
		color: 'green',
		keywords: ['kobold', 'tooth', 'necklace', 'kobold tooth', 'tooth necklace', 'kobold tooth necklace'],
		mods: {
			str: 1,
			dex: 1,
		},
		requirements: {
		},
		type: {
			armor: true,
			neck: true,
			jewelry: true,
		},
		price: 10,
		sellValue: 5,
		description: `A necklace made from Kobold teeth`,
		slot: 'neck',
		desc: function () {
			itemDescription(this)
		},
	}
	return koboldToothNecklace
}

function oldRing(monsterLevel) {
	let itemPrice = 100
	let sellValue = monsterLevel != undefined ? Math.ceil(itemPrice * 0.25) + monsterLevel * 2 : Math.ceil(itemPrice * 0.25)
	let oldRing = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'old ring',
		color: 'green',
		keywords: ['old', 'ring', 'old ring'],
		mods: {
			int: 5,
			wis: 5,
		},
		type: {
			armor: true,
			ring: true,
		},
		slot: slot13,
		desc: function () {
			itemDescription(this)
		},
	}
	return oldRing
}
///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////
///////////////////////////////////////////////++JEWELRY++//////////////////////////////////////////////////

///////////////////////////////////////////////++CLOAKS++//////////////////////////////////////////////////
///////////////////////////////////////////////++CLOAKS++//////////////////////////////////////////////////
function shabbyCloak(monsterLevel) {
	let shabbyCloak = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shabby Cloak',
		color: 'green',
		keywords: ['shabby', 'cloak', 'shabby cloak'],
		mods: {
			str: 3,
		},
		type: {
			armor: true,
			cloak: true,
			back: true,
		},
		slot: slot7,
		price: 200,
		sellValue: 5,
		description: `A shabby cloak covered in dirt. It appears to have some light magic in its fibers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return shabbyCloak
}
function shoddyCloak(monsterLevel) {
	let shoddyCloak = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shoddy Cloak',
		color: 'green',
		keywords: ['shoddy', 'cloak', 'shoddy cloak'],
		mods: {
			int: 3,
		},
		type: {
			armor: true,
			cloak: true,
			back: true,
		},
		slot: slot7,
		price: 200,
		sellValue: 5,
		description: `A shoddy cloak covered in dirt. It appears to have some light magic in its fibers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return shoddyCloak
}
function shreddedCloak(monsterLevel) {
	let shreddedCloak = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shredded Cloak',
		color: 'green',
		keywords: ['shredded', 'cloak', 'shredded cloak'],
		mods: {
			dex: 3,
		},
		type: {
			armor: true,
			cloak: true,
			back: true,
		},
		slot: slot7,
		price: 200,
		sellValue: 5,
		description: `A shredded cloak covered in dirt. It appears to have some light magic in its fibers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return shreddedCloak
}
function shiftyCloak(monsterLevel) {
	let shiftyCloak = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shifty Cloak',
		color: 'green',
		keywords: ['shifty', 'cloak', 'shifty cloak'],
		mods: {
			agi: 3,
		},
		type: {
			armor: true,
			cloak: true,
			back: true,
		},
		slot: slot7,
		price: 200,
		sellValue: 5,
		description: `A shifty cloak covered in dirt. It appears to have some light magic in its fibers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return shiftyCloak
}
function shelledCloak(monsterLevel) {
	let shelledCloak = {
		id: () => {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Shelled Cloak',
		color: 'green',
		keywords: ['shelled', 'cloak', 'shelled cloak'],
		mods: {
			wis: 3,
			mys: 3,
		},
		type: {
			armor: true,
			cloak: true,
			back: true,
		},
		slot: slot7,
		price: 200,
		sellValue: 5,
		description: `A shelled cloak covered in dirt and snail shells. It appears to have some light magic in its fibers.`,
		desc: function () {
			itemDescription(this)
		},
	}
	return shelledCloak
}
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
//////////////////////////////////////////////////++CONSUMABLES++//////////////////////////////////////////////////
function smallHealingPotion(monsterLevel) {
	let smallHealingPotion = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Healing Potion',
		color: 'green',
		keywords: ['potion', 'healing', 'healing potion', 'small healing potion'],
		type: {
			consumable: true,
		},
		activate: async function () {
			let maxHealth = player.maxHealth
			let currentHealth = player.health
			let healthDifference = maxHealth - currentHealth
			let restoreAmount = 30
			let line1 = lineFunc()
			blankSpace()
			if (healthDifference >= restoreAmount) {
				player.health += restoreAmount
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${restoreAmount} `, 'green', line1)
				customizeEachWord(`health`, 'red', line1)			
				customizeEachWord(`.`, 'white', line1)				
			} else {
				player.health += healthDifference
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${healthDifference} `, 'green', line1)
				customizeEachWord(`health.`, 'white', line1)			
			}
			blankSpace()
		},
		description: `This is a healing potion that restores 30 hit points upon drinking.`,
		desc: function() {
			itemDescription(this)
		}
	}
	return smallHealingPotion
}

function healingPotion(monsterLevel) {
	let healingPotion = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Healing Potion',
		color: 'green',
		keywords: ['potion', 'healing', 'healing potion', 'small healing potion'],
		type: {
			consumable: true,
		},
		activate: async function () {
			let maxHealth = player.maxHealth
			let currentHealth = player.health
			let healthDifference = maxHealth - currentHealth
			let restoreAmount = 60
			let line1 = lineFunc()
			blankSpace()
			if (healthDifference >= restoreAmount) {
				player.health += restoreAmount
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${restoreAmount} `, 'green', line1)
				customizeEachWord(`health`, 'red', line1)
				customizeEachWord(`.`, 'white', line1)
			} else {
				player.health += healthDifference
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${healthDifference} `, 'green', line1)
				customizeEachWord(`health.`, 'white', line1)			
			}
			blankSpace()
		},
		description: `This is a healing potion that restores 60 hit points upon drinking.`,
		desc: function() {
			itemDescription(this)
		}
	}
	return healingPotion
}
function smallManaPotion(monsterLevel) {
	let smallManaPotion = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Small Mana Potion',
		color: 'green',
		keywords: ['small mana potion', 'small mana', 'mana potion', 'potion'],
		type: {
			consumable: true,
		},
		activate: async function () {
			let maxMana = player.maxMana
			let currentMana = player.mana
			let manaDifference = maxMana - currentMana
			let restoreAmount = 50
			let line1 = lineFunc()
			blankSpace()
			if (manaDifference >= restoreAmount) {
				player.mana += restoreAmount
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${restoreAmount} `, 'green', line1)
				customizeEachWord(`mana`, 'blue', line1)
				customizeEachWord(`.`, 'white', line1)
			} else {
				player.mana += manaDifference
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${manaDifference} `, 'green', line1)
				customizeEachWord(`mana.`, 'white', line1)
			}
			blankSpace()
		},
		description: `This is a mana potion that restores 50 mana upon drinking.`,
		desc: function() {
			itemDescription(this)
		}
	}
	return smallManaPotion
}
function manaPotion(monsterLevel) {
	let manaPotion = {
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushItem[i]) {
					return i
				}
			}
		},
		roomId: currentArea.id,
		name: 'Mana Potion',
		color: 'green',
		keywords: ['potion', 'mana', 'mana potion'],
		type: {
			consumable: true,
		},
		activate: async function () {
			let maxMana = player.maxMana
			let currentMana = player.mana
			let manaDifference = maxMana - currentMana
			let restoreAmount = 100
			let line1 = lineFunc()
			blankSpace()
			if (manaDifference >= restoreAmount) {
				player.mana += restoreAmount
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${restoreAmount} `, 'green', line1)
				customizeEachWord(`mana`, 'blue', line1)
				customizeEachWord(`.`, 'white', line1)			
			} else {
				player.mana += manaDifference
				customizeEachWord(`You restore `, 'white', line1)
				customizeEachWord(`${manaDifference} `, 'green', line1)
				customizeEachWord(`mana.`, 'white', line1)
			}
			blankSpace()
		},
		description: `This is a mana potion that restores 100 mana upon drinking.`,
		desc: function() {
			itemDescription(this)
		}
	}
	return manaPotion
}

//_________________________________________________________________________________________________________________
function drinkPotion(secondCommand) {
	let selectedItem = pushItem.find(item => item.keywords.find(keyword => keyword == secondCommand))
	let line1 = document.createElement('div')
	if (secondCommand == undefined) {
		customizeEachWord(`You must specify what you want to drink`, 'white', line1)
	} else if (selectedItem == undefined) {
		customizeEachWord(`You do not have a ${secondCommand} to drink`, 'white', line1)
	} else if (!selectedItem.type.consumable) {
		customizeEachWord(`It would be proposterous to try to drink a ${secondCommand}!`, 'white', line1)
	} else if (selectedItem.roomId == backpack) {
		customizeEachWord(`You must first hold your ${selectedItem.name} before drinking it`, 'white', line1)
	} else if (selectedItem.roomId == slot1 || selectedItem.roomId == slot2) {
		drinkPotionSound.play()
		selectedItem.activate()
		if (player.rightHand == selectedItem.name) {
			player.rightHand = empty
		} else {
			player.leftHand = empty
		}
		let removeThisItem = pushItem.findIndex(x => x.id == selectedItem.id)
		pushItem.splice(removeThisItem, 1)
	}
}
//item is in right hand, item type is armor
function getAllItemsOnPerson() {
	return pushItem.filter(
		item =>
			item.roomId == 'right hand' ||
			item.roomId == 'left hand' ||
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet' ||
			item.roomId == 'backpack'
	)
}
function donWearEquip(secondCommand) {
	let allItemsOnPerson = pushItem.filter(
		item =>
			item.roomId == 'right hand' ||
			item.roomId == 'left hand' ||
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet' ||
			item.roomId == 'backpack'
	)
	let itemInBackpack = allItemsOnPerson.find(item => item.roomId == 'backpack' && item.keywords.find(keyword => keyword == secondCommand))
	let selectedItem = allItemsOnPerson.find(item => item.roomId == 'right hand' && item.type.armor) || allItemsOnPerson.find(item => item.roomId == 'left hand' && item.type.armor)
	let selectedSlot = selectedItem ? selectedItem.slot : undefined
	//if target item is in right hand or left hand and item of that type is NOT equipped
	if (secondCommand == undefined || /^\s*$/.test(secondCommand) == true) {
		quickMessage(`You must specify what you want to unpack.`)
	}
	if (selectedItem != undefined && player[selectedSlot] == empty && selectedItem.type.armor != undefined) {
		if (requirementsMet(selectedItem) == false) {
			quickMessage(`You do not meet the requirements to equip your ${selectedItem.name}`)
			return
		}
		let line1 = lineFunc()
		customizeEachWord(`You equip your `, 'white', line1)
		customizeEachWord(`${selectedItem.name}`, selectedItem.color, line1)
		let rightOrLeft = selectedItem.roomId == slot1 ? true : false
		if (rightOrLeft) {
			player.rightHand = empty
		} else if (rightOrLeft == false) {
			player.leftHand = empty
		}
		selectedItem.roomId = selectedSlot
		player[selectedSlot] = selectedItem.name
		// armorAddPlayerAttribute(selectedItem)
		//if target item is in right hand or left hand and item of that type IS equipped
	} else if (itemInBackpack != undefined && itemInBackpack.type.armor != undefined) {
		quickMessage(`You need to wield your ${itemInBackpack.name} before equipping it`)
	} else if ((itemInBackpack != undefined && itemInBackpack.type.armor != undefined) || (selectedItem != undefined && player[selectedSlot] != empty)) {
		quickMessage(`You already have something equipped in that slot.`)
	} else if (itemInBackpack != undefined && itemInBackpack.type.armor == undefined) {
		quickMessage(`You cannot wear a ${itemInBackpack.name}`)
	} else if (selectedItem == undefined && itemInBackpack == undefined) {
		quickMessage(`You do not own a ${secondCommand} to equip`)
		// } else if (selectedItem == undefined) {
		// 	quickMessage(`You need to wield something first before attempting to equip it.`)
	} else if (itemInBackpack == undefined) {
		quickMessage(`You do not own a ${secondCommand} to equip.`)
	} else {
		quickMessage(`Command not yet coded`)
	}

	// if (secondCommand == undefined) {
	// 	quickMessage(`You must specify what you want to equip`)
	// } else if (selectedItem == undefined && allItemsOnPerson.find(item => item.keywords.find(keyword => keyword == secondCommand)) != undefined) {
	// 	quickMessage(`You do not have a ${secondCommand} to wear`)
	// } else if (player[selectedSlot] != empty) {
	// 	quickMessage(`You already have something equipped of that armor type`)
	// } else if (!selectedItem.type.armor) {
	// 	quickMessage(`It would be proposterous to wear a ${secondCommand}`)
	// } else if (selectedItem.roomId == backpack) {
	// 	quickMessage(`You must first wield your ${selectedItem.name} before equipping it`)
	// } else if ((selectedItem.type.armor && selectedItem.roomId == slot1) || selectedItem.roomId == slot2) {
	// 	quickMessage(`You equip your ${selectedItem.name}`)
	// 	let rightOrLeft = selectedItem.roomId == slot1 ? true : false
	// 	if (rightOrLeft) {
	// 		player.rightHand = empty
	// 	} else if (rightOrLeft == false) {
	// 		player.leftHand = empty
	// 	}
	// 	selectedItem.roomId = selectedSlot
	// 	player[selectedSlot] = selectedItem.name
	// 	armorAddPlayerAttribute(selectedItem)
	// }
	updateWeaponIcons()
	updateEquipmentMods()
}

function requirementsMet(item) {
	if (!item || !item.requirements) {
	  console.log('No item requirements');
	  return true;
	}
	for (const [stat, requirement] of Object.entries(item.requirements)) {
	  if (stat === 'guild' && player[stat] !== requirement) {
		quickMessage(`Your class cannot equip this!`);
		return false;
	  }
	  const playerStat = player[stat]?.level !== undefined ? player[stat].level : player[stat];
	  if (playerStat < requirement) {
		let line1 = lineFunc()
		customizeEachWord(`Your `, 'white', line1)
		customizeEachWord(`${item.name} `, item.color, line1)
		customizeEachWord(`requires `, 'white', line1)
		if (player[stat].name) {
			customizeEachWord(`a `, 'white', line1)
			customizeEachWord(`${player[stat].name} `, 'green', line1)
			customizeEachWord(`skill level of `, 'white', line1)
			customizeEachWord(`${requirement} `, 'light-blue', line1)
			customizeEachWord(`to use.`, 'white', line1)
		} else {
			customizeEachWord(`${requirement} `, 'light-blue', line1)
			customizeEachWord(`${capitalizeFirstLetter(stat)} `, 'green', line1)
			customizeEachWord(`to use.`, 'white', line1)
		}
		return false;
	  }
	}
	return true;
}

function unequipRemove(secondCommand) {
	let allItemsEquipped = pushItem.filter(
		item =>
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet'
	)
	let selectedItem = allItemsEquipped.find(item => item.keywords.find(keyword => keyword == secondCommand))
	let selectedItemBySlot = allItemsEquipped.find(item => item.slot == secondCommand)

	let selectedSlot = selectedItem ? selectedItem.slot : undefined

	if (secondCommand == undefined) {
		quickMessage(`You must specify what you want to unequip`)
	} else if (selectedItem == undefined) {
		quickMessage(`You do not have a ${secondCommand} to unequip`)
	} else if (player[selectedSlot] == empty) {
		quickMessage(`You do not have anything equipped in that slot to unequip`)
	} else if ((selectedItem.type.armor != undefined && selectedItem.roomId == selectedItem.slot) || selectedItem.roomId == selectedItem.slot) {
		itemRemoved(selectedItem, selectedSlot)
	}
	updateWeaponIcons()
	updateEquipmentMods()
	updateInventory()
}
function itemRemoved(selectedItem, selectedSlot) {
	let line1 = lineFunc()
	if (player.rightHand == empty) {
		selectedItem.roomId = slot1
		player.rightHand = selectedItem.name
		player[selectedSlot] = empty
		// armorRemovePlayerAttribute(selectedItem)
		customizeEachWord(`You unequip your `, 'white', line1)
		customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
		customizeEachWord(`to your right hand.`, 'white', line1)
	} else if (player.leftHand == empty) {
		selectedItem.roomId = slot2
		player.leftHand = selectedItem.name
		player[selectedSlot] = empty
		// armorRemovePlayerAttribute(selectedItem)
		customizeEachWord(`You unequip your `, 'white', line1)
		customizeEachWord(`${selectedItem.name} `, selectedItem.color, line1)
		customizeEachWord(`to your left hand.`, 'white', line1)	
	} else {
		quickMessage(`Your hands are too full to carry anything else`)
	}
}
// function weaponOrShieldAddPlayerAttribute(moddedWeaponOrShield) {
// 	if (moddedWeaponOrShield.type.shield) {
// 		player.armor += player.shields.rating()
// 	}
// 	if (moddedWeaponOrShield.type.weapon || moddedWeaponOrShield.type.shield) {
// 		let moddedWeaponOrShieldMods = moddedWeaponOrShield.mods
// 		let moddedWeaponOrShieldKeys = Object.keys(moddedWeaponOrShieldMods)
// 		for (let i = 0; i < moddedWeaponOrShieldKeys.length; i++) {
// 			let directPlayerMods = ['str', 'dex', 'agi', 'int', 'wis', 'con', 'slashingArmor', 'piercingArmor', 'bluntArmor']
// 			if (directPlayerMods.includes(moddedWeaponOrShieldKeys[i])) {
// 				player[moddedWeaponOrShieldKeys[i]] = player[moddedWeaponOrShieldKeys[i]] + moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
// 			} else {
// 				player[moddedWeaponOrShieldKeys[i]].level = player[moddedWeaponOrShieldKeys[i]].level + moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
// 			}
// 		}
// 	}
// 	updatePlayerStats()
// }

// function weaponOrShieldRemovePlayerAttribute(moddedWeaponOrShield) {
// 	console.log(moddedWeaponOrShield)
// 	if (moddedWeaponOrShield.type.shield) {
// 		player.armor -= player.shields.rating()
// 	}
// 	if (moddedWeaponOrShield.type.weapon || moddedWeaponOrShield.type.shield) {
// 		console.log('This should add stats to player')
// 		let moddedWeaponOrShieldMods = moddedWeaponOrShield.mods
// 		let moddedWeaponOrShieldKeys = Object.keys(moddedWeaponOrShieldMods)
// 		for (let i = 0; i < moddedWeaponOrShieldKeys.length; i++) {
// 			let directPlayerMods = ['str', 'dex', 'agi', 'int', 'wis', 'con', 'slashingArmor', 'piercingArmor', 'bluntArmor']
// 			if (directPlayerMods.includes(moddedWeaponOrShieldKeys[i])) {
// 				player[moddedWeaponOrShieldKeys[i]] = player[moddedWeaponOrShieldKeys[i]] - moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
// 			} else {
// 				player[moddedWeaponOrShieldKeys[i]].level = player[moddedWeaponOrShieldKeys[i]].level - moddedWeaponOrShieldMods[moddedWeaponOrShieldKeys[i]]
// 			}

// 		}
// 	}
// 	updatePlayerStats()
// }
// function armorAddPlayerAttribute(moddedArmor) {
// 	if (moddedArmor.type.armor) {
// 		let moddedArmorMods = moddedArmor.mods
// 		let moddedArmorKeys = Object.keys(moddedArmorMods)
// 		for (let i = 0; i < moddedArmorKeys.length; i++) {
// 			//CHANGE TO ONLY USING THE TOP LINE OF CODE WHEN READY TO SWITCH OVER TO COMBINING MODDED VALUES INSTEAD OF DIRECTLY MODDING THE PLAYER
// 			let directPlayerMods = ['str', 'dex', 'agi', 'int', 'wis', 'con', 'slashingArmor', 'piercingArmor', 'bluntArmor']
// 			quickMessage(`${moddedArmorKeys[i]}`)
// 			if (directPlayerMods.includes(moddedArmorKeys[i])) {
// 				quickMessage(`FOUND`)
// 				player[moddedArmorKeys[i]] = player[moddedArmorKeys[i]] + moddedArmorMods[moddedArmorKeys[i]]
// 			} else {
// 				player[moddedArmorKeys[i]].level = player[moddedArmorKeys[i]].level + moddedArmorMods[moddedArmorKeys[i]]
// 			}
// 		}
// 	}
// 	updatePlayerStats()
// }
// function armorRemovePlayerAttribute(moddedArmor) {
// 	if (moddedArmor.type.armor) {
// 		let moddedArmorMods = moddedArmor.mods
// 		let moddedArmorKeys = Object.keys(moddedArmorMods)
// 		for (let i = 0; i < moddedArmorKeys.length; i++) {
// 			//CHANGE TO ONLY USING THE TOP LINE OF CODE WHEN READY TO SWITCH OVER TO COMBINING MODDED VALUES INSTEAD OF DIRECTLY MODDING THE PLAYER
// 			let directPlayerMods = ['str', 'dex', 'agi', 'int', 'wis', 'con', 'slashingArmor', 'piercingArmor', 'bluntArmor']
// 			if (directPlayerMods.includes(moddedArmorKeys[i])) {
// 				player[moddedArmorKeys[i]] = player[moddedArmorKeys[i]] - moddedArmorMods[moddedArmorKeys[i]]
// 			} else {
// 				player[moddedArmorKeys[i]].level = player[moddedArmorKeys[i]].level - moddedArmorMods[moddedArmorKeys[i]]
// 			}
// 		}
// 	}
// 	updatePlayerStats()
// }

//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////MONSTERS/////////////////////////////////////////////////////
function enemyLevelColor(enemy) {
	if (enemy.level < player.level - 5) {
		return 'light-red'
	}
	if (enemy.level > player.level + 5) {
		return 'dark-red'
	}
	else {
		return 'red'
	}
}

function trainingDummy(area) {
	let trainingDummy = {
		get color() {
			return enemyLevelColor(this)
		},
		x: 0,
		y: 6,
		z: -2,
		level: -10,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			let description = `This Training Dummy looks indestructible`
			enemyDescription(this, description)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 0,
		factor: 1,
		experience: () => 1,
		armor: 0,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy
}
function trainingDummy2(area) {
	let trainingDummy2 = {
		get color() {
			return enemyLevelColor(this)
		},
		x: 0,
		y: 6,
		z: -2,
		level: -10,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 2',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy2
}
function trainingDummy3(area) {
	let trainingDummy3 = {
		get color() {
			return enemyLevelColor(this)
		},
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		fireResist: 5,
		iceResist: 5,
		lightningResist: 5,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 3',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy3
}
function trainingDummy4(area) {
	let trainingDummy4 = {
		get color() {
			return enemyLevelColor(this)
		},
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		fireResist: 5,
		iceResist: 5,
		lightningResist: 5,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 4',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy4
}
function trainingDummy5(area) {
	let trainingDummy5 = {
		get color() {
			return enemyLevelColor(this)
		},		
		x: 0,
		y: 6,
		z: -2,
		level: 10,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 15,
		piercingArmor: 15,
		bluntArmor: 15,
		fireResist: 15,
		iceResist: 15,
		lightningResist: 15,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 5',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy5
}
function trainingDummy6(area) {
	let trainingDummy6 = {
		get color() {
			return enemyLevelColor(this)
		},		
		x: 0,
		y: 6,
		z: -2,
		level: 10,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 15,
		piercingArmor: 15,
		bluntArmor: 15,
		fireResist: 15,
		iceResist: 15,
		lightningResist: 15,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 6',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy6
}
function trainingDummy7(area) {
	let trainingDummy7 = {
		get color() {
			return enemyLevelColor(this)
		},		
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 7',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy7
}
function trainingDummy8(area) {
	let trainingDummy8 = {
		get color() {
			return enemyLevelColor(this)
		},		
		x: 0,
		y: 6,
		z: -2,
		level: -10,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 8',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy8
}
function trainingDummy9(area) {
	let trainingDummy9 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 9',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy9
}
function trainingDummy10(area) {
	let trainingDummy10 = {
		color: `purple`,
		x: 0,
		y: 6,
		z: -2,
		level: 1,
		str: () => 0 + this.level,
		dex: () => 0 + this.level,
		agi: () => 0 + this.level,
		int: () => 0 + this.level,
		wis: () => 0 + this.level,
		con: () => 1 + this.level,
		desc: function () {
			quickMessage(`This training dummy will not fight back`)
			quickMessage(`${this.armor}`)
			quickMessage(`${this.health}`)
			quickMessage(`${this.experience} - experience`)
		},
		hostile: false,
		combat: false,
		health: 900000000,
		maxHealth: 900000000,
		attackPower: () => this.str + this.dex,
		accuracy: 1,
		dodge: 1,
		factor: 1,
		experience: () => 1,
		armor: 1,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {

		},
		roomId: trainingHallsCombatRoom1.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Training Dummy 10',
		keywords: ['training', 'training dummy', 'dummy'],
		abilityName: '',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = 8
				return gold
			}
		},
		itemDropsRoll: function () {},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `Breaks and collapses to the ground `,
		enemyBehavior: function () {
			console.log('no behavior')
		},
	}
	return trainingDummy10
}

function contagionEnemyDies(enemy) {
	if (enemy?.debuffs?.poison) {
		let allEnemiesInRoom = getAllEnemiesInRoom()
		let targetEnemyIndex = allEnemiesInRoom.indexOf(enemy)
		allEnemiesInRoom.splice(targetEnemyIndex, 1)
		let debuffToApply = {...enemy.debuffs.poison}
		debuffToApply.stacks -= 1
		for (let i = 0; i < allEnemiesInRoom.length; i++) {
			applyDebuff(allEnemiesInRoom[i], debuffToApply)
		}
	}
}

function applyThrillOfTheKill(enemy) {
	if (player.thrillOfTheKill.level > 0) {
		player.thrillOfTheKill.activate(enemy)
	}
}
function thrillOfTheKillProc() {
	if (player.buffs.thrillOfTheKill) {
		let healAmount = player.buffs.thrillOfTheKill.heal()
		player.health + healAmount > player.maxHealth ? player.health = player.maxHealth : player.health += healAmount
		player.buffs.thrillOfTheKill.flavorText(healAmount)
	}
}
 
 
 function enemyDeathConditionals(enemy) {
	contagionEnemyDies(enemy)
	applyThrillOfTheKill(enemy)
}

function enemyDeath(enemy) {
	if (enemy.health <= 0) {
		enemyDeathConditionals(enemy)
		if (player.killList[enemy.refName] == undefined) {
			player.killList[enemy.refName] = 1
		} else {
			player.killList[enemy.refName]++
		}
		//turn all this text into its own function
		const line1 = document.createElement('div')
		const line2 = document.createElement('div')
		const line3 = document.createElement('div')
		line3.classList.add('item-drops-margin')
		customizeEachWord(`The `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`${enemy.deathPhrase} `, 'white', line1)
		customizeEachWord(`(`, 'white', line1)
		customizeEachWord(`you gain `, 'white', line1)
		customizeEachWord(`${enemy.experience} `, 'light-blue', line1)
		customizeEachWord(`experience points!)`, 'white', line1)
		//enemy had nothing of value
		if (enemy.gold == 0 && !enemy.itemDrops[0]) {
			customizeEachWord(`${enemy.name} `, enemy.color, line2)
			customizeEachWord(`had nothing of value`, 'white', line2)
			blankSpace()
		} else if (enemy.gold == 0 && enemy.itemDrops[0]) {
			//ITEM ONLY DROP
			customizeEachWord(`The `, 'white', line2)
			customizeEachWord(`${enemy.name} `, enemy.color, line2)
			customizeEachWord(`dropped:`, 'white', line2)
			enemy.itemDrops.forEach(item => {
				let lineX = document.createElement('div')
				lineX.classList.add('item-drops-margin')
				customizeEachWord(`${item.name}`, 'green', lineX)
			})
			blankSpace()
		} else if (enemy.gold > 0 && !enemy.itemDrops[0]) {
			//GOLD ONLY DROP
			customizeEachWord(`The `, 'white', line2)
			customizeEachWord(`${enemy.name} `, enemy.color, line2)
			customizeEachWord(`dropped: `, 'white', line2)
			customizeEachWord(`${enemy.gold} `, 'yellow', line3)
			customizeEachWord(`gold piece(s) `, 'white', line3)
			blankSpace()
		} else {
			//GOLD AND ITEM DROP
			customizeEachWord(`The `, 'white', line2)
			customizeEachWord(`${enemy.name} `, enemy.color, line2)
			customizeEachWord(`dropped:`, 'white', line2)
			customizeEachWord(`${enemy.gold} `, 'yellow', line3)
			customizeEachWord(`gold piece(s) `, 'white', line3)
			enemy.itemDrops.forEach(item => {
				let lineX = document.createElement('div')
				lineX.classList.add('item-drops-margin')
				customizeEachWord(`${item.name}`, 'green', lineX)
			})
			blankSpace()
		}
		clearInterval(enemy.enemyBehaviorInterval)
		const removeThisMonster = pushMonster.indexOf(enemy)
		const removeThisRoomEnemy = roomEnemies.indexOf(enemy)
		playerGainKillExperience(enemy.experience)
		enemy.itemDrops.forEach(item => item.name)
		pushMonster.splice(removeThisMonster, 1)
		roomEnemies.splice(removeThisRoomEnemy, 1)
		enemy.itemDrops.forEach(droppedItem => (droppedItem.roomId = currentArea.id))
		enemy.itemDrops.forEach(addItem => pushItem.push(addItem))
		currentArea.gold = currentArea.gold + enemy.gold
		combatCheck()
		playerLevelFunc()
	}
}
function masterMonster(area) {
	let masterMonster = {
		get color() {
			return enemyLevelColor(this)
		},
		entersTheRoomPhrase: `masters in!`,
		advancePhrase: `advances toward you..`,
		deathPhrase: `lets out a final "masters!" before it flops over dead `,
		entersExitsRoomPhrase: `hobbles`,
		strikePhrase: 'bites at you and hits!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: 'leaps across the room and bites your neck!',
		rangedMissPhrase: 'leaps at you and misses!',
		hostile: true,
		combat: false,
		armor: 1,
		damageTypes: ['slashing', 'piercing', 'blunt'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 25,
			ranged: 25,
			meleeAbility: 25,
			rangedAbility: 25,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Master Monster',
		refName: 'master',
		keywords: ['master'],
		health: () => 10000 + (this.level * this.con),
		maxHealth: () => 10000 + (this.level * this.con),
		con: () => 5,
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},		
		accuracy: () => 5,
		dodge: () => 0,
		baseExperience: 0,
		experience: () => {return enemyKillExperience(this)},
		itemDrops: [],
		gold: function () {
			randomNumberRange(100, 1000)
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratTail]
			const probability = [10]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		level: () => {
			let level = randomNumberRange(1, 1)
			return level
		},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance =  calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 2000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 50,
				ability2: 50,
			},
			ability1: {
				name: 'Ability 1',
				color: 'purple',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 5000,
				damage: function() {return randomNumberRange(5, 5)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`RANGED ABILITY 1 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A RANGED ABILITY 1`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`does something wild, and its wacky stuper, it swings at you and [RANGED]`, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			},
			ability2: {
				name: 'Ability 2',
				color: 'pink',
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				combatType: 'ranged',
				castTime: 1000,
				damage: function() {return randomNumberRange(6, 6)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`RANGED ABILITY 2 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR RANGED ABILITY 2`, 'white', line1)
				},
			}
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 50,
				ability2: 50,
			},
			ability1: {
				name: 'Melee Ability 1: Master Attack!',
				color: 'brown',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRE, WATER, ICE LIGHTNING, ETC
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'melee',
				castTime: 2000,
				damage: function() {return randomNumberRange(7, 7)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`MELEE ABILITY 1 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR A MELEE ABILITY 1`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`does something wild, and its wacky stuper, it swings at you and [MELEE] `, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			},
			ability2: {
				name: 'Melee Ability 2: Master Attack 2!',
				color: 'grey',
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				combatType: 'melee',
				castTime: 5000,
				damage: function() {return randomNumberRange(8, 8)},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`MELEE ABILITY 2 USED HERE`, 'white', line1)
				},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`GATHERING STRENGTH FOR MELEE ABILITY 2`, 'white', line1)
				},

			}
		},
		desc: function () {
			let description = `A little aggressive Master Monster. It squeeks often.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return masterMonster
}
//TRAINING FIELDS
function mudling(area) {
	let mudling = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/mudling/mudling.png",
		entersTheRoomPhrase: `plops in!`,
		advancePhrase: `flops toward you..`,
		deathPhrase: `sinks into a lifeless puddle`,
		strikePhrase: 'plops at you and hits!',
		missPhrase: 'plops at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		entersExitsRoomPhrase: `plops`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Mudling',
		refName: 'mudling',
		keywords: ['mudling'],
		level: randomNumberRange(1, 3),
		health: () => 10 + (this.level * this.con),
		maxHealth: () => 10 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 10,
		experience: () => {
			let baseLevel = 1
			return enemyKillExperience(this, baseLevel)
		},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 1.0
			let topDamage =  this.attackPower * 1.0
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function() {
			return randomNumberRange(1, 5)
		},
		itemDropsRoll: function () {
			const itemDrops =  [mudBall]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},
		enemyMoveSpeed: 6000,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		damageTypes: ['blunt'],
		attackTypes: { 
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance =  calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `The Mudling looks to be a low form of earth elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return mudling
}
function waterling(area) {
	let waterling = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/waterling/waterling.png",
		entersTheRoomPhrase: `drips in!`,
		advancePhrase: `splashes toward you`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Waterling',
		refName: 'waterling',
		keywords: ['waterling'],
		level: randomNumberRange(1, 3),
		health: () => 10 + (this.level * this.con),
		maxHealth: () => 10 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 10,
		experience: () => {
			let baseLevel = 1
			return enemyKillExperience(this, baseLevel)
		},		
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 1.0
			let topDamage =  this.attackPower * 1.0
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(1, 5)
		},
		itemDropsRoll: function () {
			const itemDrops =  [waterBerry]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},

		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		desc: function () {
			let description = `The Waterling looks to be a low form of water elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'splashes on you!',
		missPhrase: 'splashes at you and misses!',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return waterling
}
function grassling(area) {
	let grassling = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/grassling/grassling.png",
		entersTheRoomPhrase: `wafts in!`,
		advancePhrase: `waddles up to you..`,
		deathPhrase: `wilts over and fades away`,
		entersExitsRoomPhrase: `blows`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Grassling',
		refName: 'grassling',
		keywords: ['grassling'],
		level: randomNumberRange(1, 3),
		health: () => 10 + (this.level * this.con),
		maxHealth: () => 10 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 10,
		experience: () => {
			let baseLevel = 1
			return enemyKillExperience(this, baseLevel)
		},		
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 1.0
			let topDamage =  this.attackPower * 1.0
			return randomNumberRange(botDamage, topDamage)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		gold: function () {
			return randomNumberRange(1, 5)
		},
		itemDropsRoll: function () {
			const itemDrops =  [grassFruit]
			const probability = [30]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],

		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		desc: function () {
			let description = `The Grassling looks to be a low form of air elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'whips itself at you and hits!',
		missPhrase: 'whips itself at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return grassling
}
function mudlet(area) {
	let mudlet = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/mudlet/mudlet.png",
		entersTheRoomPhrase: `plops in!`,
		advancePhrase: `flops toward you..`,
		deathPhrase: `sinks into a lifeless puddle`,
		entersExitsRoomPhrase: `plops`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Mudlet',
		refName: 'mudlet',
		keywords: ['mudlet'],
		level: randomNumberRange(3, 4),
		health: () => 20 + (this.level * this.con),
		maxHealth: () => 20 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 15,
		experience: () => {
			let baseLevel = 3
			return enemyKillExperience(this, baseLevel)
		},			
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(8, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [mudBall, muddyGloves]
			const probability = [50, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		enemyMoveSpeed: 6000,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 50,
			rangedAbility: 0,
		},
		
		itemDrops: [],

		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Gurgle Slap',
				color: 'brown',
				damageType: 'physical',
				penetrationTypes: ['blunt'],
				combatType: 'melee',
				castTime: 3000,
				damage: function() {return randomNumberRange(7, 8)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`With a gurgling lurch forward, the `, 'white', line1)
					customizeEachWord(`Mudlet `, 'red', line1)
					customizeEachWord(`slaps you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Mudlet `, 'red', line1)
					customizeEachWord(`looks to be preparing for something...`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`lunges forward with a `, 'white', line1)
					customizeEachWord(`Gurgling Lurch `, this.color, line1)
					customizeEachWord(`and `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
			},
		},
		desc: function () {
			let description = `The Mudlet looks to be a low form of earth elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'plops at you and hits!',
		missPhrase: 'plops at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return mudlet
}
function waterlet(area) {
	let waterlet = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/waterlet/waterlet.png",
		entersTheRoomPhrase: `drips in!`,
		advancePhrase: `splashes toward you`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 1,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Waterlet',
		refName: 'waterlet',
		keywords: ['waterlet'],
		level: randomNumberRange(3, 4),
		health: () => 20 + (this.level * this.con),
		maxHealth: () => 20 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 15,
		experience: () => {
			let baseLevel = 3
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(8, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [waterBerry, waterloggedBoots]
			const probability = [50, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 100,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 6000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Stinging Wind',
				color: 'light-green',
				damage: function() {return randomNumberRange(10, 20)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`whips its body toward you, sending a blade of wind at you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`begins dancing back and forth..`, 'white', line1)
				}, 
				damageType: 'wind',
				penetrationTypes: ['piercing'],
				combatType: 'ranged',
				castTime: 5000,
			},
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(1, 10)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`With a gurgling lurch forward, the `, 'white', line1)
					customizeEachWord(`Mudling `, 'red', line1)
					customizeEachWord(`slaps you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Mudling `, 'red', line1)
					customizeEachWord(`looks to be preparing for something...`, 'white', line1)
				}, 
				damageType: 'physical',
				penetrationTypes: [],
				combatType: 'melee',
				castTime: 3000,
			},
		},
		desc: function () {
			let description = `The Waterling looks to be a low form of water elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return waterlet
}
function grasslet(area) {
	let grasslet = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/grasslet/grasslet.png",
		entersTheRoomPhrase: `wafts in!`,
		advancePhrase: `waddles up to you..`,
		deathPhrase: `wilts over and fades away`,
		entersExitsRoomPhrase: `blows`,
		hostile: true,
		combat: false,
		armor: 1,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Grasslet',
		refName: 'grasslet',
		keywords: ['grasslet'],
		level: randomNumberRange(3, 4),
		health: () => 20 + (this.level * this.con),
		maxHealth: () => 20 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 15,
		experience: () => {
			let baseLevel = 3
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(8, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [grassFruit, grassStainedHat]
			const probability = [50, 20]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 100,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		enemyMoveSpeed: 6000,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Stinging Wind',
				color: 'wind',
				damageType: 'wind', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				// penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 5000,
				damage: function() {return randomNumberRange(5, 6)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`whips its body toward you, sending a blade of wind at you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Grassling `, 'red', line1)
					customizeEachWord(`begins dancing back and forth..`, 'white', line1)
				}, 
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`whips its body at you and`, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			},
		},
		desc: function () {
			let description = `The Grasslet looks to be a low form of air elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'whips itself at you and hits!',
		missPhrase: 'whips itself at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return grasslet
}
function littleMudElemental(area) {
	let littleMudElemental = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/lesser mud elemental/lesser mud elemental.png",
		entersTheRoomPhrase: `gurgles in!`,
		advancePhrase: `bubbles toward you..`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Lessser Mud Ele',
		refName: 'littleMudElemental',
		keywords: ['little', 'mud', 'elemental', 'little mud elemental'],
		level: 5,
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 25,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(10, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [mudBall, muddyGloves]
			const probability = [100]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 50,
			rangedAbility: 0,
		},
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		enemyMoveSpeed: 5000,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(6, 9)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`With a gurgling lurch forward, the `, 'white', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`slaps you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`looks to be preparing for something...`, 'white', line1)
				}, 
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`lurches forward to slap you but `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
				damageType: 'physical',
				penetrationTypes: ['slashing'],
				combatType: 'melee',
				castTime: 3000,
			},
		},
		desc: function () {
			let description = `The Mud Elemental looks to be a low form of earth elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			fieldsTrainer.questSequence.third = true
			currentArea.npc.pop()
			enemyDeath(enemy)
		},
		strikePhrase: 'reaches out with a muddy appendage and slaps you!',
		missPhrase: 'tries to slap you, but misses!',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return littleMudElemental
}
function littleWaterElemental(area) {
	let littleWaterElemental = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/lesser water elemental/lesser water elemental.png",
		entersTheRoomPhrase: `gurgles in!`,
		advancePhrase: `bubbles toward you..`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Little Water Ele',
		refName: 'littleWaterElemental',
		keywords: ['little', 'water', 'elemental', 'little water elemental', 'water elemental', 'little water'],
		level: 5,
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 25,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(10, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [waterBerry, waterloggedBoots]
			const probability = [100, 100]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 100,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 5000,
		desc: function () {
			let description = `The little Water Elemental looks to be a low form of water elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			fieldsTrainer.questSequence.third = true
			currentArea.npc.pop()
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'splurts water at you!',
		rangedMissPhrase: 'splurts water at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return littleWaterElemental
}
function littleGrassElemental(area) {
	let littleGrassElemental = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/elementals/lesser grass elemental/lesser grass elemental.png",
		entersTheRoomPhrase: `gurgles in!`,
		advancePhrase: `bubbles toward you..`,
		deathPhrase: `splashes to bits`,
		entersExitsRoomPhrase: `bounces`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Little Grass Ele',
		refName: 'littleGrassElemental',
		keywords: ['little', 'grass', 'elemental', 'little grass elemental'],
		level: 5,
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 5,
		accuracy: () => 0,
		dodge: () => 0,
		baseExperience: 25,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(10, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [grassFruit, grassStainedHat]
			const probability = [100, 100]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 50,
			meleeAbility: 0,
			rangedAbility: 50,
		},
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		enemyMoveSpeed: 5000,
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Stinging Wind',
				color: 'light-green',
				damage: function() {return randomNumberRange(3, 5)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`whips its body toward you, sending a blade of wind at you!`, 'white', line1)
				}, 
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name}`, enemy.color, line1)
					customizeEachWord(`begins dancing back and forth..`, 'white', line1)
				}, 
				damageType: 'wind',
				penetrationTypes: ['piercing'],
				combatType: 'ranged',
				castTime: 5000,
			},
		},
		desc: function () {
			let description = `The Little Grass Elemental looks to be a low form of grass elemental`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			fieldsTrainer.questSequence.third = true
			currentArea.npc.pop()
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'whips itself at you and hits!',
		rangedMissPhrase: 'whips itself at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 2000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return littleGrassElemental
}
//GRAVEYARD
function skeleton(area) {
	let skeleton = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/undead/skeletons/skeleton/skeleton.png",
		entersTheRoomPhrase: `clacks in!`,
		advancePhrase: `creeps toward you..`,
		deathPhrase: `lets out a hoarse scream as the magic leaves its bones`,
		entersExitsRoomPhrase: `creeps`,
		hostile: true,
		combat: false,
		armor: 0,
		slashingArmor: 2,
		piercingArmor: 4,
		bluntArmor: 2,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Skeleton',
		refName: 'skeleton',
		keywords: ['skeleton'],
		level: randomNumberRange(5, 10),
		health: () => 60 + (this.level * this.con),
		maxHealth: () => 60 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 0,
		baseExperience: 40,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(20, 30)
		},
		itemDropsRoll: function () {
			const itemDrops =  [smallBone, largeBone, crackedBone, copperOre]
			const probability = [10, 5, 20, 2]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A skeleton animated by magic`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'swings its bony arm at you!',
		missPhrase: 'swings its bony arm at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 6000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return skeleton
}
function cultist(area) {
	let cultist = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/humanoids/cultist/cultist.png",
		entersTheRoomPhrase: `looms in!`,
		advancePhrase: `strides toward you..`,
		deathPhrase: `collapses into a pile of robes`,
		entersExitsRoomPhrase: `strides`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Cultist',
		refName: 'cultist',
		keywords: ['cultist'],
		level: randomNumberRange(5, 10),
		health: () => 60 + (this.level * this.con),
		maxHealth: () => 60 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 0,
		baseExperience: 40,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(20, 30)
		},
		itemDropsRoll: function () {
			const itemDrops =  [cultRobes, crucifix]
			const probability = [10, 20]
			console.log(isThereAUniqueItem)
			if (!isThereAUniqueItem('cultTexts')) {
				itemDrops.push(cultTexts)
				probability.push(100)
			}
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 3,
		piercingArmor: 3,
		bluntArmor: 3,
		itemDrops: [],

		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A hooded figure holding a sharp dagger at its side.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'slashes at you with a dagger!',
		missPhrase: 'slashes at you with a dagger and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 6000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return cultist
}
function giantRat(area) {
	let giantRat = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/animals/giant rat/giant rat.png",
		entersTheRoomPhrase: `squeeks in!`,
		advancePhrase: `scurries toward you..`,
		deathPhrase: `wimpers as it flops over dead`,
		entersExitsRoomPhrase: `scurries`,
		hostile: true,
		combat: false,
		armor: 0,
		damageTypes: ['slashing'],		
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		strikePhrase: 'bares its fangs at you and bites!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		slashingArmor: 2,
		piercingArmor: 2,
		bluntArmor: 2,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Giant Rat',
		refName: 'giantRat',
		keywords: ['giant', 'rat', 'giant rat'],
		level: randomNumberRange(5, 10),
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 0,
		baseExperience: 20,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			return randomNumberRange(5, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratTail, lightHide]
			const probability = [10, 2]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A big ole rat`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 6000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return giantRat
}
function graveWorm(area) {
	let graveWorm = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/insects/graveworm/graveworm.png",
		entersTheRoomPhrase: `squishes in!`,
		advancePhrase: `writhes toward you..`,
		deathPhrase: `turns into a pile of pink mess`,
		entersExitsRoomPhrase: `writhes`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Grave Worm',
		refName: 'graveWorm',
		keywords: ['grave', 'worm', 'grave worm'],
		level: randomNumberRange(5, 10),
		health: () => 25 + (this.level * this.con),
		maxHealth: () => 25 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 0,
		baseExperience: 20,
		experience: () => {
			let baseLevel = 5
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(5, 15)
		},
		itemDropsRoll: function () {
			const itemDrops =  [wormGuts]
			const probability = [20]
			enemyItemDrops(itemDrops, probability, this)
		},
		itemDrops: [],
		damageTypes: ['slashing'],		
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A thick, pink grave worm. Disgusting.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'bites at you!',
		missPhrase: 'bites at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return graveWorm
}
//THE SHALLOWS
function wildBoar(area) {
	let wildBoar = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/animals/wild boar/wild boar.png",
		entersTheRoomPhrase: `charges in!`,
		advancePhrase: `charges toward you..`,
		deathPhrase: `lets out a shrill squeal as it thuds to the ground`,
		entersExitsRoomPhrase: `charges`,
		hostile: true,
		combat: false,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Wild Boar',
		refName: 'wildBoar',
		keywords: ['wild', 'boar', 'wild boar'],
		level: randomNumberRange(10, 15),
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 5,
		baseExperience: 60,
		experience: () => {
			let baseLevel = 10
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(20, 40)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [rawBoarMeat, lightHide]
			const probability = [10, 5]
			enemyItemDrops(itemDrops, probability, this)
		},
		armor: 0,
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A large wild boar`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'runs at you and gores you with its tusks!',
		missPhrase: 'runs at you to gore you but misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return wildBoar
}
function stag(area) {
	let stag = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/animals/stag/stag.png",
		entersTheRoomPhrase: `trots in!`,
		advancePhrase: `charges toward you..`,
		deathPhrase: `collapses to the ground`,
		entersExitsRoomPhrase: `trots`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Stag',
		refName: 'stag',
		keywords: ['stag'],
		level: randomNumberRange(10, 15),
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 5,
		dodge: () => 5,
		baseExperience: 60,
		experience: () => {
			let baseLevel = 10
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			let goldAmount = randomNumberRange(20, 40)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [lightHide, stagAntlers]
			const probability = [2, 10]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['blunt'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 3,
		bluntArmor: 10,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A large wild stag`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'rears back and clops you with its hooves!',
		missPhrase: 'stamps at you but misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return stag
}
function impling(area) {
	let impling = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/imps/impling/impling.png",
		entersTheRoomPhrase: `troddles in!`,
		advancePhrase: `hops toward you..`,
		deathPhrase: `curses you as its scream turns to silence`,
		entersExitsRoomPhrase: `troddles`,
		hostile: true,
		combat: false,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Impling',
		refName: 'impling',
		keywords: ['impling'],
		level: randomNumberRange(10, 15),
		health: () => 20 + (this.level * this.con),
		maxHealth: () => 20 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 10,
		dodge: () => 5,
		dodge: () => 5,
		baseExperience: 70,
		experience: () => {
			let baseLevel = 10
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(35, 65)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [clothCap, silkFootwraps]
			const probability = [5, 1]
			enemyItemDrops(itemDrops, probability, this)
		},
		armor: 0,
		damageTypes: [], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 100,
		},
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(10, 20)},
				windUpPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Impling `, 'red', line1)
					customizeEachWord(`begins chanting strange words of magic..`, 'white', line1)
				},
				abilityPhrase: function() {
					let line1 = lineFunc()
					customizeEachWord(`With outstretched fingers, the `, 'white', line1)
					customizeEachWord(`Impling `, 'red', line1)
					customizeEachWord(`shoots out a small streak of `, 'white', line1)
					customizeEachWord(`fire `, 'fire', line1)
					customizeEachWord(`at you!`, 'white', line1)

				},
				name: 'Fireball',
				damageType: 'fire', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				color: 'fire',
				penetrationTypes: [],
				combatType: 'ranged',
				castTime: 3000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A small Impling`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return impling
}
function bandit(area) {
	let bandit = {
		get color() {
			return enemyLevelColor(this)
		},
		entersTheRoomPhrase: `sneaks in!`,
		advancePhrase: `advances toward you..`,
		deathPhrase: `falls to the ground dead`,
		entersExitsRoomPhrase: `sneaks`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Bandit',
		refName: 'bandit',
		keywords: ['bandit'],
		level: randomNumberRange(10, 15),
		health: () => 110 + (this.level * this.con),
		maxHealth: () => 110 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 10,
		dodge: () => 20,
		dodge: () => 5,
		baseExperience: 70,
		experience: () => {
			let baseLevel = 10
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			return randomNumberRange(50, 100)
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A cloaked, hooded Bandit.`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'slashes his daggers at you!',
		missPhrase: 'slashes his daggers at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 1000, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return bandit
}
//KOBOLD CAVES
function koboldChild(area) {
	let koboldChild = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/kobolds/kobold child/kobold child.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a high pitched cry as it dies!`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Child',
		refName: 'koboldChild',
		keywords: ['kobold', 'child', 'kobold child'],
		level: () => {
			let level = randomNumberRange(15, 20)
			return level
		},
		health: () => 0 + (this.level * this.con),
		maxHealth: () => 0 + (this.level * this.con),
		con: () => 10,
		accuracy: () => 5,
		dodge: () => 0,
		baseExperience: 100,
		experience: () => {
			let baseLevel = 15
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(20, 50)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [littleBoneToy, dirtyRags, halfEatenFish]
			const probability = [10, 10, 10]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A skeleton animated by magic`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'swings at you with a stick!',
		missPhrase: 'swings a stick at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldChild
}
function koboldScoundrel(area) {
	let koboldScoundrel = {
		level: randomNumberRange(15, 20),
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/kobolds/kobold scoundrel/kobold scoundrel.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a soft howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,

		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Scoundrel',
		refName: 'koboldScoundrel',
		keywords: ['kobold', 'scoundrel', 'kobold scoundrel'],

		health: () => 75 + (this.level * this.con),
		maxHealth: () => 75 + (this.level * this.con),
		con: () => 15,
		accuracy: () => 5,
		dodge: () => 15,
		baseExperience: 115,
		experience: () => {
			let baseLevel = 15
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [leatherGrips, dirtyRags, halfEatenFish, copperOre]
			const probability = [5, 10, 10, 2]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
		let enemyHitChance = calculateEnemyHitChance(enemy)
		let hitRoll = Math.floor(Math.random() * 100) + 1
		return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A skeleton animated by magic`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'jabs at you with a broken spear!',
		missPhrase: 'swings its bony arm at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldScoundrel
}
function koboldSpearthrower(area) {
	let koboldSpearthrower = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/kobolds/kobold spearthrower/kobold spearthrower.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a whimpy howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Spearthrower',
		refName: 'koboldSpearthrower',
		keywords: ['kobold', 'thrower', 'kobold thrower'],
		health: () => 75 + (this.level * this.con),
		maxHealth: () => 75 + (this.level * this.con),
		con: () => 15,
		accuracy: () => 5,
		dodge: () => 15,
		baseExperience: 115,
		experience: () => {
			let baseLevel = 15
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		level: randomNumberRange(15, 20),
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [boneTippedSpear, dirtyRags, halfEatenFish, copperOre]
			const probability = [5, 10, 10, 2]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 50,
		},
		slashingArmor: 5,
		piercingArmor: 5,
		bluntArmor: 5,
		itemDrops: [],
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Aimed Spear',
				color: 'red',
				damage: function() {return randomNumberRange(20, 30)},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`postures to take aim at you!`, 'white', line1)
				}, 
				abilityPhrase: function(enemy) {
					console.log(enemy)
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`launches a spear at you!`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`launches a spear at you and `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
				damageType: 'physical',
				penetrationTypes: ['piercing'],
				combatType: 'ranged',
				castTime: 4000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A Kobold Spearthrower`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: 'jabs is spear at you!',
		missPhrase: 'lunges forward with its spear at you and misses!',
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldSpearthrower
}
function koboldArcher(area) {
	let koboldArcher = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/kobolds/kobold archer/kobold archer.png",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a whimpy howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 0,
			ranged: 100,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Archer',
		refName: 'koboldArcher',
		keywords: ['kobold', 'archer', 'kobold archer'],
		health: () => 50 + (this.level * this.con),
		maxHealth: () => 50 + (this.level * this.con),
		con: () => 15,
		accuracy: () => 5,
		dodge: () => 15,
		baseExperience: 115,
		experience: () => {
			let baseLevel = 15
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [crudelyCarvedBow, dirtyRags, halfEatenFish, koboldToothNecklace, copperOre]
			const probability = [5, 10, 10, 2, 2]
			enemyItemDrops(itemDrops, probability, this)
		},
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		level: randomNumberRange(15, 20),
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `A Kobold Archer`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'fires an arrow at you!',
		rangedMissPhrase: 'fires an arrow at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldArcher
}
function koboldDigger(area) {
	let koboldDigger = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/skeleton1.jpg",
		entersTheRoomPhrase: `scampers in!`,
		advancePhrase: `runs up to you..`,
		deathPhrase: `lets out a whimpy howl as it dies`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Digger',
		refName: 'koboldDigger',
		keywords: ['kobold', 'digger', 'kobold digger'],
		level: randomNumberRange(15, 20),
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 15,
		accuracy: () => 5,
		dodge: () => 15,
		baseExperience: 115,
		experience: () => {
			let baseLevel = 15
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(35, 80)
			return goldAmount
		},
		itemDropsRoll: function () {
			const itemDrops =  [dirtyRags, halfEatenFish, copperOre, pickaxe]
			const probability = [10, 10, 2, 10]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 10,
		piercingArmor: 10,
		bluntArmor: 10,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Aimed Spear',
				color: 'green',
				damage: function() {return randomNumberRange(9, 12)},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Archer `, 'red', line1)
					customizeEachWord(`draws back its bow taking aim at you!`, 'white', line1)
				}, 
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`The `, 'white', line1)
					customizeEachWord(`Kobold Archer `, 'red', line1)
					customizeEachWord(`lets fly an arrow at you!`, 'white', line1)
				}, 
				damageType: 'physical',
				penetrationTypes: ['slashing', 'piercing'],
				combatType: 'ranged',
				castTime: 4000,
			},
		},
		meleeAbilityCalculation: {
		},
		desc: function () {
			let description = `A Kobold Digger`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		strikePhrase: '',
		missPhrase: '',
		rangedAttackPhrase: 'fires an arrow at you!',
		rangedMissPhrase: 'fires an arrow at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldDigger
}

function koboldChief(area) {
	let koboldChief = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/kobolds/kobold chief/kobold chief.png",
		entersTheRoomPhrase: `jumps in!`,
		advancePhrase: `charges toward you..`,
		deathPhrase: `lets out a gurgling murmur as its eyes stare blankly upward.`,
		entersExitsRoomPhrase: `charges`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold Chief',
		refName: 'koboldChief',
		keywords: ['kobold', 'chief', 'kobold chief'],
		level: 20,
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 20,
		accuracy: () => 10,
		dodge: () => 15,
		baseExperience: 200,
		experience: () => {
			let baseLevel = 20
			return enemyKillExperience(this, baseLevel)
		},	
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(100, 200)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  [ratHideTunic, ratHidePants, ratSkullHelm, copperOre, halfEatenFish, lightHide]
			const probability = [50, 50, 50, 100, 100, 100]
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 75,
			ranged: 0,
			meleeAbility: 25,
			rangedAbility: 0,
		},
		slashingArmor: 20,
		piercingArmor: 20,
		bluntArmor: 20,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		rangedAbilityCalculation: {
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				damage: function() {return randomNumberRange(30, 30)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`leaps and slashes down at you with its spear!`, 'white', line1)
				},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`lets out a furious cry as it prepares to attack!`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`leaps and slashes at you with its spear but `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
				name: 'Leap Strike',
				color: 'green',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRERESIST, ICERESIST, AIRRESIST, ETC
				penetrationTypes: ['slashing'],
				combatType: 'melee',
				castTime: 3000,
			},
		},
		desc: function () {
			let description = `A Kobold Chief`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`swings its 10 inch tinky at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
		},
		strikePhrase: 'slashes you with its spear!',
		missPhrase: 'swings its spear at your and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 3000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return koboldChief
}
//GNOLL PLAINS

//gnoll brute
//gnoll magi
//gnoll skirmisher
//gnoll pack leader
function gnollSkirmisher(area) {
	let gnollSkirmisher = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/gnolls/gnoll skirmisher/gnoll skirmisher.png",
		entersTheRoomPhrase: `howls in!`,
		advancePhrase: `runs toward you..`,
		deathPhrase: `lets out a piercing squeel.`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Gnoll Skirmisher',
		refName: 'gnollSkirmisher',
		keywords: ['gnoll', 'skirmisher', 'gnoll skirmisher'],
		level: randomNumberRange(20, 25),
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 20,
		accuracy: () => 10,
		dodge: () => 10,
		baseExperience: 200,
		experience: () => {return enemyKillExperience(this)},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(50, 120)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['slashing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 20,
		piercingArmor: 10,
		bluntArmor: 30,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},

			hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `A Gnoll Skirmisher`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`swings its 10 inch tinky at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
		},
		strikePhrase: 'slashes you with its spear!',
		missPhrase: 'swings its spear at your and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 3000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return gnollSkirmisher
}
function gnollBrawler(area) {
	let gnollBrawler = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/gnolls/gnoll brawler/gnoll brawler.png",
		entersTheRoomPhrase: `howls in!`,
		advancePhrase: `runs toward you..`,
		deathPhrase: `lets out a piercing squeel.`,
		entersExitsRoomPhrase: `scampers`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Gnoll Brawler',
		refName: 'gnollBrawler',
		keywords: ['gnoll', 'brawler', 'gnoll brawler'],
		level: randomNumberRange(20, 25),
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 20,
		accuracy: () => 10,
		dodge: () => 10,
		baseExperience: 200,
		experience: () => {return enemyKillExperience(this)},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = this.attackPower * 0.5
			let topDamage =  this.attackPower * 1.5
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(50, 120)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['blunt'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 50,
			rangedAbility: 0,
		},
		slashingArmor: 20,
		piercingArmor: 10,
		bluntArmor: 30,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `A Gnoll Brawler`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`throws its balled fist at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
		},
		strikePhrase: 'smashes you with its fist!',
		missPhrase: 'swings its fist at you and misses!',
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Paw Punch',
				color: 'brown',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRE, WATER, ICE LIGHTNING, ETC
				penetrationTypes: ['blunt'],
				combatType: 'melee',
				castTime: 2000,
				damage: function() {return randomNumberRange(25, 50)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`leaps at you and smashes you with both its fists!`, 'white', line1)
				},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`clenches its fists as it lets out a furious howl!`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`leaps at you, swinging its fists wildly at you but `, 'white', line1)
					customizeEachWord(`misses`, 'red', line1)
					customizeEachWord(`!`, 'white', line1)
				},
			},
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 3000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return gnollBrawler
}
function gnollBrute(area) {
	let gnollBrute = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/gnolls/gnoll brute/gnoll brute.png",
		entersTheRoomPhrase: `stomps in!`,
		advancePhrase: `lumbers toward you..`,
		deathPhrase: `lets out a rumbling growl.`,
		entersExitsRoomPhrase: `stomps`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Gnoll Brute',
		refName: 'gnollBrute',
		keywords: ['gnoll', 'brute', 'gnoll brute'],
		level: randomNumberRange(20, 25),
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 30,
		accuracy: () => 10,
		dodge: () => 10,
		baseExperience: 300,
		experience: () => {return enemyKillExperience(this)},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = Math.ceil(this.attackPower * 1)
			let topDamage =  Math.ceil(this.attackPower * 2.5)
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(50, 120)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['blunt'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		slashingArmor: 30,
		piercingArmor: 10,
		bluntArmor: 30,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		desc: function () {
			let description = `A Gnoll Brute`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`slams its club into you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
		},
		strikePhrase: 'smashes you with its club!',
		missPhrase: 'swings its club at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 4000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return gnollBrute
}
function gnollPackLeader(area) {
	let gnollPackLeader = {
		get color() {
			return enemyLevelColor(this)
		},
		picture: "images/monsters/gnolls/gnoll pack leader/gnoll pack leader.png",
		entersTheRoomPhrase: `stomps in!`,
		advancePhrase: `lumbers toward you..`,
		deathPhrase: `lets out a rumbling growl.`,
		entersExitsRoomPhrase: `stomps`,
		hostile: true,
		combat: false,
		armor: 0,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Gnoll Pack Leader',
		refName: 'gnollPackLeader',
		keywords: ['gnoll', 'pack leader', 'leader', 'gnoll pack leader'],
		level: 25,
		health: () => 100 + (this.level * this.con),
		maxHealth: () => 100 + (this.level * this.con),
		con: () => 40,
		accuracy: () => 15,
		dodge: () => 15,
		baseExperience: 600,
		experience: () => {return enemyKillExperience(this)},
		attackPower: () => this.level,
		damageCalculation: function() {
			let botDamage = Math.ceil(this.attackPower * 1)
			let topDamage =  Math.ceil(this.attackPower * 2.5)
			return randomNumberRange(botDamage, topDamage)
		},
		itemDrops: [],
		gold: function () {
			let goldAmount = randomNumberRange(200, 350)
			return goldAmount		
		},
		itemDropsRoll: function () {
			const itemDrops =  []
			const probability = []
			enemyItemDrops(itemDrops, probability, this)
		},
		damageTypes: ['piercing'], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 50,
			ranged: 0,
			meleeAbility: 50,
			rangedAbility: 0,
		},
		slashingArmor: 35,
		piercingArmor: 35,
		bluntArmor: 35,
		x: function () {return currentArea.x},
		y: function () {return currentArea.y},
		z: function () {return currentArea.z},
		isAlive: function() {
			return this.health > 0
		},
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		hitChance: function(enemy) {
			let enemyHitChance = calculateEnemyHitChance(enemy)
			let hitRoll = Math.floor(Math.random() * 100) + 1
			return enemyHitChance >= hitRoll
		},
		meleeAbilityCalculation: {
			abilityUseChance: {
				ability1: 100,
			},
			ability1: {
				name: 'Bloody Bite',
				color: 'red',
				damageType: 'physical', //IF NOT PHYSICAL, THIS HAS TO BE A DAMAGE TYPE THAT EXISTS ON THE PLAYER LIKE FIRE, WATER, ICE LIGHTNING, ETC
				penetrationTypes: ['piercing'],
				combatType: 'melee',
				castTime: 2000,
				damage: function() {return randomNumberRange(40, 60)},
				abilityPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`leaps onto you and sinks its teeth into you!`, 'white', line1)
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
				},
				windUpPhrase: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`crouches down preparing to leap!`, 'white', line1)
				},
				flavorTextMiss: function(enemy) {
					let line1 = lineFunc()
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`leaps at you in an attempt to bite you but `, 'white', line1)
					customizeEachWord(`misses!`, 'red', line1)
				},
			}
		},
		desc: function () {
			let description = `A Gnoll Pack Leader`
			enemyDescription(this, description)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		swing: function(enemy, damage, damageType, damageBlocked) {
			let line1 = lineFunc()
			let line2 = lineFunc()
			blankSpace()
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`slashes its spear at you and hits!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${damage} `, 'light-blue', line2)
			customizeEachWord(`${damageType} `, damageType, line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${damageBlocked}`, 'light-blue', line2)
			customizeEachWord(`)`, 'white', line2)
			blankSpace()
		},
		strikePhrase: 'smashes you with its club!',
		missPhrase: 'swings its club at you and misses!',
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: async function (enemy) {
			if (!player.isAlive) {
				enemyMovesRandomly(enemy);
			} else if (enemyIsOneRoomFromPlayer(enemy)) {
				enemyMoveOneRoom(enemy);
			} else {
				switch (enemy.moveSwitch) {
					case 0:
						enemyMoveOneRoom(enemy);
						break;
					case 1:
						enemyMovesRandomly(enemy);
						break;
					case 2:
						// Additional logic for moveSwitch 2 if needed
						break;
					default:
						// Handle unexpected moveSwitch values
						break;
				}
			}
		},
		moveSwitch: 0,
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 100, //probably delete this I think it was used in an old function
		enemyMoveSpeed: 3000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			monsterBehavior(this)
		},
	}
	return gnollPackLeader
}



function enemyIsOneRoomFromPlayer(enemy) {
	let playerCoords = {
    	x: player.x,
    	y: player.y,
    	z: player.z
    }

    let enemyCoords = {
        x: enemy.x,
        y: enemy.y,
        z: enemy.z
    };
    // Calculate Manhattan distance
    let distance = Math.abs(enemyCoords.x - playerCoords.x) + Math.abs(enemyCoords.y - playerCoords.y);
    // Check if the distance is exactly 1
    return distance === 1;
}

function strikePhraseFunc(enemyName, enemyColor, enemyDamage, damageType, armorBlockAmount, phrase) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	blankSpace()
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${phrase}`, 'white', line1)
	customizeEachWord(`You are hit for `, 'yellow', line2)
	customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
	if (damageType != undefined) {
		customizeEachWord(`${damageType} `, damageType, line2)
	}
	customizeEachWord(`damage. `, 'yellow', line2)
	customizeEachWord(`(Your armor blocks `, 'white', line2)
	customizeEachWord(`${armorBlockAmount}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
	updateScroll()
}
function strikeMissPhraseFunc(enemyName, enemyColor, enemyMissPhrase) {
	let line1 = document.createElement('div')
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${enemyMissPhrase}`, 'white', line1)
	updateScroll()
}
function enemyAbilityMissPhraseFunc(enemy) {
	let line1 = document.createElement('div')
	customizeEachWord(`${enemy.name} `, enemy.color, line1)
	customizeEachWord(`${enemyMissPhrase}`, 'white', line1)
	updateScroll()
}
function rangedAttackPhraseFunc(enemyName, enemyColor, enemyDamage, damageType, armorBlockAmount, phrase) {
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	blankSpace()
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${phrase}`, 'white', line1)
	customizeEachWord(`You are hit for `, 'yellow', line2)
	customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
	if (damageType != undefined) {
		customizeEachWord(`${damageType} `, damageType, line2)
	}
	customizeEachWord(`damage. `, 'yellow', line2)
	customizeEachWord(`(your armor blocks `, 'white', line2)
	customizeEachWord(`${armorBlockAmount}`, 'light-blue', line2)
	customizeEachWord(`)`, 'white', line2)
	blankSpace()
	updateScroll()
}
function rangedMissPhraseFunc(enemyName, enemyColor, enemyMissPhrase) {
	let line1 = document.createElement('div')
	customizeEachWord(`${enemyName} `, enemyColor, line1)
	customizeEachWord(`${enemyMissPhrase}`, 'white', line1)
	updateScroll()
}
function rangedAbilityPhraseFunc(ability, enemy) {
	console.log(ability)
	let line1 = document.createElement('div')
	blankSpace()
	ability.abilityPhrase(enemy)
	customizeEachWord(`${ability.name} `, ability.color, line1)
	customizeEachWord(`hits you for `, 'yellow', line1)
	customizeEachWord(`${ability.totalDamage} `, 'light-blue', line1)
	if (ability.penetrationType) {
		customizeEachWord(`${ability.penetrationType} `, `${ability.penetrationType}`, line1)
	}
	if (ability.damageType != 'physical') {
		customizeEachWord(`${ability.damageType} `, ability.damageType, line1)
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(You resist `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
	} else {
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(Your armor blocks `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
		}
		blankSpace()
		updateScroll()
}
function meleeAbilityPhraseFunc(ability, enemy) {
	//abilityObject.totalDamage, abilityObject.damageType, abilityObject.mitigationAmount
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	blankSpace()
	ability.abilityPhrase(enemy)
	customizeEachWord(`${ability.name} `, ability.color, line1)
	customizeEachWord(`hits you for `, 'yellow', line1)
	customizeEachWord(`${ability.totalDamage} `, 'light-blue', line1)
	if (ability.penetrationType) {
		customizeEachWord(`${ability.penetrationType} `, `${ability.penetrationType}`, line1)
	}
	if (ability.damageType != 'physical') {
		customizeEachWord(`${ability.damageType} `, ability.damageType, line1)
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(You resist `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
	} else {
		customizeEachWord(`damage. `, 'yellow', line1)
		customizeEachWord(`(Your armor blocks `, 'white', line1)
		customizeEachWord(`${ability.mitigationAmount}`, 'light-blue', line1)
		customizeEachWord(`)`, 'white', line1)
		}
		blankSpace()
		updateScroll()
}

function playerStealthCheck(enemy) {
	if (coordinatesMatch(player, enemy) && player.isStealthed) {
		let line1 = lineFunc()
		if (player.level + player.stealth.level < enemy.level) {
			customizeEachWord(`You have been discovered!`, 'white', line1)
			player.isStealthed = false
			return true
		} else if (player.level + player.stealth.level >= enemy.level) {
				customizeEachWord(`The ${enemy.name} is completely unaware of your presence.`, 'white', line1)
				return false
		}
	}

}
function playerSpellsList() {
	blankSpace()
	for (let spell in player) {
		if (player[spell].conjureTime) {
			if (player[spell].level > 0) {
				let line = lineFunc()
				customizeEachWord(`${player[spell].name}`, player[spell].color, line)
				customizeEachWord(`: Level `, 'white', line)
				customizeEachWord(`${player[spell].level}`, 'light-blue', line)
			}
		}
	}
	blankSpace()
}
function playerAbilitiesList() {
	blankSpace()
	for (let ability in player) {
		if (player[ability].resourceName) {
			if (player[ability].level > 0) {
				let line = lineFunc()
				customizeEachWord(`${player[ability].name}`, player[ability].color, line)
				customizeEachWord(`: Level `, 'white', line)
				customizeEachWord(`${player[ability].level}`, 'light-blue', line)
			}
		}
	}
	blankSpace()
}

function playerSkillsList() {
	blankSpace()
	for (let skill in player) {
		if (player[skill].type == 'skill') {
			if (player[skill].level > 0) {
				let line = lineFunc()
				customizeEachWord(`${player[skill].name}`, player[skill].color, line)
				customizeEachWord(`: Level `, 'white', line)
				customizeEachWord(`${player[skill].level}`, 'light-blue', line)
			}
		}
	}
	blankSpace()
}


// async function monsterBehavior(enemy) {
// 	while (enemy.isAlive() && !enemy.isStunned) {
// 		//sets attack timer interval, can be moved to enemy object later
// 		enemy.attackTimer = enemy.capturedAttackTimer ? enemy.capturedAttackTimer : 3000
// 		clearInterval(enemy.attackTimerInterval)
// 		enemy.attackTimerInterval = setInterval(() => {
// 			enemy.attackTimer -= 100
// 			if (enemy.attackTimer <= 0) {
// 				enemy.attackTimer = 3000
// 			}
// 		}, 100)
// 		enemy.isBehaviorRunning = true
// 		//
// 		if (enemy.wasStunned) {
// 			quickMessage(`Attack should happen in ${enemy.capturedAttackTimer}`)
// 			await waitForNextAction(enemy.capturedAttackTimer)
// 			enemy.wasStunned = false
// 		} else {
// 			await waitForNextAction(enemy.enemyMoveSpeed)

// 		}
// 		if (!enemy.isAlive()) {return}
// 		playerStealthCheck(enemy)
// 		if (!player.isStealthed) {
//     		let attackType = determineEnemyAttackType(enemy);
//         	console.log(attackType)
//         	let currentAttackType = attackType;
//         	let shouldEngage = shouldEngagePlayer(enemy, currentAttackType);
//         	if (!player.isAlive) {
// 	            console.log('enemy should be moving')
//             	enemy.enemyMove(enemy);
//         	} else if (shouldEngage && enemy.isAlive() && !enemy.isStunned) {
// 	            await engagePlayer(enemy)
// 				await waitForNextAction(enemy.enemyMoveSpeed)
//             	if (currentAttackType == 'melee'&& enemy.isAlive() && !enemy.isStunned) {
// 					await enemySwing(enemy)
// 				} 
//             	if (currentAttackType == 'meleeAbility'&& enemy.isAlive()) {
// 					await enemyMeleeAbility(enemy)
// 				} 
//         	} else if (!coordinatesMatch(enemy, player) && !enemy.isStunned) {
// 	            enemy.enemyMove(enemy);
//         	}  else if (currentAttackType == 'melee' && enemy.isAlive() && !enemy.isStunned) {
// 				await enemySwing(enemy)
// 			} else if (currentAttackType == 'ranged' && enemy.isAlive() && !enemy.isStunned) {
// 	            await enemyRangedAttack(enemy);
//         	} else if (currentAttackType == 'rangedAbility' && enemy.isAlive() && !enemy.isStunned) {
// 	            await enemyRangedAbility(enemy);
//         	} else if (currentAttackType == 'meleeAbility' && enemy.isAlive() && !enemy.isStunned) {
// 	            await enemyMeleeAbility(enemy);
//         	} else {
// 	            enemy.enemyMove(enemy);
//         	}
// 			updateMonsterBox()
//     	} else {
// 			enemy.enemyMove(enemy)
// 			updateMonsterBox()
// 		}
// 	}
// 	enemy.isBehaviorRunning = false
// }

async function monsterBehavior(enemy) {
	while (enemy.isAlive() && !enemy.isStunned) {
	// let enemyAttackTimer = enemy.capturedAttackTimer ? enemy.capturedAttackTimer : enemy.enemyMoveSpeed
		enemy.attackTimer = enemy.capturedAttackTimer ? enemy.capturedAttackTimer : enemy.enemyMoveSpeed;
		clearInterval(enemy.attackTimerInterval);
		enemy.attackTimerInterval = setInterval(() => {
		enemy.attackTimer -= 100
		// console.log(enemy.attackTimer)
		if (enemy.attackTimer <= 0) {
			enemy.attackTimer = enemy.enemyMoveSpeed;
			enemy.capturedAttackTimer = undefined
		}
	}, 100);

	enemy.isBehaviorRunning = true;
	let timerToUse
	if (enemy.capturedAttackTimer) {
		timerToUse = enemy.capturedAttackTimer
		// quickMessage(`${timerToUse} timer set (CAPTURED ATTACK TIMER)`)
	} else {
		timerToUse = enemy.enemyMoveSpeed
		// quickMessage(`${timerToUse} timer set (RESETS TO DEFAULT)`)
	  }

	  if (enemy.capturedAttackTimer) {
		// quickMessage(`Attack should happen in ${enemy.capturedAttackTimer}`);
		await waitForNextAction(timerToUse);
	  } else {
		// quickMessage(`timer resset to ddefault`)
		await waitForNextAction(timerToUse);
	  }
  
	  if (!enemy.isAlive()) {
		return;
	  }
  
	  playerStealthCheck(enemy)
	  if (!player.isStealthed && !enemy.isStunned) {
		  let attackType = determineEnemyAttackType(enemy);
		  console.log(attackType)
		  let currentAttackType = attackType;
		  let shouldEngage = shouldEngagePlayer(enemy, currentAttackType);
		  let doesPlayerSideStep = player.sideStep.calculate(enemy)
		  if (!player.isAlive) {
			  enemy.enemyMove(enemy);
			  enemy.capturedAttackTimer = undefined
		  } else if (shouldEngage && enemy.isAlive() && !enemy.isStunned) {
			if (doesPlayerSideStep) {
				player.sideStep.flavorText(enemy)
				player.quickshot.strike(enemy)
			} else {
			await engagePlayer(enemy)
			await waitForNextAction(timerToUse)
			if (currentAttackType == 'melee' && enemy.isAlive() && !enemy.isStunned && enemy.combat) {
				await enemySwing(enemy)
					enemy.capturedAttackTimer = undefined
				} else if (currentAttackType == 'meleeAbility'&& enemy.isAlive() && enemy.combat) {
					await enemyMeleeAbility(enemy)
					enemy.capturedAttackTimer = undefined
				} else if (!enemy.combat && coordinatesMatch(enemy, player) && shouldEngage) {
					await engagePlayer(enemy)
				} else {
					enemy.enemyMove(enemy)
				}
			}

		  } else if (!coordinatesMatch(enemy, player) && !enemy.isStunned) {
			  enemy.enemyMove(enemy);
			  enemy.capturedAttackTimer = undefined
		  }  else if (currentAttackType == 'melee' && enemy.isAlive() && !enemy.isStunned) {
			  await enemySwing(enemy)
		  } else if (currentAttackType == 'ranged' && enemy.isAlive() && !enemy.isStunned) {
			  await enemyRangedAttack(enemy);
		  } else if (currentAttackType == 'rangedAbility' && enemy.isAlive() && !enemy.isStunned) {
			  await enemyRangedAbility(enemy);
		  } else if (currentAttackType == 'meleeAbility' && enemy.isAlive() && !enemy.isStunned) {
			  await enemyMeleeAbility(enemy);
		  } else {
			  enemy.enemyMove(enemy);
		  }
		  updateMonsterBox()
	  } else {
		  enemy.enemyMove(enemy)
		  updateMonsterBox()
	  }  
	  enemy.isBehaviorRunning = false;
	}
  }
  

async function shouldEngagePlayer(enemy, attackType) {
	if (coordinatesMatch(enemy, player) && player.isAlive && !enemy.combat && (attackType == 'melee' || attackType == 'meleeAbility') && !player.isStealthed) {return true}
}

async function shouldEnemyMove(enemy) {
	if (!coordinatesMatch(player, enemy)) {return true}
	if (coordinatesMatch(player, enemy) && !player.isAlive) {return true}
}

async function engagePlayer(enemy) {
	if (!player.isAlive) {return}
	let line1 = lineFunc()
	customizeEachWord(`The `, 'white', line1)
	customizeEachWord(`${enemy.name} `, enemy.color, line1)
	customizeEachWord(`${enemy.advancePhrase} `, 'white', line1)
	player.combat = true
	enemy.combat = true
}

function calculateEnemyHitChance(enemy) {
	let playerValues = player.dodge
	let enemyValues = enemy.level + enemy.accuracy + 75
	console.log(enemyValues - playerValues, ' ENEMY HIT CHANCE')
	return enemyValues - playerValues
}

function determineEnemyAttackType(enemy) {
	let roll = randomNumberRange(1, 100)
	let cumulativeProbability = 0
	let length = 0
	for (const [type, probability] of Object.entries(enemy.attackTypes)) {
		cumulativeProbability += probability
		length++
		if (roll <= cumulativeProbability) {
			return type
		} 
	}
	let index = randomNumberRange(0, length - 1)
	return Object.keys(enemy.attackTypes)[index]
	// return Object.keys(enemy.attackTypes).shift()
}
function determineEnemyAbility(abilitiesToChooseFrom) {
	let roll = randomNumberRange(1, 100)
	let cumulativeProbability = 0 
	for (const [ability, probability] of Object.entries(abilitiesToChooseFrom.abilityUseChance)) {
		cumulativeProbability += probability
		if (roll <= cumulativeProbability) {
			return ability
		} 
	}
	return Object.keys(abilitiesToChooseFrom.abilityUseChance).pop()
}

async function enemySwing(enemy) { //CALCULATE ENEMY ATTACK FUNCTION IS USED
	//if swing misses, -> nothing else should calculate
	//did swing land?
	//did player block?
	//is damage 0?
	if (!coordinatesMatch(enemy, player) || !player.isAlive) {
		enemy.enemyMove(enemy)
		return
	}
	let swingObject = calculateEnemyAttack(enemy)
	if (!swingObject.enemyHits) {
		//this is a miss
		//no counter or pre-emptive strike should happen
		strikeMissPhraseFunc(enemy.name, enemy.color, enemy.missPhrase)
		if (player.dodgeStrike.level > 0) {player.dodgeStrike.strike(enemy)}
	} else if (swingObject.wasBlocked == false) {
		//this is a hit and the player did not shield block
		//player can counter or pre-emptive strike here
		if (player.preemptiveStrike.level > 0) {player.preemptiveStrike.strike(enemy)}
		//if the enemy is still alive after preemptive strike, it will now hit the player
		if (enemy.health > 0) {
			// enemy.strikePhrase(swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount)
			console.log(swingObject)
			console.log(enemy)
			//Not sure which swing function/method to use. They both work. 
			if (enemy.swing) {
				enemy.swing(enemy, swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount)
			} else {
				strikePhraseFunc(enemy.name, enemy.color, swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount, enemy.strikePhrase)
			}
			applyDamageToPlayer(swingObject.totalDamage)
			if (!player.isAlive) {return}
			if (player.counterAttack.level > 0) {player.counterAttack.strike(enemy)}
			if (player.hardenedSkin.level > 0) {player.hardenedSkin.activate(enemy)}
			if (player.battleRage.level > 0) {player.battleRage.activate(enemy)}
		} else {
			return
		}
	} else if (swingObject.wasBlocked) {
		//this is a hit and the player blocked with shield
		//player cannot counter or pre-emptive strike if attack was blocked
		quickMessage(`You blocked the attack! Figure out block formula and complete the rest of this function`)
	}
	// if (counterAttackRoll()) {attack(enemy)}
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}

function enemyMissProcs() {}
function enemyHitsProcs() {}

async function enemyRangedAttack(enemy) { //CALCULATE ENEMY ATTACK FUNCTION IS USED
	let swingObject = calculateEnemyAttack(enemy)
	if (!swingObject.enemyHits) {
		//this is a miss
		//no counter or pre-emptive strike should happen
		rangedMissPhraseFunc(enemy.name, enemy.color, enemy.rangedMissPhrase)
	} else if (swingObject.wasBlocked == false) {
		if (enemy.health > 0) {
			rangedAttackPhraseFunc(enemy.name, enemy.color, swingObject.totalDamage, swingObject.damageType, swingObject.mitigationAmount, enemy.rangedAttackPhrase)
			applyDamageToPlayer(swingObject.totalDamage)
		} else {
			return
		}
	} else if (swingObject.wasBlocked) {
		//this is a hit and the player blocked with shield
		//player cannot counter or pre-emptive strike if attack was blocked
		quickMessage(`You blocked the attack! Figure out block formula and complete the rest of this function`)
	}
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}

async function enemyRangedAbility(enemy) { //CALCULATE
	let abilityObject = calculateEnemyRangedAbility(enemy)
	if (!player.isAlive || !coordinatesMatch(player, enemy)) {
		enemy.enemyMove(enemy)
		return
	}
	abilityObject.windUpPhrase(enemy)
	await waitForNextAction(abilityObject.castTime)
	if (!player.isAlive || !coordinatesMatch(player, enemy)) {
		enemy.enemyMove(enemy)
		return
	}
	console.log(abilityObject)
	if (abilityObject.enemyHits == false) {
		abilityObject.flavorTextMiss(enemy)
	} else if (enemy.health > 0) {
		rangedAbilityPhraseFunc(abilityObject, enemy)
		applyDamageToPlayer(abilityObject.totalDamage)
	}
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}

async function enemyMeleeAbility(enemy) { //CALCULATE PHYSICAL ABILITY
	let abilityObject = calculateEnemyMeleeAbility(enemy)
	if (!player.isAlive || !coordinatesMatch(player, enemy) || !enemy.combat) {
		// let test = enemyIsOneRoomFromPlayer(enemy)
		enemy.enemyMove(enemy)
		return
	}
	abilityObject.windUpPhrase(enemy)
	await waitForNextAction(abilityObject.castTime)
	if (!player.isAlive || !coordinatesMatch(player, enemy) || !enemy.combat) {
		// let test = enemyIsOneRoomFromPlayer(enemy)
		enemy.enemyMove(enemy)
		return
	}
	console.log(abilityObject)
	if (abilityObject.enemyHits == false) {
		abilityObject.flavorTextMiss(enemy)
	} else if (enemy.health > 0) {
		meleeAbilityPhraseFunc(abilityObject, enemy)
		applyDamageToPlayer(abilityObject.totalDamage)
	} 
	displayPlayerHealthFunc()
	updatePlayerStats()
	enemyLocation()
	updateScroll()
}


function calculateEnemyAttack(enemy) {
	const damageType = enemy.damageTypes[randomNumberRange(0, enemy.damageTypes.length - 1)] != undefined ? enemy.damageTypes[randomNumberRange(0, enemy.damageTypes.length - 1)] : undefined
	let damageObject = {
		enemyHits: enemy.hitChance(enemy), //checks if enemy misses its swing
		enemyRawDamage: enemy.damageCalculation(), //raw damage before any mitigation
		mitigationAmount: 0,
		totalDamage: 0,
		damageType: damageType,
		//checks to see if player is wearing any slashing/piercing/blunt armor
		playerPenArmor: damageType == 'slashing' ? player.slashingArmor : damageType == 'piercing' ? player.piercingArmor : damageType == 'blunt' ? player.bluntArmor : undefined,
		playerArmor: player.armor <= 0 ? 0 : player.armor,
		wasBlocked: false,
	}
	damageObject.playerPenArmor = damageObject.playerPenArmor < 0 ? 0 : damageObject.playerPenArmor
	if (damageObject.damageType !== undefined) {
		const damageWithoutArmorPenalty = (damageObject.enemyRawDamage - damageObject.playerPenArmor) * (1000 / (1000 + damageObject.playerPenArmor)) <= 0 ? 0 : (damageObject.enemyRawDamage - damageObject.playerPenArmor) * (1000 / (1000 + damageObject.playerPenArmor))
		damageObject.totalDamage = Math.floor(damageWithoutArmorPenalty) <= 0 ? 0 : Math.floor(damageWithoutArmorPenalty)
	  } else {
		const damageWithoutArmorPenalty = (damageObject.enemyRawDamage - damageObject.playerArmor) * (1000 / (1000 + damageObject.playerArmor)) <= 0 ? 0 : (damageObject.enemyRawDamage - damageObject.playerArmor) * (1000 / (1000 + damageObject.playerArmor))
		// const damageAfterMitigation = (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen)) <= 0 ? 0 : (damageBeforeMitigation - armorAfterPen) * (1000 / (1000 + armorAfterPen))

		damageObject.totalDamage = Math.floor(damageWithoutArmorPenalty) <= 0 ? 0 : Math.floor(damageWithoutArmorPenalty)
	  }
	damageObject.mitigationAmount = Math.floor(damageObject.enemyRawDamage - damageObject.totalDamage)
	let doesPlayerHaveShield = pushItem.some(item => item.type.shield == true && (item.roomId == 'right hand' || item.roomId == 'left hand'))
	let isAttackBlocked = player.block.blockRoll()
	if (doesPlayerHaveShield && isAttackBlocked) {
		damageObject.wasBlocked = true
	}
	return damageObject
}

function calculateEnemyRangedAbility(enemy) {
	let enemyAbilityObject = enemy.rangedAbilityCalculation
	let chosenAbilityName = determineEnemyAbility(enemyAbilityObject) //this will be a string like ability1, ability2, ability3, etc
	let chosenAbility = enemyAbilityObject[chosenAbilityName]
	let magicDamageType = {
		fire: 'fireResist',
		ice: 'iceResist',
		lightning:'lightningResist',
		water: 'waterResist',
		wind: 'windResist',
	}
	if (chosenAbility.damageType != 'physical') {
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.totalDamage = Math.floor(chosenAbility.rawDamage * (1 - player[magicDamageType[chosenAbility.damageType]] * 0.01))
		chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
		return chosenAbility
	} else {
		const penetrationType = chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] != undefined ? chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] : undefined
		chosenAbility.enemyHits = enemy.hitChance(enemy)
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.penetrationType = penetrationType
		chosenAbility.playerPenArmor = penetrationType == 'slashing' ? player.slashingArmor : penetrationType == 'piercing' ? player.piercingArmor : penetrationType == 'blunt' ? player.bluntArmor : undefined
		chosenAbility.playerPenArmor < 0 ? 0 : chosenAbility.playerPenArmor
		chosenAbility.playerArmor = player.armor <= 0 ? 0 : player.armor
		if (chosenAbility.penetrationType !== undefined) {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerPenArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  	} else {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerPenArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  }
	  chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
	  return chosenAbility
	}
}
function calculateEnemyMeleeAbility(enemy) {
	let enemyAbilityObject = enemy.meleeAbilityCalculation
	let chosenAbilityName = determineEnemyAbility(enemyAbilityObject) //this will be a string like ability1, ability2, ability3, etc
	let chosenAbility = enemyAbilityObject[chosenAbilityName]
	let magicDamageType = {
		fire: 'fireResist',
		ice: 'iceResist',
		lightning:'lightningResist',
		water: 'waterResist',
		wind: 'windResist',
	}
	if (chosenAbility.damageType != 'physical') {
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.totalDamage = Math.floor(chosenAbility.rawDamage * (1 - player[magicDamageType[chosenAbility.damageType]] * 0.01))
		chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
		return chosenAbility
	} else {
		const penetrationType = chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] != undefined ? chosenAbility.penetrationTypes[randomNumberRange(0, chosenAbility.penetrationTypes.length - 1)] : undefined
		chosenAbility.enemyHits = enemy.hitChance(enemy)
		chosenAbility.rawDamage = chosenAbility.damage()
		chosenAbility.penetrationType = penetrationType
		chosenAbility.playerPenArmor = penetrationType == 'slashing' ? player.slashingArmor : penetrationType == 'piercing' ? player.piercingArmor : penetrationType == 'blunt' ? player.bluntArmor : undefined
		chosenAbility.playerArmor = player.armor <= 0 ? 0 : player.armor
		if (chosenAbility.penetrationType !== undefined) {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerPenArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  	} else {
			const damageWithoutArmorPenalty = Math.floor(chosenAbility.rawDamage * (10 / (10 + chosenAbility.playerArmor)))
			chosenAbility.totalDamage = damageWithoutArmorPenalty <= 0 ? 0 : damageWithoutArmorPenalty
	  }
	  chosenAbility.mitigationAmount = Math.floor(chosenAbility.rawDamage - chosenAbility.totalDamage)
	  return chosenAbility
	}
}









async function enemyMove(enemy) {
	quickMessage('before quickmessage')
	return new Promise((resolve) => {
		console.log('enemy should be moving')
		resolve();
	})
	// enemy.enemyMove()
}
async function waitForNextAction(delayInMilliseconds) {
	await new Promise((resolve) => setTimeout(resolve, delayInMilliseconds));
  }



function coordinatesMatch(a, b) {
	return a.x === b.x && a.y === b.y && a.z === b.z
}


function goblin(area) {
	let goblinLevel
	let goblin = {
		get color() {
			return enemyLevelColor(this)
		},
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(3, 7)
			goblinLevel = level
			return level
		},
		str: () => 2 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.attackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a goblin`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: "'s body goes limp and plops to the ground",
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings its weapon at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		attackPower: () => this.str + goblinLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Goblin',
		refName: 'goblin',
		keywords: ['goblin'],
		abilityName: 'Goblin Punch',
		abilityUseChance: 0,
		useAbility: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let roll = randomNumberRange(1, 100)
			if (roll == 101) {
				customizeEachWord(`${this.name} `, 'red', line1)
				customizeEachWord(`throws its arms in the air, head back screaming`, 'white', line1)
				let ability1Timeout = setTimeout(() => {
					if (this.health > 0) {
						let damage = this.abilityDamage()
						blankSpace()
						customizeEachWord(`The ${this.name} `, 'red', line2)
						customizeEachWord(`rushes forward, throwing its fist at you hitting you with `, 'white', line2)
						customizeEachWord(`Goblin Punch! `, 'light-green', line2)
						customizeEachWord(`Goblin Punch `, 'light-green', line3)
						customizeEachWord(`hits you for `, 'yellow', line3)
						customizeEachWord(`${damage} `, 'light-blue', line3)
						customizeEachWord(`damage.`, 'yellow', line3)
						blankSpace()
						player.health = player.health - damage
						displayPlayerHealthFunc()
						updatePlayerStats()
					} else {
						clearTimeout(ability1Timeout)
					}
					clearInterval(this.enemyBehaviorInterval)
					this.enemyBehavior()
				}, 1000)
			}
		},

		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return goblin
}
function kobold(area) {
	let koboldLevel
	let kobold = {
		get color() {
			return enemyLevelColor(this)
		},
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(3, 7)
			koboldLevel = level
			return level
		},
		str: () => 3 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.attackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a kobold`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: 'lets out a cry as it falls to the ground',
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings its weapon at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		attackPower: () => this.str + koboldLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Kobold',
		refName: 'kobold',
		keywords: ['kobold'],
		abilityName: 'Kobold Punch',
		abilityUseChance: 0,
		useAbility: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let roll = randomNumberRange(1, 100)
			if (roll == 101) {
				customizeEachWord(`${this.name} `, 'red', line1)
				customizeEachWord(`begins sobbing uncontrollably`, 'white', line1)
				let ability1Timeout = setTimeout(() => {
					if (this.health > 0) {
						let damage = this.abilityDamage()
						blankSpace()
						customizeEachWord(`The ${this.name} `, 'red', line2)
						customizeEachWord(`runs up and punches you in the nuts with `, 'white', line2)
						customizeEachWord(`${this.abilityName}!`, 'light-green', line2)
						customizeEachWord(`${this.abilityName} `, 'light-green', line3)
						customizeEachWord(`hits you for `, 'yellow', line3)
						customizeEachWord(`${damage} `, 'light-blue', line3)
						customizeEachWord(`damage.`, 'yellow', line3)
						blankSpace()
						player.health = player.health - damage
						displayPlayerHealthFunc()
						updatePlayerStats()
					} else {
						clearTimeout(ability1Timeout)
					}
					clearInterval(this.enemyBehaviorInterval)
					this.enemyBehavior()
				}, 1000)
			}
		},

		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			// this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return kobold
}
function orc(area) {
	let orcLevel
	let orc = {
		color: `enemy-red`,
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(7, 12)
			orcLevel = level
			return level
		},
		str: () => 3 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.attackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is an orc`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: 'lets out a cry as it falls to the ground',
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings its weapon at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`swings at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		attackPower: () => this.str + orcLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Orc',
		refName: 'orc',
		keywords: ['orc'],
		abilityName: 'Orc Punch',
		abilityUseChance: 0,
		useAbility: function () {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			let line3 = document.createElement('div')
			let roll = randomNumberRange(1, 100)
			if (roll == 101) {
				customizeEachWord(`${this.name} `, 'red', line1)
				customizeEachWord(`begins sobbing uncontrollably`, 'white', line1)
				let ability1Timeout = setTimeout(() => {
					if (this.health > 0) {
						let damage = this.abilityDamage()
						blankSpace()
						customizeEachWord(`The ${this.name} `, 'red', line2)
						customizeEachWord(`runs up and punches you in the nuts with `, 'white', line2)
						customizeEachWord(`${this.abilityName}!`, 'light-green', line2)
						customizeEachWord(`${this.abilityName} `, 'light-green', line3)
						customizeEachWord(`hits you for `, 'yellow', line3)
						customizeEachWord(`${damage} `, 'light-blue', line3)
						customizeEachWord(`damage.`, 'yellow', line3)
						blankSpace()
						player.health = player.health - damage
						displayPlayerHealthFunc()
						updatePlayerStats()
					} else {
						clearTimeout(ability1Timeout)
					}
					clearInterval(this.enemyBehaviorInterval)
					this.enemyBehavior()
				}, 1000)
			}
		},

		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			// this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return orc
}

function despawnAfter5Minutes(enemy) {
	let count = 0
	let despawn = setInterval(() => {
		if (count == 300) {
			let enemyIndex = pushMonster.indexOf(enemy)
			enemy.health = 0
			pushMonster.splice(enemyIndex, 1)
			clearInterval(enemy.enemyBehaviorInterval)
			clearInterval(despawn)
		} else if (enemy.health <= 0 || enemy.health == undefined) {
			clearInterval(enemy.enemyBehaviorInterval)
			clearInterval(despawn)
		} else if (coordinatesMatch(player, enemy) && player.isAlive) {
			count = 0
		}
		// console.log('not cleared')
		// console.log(enemy.health, ' ENEMY HEALTH')
		// console.log(count)
		count++
	}, 1000)
}

function blob(area) {
	let blobLevel
	let blob = {
		color: `enemy-red`,
		x: function () {
			return currentArea.x
		},
		y: function () {
			return currentArea.y
		},
		z: function () {
			return currentArea.z
		},
		level: () => {
			let level = randomNumberRange(1, 5)
			blobLevel = level
			return level
		},
		str: () => 1 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		advancePhrase: `slimes toward you..`,
		desc: () => {
			enemyDescription(this.health, this.attackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`Looks to be a lower form of blob.`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: `splashes into bits and sinks into the ground`,
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`spits at you and hits!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`spits at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		attackPower: () => 2 + blobLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Blob',
		refName: 'blob',
		keywords: ['blob'],
		abilityName: 'Blob Toss',
		abilityDamage: Math.floor(Math.random() * 3 + 1),
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 4)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(4, 6)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(6, 8)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(9, 10)
				return gold
			}
		},
		itemDropsRoll: function () {
			this.itemDrops.push(pieceOfBlob(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {
			enemyMoveOneRoom(this)
		},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return blob
}

//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS
//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS
//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS
//ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS ENEMY FUNCTIONS

function enemyBehaviorNormal(enemy) {
	let interval = enemy.mainInterval
	enemy.enemyBehaviorInterval = setInterval(() => {
		if (enemy.combat === false && enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
			//This is if player is hidden
			if (player.isStealthed == true) {
				if (player.stealth.level * 3 + player.level / 2 >= enemy.level) {
					quickMessage(`The ${enemy.name} cannot find you and moves on`)
				} else {
					quickMessage(`You have been spotted!`)
					player.isStealthed = false
				}
			} else {
				player.isStealthed = false
				let line2 = document.createElement('div')
				if (player.sideStep.level > 0) {
					quickMessage('1')
					let randomNumber = randomNumberRange(1, 10)
					if (randomNumber <= 5) {
						let line1 = lineFunc()
						blankSpace()
						customizeEachWord(`You sidestep the `, 'white', line1)
						customizeEachWord(`${enemy.name}`, enemy.nameColor, line1)
						blankSpace()
						sideStepRoll(enemy)
					}
				} else {
					customizeEachWord(`${enemy.name} `, enemy.color, line2)
					customizeEachWord(`${enemy.advancePhrase}`, 'white', line2)
					updateScroll()
					player.combat = true
					enemy.combat = player.combat
				}
			}
		} else if (enemy.combat == true && enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
			if (enemy.useAbility && enemy.abilityUseChance <= randomNumberRange(1, 100)) {
				console.log('ability should be used here')

				enemy.useAbility()
			} else {
				console.log('regular swing should be used here')
				enemySwing(enemy)
			}
		}
		enemy.enemyMove()
		console.log(interval, ' ENEMY MAIN INTERVAL')
	}, interval)
}
function rangedEnemyBehaviorNormal(enemy) {
	let interval = enemy.mainInterval
	enemy.enemyBehaviorInterval = setInterval(() => {
		if (coordinatesMatch(enemy, player) && player.isAlive == true) {
			//This is if player is hidden
			if (player.isStealthed == true) {
				if (player.stealth.level * 3 + player.level / 2 >= enemy.level) {
					quickMessage(`The ${enemy.name} cannot find you and moves on`)
				} else {
					quickMessage(`You have been spotted!`)
					player.isStealthed = false
				}
			} else if (enemy.useAbility && enemy.abilityUseChance >= randomNumberRange(1, 100)) {
				enemy.useAbility()
			} else {
				rangedEnemySwing(enemy)
			}
		}
		enemy.enemyMove()
		console.log(interval, ' ENEMY MAIN INTERVAL')
	}, interval)
}

function playerAbilityChecks(enemy, enemyDamage) {
	let doesPlayerHaveShield = pushItem.some(item, ({ roomId }) => roomId == 'right hand' || (roomId == 'left hand' && item.type.shield == 'true'))
	if (player.block.level > 0 && doesPlayerHaveShield == true && enemyDamage != false) {
		blockRoll(enemy, enemyDamage)
	} else if (player.counterAttack.level > 0) {
		counterAttackRoll(enemy)
	} else if (player.preemptiveStrike.level > 0) {
		preemptiveStrikeRoll(enemy)
	}
}
function blockRoll(enemy, enemyDamage) {
	let blockAmount = player.block.blockAmount()
	let negatedDamage = enemyDamage - blockAmount
	let finalDamage = negatedDamage <= 0 ? 0 : negatedDamage
	let line1 = document.createElement('div')
	let line2 = document.createElement('div')
	player.health = player.health - finalDamage
	blankSpace()
	customizeEachWord(`The `, 'white', line1)
	customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
	customizeEachWord(`swings at you!`, 'white', line1)
	customizeEachWord(`You block the attack with your shield and take `, 'yellow', line2)
	customizeEachWord(`${finalDamage} `, 'red', line2)
	customizeEachWord(`damage.`, 'yellow', line2)
	customizeEachWord(`(your block negates ${blockAmount}, armor negates ${playerBlockedDamage} damage)`, 'white', line2)
	blankSpace()
	displayPlayerHealthFunc()
	updatePlayerStats()
	updateScroll()
}




function sideStepRoll(enemy) {
	let sideStepRoll = player.sideStep.level * 5
	let randomRoll = randomNumberRange(1, 100)
	let line1 = document.createElement('div')
	if (randomRoll <= sideStepRoll) {
		blankSpace()
		customizeEachWord(`You `, 'white', line1)
		customizeEachWord(`SIDE STEP `, 'yellow', line1)
		customizeEachWord(`the enemy's attempt to advance you!`, 'white', line1)
		blankSpace()
		updateScroll()
	} else {
		blankSpace()
		customizeEachWord(`The `, 'white', line1)
		customizeEachWord(`${enemy.name} `, enemy.color, line1)
		customizeEachWord(`${enemy.advancePhrase}`, 'white', line1)
		blankSpace()
		updateScroll()
		player.combat = true
		enemy.combat = player.combat
	}
}

function cleaveAbility(targetedMonster) {
	let allMonstersInRoom = getAllEnemiesInRoom()
	let targetedMonsterIndex = allMonstersInRoom.indexOf(targetedMonster)
	let previousMonster = allMonstersInRoom[targetedMonsterIndex - 1]
	let previousPreviousMonster = allMonstersInRoom[targetedMonsterIndex - 2]
	let nextMonster = allMonstersInRoom[targetedMonsterIndex + 1]
	let nextNextMonster = allMonstersInRoom[targetedMonsterIndex + 2]
	if (previousMonster != undefined || nextMonster != undefined) {
		if (player.cleave.level > 0) {
			if (player.cleave.level == 1) {
				if (previousMonster != undefined && previousMonster.combat == true) {
					cleaveCounter = 1
					attack(previousMonster)
					cleaveCounter = 0
				} else if (nextMonster != undefined && nextMonster.combat == true) {
					cleaveCounter = 1
					attack(nextMonster)
					cleaveCounter = 0
				}
			}
			if (player.cleave.level == 2) {
				if (nextMonster != undefined && nextNextMonster != undefined) {
					cleaveCounter++
					if (nextMonster.combat == true) {
						attack(nextMonster)
					}
					if (nextNextMonster.combat == true) {
						attack(nextNextMonster)
					}
				} else if (previousMonster != undefined && nextMonster != undefined) {
					cleaveCounter++
					if (previousMonster.combat == true) {
						attack(previousMonster)
					}
					if (nextMonster.combat == true) {
						attack(nextMonster)
					}
				} else if (previousMonster != undefined && previousPreviousMonster != undefined) {
					cleaveCounter++
					if (previousMonster.combat == true) {
						attack(previousMonster)
					}
					if (previousPreviousMonster.combat == true) {
						attack(previousPreviousMonster)
					}
				}
			}
		}
	}
}

function displayDeathMessage() {
	let line1 = lineFunc()	
	let line2 = lineFunc()	
	let line3 = lineFunc()	
	let line4 = lineFunc()	
	blankSpace()
	customizeEachWord(`************************************************`, 'white', line1)
	customizeEachWord(`*************** You have been slain! ***************`, 'white', line2)
	customizeEachWord(`************************************************`, 'white', line3)
	blankSpace()
	customizeEachWord(`You cannot do anything while dead. You must type REVIVE in order to resurrect.`, `white`, line4)
	blankSpace()
}

function openObject(secondCommand) {
	let line1 = lineFunc()
	let itemInHand = getAllItemsOnPerson().find(({ keywords, roomId }) => keywords.some(keyword => secondCommand === keyword && (roomId === 'right hand' || roomId === 'left hand')))
	if (!secondCommand) {
		customizeEachWord(`You must specify what you want to open.`, 'white', line1)
	}
	if (!itemInHand || !itemInHand.type.openable) {
		customizeEachWord(`You cannot open this.`, 'white', line1)
		return
	}
	// if (!secondCommand) {
	// 	customizeEachWord(`You must specify what you want to open.`)
	// 	return
	// }
	console.log(itemInHand)
	itemInHand.spillContents(itemInHand)


}

function deletePlayerBuffs() {
	for (let buffName in player.buffs) {
		delete player.buffs[buffName]
	}
}
function removeAllEnemiesFromCombat() {
	for (let i = 0; i < pushMonster.length; i++) {
		pushMonster[i].combat = false
	}
}

function playerDeath() {
	displayDeathMessage()
	deathResetUI()
	deletePlayerBuffs()
	removeAllEnemiesFromCombat()
	player.isAlive = false
	player.combat = false


}
function deathResetUI() {
	player.spellsConjured = []
	const conjureBar1 = document.querySelector('.bar-1')
	const conjureBar2 = document.querySelector('.bar-2')
	const conjureBar3 = document.querySelector('.bar-3')
	let cbArray1 = Array.from(conjureBar1.classList)
	let cbArray2 = Array.from(conjureBar2.classList)
	let cbArray3 = Array.from(conjureBar3.classList)
	conjureBar1.classList = cbArray1[0]
	conjureBar2.classList = cbArray2[0]
	conjureBar3.classList = cbArray3[0]

	conjureBar1.style.width = ''	
	conjureBar2.style.width = ''	
	conjureBar3.style.width = ''

	player.warriorAbilityQueue = false
	for (let spell in player) {
		if (player?.[spell]?.chambered) {
			player[spell].chambered = false
		}
	}
}


function applyDamageToPlayer(damage) {
	damage = Math.floor(damage)
	if (player.magicShield > 0) {
		//damage = 10
		//magic shield = 3
		let damageToApplyToHealth = Math.abs(player.magicShield + damage)
		player.magicShield = player.magicShield - damage < 0 ? 0 : player.magicShield - damage
		if (player.magicShield <= 0) {
			player.health -= damageToApplyToHealth
		}
	} else {
		player.health = player.health - damage < 0 ? 0 : player.health - damage
	}
	updatePlayerStats()
	displayPlayerHealthFunc()
	if (player.health <= 0) {playerDeath()}
	updateScroll()
}
function applyHealToPlayer(healAmount) {
	player.health += healAmount
	updatePlayerStats()
	displayPlayerHealthFunc()
	updateScroll()
}
function applyMagicShieldToPlayer() {
	let shieldAmount = player.barrier.maxShield()
	player.maxShield = shieldAmount
	player.barrier.flavorTextCast(shieldAmount)
	player.magicShield = shieldAmount
	updatePlayerStats()
	displayPlayerHealthFunc()
	updateScroll()
}

function preemptiveStrikeRoll() {
	return player.preemptiveStrike.level * 5 >= randomNumberRange(1, 100)
}
function counterAttackRoll() {
	return player.counterAttack.level * 5 >= randomNumberRange(1, 100)
}
function performPreemptiveStrike() {

}

function enemyPicksUpItemsAndGold(enemy, area) {
	if (!coordinatesMatch(enemy, player)) {
		// quickMessage(`enemy should pick up stuff`)
		enemy.gold += area.gold
		area.gold = 0
		pushItem.forEach(item => {
			if (item.roomId == enemy.roomId) {
				quickMessage(`Item picked up, should be in monster inventory`)
				enemy.itemDrops.push(item)
				pushItem.splice(pushItem.indexOf(item), 1)
			}
		})
	}
}



function enemyMoveOneRoom(enemy) {
	if (!enemy.isAlive()) {return}
	let enemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemyPicksUpItemsAndGold(enemy, enemyArea)
	enemy.roomId = enemyArea.id
	let canMonsterExit = enemyArea.descriptions.zoneExits.toLowerCase()
	let line = lineFunc()
	if (coordinatesMatch(enemy, player) && player.isStealthed == false && player.isAlive) {
		enemy.moveSwitch = 0 //Switches to always finding player
	} else if (coordinatesMatch(enemy, player) == false && player.isStealthed == false) {
		if (enemy.y == player.y - 1 && enemy.x == player.x - 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('northeast') != -1) {
				enemy.y = enemy.y + 1
				enemy.x = enemy.x + 1
				direction = 'southwest'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y + 1 && enemy.x == player.x - 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southeast') != -1) {
				enemy.y = enemy.y - 1
				enemy.x = enemy.x + 1
				direction = 'northwest'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y + 1 && enemy.x == player.x + 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southwest') != -1) {
				enemy.y = enemy.y - 1
				enemy.x = enemy.x - 1
				direction = 'northeast'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y - 1 && enemy.x == player.x + 1 && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('northwest') != -1) {
				enemy.y = enemy.y + 1
				enemy.x = enemy.x - 1
				direction = 'southeast'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y + 1 && enemy.x == player.x && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('south') != -1) {
				console.log(enemy, ' THIS THIS THIS THIS THIS')
				enemy.y = enemy.y - 1
				direction = 'north'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x + 1 && enemy.y == player.y && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('west') != -1) {
				enemy.x = enemy.x - 1
				direction = 'east'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.y == player.y - 1 && enemy.x == player.x && enemy.z == player.z && currentArea.hostile == true) {
			console.log('ENEMY MOVE ONE ROOM 4')
			console.log(canMonsterExit)
			if (canMonsterExit.search('north') != -1) {
				enemy.y = enemy.y + 1
				direction = 'south'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x - 1 && enemy.y == player.y && enemy.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('east') != -1) {
				enemy.x = enemy.x + 1
				direction = 'west'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z + 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('up') != -1) {
				enemy.z = enemy.z + 1
				direction = 'below'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z - 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('down') != -1) {
				enemy.z = enemy.z - 1
				direction = 'above'
				customizeEachWord(`${enemy.name} `, enemy.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from ${direction}`, 'white', line)
				updateScroll()
			}
		} else {
			let canMonsterExitSplit = canMonsterExit.split(' ')
			let numberOfDirectionsToMove = canMonsterExitSplit.length
			let randomIndexChosen = randomNumberRange(0, numberOfDirectionsToMove)
			let randomlyChosenDirection = canMonsterExitSplit[randomIndexChosen]
			let coordinateXToTest = 0
			let coordinateYToTest = 0
			let coordinateZToTest = 0
			if (randomlyChosenDirection == 'northwest') {
				coordinateXToTest = -1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'north') {
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'northeast') {
				coordinateXToTest = 1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'east') {
				coordinateXToTest = 1
			} else if (randomlyChosenDirection == 'southeast') {
				coordinateXToTest = 1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'south') {
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'southwest') {
				coordinateXToTest = -1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'west') {
				coordinateXToTest = -1
			} else if (randomlyChosenDirection == 'up') {
				coordinateZToTest = 1
			} else if (randomlyChosenDirection == 'down') {
				coordinateZToTest = -1
			}
			let newAreaForMonsterToMove = allAreas.find(area => {
				return area.x == enemyArea.x + coordinateXToTest && area.y == enemyArea.y + coordinateYToTest && area.z == enemyArea.z + coordinateZToTest
			})
			if (newAreaForMonsterToMove.hostile == true) {
				enemy.x = newAreaForMonsterToMove.x
				enemy.y = newAreaForMonsterToMove.y
				enemy.z = newAreaForMonsterToMove.z
			}
		}
	} else {
		let canMonsterExitSplit = canMonsterExit.split(' ')
		let numberOfDirectionsToMove = canMonsterExitSplit.length - 1
		let randomIndexChosen = randomNumberRange(0, numberOfDirectionsToMove)
		let randomlyChosenDirection = canMonsterExitSplit[randomIndexChosen]
		let enemyEntersFromThisDirection
		let coordinateXToTest = 0
		let coordinateYToTest = 0
		let coordinateZToTest = 0
		if (randomlyChosenDirection == 'northwest') {
			coordinateXToTest = -1
			coordinateYToTest = 1
		} else if (randomlyChosenDirection == 'north') {
			coordinateYToTest = 1
		} else if (randomlyChosenDirection == 'northeast') {
			coordinateXToTest = 1
			coordinateYToTest = 1
		} else if (randomlyChosenDirection == 'east') {
			coordinateXToTest = 1
		} else if (randomlyChosenDirection == 'southeast') {
			coordinateXToTest = 1
			coordinateYToTest = -1
		} else if (randomlyChosenDirection == 'south') {
			coordinateYToTest = -1
		} else if (randomlyChosenDirection == 'southwest') {
			coordinateXToTest = -1
			coordinateYToTest = -1
		} else if (randomlyChosenDirection == 'west') {
			coordinateXToTest = -1
		} else if (randomlyChosenDirection == 'up') {
			coordinateZToTest = 1
		} else if (randomlyChosenDirection == 'down') {
			coordinateZToTest = -1
		}
		switch (randomlyChosenDirection) {
			case 'northwest':
				enemyEntersFromThisDirection = 'southeast'
				break
			case 'north':
				enemyEntersFromThisDirection = 'south'
				break
			case 'northeast':
				enemyEntersFromThisDirection = 'southweast'
				break
			case 'east':
				enemyEntersFromThisDirection = 'west'
				break
			case 'southeast':
				enemyEntersFromThisDirection = 'northwest'
				break
			case 'south':
				enemyEntersFromThisDirection = 'north'
				break
			case 'southwest':
				enemyEntersFromThisDirection = 'northeast'
				break
			case 'west':
				enemyEntersFromThisDirection = 'east'
				break
			default:
				quickMessage(`figure out why this message is displayed`)
		}
		let newAreaForMonsterToMove = allAreas.find(area => {
			return area.x == enemyArea.x + coordinateXToTest && area.y == enemyArea.y + coordinateYToTest && area.z == enemyArea.z + coordinateZToTest
		})
		if (newAreaForMonsterToMove.hostile == true) {
			let line1 = document.createElement('div')
			if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
				customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
				customizeEachWord(` moves to the ${randomlyChosenDirection}`, 'white', line1)
			}
			enemy.x = newAreaForMonsterToMove.x
			enemy.y = newAreaForMonsterToMove.y
			enemy.z = newAreaForMonsterToMove.z
			if (enemy.x == player.x && enemy.y == player.y && enemy.z == player.z) {
				customizeEachWord(`${enemy.name} `, `${enemy.color}`, line1)
				customizeEachWord(`enters the room from the ${enemyEntersFromThisDirection}`, 'white', line1)
			}
		}
	}
	let newEnemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemy.roomId = newEnemyArea.id
}

function enemyAlwaysFindsPlayer(enemy) {
	const path = trackPlayer(enemy)
	console.log(path, ' PATH PATH PATH PATH')
	let enemyDirection

	let monsterX = enemy.x
	let monsterY = enemy.y
	let monsterZ = enemy.z

	if (path != null) {
		if (path[0] == 0 && path[1] == 1 && path[2] == 0) {
			enemyDirection = 'south'
		} else if (path[0] == 0 && path[1] == -1 && path[2] == 0) {
			enemyDirection = 'north'
		} else if (path[0] == 1 && path[1] == 0 && path[2] == 0) {
			enemyDirection = 'west'
		} else if (path[0] == -1 && path[1] == 0 && path[2] == 0) {
			enemyDirection = 'east'
		} else if (path[0] == 0 && path[1] == 0 && path[2] == 1) {
			enemyDirection = 'below'
		} else if (path[0] == 0 && path[1] == 0 && path[2] == -1) {
			enemyDirection = 'above'
		} else if (path[0] == 1 && path[1] == 1 && path[2] == 0) {
			enemyDirection = 'southwest'
		} else if (path[0] == -1 && path[1] == 1 && path[2] == 0) {
			enemyDirection = 'southeast'
		} else if (path[0] == 1 && path[1] == -1 && path[2] == 0) {
			enemyDirection = 'northwest'
		} else if (path[0] == -1 && path[1] == -1 && path[2] == 0) {
			enemyDirection = 'northeast'
		}
	}

	if (path !== null) {
		let enemyLocation = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
		let potentialLocation = allAreas.find(area => area.x == enemyLocation.x + path[0] && area.y == enemyLocation.y + path[1] && area.z == enemyLocation.z + path[2])
		if (potentialLocation.hostile == false) {
			enemy.moveSwitch = 1
			quickMessage(`Behavior switched`)
		} else {
			console.log(enemyLocation, ' ENEMY LOCATION')
			console.log(potentialLocation, ' POTENTIAL LOCATION')
			enemy.x += path[0]
			enemy.y += path[1]
			enemy.z += path[2]
			let line1 = document.createElement('div')
			if (coordinatesMatch(enemy, player)) {
				if (enemyDirection == 'above' || enemyDirection == 'below') {
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`${enemy.entersExitsRoomPhrase} in from ${enemyDirection}`, 'white', line1)
				} else {
					customizeEachWord(`${enemy.name} `, enemy.color, line1)
					customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${enemyDirection}`, 'white', line1)
					console.log(`Monster moved to room (${monsterX}, ${monsterY}, ${monsterZ})`)
				}
			} else {
				console.log('No valid path found')
			}
		}
	}
}

function enemyMovesRandomly(enemy) {
	const enemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemyPicksUpItemsAndGold(enemy, enemyArea)
	enemy.roomId = enemyArea.id
	const availableDirections = enemyArea.descriptions.zoneExits.split(' ')
	let directionEntersFrom
	let directionMovesTo

	for (let i = 0; i < availableDirections.length; i++) {
		const randomDirectionIndex = Math.floor(Math.random() * availableDirections.length)
		const randomDirection = availableDirections[randomDirectionIndex].toLowerCase()

		let dx = 0
		let dy = 0
		let dz = 0

		switch (randomDirection) {
			case 'north':
				directionEntersFrom = 'south'
				dy = 1
				break
			case 'south':
				directionEntersFrom = 'north'
				dy = -1
				break
			case 'east':
				directionEntersFrom = 'west'
				dx = 1
				break
			case 'west':
				directionEntersFrom = 'east'
				dx = -1
				break
			case 'northeast':
				directionEntersFrom = 'southwest'
				dx = 1
				dy = 1
				break
			case 'southeast':
				directionEntersFrom = 'northwest'
				dx = 1
				dy = -1
				break
			case 'southwest':
				directionEntersFrom = 'northeast'
				dx = -1
				dy = -1
				break
			case 'northwest':
				directionEntersFrom = 'southeast'
				dx = -1
				dy = 1
				break
			case 'up':
				directionEntersFrom = 'below'
				dz = 1
				break
			case 'down':
				directionEntersFrom = 'above'
				dz = -1
				break
			default:
				console.log('figure out what went wrong here')
		}

		const futureArea = allAreas.find(area => area.x == enemyArea.x + dx && area.y == enemyArea.y + dy && area.z == enemyArea.z + dz)

		if (futureArea && futureArea.hostile == true) {
			enemy.x += dx
			enemy.y += dy
			enemy.z += dz
			directionEntersFrom = /* calculate direction */
			directionMovesTo = randomDirection

			if (coordinatesMatch(enemy, player)) {
				enemy.moveSwitch = 0
				let line1 = lineFunc()
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} in from the ${directionEntersFrom}`, 'white', line1)
			} else if (!coordinatesMatch(enemy, player) && coordinatesMatch(enemyArea, player)) {
				let line1 = lineFunc()
				customizeEachWord(`${enemy.name} `, enemy.color, line1)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} to the ${directionMovesTo}`, 'white', line1)
			}

			// Break out of the loop after a valid move
			break;
		}
		// Optionally add an else statement for handling non-hostile areas
	}
	let newEnemyArea = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	enemy.roomId = newEnemyArea.id
}

function npcMovesRandomly2(npc) {
	const currentRoom = allAreas.find(area => area.x == npc.x && area.y == npc.y && area.z == npc.z)
	const availableDirections = currentRoom.descriptions.zoneExits.split(' ')
	console.log(availableDirections.length, ' AVAILABLE DIRECTIONS LEGNTH')
	if (coordinatesMatch(player, npc) == true) {
		console.log(' NPC IS IN THE SAME ROOM AS PLAYER, NPC DOES NOT MOVE!!!')
	} else {
		for (let i = 0; i < availableDirections.length; i++) {
			const randomDirectionIndex = Math.floor(Math.random() * availableDirections.length)
			const randomDirection = availableDirections[randomDirectionIndex].toLowerCase()
			let directionEntersFrom
			console.log(currentRoom, ' CURRENT ROOM')
			console.log(availableDirections, ' AVAILABLE DIRECTIONS')
			console.log(randomDirectionIndex, ' RANDOM DIRECTION INDEX')
			console.log(randomDirection, ' RANDOM DIRECTION')
			let dx = 0
			let dy = 0
			let dz = 0
			switch (randomDirection) {
				case 'north':
					directionEntersFrom = 'south'
					dy = 1
					break
				case 'south':
					directionEntersFrom = 'north'
					dy = -1
					break
				case 'east':
					directionEntersFrom = 'west'
					dx = 1
					break
				case 'west':
					directionEntersFrom = 'east'
					dx = -1
					break
				case 'northeast':
					directionEntersFrom = 'southwest'
					dx = 1
					dy = 1
					break
				case 'southeast':
					directionEntersFrom = 'northwest'
					dx = 1
					dy = -1
					break
				case 'southwest':
					directionEntersFrom = 'northeast'
					dx = -1
					dy = -1
					break
				case 'northwest':
					directionEntersFrom = 'southeast'
					dx = -1
					dy = 1
					break
				case 'up':
					directionEntersFrom = 'below'
					dz = 1
					break
				case 'down':
					directionEntersFrom = 'above'
					dz = -1
					break
				default:
					console.log('figure out what went wrong here')
			}
		}
		let futureArea = allAreas.find(area => area.x == currentRoom.x + dx && area.y == currentRoom.y + dy && area.z == currentRoom.z + dz)
		if (futureArea.hostile == false && moveSwitch == 0) {
			npc.x += dx
			npc.y += dy
			npc.z += dz
			if (coordinatesMatch(npc, player) == true) {
				let line1 = document.createElement('div')
				customizeEachWord(`${npc.name} `, npc.nameColor, line1)
				customizeEachWord(`${npc.entersExitsRoomPhrase} from the ${directionEntersFrom}`, 'white', line1)
			}
		} else if (futureArea.hostile == true) {
			console.log(' NPC STOPPED ITSELF FROM MOVING INTO HOSTILE ZONE')
		}
	}
}

function trackPlayer(enemy) {
	let monsterX = enemy.x
	let monsterY = enemy.y
	let monsterZ = enemy.z

	let playerX = player.x
	let playerY = player.y
	let playerZ = player.z

	let enemyLocation = allAreas.find(area => area.x == enemy.x && area.y == enemy.y && area.z == enemy.z)
	let possibleExits = Object.keys(enemyLocation.descriptions.zoneExitsBool)

	const distanceX = Math.abs(playerX - monsterX)
	const distanceY = Math.abs(playerY - monsterY)
	const distanceZ = Math.abs(playerZ - monsterZ)

	if (distanceX === 0 && distanceY === 0 && distanceZ === 0) {
		return null
	}

	// Initialize variables for the chosen path and the minimum distance to the player
	let path = null
	let minDistance = Infinity

	// Check each possible path from the current room to the player
	for (let i = 0; i < possibleExits.length; i++) {
		const exit = possibleExits[i]
		let newPath = null

		// Calculate the new coordinates based on the chosen exit
		switch (exit) {
			case 'north':
				newPath = [0, 1, 0]
				break
			case 'south':
				newPath = [0, -1, 0]
				break
			case 'east':
				newPath = [1, 0, 0]
				break
			case 'west':
				newPath = [-1, 0, 0]
				break
			case 'up':
				newPath = [0, 0, 1]
				break
			case 'down':
				newPath = [0, 0, -1]
				break
			case 'northeast':
				newPath = [1, 1, 0]
				break
			case 'northwest':
				newPath = [-1, 1, 0]
				break
			case 'southeast':
				newPath = [1, -1, 0]
				break
			case 'southwest':
				newPath = [-1, -1, 0]
				break
			default:
				newPath = null
		}

		// If a valid path was found, calculate the distance to the player
		if (newPath !== null) {
			const newMonsterX = monsterX + newPath[0]
			const newMonsterY = monsterY + newPath[1]
			const newMonsterZ = monsterZ + newPath[2]
			const newDistanceX = Math.abs(playerX - newMonsterX)
			const newDistanceY = Math.abs(playerY - newMonsterY)
			const newDistanceZ = Math.abs(playerZ - newMonsterZ)
			const totalDistance = newDistanceX + newDistanceY + newDistanceZ

			// If the total distance is less than the minimum distance, choose this path
			if (totalDistance < minDistance) {
				path = newPath
				minDistance = totalDistance
			}
		}
	}
	return path
}
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
// TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE TEMPLATE
function enemyTracksPlayerBy1Room() {
	let enemyArea = allAreas.find(area => area.x == this.x && area.y == this.y && area.z == this.z)
	let canMonsterExit = enemyArea.descriptions.zoneExits
	let line = document.createElement('div')
	if (this.y == player.y && this.x == player.x && this.z == player.z) {
	} else if (!coordinatesMatch(player, enemy)) {
		if (this.y == player.y - 1 && this.x == player.x - 1 && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southwest') != -1) {
				this.y = this.y + 1
				this.x = this.x + 1
				direction = 'northeast'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y + 1 && this.x == player.x - 1 && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('northwest') != -1) {
				this.y = this.y - 1
				this.x = this.x + 1
				direction = 'southeast'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y + 1 && this.x == player.x + 1 && this.z == player.z && currentArea.hostile == true) {
			console.log(1)
			if (canMonsterExit.search('northeast') != -1) {
				this.y = this.y - 1
				this.x = this.x - 1
				direction = 'southwest'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y - 1 && this.x == player.x - 1 && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('southeast') != -1) {
				this.y = this.y - 1
				this.x = this.x + 1
				direction = 'northwest'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y + 1 && this.x == player.x && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('south') != -1) {
				console.log(this, ' THIS THIS THIS THIS THIS')
				this.y = this.y - 1
				direction = 'north'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x + 1 && this.y == player.y && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('west') != -1) {
				this.x = this.x - 1
				direction = 'east'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.y == player.y - 1 && this.x == player.x && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('north') != -1) {
				console.log(this.y, ' THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS THIS')
				this.y = this.y + 1
				direction = 'south'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x - 1 && this.y == player.y && this.z == player.z && currentArea.hostile == true) {
			if (canMonsterExit.search('east') != -1) {
				this.x = this.x + 1
				direction = 'west'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from the ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x && this.y == player.y && this.z == player.z + 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('up') != -1) {
				this.z = this.z + 1
				direction = 'below'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from ${direction}`, 'white', line)
				updateScroll()
			}
		} else if (this.x == player.x && this.y == player.y && this.z == player.z - 1 && currentArea.hostile == true) {
			if (canMonsterExit.search('down') != -1) {
				this.z = this.z - 1
				direction = 'above'
				customizeEachWord(`A `, 'white', line)
				customizeEachWord(`${this.name} `, this.color, line)
				customizeEachWord(`${enemy.entersExitsRoomPhrase} from ${direction}`, 'white', line)
				updateScroll()
			}
		} else {
			let canMonsterExitSplit = canMonsterExit.split(' ')
			let numberOfDirectionsToMove = canMonsterExitSplit.length
			let randomIndexChosen = randomNumberRange(0, numberOfDirectionsToMove)
			let randomlyChosenDirection = canMonsterExitSplit[randomIndexChosen]
			let coordinateXToTest = 0
			let coordinateYToTest = 0
			let coordinateZToTest = 0

			if (randomlyChosenDirection == 'Northwest') {
				coordinateXToTest = -1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'north') {
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'northeast') {
				coordinateXToTest = 1
				coordinateYToTest = 1
			} else if (randomlyChosenDirection == 'east') {
				coordinateXToTest = 1
			} else if (randomlyChosenDirection == 'southeast') {
				coordinateXToTest = 1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'south') {
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'southwest') {
				coordinateXToTest = -1
				coordinateYToTest = -1
			} else if (randomlyChosenDirection == 'west') {
				coordinateXToTest = -1
			} else if (randomlyChosenDirection == 'up') {
				coordinateZToTest = 1
			} else if (randomlyChosenDirection == 'down') {
				coordinateZToTest = -1
			}
			let newAreaForMonsterToMove = allAreas.find(area => {
				return area.x == enemyArea.x + coordinateXToTest && area.y == enemyArea.y + coordinateYToTest && area.z == enemyArea.z + coordinateZToTest
			})
			if (newAreaForMonsterToMove.hostile == true) {
				console.log(newAreaForMonsterToMove, ' NEW AREA FOR MONSTER TO MOVE')
				this.x = newAreaForMonsterToMove.x
				this.y = newAreaForMonsterToMove.y
				this.z = newAreaForMonsterToMove.z
			}
		}
	}
}
function shackledGoblin(area) {
	let shackledGoblinLevel
	let shackledGoblin = {
		color: `enemy-red`,
		x: function () {
			return area.x
		},
		y: function () {
			return area.y
		},
		z: function () {
			return area.z
		},
		level: () => {
			let level = randomNumberRange(1, 1)
			shackledGoblinLevel = level
			return level
		},
		str: () => 2 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `hops in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.attackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a shackled goblin`)
		},
		death: function (enemy) {
			enemyDeath(enemy)
		},
		deathPhrase: "'s body goes limp and plops to the ground",
		strikePhrase: function (enemyDamage) {
			let line1 = document.createElement('div')
			let line2 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`claws at you!`, 'white', line1)
			customizeEachWord(`You are hit for `, 'yellow', line2)
			customizeEachWord(`${enemyDamage} `, 'light-blue', line2)
			customizeEachWord(`damage. `, 'yellow', line2)
			customizeEachWord(`(Your armor blocks `, 'white', line2)
			customizeEachWord(`${playerBlockedDamage})`, 'light-blue', line2)
			blankSpace()
			updateScroll()
		},
		missPhrase: function () {
			let line1 = document.createElement('div')
			blankSpace()
			customizeEachWord(`${this.name} `, 'red', line1)
			customizeEachWord(`claws at you and misses!`, 'white', line1)
			blankSpace()
			updateScroll()
		},
		hostile: true,
		combat: false,
		health: () => this.con * 5,
		maxHealth: () => this.con * 5,
		attackPower: () => this.str + shackledGoblinLevel,
		accuracy: () => this.dex,
		dodge: () => 5,
		factor: 1,
		experience: () => this.level,
		armor: 5,
		slashingArmor: 0,
		piercingArmor: 0,
		bluntArmor: 0,
		statusEffects: {
			
		},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Shackled Goblin',
		refName: 'shackled goblin',
		keywords: ['shackled', 'goblin', 'shackled goblin'],
		abilityName: '',
		abilityUseChance: 0,
		useAbility: function () {},
		abilityDamage: function () {
			return Math.floor(Math.random() * 3 + this.level)
		},
		itemDrops: [],
		gold: function () {
			let goldRandom = randomSingleNumber(100)
			let gold
			if (goldRandom <= 52) {
				gold = randomNumberRange(1, 1)
				return gold
			} else if (goldRandom <= 77 && goldRandom >= 53) {
				gold = randomNumberRange(1, 1)
				return gold
			} else if (goldRandom <= 92 && goldRandom >= 78) {
				gold = randomNumberRange(1, 1)
				return gold
			} else if (goldRandom >= 79) {
				gold = randomNumberRange(1, 1)
				return gold
			}
		},
		itemDropsRoll: function () {
			this.itemDrops.push(goblinHead(this.level, true))
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 5000,
		enemyBehavior: function () {
			despawnAfter5Minutes(this)
			enemyBehaviorNormal(this)
		},
	}
	return shackledGoblin
}

function woundedGoblinScout(area) {
	let woundedGoblinScout = {
		isAlive: function() {
			return this.health > 0
		},
		enemyMoveSpeed: 6000,
		shouldEngagePlayer: function(enemy, attackType) {
			if (enemy.combat == true) {return false}
			if (player.isAlive == false) {return false}
			if (attackType == 'ranged' || attackType == 'rangedAbility') {return false}
			if (enemy.combat == false && coordinatesMatch(enemy, player) && player.isStealthed == false) {
				return true
			} else if (player.stealth.level > enemy.level) {
				return false
			} else if (player.stealth.level < enemy.level) {
				player.isStealthed = false
			} else {
				return false
			}
		},
		shouldAttackPlayer: function(enemy) { //change to attack type
			if (!coordinatesMatch(enemy, player)) {return}
			let attackType = determineEnemyAttackType(enemy)
			console.log(attackType, ' ATTACK TYPE')
			return attackType
		},
		damageCalculation: function() {
			return randomNumberRange(2, 3)
		},		
		rangedAbilityCalculation: {},
		meleeAbilityCalculation: {},
		color: `enemy-red`,
		x: function () {
			return area.x
		},
		y: function () {
			return area.y
		},
		z: function () {
			return area.z
		},
		level: () => {
			let level = randomNumberRange(2, 2)
			woundedGoblinScout = level
			return level
		},
		str: () => 1 + this.level,
		dex: () => 1 + this.level,
		agi: () => 1 + this.level,
		int: () => 1 + this.level,
		wis: () => 1 + this.level,
		con: () => 5 + this.level,
		entersTheRoomPhrase: `limps in!`,
		advancePhrase: `walks up to you...`,
		desc: () => {
			enemyDescription(this.health, this.attackPower, this.accuracy, this.dodge, this.armor, this.slashingArmor, this.piercingArmor, this.bluntArmor)
			quickMessage(`This is a Wounded Goblin Scout`)
		},
		death: async function () {
			if (player.killList[this.refName] == undefined) {
				player.killList[this.refName] = 1
			} else {
				player.killList[this.refName]++
			}
			enemyDeath(this)
			await dialogueWait(1000)
			let line1 = lineFunc()
			customizeEachWord(`${egbert.name} `, egbert.nameColor, line1)
			customizeEachWord(`strides in from the south`, 'white', line1)
			egbert.y++
			egbert.questSequence.sixth = true
			currentArea.npc.push(egbert)
			await dialogueWait(1000)

			galvadiaWelcomeArea14.npc = []
			egbert.speak()
		},
		deathPhrase: "'s body goes limp and plops to the ground",
		strikePhrase: `swings at you and scratches you with its claws!`,
		missPhrase: 'swings at you and misses!',		
		rangedAttackPhrase: '',
		rangedMissPhrase: '',
		entersExitsRoomPhrase: '',
		hostile: true,
		combat: false,
		health: () => 12,
		maxHealth: () => 12,
		attackPower: () => this.str,
		accuracy: () => this.dex,
		dodge: () => 5,
		hitChance: function () {
			return 80
		},
		damageTypes: [], //if it has any, should be slashing, piercing, and or blunt
		attackTypes: { //this is the type and percentage chance of each type of attack occuring
			melee: 100,
			ranged: 0,
			meleeAbility: 0,
			rangedAbility: 0,
		},
		experience: () => 5,
		armor: 0,
		slashingArmor: 1,
		piercingArmor: 1,
		bluntArmor: 1,
		statusEffects: {},
		roomId: area.id,
		randomItemDrops: Math.floor(Math.random() * 4) + 1,
		name: 'Goblin Scout',
		refName: 'goblin_scout',
		keywords: ['goblin', 'scout', 'goblin scout'],
		itemDrops: [],
		gold: function () {
			return randomNumberRange(4, 6)
		},
		itemDropsRoll: function () {
		},
		id: function () {
			for (let i = 0; i < 50; i++) {
				if (!pushMonster[i]) {
					return i
				}
			}
		},
		enemyMove: function () {},
		enemyBehaviorInterval: undefined,
		behaviorInterval: false,
		mainInterval: 6000,
		enemyBehavior: function () {
			console.log(this)
			monsterBehavior(this)
		},
	}
	return woundedGoblinScout
}

function customizeEachWord(message, addClass, line) {
	const classOrClassArray = addClass
	let span = document.createElement('span') //string 1
	span.textContent = message
	if (Array.isArray(classOrClassArray)) {
		classOrClassArray.forEach(classToAdd => span.classList.add(classToAdd))
	} else {
		span.classList.add(classOrClassArray)
	}
	line.appendChild(span)
	masterArea.appendChild(line)
	updateScroll()
}

function customizeNPCDialogue(message, wordColor, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(wordColor)
	span.classList.add('bold')
	line.appendChild(span)
	masterArea.appendChild(line)
	updateScroll()
}
function customizeGameDialogue(message, wordColor, line) {
	let span = document.createElement('span') //string 1
	span.textContent = message
	span.classList.add(wordColor)
	span.classList.add('italic')
	line.appendChild(span)
	masterArea.appendChild(line)
	updateScroll()
}

//randomNumberRange(3, 10) will return range of numbers between 3 and 9. what is returned is (min, max -1) technically
function randomNumberRange(min, max) {
	return Math.floor(Math.random() * (max + 1 - min) + min)
}
function randomSingleNumber(maxNumber) {
	return Math.floor(Math.random() * maxNumber) + 1
}
function enemyLocation(directionMonsterComesInFrom) {}

function dragon() {
	let dragon = {
		randomItemDrops: Math.floor(Math.random() * 10) + 1,
		name: 'Dragon',
		level: 99,
		abilityName: 'Fire breath',
		abilityDamage: Math.floor(Math.random() * 187) + 1,
		itemDrops: function () {
			if (dragon.randomItemDrops < 3) {
				return dragonTooth + ', ' + dragonScale
			} else if (dragon.randomItemDrops < 5) {
				return dragonTooth
			} else if (dragon.randomItemDrops <= 5) {
				return dragonScale
			} else if (dragon.randomItemDrops > 5) {
				return dragonSword
			}
		},
	}
	return dragon
}

function startBehavior() {
	for (let i = 0; i < pushMonster.length; i++) {
		if (pushMonster[i].behaviorInterval == false) {
			pushMonster[i].enemyBehavior()
			pushMonster[i].behaviorInterval = true
		}
	}
}
class NPC {
	constructor() {}
}
//enemy class mob generator
function monsterGen(enemy) {
	if (pushMonster.length < 100) {
		this.isAlive = enemy.isAlive
		this.enemyMoveSpeed = enemy.enemyMoveSpeed
		this.shouldEngagePlayer = enemy.shouldEngagePlayer
		this.shouldAttackPlayer = enemy.shouldAttackPlayer
		this.damageCalculation = enemy.damageCalculation
		this.rangedAbilityCalculation = enemy.rangedAbilityCalculation
		this.meleeAbilityCalculation = enemy.meleeAbilityCalculation
		this.color = enemy.color
		this.picture = enemy.picture
		this.x = enemy.x()
		this.y = enemy.y()
		this.z = enemy.z()
		this.level = enemy.level
		this.con = enemy.con()
		this.entersTheRoomPhrase = enemy.entersTheRoomPhrase
		this.advancePhrase = enemy.advancePhrase
		this.desc = enemy.desc
		this.death = enemy.death
		this.deathPhrase = enemy.deathPhrase
		this.strikePhrase = enemy.strikePhrase
		this.swing = enemy.swing
		this.missPhrase = enemy.missPhrase
		this.rangedAttackPhrase = enemy.rangedAttackPhrase
		this.rangedMissPhrase = enemy.rangedMissPhrase
		this.entersExitsRoomPhrase = enemy.entersExitsRoomPhrase
		this.hostile = enemy.hostile
		this.combat = enemy.combat
		this.health = enemy.health()
		this.maxHealth = enemy.maxHealth()
		this.attackPower = enemy.attackPower()
		this.accuracy = enemy.accuracy()
		this.dodge = enemy.dodge()
		this.hitChance = enemy.hitChance
		this.damageTypes = enemy.damageTypes
		this.attackTypes = enemy.attackTypes
		this.baseExperience = enemy.baseExperience
		this.experience = enemy.experience()
		this.armor = enemy.armor
		this.slashingArmor = enemy.slashingArmor
		this.piercingArmor = enemy.piercingArmor
		this.bluntArmor = enemy.bluntArmor
		this.statusEffects = enemy.statusEffects
		this.roomId = enemy.roomId
		this.randomItemDrops = enemy.randomItemDrops
		this.name = enemy.name
		this.refName = enemy.refName
		this.keywords = enemy.keywords
		this.itemDrops = enemy.itemDrops
		this.gold = enemy.gold()
		this.itemDropsRoll = enemy.itemDropsRoll()
		this.id = enemy.id()
		this.enemyMove = enemy.enemyMove
		this.moveSwitch = enemy.moveSwitch
		this.enemyBehaviorInterval = enemy.enemyBehaviorInterval
		this.behaviorInterval = enemy.behaviorInterval
		this.mainInterval = enemy.mainInterval
		this.enemyBehavior = enemy.enemyBehavior
		pushMonster.push(
			new Monster(
				this.isAlive,
				this.enemyMoveSpeed,
				this.shouldEngagePlayer,
				this.shouldAttackPlayer,
				this.damageCalculation,
				this.rangedAbilityCalculation,
				this.meleeAbilityCalculation,
				this.color,
				this.picture,
				this.x,
				this.y,
				this.z,
				this.level,
				this.con,
				this.entersTheRoomPhrase,
				this.advancePhrase,
				this.desc,
				this.death,
				this.deathPhrase,
				this.strikePhrase,
				this.swing,
				this.missPhrase,
				this.rangedAttackPhrase,
				this.rangedMissPhrase,
				this.entersExitsRoomPhrase,
				this.hostile,
				this.combat,
				this.health,
				this.maxHealth,
				this.attackPower,
				this.accuracy,
				this.dodge,
				this.hitChance,
				this.damageTypes,
				this.attackTypes,
				this.baseExperience,
				this.experience,
				this.armor,
				this.slashingArmor,
				this.piercingArmor,
				this.bluntArmor,
				this.statusEffects,
				this.roomId,
				this.randomItemDrops,
				this.name,
				this.refName,
				this.keywords,
				this.itemDrops,
				this.gold,
				this.itemDropsRoll,
				this.id,
				this.enemyMove,
				this.moveSwitch,
				this.enemyBehaviorInterval,
				this.behaviorInterval,
				this.mainInterval,
				this.enemyBehavior
			)
		)
		if (enemy.x() == player.x && enemy.y() == player.y && enemy.z() == player.z) {
			let line1 = document.createElement('div')
			customizeEachWord(`${enemy.name} `, enemy.color, line1)
			customizeEachWord(`${enemy.entersTheRoomPhrase}`, 'white', line1)
		}
		startBehavior()
		updateMonsterBox()
	}

}

function updateMonsterBox() {
	updateRoomEnemies()
	let allEnemiesInRoom = roomEnemies
	let allMonsterBoxes = document.querySelectorAll('.monster-nameplate');
	allMonsterBoxes.forEach((monsterBox, index) => {
		let enemy = allEnemiesInRoom[index];
		if (enemy) {
			let monsterName = monsterBox.querySelector('.monster-name');
			let monsterPicture = monsterBox.querySelector('.monster-picture');
			let monsterHealthBar = monsterBox.querySelector('.enemy-health-bar');
			let monsterStatusEffects = monsterBox.querySelectorAll('#monster-status-effects');
			// Reset debuff slots
			monsterStatusEffects.forEach(debuffSlot => {
				debuffSlot.classList.remove(...debuffSlot.classList);
				debuffSlot.textContent = ''; // Reset debuff stack display
			});
	
			// Update name, picture, and health bar
			monsterName.textContent = enemy.name;
			monsterPicture.src = enemy.picture;
			monsterHealthBar.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
	
			// Update debuffs
			if (enemy.debuffs) {
				Object.keys(enemy.debuffs).forEach((debuffName, debuffIndex) => {
					let debuffSlot = monsterStatusEffects[debuffIndex];
					if (debuffSlot) {
						if (!debuffSlot.classList.contains(debuffName)) {
							debuffSlot.classList = `${debuffName}`;
						}
						// Update debuff stack display
						if (enemy.debuffs[debuffName].stacks) {
							debuffSlot.textContent = enemy.debuffs[debuffName].stacks;
						}
					}
				});
			}
		}
	});
	if (allEnemiesInRoom.length === 0) {
		allMonsterBoxes.forEach(box => box.classList.add('hide'));
	} else {
		allMonsterBoxes.forEach((box, index) => {
			if (index < allEnemiesInRoom.length) {
				box.classList.remove('hide');
			} else {
				box.classList.add('hide');
			}
		});
	}



	// for (let i = 0; i < allEnemiesInRoom.length; i++) {
	// 	if (allMonsterNamePlates[i]) {
	// 		allMonsterNamePlates[i].textContent = allEnemiesInRoom[i].name
	// 		allMonsterPictureBox[i].src = allEnemiesInRoom[i].picture
	// 	}
	// 	if (allMonsterHealthBars[i]) {
	// 		allMonsterHealthBars[i].style.width = `${allEnemiesInRoom[i].health / allEnemiesInRoom[i].maxHealth * 100}%`
	// 	}
	// }
}
function tester() {
	console.log('too many?')
}
function isThereAUniqueItem(uniqueItemToCheck) {
	return pushItem.some(item => item.refName == uniqueItemToCheck) || pushMonster.some(monster => monster.itemDrops.some(item => item.refName == uniqueItemToCheck))
}


class Monster {
	constructor(
		isAlive,
		enemyMoveSpeed,
		shouldEngagePlayer,
		shouldAttackPlayer,
		damageCalculation,
		rangedAbilityCalculation,
		meleeAbilityCalculation,
		color,
		picture,
		x,
		y,
		z,
		level,
		con,
		entersTheRoomPhrase,
		advancePhrase,
		desc,
		death,
		deathPhrase,
		strikePhrase,
		swing,
		missPhrase,
		rangedAttackPhrase,
		rangedMissPhrase,
		entersExitsRoomPhrase,
		hostile,
		combat,
		health,
		maxHealth,
		attackPower,
		accuracy,
		dodge,
		hitChance,
		damageTypes,
		attackTypes,
		baseExperience,
		experience,
		armor,
		slashingArmor,
		piercingArmor,
		bluntArmor,
		statusEffects,
		roomId,
		randomItemDrops,
		name,
		refName,
		keywords,
		itemDrops,
		gold,
		itemDropsRoll,
		id,
		enemyMove,
		moveSwitch,
		enemyBehaviorInterval,
		behaviorInterval,
		mainInterval,
		enemyBehavior
	) {
		this.isAlive = isAlive
		this.enemyMoveSpeed = enemyMoveSpeed
		this.shouldEngagePlayer = shouldEngagePlayer
		this.shouldAttackPlayer = shouldAttackPlayer
		this.damageCalculation = damageCalculation
		this.rangedAbilityCalculation = rangedAbilityCalculation
		this.meleeAbilityCalculation = meleeAbilityCalculation
		this.color = color
		this.picture = picture
		this.x = x
		this.y = y
		this.z = z
		this.level = level
		this.con = con
		this.entersTheRoomPhrase = entersTheRoomPhrase
		this.advancePhrase = advancePhrase
		this.desc = desc
		this.death = death
		this.deathPhrase = deathPhrase
		this.strikePhrase = strikePhrase
		this.swing = swing
		this.missPhrase = missPhrase
		this.rangedAttackPhrase = rangedAttackPhrase
		this.rangedMissPhrase = rangedMissPhrase
		this.entersExitsRoomPhrase = entersExitsRoomPhrase
		this.hostile = hostile
		this.combat = combat
		this.health = health
		this.maxHealth = maxHealth
		this.attackPower = attackPower
		this.accuracy = accuracy
		this.dodge = dodge
		this.hitChance = hitChance
		this.damageTypes = damageTypes
		this.attackTypes = attackTypes
		this.baseExperience = baseExperience
		this.experience = experience
		this.armor = armor
		this.slashingArmor = slashingArmor
		this.piercingArmor = piercingArmor
		this.bluntArmor = bluntArmor
		this.statusEffects = statusEffects
		this.roomId = roomId
		this.randomItemDrops = randomItemDrops
		this.name = name
		this.refName = refName
		this.keywords = keywords
		this.itemDrops = itemDrops
		this.gold = gold
		this.itemDropsRoll = itemDropsRoll
		this.id = id
		this.enemyMove = enemyMove
		this.moveSwitch = moveSwitch
		this.enemyBehaviorInterval = enemyBehaviorInterval
		this.behaviorInterval = behaviorInterval
		this.mainInterval = mainInterval
		this.enemyBehavior = enemyBehavior
	}
}

//QUEST ITEMS/SELLABLES/CRAFTING MATERIALS
//FOOD
//WEAPON GEN
//ARMOR GEN
function treasureGen(item) {
	this.id = item.id()
	this.roomId = item.roomId
	this.name = item.name
	this.refName = item.refName
	this.color = item.color
	this.keywords = item.keywords
	this.itemDrops = item.itemDrops
	this.spillContents = item.spillContents
	this.type = item.type
	this.sellValue = item.sellValue
	this.description = item.description
	this.desc = item.desc
	pushItem.push(new ChestItem(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.itemDrops, this.spillContents, this.type, this.sellValue, this.description, this.desc))
}

class ChestItem {
	constructor(id, roomId, name, refName, color, keywords, itemDrops, spillContents, type, sellValue, description, desc) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.itemDrops = itemDrops
		this.spillContents = spillContents
		this.type = type
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
	}
}
function questItemGen(item) {
	pushItem.push(item)
}
// function questItemGen(item) {
// 	this.id = item.id()
// 	this.roomId = item.roomId
// 	this.name = item.name
// 	this.refName = item.refName
// 	this.color = item.color
// 	this.keywords = item.keywords
// 	this.type = item.type
// 	this.sellValue = item.sellValue
// 	this.description = item.description
// 	this.desc = item.desc
// 	pushItem.push(new QuestItem(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.sellValue, this.description, this.desc))
// }
class QuestItem {
	constructor(id, roomId, name, refName, color, keywords, type, sellValue, description, desc) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
	}
}

function craftingMaterialGen(item) {
	this.id = item.id()
	this.tier = item.tier
	this.increase = item.increase
	this.roomId = item.roomId
	this.name = item.name
	this.refName = item.refName
	this.color = item.color
	this.keywords = item.keywords
	this.type = item.type
	this.sellValue = item.sellValue
	this.description = item.description
	this.desc = item.desc
	pushItem.push(new craftingMaterial(this.id, this.tier, this.increase, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.sellValue, this.description, this.desc))
}
class craftingMaterial {
	constructor(id, tier, increase, roomId, name, refName, color, keywords, type, sellValue, description, desc) {
		this.id = id
		this.tier = tier
		this.increase = increase
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
	}
}



function foodGen(food) {
	this.id = food.id()
	this.roomId = food.roomId
	this.name = food.name
	this.refName = food.refName
	this.color = food.color
	this.keywords = food.keywords
	this.type = food.type
	this.cookable = food.cookable
	this.cookedVersion = food.cookedVersion
	this.cookPhrase = food.cookPhrase
	this.buff = food.buff
	this.desc = food.desc
	this.price = food.price
	this.sellValue = food.sellValue
	pushItem.push(new Food(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.cookable, this.cookedVersion, this.cookPhrase, this.buff, this.desc, this.price, this.sellValue))
} 
class Food {
	constructor(id, roomId, name, refName, color, keywords, type, cookable, cookedVersion, cookPhrase, buff, desc, price, sellValue) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.cookable = cookable
		this.cookedVersion = cookedVersion
		this.cookPhrase = cookPhrase
		this.buff = buff
		this.desc = desc
		this.price = price
		this.sellValue = sellValue
	}
}

function fishItemGen(fish) {
	this.id = fish.id()
	this.roomId = fish.roomId
	this.name = fish.name
	this.refName = fish.refName
	this.color = fish.color
	this.keywords = fish.keywords
	this.type = fish.type
	this.cookable = fish.cookable
	this.cookedVersion = fish.cookedVersion
	this.cookPhrase = fish.cookPhrase
	this.buff = fish.buff
	this.description = fish.description
	this.desc = fish.desc
	this.price = fish.price
	this.sellValue = fish.sellValue
	this.timeTilBite = fish.timeTilBite
	this.speed = fish.speed
	this.catchRange = fish.catchRange
	pushItem.push(new Fish(this.id, this.roomId, this.name, this.refName, this.color, this.keywords, this.type, this.cookable, this.cookedVersion, this.cookPhrase, this.buff, this.description, this.desc, this.price, this.sellValue, this.timeTilBite, this.speed, this.catchRange))
} 
class Fish {
	constructor(id, roomId, name, refName, color, keywords, type, cookable, cookedVersion, cookPhrase, buff, description, desc, price, sellValue, timeTilBite, speed, catchRange) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.refName = refName
		this.color = color
		this.keywords = keywords
		this.type = type
		this.cookable = cookable
		this.cookedVersion = cookedVersion
		this.cookPhrase = cookPhrase
		this.buff = buff
		this.description = description
		this.desc = desc
		this.price = price
		this.sellValue = sellValue
		this.timeTilBite = timeTilBite
		this.speed = speed
		this.catchRange = catchRange
	}
}




function weaponGen(weapon) {
	pushItem.push(weapon)
}
function spawnItem(item) {
	pushItem.push(item)
}
class Weapon {
	constructor(isShopItem, id, roomId, name, picture, color, keywords, topDamage, botDamage, mods, requirements, type, enchantment, skillUsed, price, sellValue, description, desc, swing) {
		this.isShopItem = isShopItem
		this.id = id
		this.roomId = roomId
		this.name = name
		this.picture = picture
		this.color = color
		this.keywords = keywords
		this.topDamage = topDamage
		this.botDamage = botDamage
		this.mods = mods
		this.requirements = requirements
		this.type = type
		this.enchantment = enchantment
		this.skillUsed = skillUsed
		this.price = price
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
		this.swing = swing
		this.miss = miss
	}
}
function armorGen(armor) {
	pushItem.push(armor)
}
// function armorGen(armor) {
// 	this.isShopItem = armor.isShopItem
// 	this.id = armor.id()
// 	this.roomId = armor.roomId
// 	this.name = armor.name
// 	this.picture = armor.picture
// 	this.color = armor.color
// 	this.keywords = armor.keywords
// 	this.mods = armor.mods
// 	this.requirements = armor.requirements
// 	this.type = armor.type
// 	this.price = armor.price
// 	this.sellValue = armor.sellValue
// 	this.description = armor.description
// 	this.slot = armor.slot
// 	this.desc = armor.desc
// 	pushItem.push(new Armor(this.isShopItem, this.id, this.roomId, this.name, this.picture, this.color, this.keywords, this.mods, this.requirements, this.type, this.price, this.sellValue, this.description, this.slot, this.desc))
// }
class Armor {
	constructor(isShopItem, id, roomId, name, picture, color, keywords, mods, requirements, type, price, sellValue, description, slot, desc) {
		this.isShopItem = isShopItem
		this.id = id
		this.roomId = roomId
		this.name = name
		this.picture = picture
		this.color = color
		this.keywords = keywords
		this.mods = mods
		this.requirements = requirements
		this.type = type
		this.price = price
		this.sellValue = sellValue
		this.description = description
		this.slot = slot
		this.desc = desc
	}
}

function consumableGen(consumable) {
	this.id = consumable.id()
	this.roomId = consumable.roomId
	this.name = consumable.name
	this.color = consumable.color
	this.keywords = consumable.keywords
	this.activate = consumable.activate
	this.type = consumable.type
	this.price = consumable.price
	this.sellValue = consumable.sellValue
	this.description = consumable.description
	this.desc = consumable.desc
	pushItem.push(
		new Consumable(
			this.id,
			this.roomId,
			this.name,
			this.color,
			this.keywords,
			this.activate,
			this.type,
			this.price,
			this.sellValue,
			this.description,
			this.desc
		)
	)
}

class Consumable {
	constructor(id, roomId, name, color, keywords, activate, type, price, sellValue, description, desc) {
		this.id = id
		this.roomId = roomId
		this.name = name
		this.color = color
		this.keywords = keywords
		this.activate = activate
		this.type = type
		this.price = price
		this.sellValue = sellValue
		this.description = description
		this.desc = desc
	}
}




function spawnObject(secondCommand) {
	if (secondCommand == 'hellguardian') {
		monsterGen(hellGuardian(currentArea))
	}
}

function speak(secondCommand) {
	console.log('SPEAK')
	let validNpcs = currentArea.npc
	const specifiedNpc = validNpcs.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	console.log(specifiedNpc)
	if (validNpcs.length == 1) {
		validNpcs[0].speak()
	} else if (validNpcs) {
		if (secondCommand == undefined) {
			quickMessage(`You must specify who you want to talk to`)
		} else if (specifiedNpc == undefined) {
			quickMessage(`You do not see anyone here named ${secondCommand} to speak to`)
		} else if (specifiedNpc && specifiedNpc.speak) {
			specifiedNpc.speak()
		} else {
			let line1 = document.createElement('div')
			customizeEachWord(`${specifiedNpc.name} `, specifiedNpc.nameColor, line1)
			customizeEachWord(`will not speak to you `, 'white', line1)
		}
	}
}

function enemySpawn() {

}

function displayNPCName(peopleDiv, npc) {
	const npcDiv = document.createElement('div')
	const firstNameSpan = document.createElement('span')
	const firstNameNode = document.createTextNode(`${npc.name}`)
	if (npc.prefix != null) {
		const prefixSpan = document.createElement('span')
		const prefixNode = document.createTextNode(`${npc.prefix}`)
		prefixSpan.classList.add(npc.prefixColor)
		prefixSpan.appendChild(prefixNode)
		npcDiv.appendChild(prefixSpan)
	}

	firstNameSpan.classList.add(npc.nameColor)
	firstNameSpan.appendChild(firstNameNode)
	npcDiv.appendChild(firstNameSpan)

	if (npc.suffix != null) {
		const suffixSpan = document.createElement('span')
		const suffixNode = document.createTextNode(`${npc.suffix}`)
		suffixSpan.classList.add(npc.suffixColor)
		suffixSpan.appendChild(suffixNode)
		npcDiv.appendChild(suffixSpan)
	}
	if (npc.isQuestAvailable || npc.questStage > 0) {
		const QSpan = document.createElement('span')
		const QNode = document.createTextNode(` (Q)`)
		QSpan.appendChild(QNode)
		npcDiv.appendChild(QSpan)
	}
	peopleDiv.appendChild(npcDiv)
}

function npcsAll() {
	return currentArea.npc
}
function npcByName(secondCommand) {
	return npcsAll().find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	
}
function npcByNumber() {}






//EXAMINE FUNCITON - for examining items in backpack, held, and equipped
function inspect(secondCommand, thirdCommand) {
	let allItemsOnPerson = pushItem.filter(
		item =>
			item.roomId == 'right hand' ||
			item.roomId == 'left hand' ||
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet' ||
			item.roomId == 'backpack'
	)
	let allItemsEquipped = allItemsOnPerson.filter(
		item =>
			item.roomId == 'right ring' ||
			item.roomId == 'left ring' ||
			item.roomId == 'head' ||
			item.roomId == 'necklace' ||
			item.roomId == 'shoulders' ||
			item.roomId == 'chest' ||
			item.roomId == 'back' ||
			item.roomId == 'hands' ||
			item.roomId == 'waist' ||
			item.roomId == 'legs' ||
			item.roomId == 'feet'
	)
	let rightHandItem = allItemsOnPerson.find(item => item.roomId == 'right hand')
	let leftHandItem = allItemsOnPerson.find(item => item.roomId == 'left hand')
	let allItemsHeld = []
	allItemsHeld.push(rightHandItem, leftHandItem)

	let equippedItemsMapped = allItemsEquipped.map(item => item.roomId)

	let targetItemsOnPerson = allItemsOnPerson.filter(item => item.keywords.find(keyword => keyword == secondCommand))
	targetItemsOnPerson.sort((a, b) => (a.name > b.name ? 1 : -1))

	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack') //Every item in backpack - not held or equipped
	allItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))

	let targetItemsInBackpack = pushItem.filter(item => item.keywords.find(keyword => keyword == secondCommand) && item.roomId == 'backpack') //array of items on person that matches the item's keyword
	targetItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))

	if (secondCommand == undefined || /^\s*$/.test(secondCommand) == true) {
		console.log(1)
		quickMessage(`You must specify what you want to examine.`)
	} else if (secondCommand == 'left' && leftHandItem != undefined) {
		console.log(2)
		findAny(leftHandItem)
	} else if (secondCommand == 'right' && rightHandItem != undefined) {
		console.log(3)
		findAny(rightHandItem)
	} else if (secondCommand == 'left' && leftHandItem == undefined) {
		console.log(4)
		quickMessage(`You do not have anything in your left hand to examine.`)
	} else if (secondCommand == 'right' && rightHandItem == undefined) {
		console.log(5)
		quickMessage(`You do not have anything in your right hand to examine.`)
	} else if (isNaN(secondCommand) && secondCommand != undefined && targetItemsOnPerson[0] == undefined) {
		console.log(6)
		quickMessage(`You do not have a ${secondCommand} in your backpack to examine`) //add a way for it to say a or an ${secondCommand} depending on if it starts with a vowel or not
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] == undefined) {
		console.log(7)
		quickMessage(`You do not have an item in that slot to examine.`)
	} else if (!isNaN(thirdCommand) && targetItemsInBackpack[thirdCommand - 1] == undefined) {
		console.log(8)
		quickMessage(`You do not have an item in that slot to examine.`)
	} else if (!isNaN(secondCommand) && allItemsInBackpack[secondCommand - 1] != undefined) {
		console.log(9)
		findAny(allItemsInBackpack[secondCommand - 1], allItemsInBackpack)
	} else if (targetItemsOnPerson[0] != undefined && targetItemsOnPerson[1] == undefined && isNaN(thirdCommand)) {
		console.log(10)
		findAny(targetItemsOnPerson[0])
	} else if (allItemsHeld[0] != undefined && allItemsHeld[1] != undefined) {
		console.log(12)
		findAny(allItemsHeld[0])
	} else if (allItemsHeld[0] == undefined && allItemsHeld[1] != undefined && player[allItemsHeld[1].slot] == empty) {
		console.log(13)
		findAny(allItemsHeld[1])
	} else if (!isNaN(thirdCommand) == true && thirdCommand != undefined && targetItemsInBackpack[thirdCommand - 1] != undefined) {
		console.log(targetItemsInBackpack[thirdCommand - 1])
		findAny(targetItemsInBackpack[thirdCommand - 1], allItemsInBackpack)
	} else if (targetItemsOnPerson[0] != undefined && targetItemsOnPerson[1] != undefined) {
		console.log(15)
		if (rightHandItem != undefined && rightHandItem.keywords.find(keyword => keyword == secondCommand) != undefined) {
			console.log(16)
			findAny(rightHandItem)
		} else if (leftHandItem != undefined && leftHandItem.keywords.find(keyword => keyword == secondCommand) != undefined) {
			console.log(17)
			findAny(leftHandItem)
		} else {
			quickMessage(`You must specify which ${secondCommand} you want to examine.`)
		}
		let itemEquipped
		let isItemEquipped
		targetItemsOnPerson.forEach(item => {
			if (equippedItemsMapped.includes(item.roomId)) {
				console.log(18)
				itemEquipped = item
				isItemEquipped = true
			} else if (allItemsHeld.includes(item.roomId)) {
				console.log(19)
				itemEquipped = item
				isItemEquipped = true
			}
		})
		if (isItemEquipped == true) {
			findAny(itemEquipped)
		} else if (isItemEquipped == false) {
			console.log(20)
			quickMessage(`You must specify which ${secondCommand} you want to examine.`)
		} else {
			console.log(21)
		}
	}
}
// function findItemInRoom(secondCommand, thirdCommand) {
// 	let allItemsInBackpack = pushItem.filter(items => items.roomId == backpack)
// 	let itemInRightHand = pushItem.filter(item => item.roomId == rightHand)
// 	let itemInLeftHand = pushItem.filter(item => item.roomId == leftHand)

// 	let allItemsInRoom = pushItem.filter(items => items.roomId == currentArea.id)
// 	let allSpecifiedItemsInRoom = allItemsInRoom.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
// 	let itemObject = allItemsInRoom.find(({ keywords }) => keywords.some(x => x == secondCommand))
// 	if (thirdCommand != undefined && isNaN(thirdCommand) == false) {
// 		if (allSpecifiedItemsInRoom[thirdCommand - 1] != undefined) {
// 			if (allSpecifiedItemsInRoom[thirdCommand - 1].type.weapon) {
// 				findWeapon(allSpecifiedItemsInRoom[thirdCommand - 1])
// 			} else if (allSpecifiedItemsInRoom[thirdCommand - 1].type.armor) {
// 				findArmor(allSpecifiedItemsInRoom[thirdCommand - 1])
// 			}
// 		} else {
// 			quickMessage(`You do not own that number of ${itemObject.name}`)
// 		}
// 	} else if (itemObject != undefined) {
// 		if (allSpecifiedItemsInRoom[0].type.weapon) {
// 			findWeapon(allSpecifiedItemsInRoom[0])
// 		} else if (allSpecifiedItemsInRoom[0].type.armor) {
// 			findArmor(allSpecifiedItemsInRoom[0])
// 		}
// 	} else {
// 		return false
// 	}
// }

//INSPECT FUNCITON - for examining items equipped or in backpack
function findItemInBackpack(command, secondCommand, thirdCommand) {
	let allItemsInBackpack = pushItem.filter(items => items.roomId == backpack)
	let itemInRightHand = pushItem.filter(item => item.roomId == rightHand)
	let itemInLeftHand = pushItem.filter(item => item.roomId == leftHand)
	let allItemsInBackpackAndEquipped = pushItem.filter(items => {
		let nonNumId
		if (isNaN(items.roomId) == true) return items
	})

	let allSpecifiedItemsInRoom = allItemsInBackpack.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	let itemObject = allItemsInRoom.find(({ keywords }) => keywords.some(x => x == secondCommand))
	if (thirdCommand != undefined && isNaN(thirdCommand) == false) {
		if (allSpecifiedItemsInRoom[thirdCommand - 1] != undefined) {
			if (allSpecifiedItemsInRoom[thirdCommand - 1].type.weapon) {
				findWeapon(allSpecifiedItemsInRoom[thirdCommand - 1])
			} else if (allSpecifiedItemsInRoom[thirdCommand - 1].type.armor) {
				findArmor(allSpecifiedItemsInRoom[thirdCommand - 1])
			}
		} else {
			quickMessage(`You do not own that number of ${itemObject.name}`)
		}
	} else if (itemObject != undefined) {
		if (allSpecifiedItemsInRoom[0].type.weapon) {
			findWeapon(allSpecifiedItemsInRoom[0])
		} else if (allSpecifiedItemsInRoom[0].type.armor) {
			findArmor(allSpecifiedItemsInRoom[0])
		}
	} else {
		return false
	}
}

//EXAMINE FUNCITON - for examining items on person
function findItemOnPerson(secondCommand, thirdCommand) {
	let allItemsInBackpack = pushItem.filter(items => items.roomId == backpack)
	let itemInRightHand = pushItem.filter(item => item.roomId == rightHand)
	let itemInLeftHand = pushItem.filter(item => item.roomId == leftHand)

	let allSpecifiedItemsInRoom = allItemsInBackpack.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	let itemObject = allItemsInRoom.find(({ keywords }) => keywords.some(x => x == secondCommand))
	if (thirdCommand != undefined && isNaN(thirdCommand) == false) {
		if (allSpecifiedItemsInRoom[thirdCommand - 1] != undefined) {
			if (allSpecifiedItemsInRoom[thirdCommand - 1].type.weapon) {
				findWeapon(allSpecifiedItemsInRoom[thirdCommand - 1])
			} else if (allSpecifiedItemsInRoom[thirdCommand - 1].type.armor) {
				findArmor(allSpecifiedItemsInRoom[thirdCommand - 1])
			}
		} else {
			quickMessage(`You do not own that number of ${itemObject.name}`)
		}
	} else if (itemObject != undefined) {
		if (allSpecifiedItemsInRoom[0].type.weapon) {
			findWeapon(allSpecifiedItemsInRoom[0])
		} else if (allSpecifiedItemsInRoom[0].type.armor) {
			findArmor(allSpecifiedItemsInRoom[0])
		}
	} else {
		return false
	}
}

function findAny(item) {
	let targetItem = item
	let allItemsInBackpack = pushItem.filter(item => item.roomId == 'backpack')
	allItemsInBackpack.sort((a, b) => (a.name > b.name ? 1 : -1))
	console.log(targetItem, 'TARGET ITEM')
	console.log(allItemsInBackpack, 'ALL ITEMS IN BACKPACK')
	let itemSlot = () => {
		if (targetItem.roomId == 'backpack') {
			return `Backpack slot ${allItemsInBackpack.indexOf(targetItem) + 1}`
		} else if (item.roomId == 'right hand') {
			return 'right hand'
		} else if (item.roomId == 'left hand') {
			return 'left hand'
		} else {
			return item.roomId
		}
	}
	console.log(targetItem, ' TARGET ITEM')
	console.log(targetItem.type, ' ITEM TYPE')
	let isWeapon = item.type['weapon'] != undefined ? item : undefined
	let isArmor = item.type['armor'] != undefined ? item : undefined
	let isShield = item.type['shield'] != undefined ? item : undefined
	let isConsumable = item.type.weapon != undefined ? item : undefined
	let isQuest = item.type.quest != undefined ? item : undefined
	if (isWeapon != undefined) {
		item.desc(itemSlot(), item.botDamage, item.topDamage, item.name, item.mods)
	} else if (isArmor != undefined) {
		item.desc(itemSlot(), item.name, item.mods, item.id)
	} else if (isShield != undefined) {
		item.desc(itemSlot() + ' slot ' + itemSlot(), item.name, item.mods)
	} else if (isConsumable != undefined) {
		item.desc(/*consumable info*/)
	} else if (isQuest) {
		item.desc(/*quest info*/)
	} else {
		item.desc()
	}
}

function showItemDescription(item) {
	let itemValues = Object.values(item)
	let itemKeys = Object.keys(item)
	for (let i = 0; i < itemKeys.length; i++) {
		if (itemValues[i] != 0) {
			if (itemKeys[i] == 'armor') {
				let textDiv = document.createElement('div')
				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
				textDiv.appendChild(textNode)
				masterArea.appendChild(textDiv)
			} else {
				let textDiv = document.createElement('div')
				let textNode = document.createTextNode(`${itemKeys[i]}: ${itemValues[i]}`)
				textDiv.appendChild(textNode)
				masterArea.appendChild(textDiv)
			}
		}
	}
}
//INSPECT FUNCTION - for inspecting items only in your inventory or that you're wielding/wearing
function findItemInventory(secondCommand, thirdCommand) {
	let allInventory = pushItem.filter(allItems => isNaN(allItems.roomId))
	let allSpecifiedInventory = allInventory.filter(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	let targetItem = allSpecifiedInventory.find(target => target.roomId == 'right hand' || target.roomId == 'left hand' || target.keywords.find(keyword => keyword == secondCommand))
	let targetItemRightHand = allSpecifiedInventory.find(target => target.roomId == 'right hand')
	let targetItemLeftHand = allSpecifiedInventory.find(target => target.roomId == 'left hand')
	let targetItemInBackpack = allInventory.find(target => target.keywords.find(keyword => keyword == secondCommand))
	if (thirdCommand != undefined && !isNaN(thirdCommand)) {
		if (allSpecifiedInventory[thirdCommand - 1] != undefined) {
			return allSpecifiedInventory[thirdCommand - 1].desc(allSpecifiedInventory[thirdCommand - 1].botDamage, allSpecifiedInventory[thirdCommand - 1].topDamage, allSpecifiedInventory[thirdCommand - 1].roomId)
		} else if (thirdCommand == undefined && isNaN(thirdCommand) == true) {
			quickMessage(`You do not own that number of ${targetItem.name}`)
		}
	} else if (targetItemRightHand != undefined) {
		console.log('inspect right hand')
		return targetItemRightHand.desc(targetItemRightHand.id, targetItemRightHand.botDamage, targetItemRightHand.topDamage, targetItemRightHand.roomId)
	} else if (targetItemLeftHand != undefined) {
		console.log('inspect left hand')
		return targetItemLeftHand.desc(targetItemLeftHand.botDamage, targetItemLeftHand.topDamage, targetItemLeftHand.roomId)
	} else if (targetItemInBackpack != undefined) {
		console.log('inspect in backpack')
		return targetItemInBackpack.desc(targetItemInBackpack.botDamage, targetItemInBackpack.topDamage, targetItemInBackpack.roomId)
	}
}

function examine(secondCommand, thirdCommand) {
	let allItemsInRoom = pushItem.filter(items => items.roomId == currentArea.id)
	let allSpecifiedItemsInRoom = allItemsInRoom.filter(items => items.keywords.find(keyword => keyword == secondCommand))
	let firstSpecifiedItem = allSpecifiedItemsInRoom[0] != undefined ? allSpecifiedItemsInRoom.find(item => item.keywords.find(keyword => keyword == secondCommand)) : undefined
	let specifiedByNumber = allSpecifiedItemsInRoom[1] != undefined ? allSpecifiedItemsInRoom.filter(item => item.keywords.filter(keyword => keyword == secondCommand))[thirdCommand - 1] : undefined
	let firstMonsterInRoom = pushMonster.find(enemy => currentArea.id == enemy.roomId)
	let specifiedEnemy = pushMonster.find(({ keywords }) => keywords.some(keyword => keyword == secondCommand))
	console.log(firstMonsterInRoom, ' FIRST MONSTER IN THE ROOM')
	let roomInteractable = currentArea.interactables && currentArea.interactables[secondCommand] != undefined ? currentArea.interactables[secondCommand] : undefined
	//inspects object from the room description
	if (specifiedEnemy) {
		specifiedEnemy.desc() 
		return
	}
	if (roomInteractable && roomInteractable.names.find(name => name == secondCommand) != undefined) {
		roomInteractable.desc(secondCommand)
	}
	//inspects NPC
	else if (currentArea.npc[0] != undefined && currentArea.npc.find(npc => npc.keywords.find(keyword => keyword == secondCommand))) {
		let npc = currentArea.npc.find(npc => npc.keywords.find(keyword => keyword == secondCommand))
		npc.desc()
	} else if (firstMonsterInRoom != undefined && firstMonsterInRoom.keywords.find(keyword => keyword == secondCommand)) {
		firstMonsterInRoom.desc()

		//inspects item on the ground
	} else if (secondCommand == undefined || /^\s*$/.test(secondCommand) == true) {
		quickMessage(`You must specify what you want to inspect.`)
	} else if (!isNaN(secondCommand) && allItemsInRoom[secondCommand - 1] == undefined) {
		quickMessage(`You do not see that number of item to inspect.`)
	} else if (!isNaN(secondCommand) && allItemsInRoom[secondCommand - 1] != undefined) {
		findAny(allItemsInRoom[secondCommand - 1])
	} else if (firstSpecifiedItem == undefined) {
		quickMessage(`You do not see a ${secondCommand} to inspect.`)
	} else if (allSpecifiedItemsInRoom == undefined) {
		quickMessage(`You do not see a ${secondCommand} to inspect`)
	} else if (!isNaN(thirdCommand) == true && allSpecifiedItemsInRoom[thirdCommand - 1] == undefined) {
		quickMessage(`You do not see that number of ${secondCommand} to inspect.`)
	} else if (firstSpecifiedItem != undefined && specifiedByNumber == undefined) {
		console.log('first')
		findAny(firstSpecifiedItem)
	} else if (specifiedByNumber != undefined && !isNaN(thirdCommand) == true) {
		console.log('second')
		findAny(specifiedByNumber)
	}
}

function colorText() {
	const span1 = document.createElement('span')
	const textNode = document.createTextNode('damage')
}

let preRace = {
	maxHealth: 0,
	healthPerLevel: 0,
	healthPerCON: 0,

	maxMana: 0,
	manaPerLevel: 0,
	manaPerWIS: 0,
	str: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	mys: 0,
	con: 0,
	oneHanded: 0,
	twoHanded: 0,
	daggers: 0,
	unarmed: 0,
	bows: 0,
	shields: 0,
	lockpicking: 0,
	tactics: 0,
	vigilance: 0,
	initiation: 0,
	fleetFooted: 0,
	toughness: 0,
	dodging: 0,
	stealth: 0,
	ridingSkill: 0,
	rest: 0,
	perception: 0,
	athletics: 0,
	vigor: 0,
	devotion: 0,
	fireflames: 0,
	frostfreeze: 0,
	flashbolt: 0,
}

let preClass = {
	maxHealth: 0,
	healthPerLevel: 0,
	healthPerCON: 0,

	maxMana: 0,
	manaPerLevel: 0,
	manaPerWIS: 0,
	str: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	mys: 0,
	con: 0,
	oneHanded: 0,
	twoHanded: 0,
	daggers: 0,
	unarmed: 0,
	bows: 0,
	shields: 0,
	lockpicking: 0,
	tactics: 0,
	vigilance: 0,
	initiation: 0,
	fleetFooted: 0,
	toughness: 0,
	dodging: 0,
	stealth: 0,
	ridingSkill: 0,
	rest: 0,
	perception: 0,
	athletics: 0,
	vigor: 0,
	devotion: 0,
	fireflames: 0,
	frostfreeze: 0,
	flashbolt: 0,
}

let playerBaseStats = {
	maxHealth: 0,
	health: 0,
	maxMana: 0,
	mana: 0,

	healthMultiplier: 0,
	manaMultiplier: 0,

	raceHealthMultiplier: 0,
	manaMultiplier: 0,

	str: 0,
	con: 0,
	dex: 0,
	agi: 0,
	int: 0,
	wis: 0,
	get advanceTimer() {
		player.advanceTimer = Math.min(player.advanceTimer, player.advanceTimer - player.initiation.reduction())
	},
	get retreatTimer() {
		player.retreatTimer = Math.min(player.retreatTimer + player.debuffMods.retreatTimer, player.retreatTimer - player.fleetFooted.reduction() + player.debuffMods.retreatTimer)
	},	
	twoHanded: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	oneHanded: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	unarmed: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	daggers: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	bows: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
	dualWield: {
		level: 0,
		speed: 0,
		topMultiplier: 0,
	},
}

function removePreClassStats() {
	let preClassKeys = Object.keys(playerBaseStats)
	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			player[stat] = player[stat] - preClass[stat]
		}
	})

	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			player[stat].level = player[stat].level - preClass[stat].level
			player[stat].speed = player[stat].speed - preClass[stat].speed
		}
	})
}
function addPreClassStats() {
	let preClassKeys = Object.keys(playerBaseStats)
	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			console.log(player['maxHealth'], ' PLAYER MAX HEALTH')
			console.log(preClass['maxHealth'], ' PRECLASS MAX HEALTH')
			player[stat] = player[stat] + preClass[stat]
			console.log(player['maxHealth'], ' PLAYER MAX HEALTH')
			console.log(preClass['maxHealth'], ' PRECLASS MAX HEALTH')
		}
	})

	preClassKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			console.log(player[stat].speed, `PLAYER ${stat} STAT BEFORE`)
			player[stat].level = player[stat].level + preClass[stat].level
			player[stat].speed = player[stat].speed + preClass[stat].speed
			console.log(player[stat].speed, `PLAYER ${stat} STAT AFTER`)
		}
	})
}
function removePreRaceStats() {
	let preRaceKeys = Object.keys(playerBaseStats)
	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			player[stat] = player[stat] - preRace[stat]
		}
	})

	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			player[stat].level = player[stat].level - preRace[stat].level
			player[stat].speed = player[stat].speed - preRace[stat].speed
		}
	})
}
function addPreRaceStats() {
	let preRaceKeys = Object.keys(playerBaseStats)
	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] != 'object') {
			player[stat] = player[stat] + preRace[stat]
		}
	})

	preRaceKeys.forEach(stat => {
		if (typeof playerBaseStats[stat] == 'object') {
			player[stat].level = player[stat].level + preRace[stat].level
			player[stat].speed = player[stat].speed + preRace[stat].speed
		}
	})
}

function removeStartingClassSkills() {
	for (let statOrSkill in preClass) {
		preClass[statOrSkill] = 0
	}
	// preClass.healthPerLevel = 0

	// preClass.str = 0
	// preClass.dex = 0
	// preClass.agi = 0
	// preClass.int = 0
	// preClass.wis = 0
	// preClass.mys = 0
	// preClass.con = 0
	// //weapon skills
	// preClass.unarmed = 0
	// preClass.oneHanded = 0
	// preClass.twoHanded = 0
	// preClass.daggers = 0
	// preClass.bows = 0
	// preClass.shields = 0
	// //secondary skills
	// preClass.stealth = 0
	// preClass.dodge = 0
	// //spells
	// preClass.fireflames = 0
	// preClass.frostfreeze = 0
	// preClass.flashbolt = 0
}
function removeStartingRaceSkills() {
	for (let statOrSkill in preRace) {
		preRace[statOrSkill] = 0
	}
	// preRace.str = 0
	// preRace.dex = 0
	// preRace.agi = 0
	// preRace.int = 0
	// preRace.wis = 0
	// preRace.mys = 0
	// preRace.con = 0
	// //weapon skills
	// preRace.unarmed = 0
	// preRace.oneHanded = 0
	// preRace.twoHanded = 0
	// preRace.daggers = 0
	// preRace.bows = 0
	// preRace.shields = 0
	// //secondary skills
	// preRace.stealth = 0
	// preRace.dodge = 0
	// //spells
	// preRace.fireflames = 0
	// preRace.frostfreeze = 0
	// preRace.flashbolt = 0
}

function combineClassAndRaceValues() {
	player.baseStats.str = preClass.str + preRace.str
	player.baseStats.dex = preClass.dex + preRace.dex
	player.baseStats.agi = preClass.agi + preRace.agi
	player.baseStats.int = preClass.int + preRace.int
	player.baseStats.wis = preClass.wis + preRace.wis
	player.baseStats.mys = preClass.mys + preRace.mys
	player.baseStats.con = preClass.con + preRace.con
	player.baseStats.maxHealth = preClass.maxHealth + preRace.maxHealth
	player.baseStats.maxMana = preClass.maxMana + preRace.maxMana
	player.baseStats.maxMight = preClass.maxMight
	player.baseStats.maxFocus = preClass.maxFocus
	player.baseStats.maxAdrenaline = preClass.maxAdrenaline
	player.baseStats.healthPerLevel = preClass.healthPerLevel + preRace.healthPerLevel
	player.baseStats.healthPerCON = preClass.healthPerCON + preRace.healthPerCON
	player.baseStats.manaPerLevel = preClass.manaPerLevel + preRace.manaPerLevel
	player.baseStats.manaPerWIS = preClass.manaPerWIS + preRace.manaPerWIS

	player.might = preClass.maxMight
	player.focus = preClass.maxFocus
	player.adrenaline = preClass.maxAdrenaline

	player.health = player.maxHealth
	player.mana = player.maxMana

	player.manaMultiplier = preClass.manaMultiplier + preRace.manaMultiplier

	player.skillMods.oneHanded = preClass.oneHanded + preRace.oneHanded
	player.skillMods.twoHanded = preClass.twoHanded + preRace.twoHanded
	player.skillMods.daggers = preClass.daggers + preRace.daggers
	player.skillMods.unarmed = preClass.unarmed + preRace.unarmed
	player.skillMods.bows = preClass.bows + preRace.bows
	player.skillMods.shields = preClass.shields + preRace.shields

	player.skillMods.stealth = preClass.stealth + preRace.stealth
	player.skillMods.lockpicking = preClass.lockpicking + preRace.lockpicking
	player.skillMods.tactics = preClass.tactics + preRace.tactics
	player.skillMods.vigilance = preClass.vigilance + preRace.vigilance
	player.skillMods.initiation = preClass.initiation + preRace.initiation
	player.skillMods.fleetFooted = preClass.fleetFooted + preRace.fleetFooted
	player.skillMods.toughness = preClass.toughness + preRace.toughness
	player.skillMods.dodging = preClass.dodging + preRace.dodging
	player.skillMods.ridingSkill = preClass.ridingSkill + preRace.ridingSkill
	player.skillMods.rest = preClass.rest + preRace.rest + 1
	player.skillMods.perception = preClass.perception + preRace.perception
	player.skillMods.athletics = preClass.athletics + preRace.athletics
	player.skillMods.vigor = preClass.vigor + preRace.vigor
	player.skillMods.devotion = preClass.devotion + preRace.devotion

	player.skillMods.fireflames = preClass.fireflames + preRace.fireflames
	player.skillMods.frostfreeze = preClass.frostfreeze + preRace.frostfreeze
	player.skillMods.flashbolt = preClass.flashbolt + preRace.flashbolt
}


let berserkerClass = {
	name: 'Berserker',
	color: 'warrior-color',
}
let fighterClass = {
	name: 'Fighter',
	color: 'warrior-color',
}
let knightClass = {
	name: 'Knight',
	color: 'warrior-color',
}
let assassinClass = {
	name: 'Assassin',
	color: 'sinistral-color',
}
let thiefClass = {
	name: 'Thief',
	color: 'sinistral-color',
}
let shadowbladeClass = {
	name: 'Shadowblade',
	color: 'sinistral-color',
}
let martialMonkClass = {
	name: 'Martial Monk',
	color: 'monk-color',
}
let mysticMonkClass = {
	name: 'Mystic Monk',
	color: 'monk-color',
}
let elementalMonkClass = {
	name: 'Elemental Monk',
	color: 'monk-color',
}
let rangerClass = {
	name: 'Ranger',
	color: 'ranger-color',
}
let pyromancerClass = {
	name: 'Pyromancer',
	color: 'pyromancer-color',
}
let cryoMageClass = {
	name: 'Cryo Mage',
	color: 'cryo-mage-color',
}
let lightningMagusClass = {
	name: 'Lightning Magus',
	color: 'lightning-magus-color',
}
//relegated variables. Remove these when possible
let monkClass = {
	name: 'Monk',
	color: 'monk-color',
}
let warriorClass = {
	name: 'Warrior',
	color: 'warrior-color',
}

function startBerserker(event) {
	if (player.playerClass.name != 'Berserker') {
		removeStartingClassSkills()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Berserker'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('warrior-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('warrior-resource-bar')

		player.playerClass = berserkerClass
		player.guild = 'Warrior'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 1.0
		preClass.manaPerWIS = 1
		preClass.maxMight = 5
		// preClass.maxHealth = 5
		preClass.maxMana = 0
		preClass.healthPerLevel = 6
		preClass.str = 4
		preClass.con = 3
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		preClass.twoHanded = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 4
		applyBerserkerClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		
		fieldsTrainer = {...velthash}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('twohanded')
	}
}
function startFighter(event) {
	if (player.playerClass.name != 'Fighter') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Fighter'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('warrior-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('warrior-resource-bar')

		player.playerClass = fighterClass
		player.guild = 'Warrior'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 1.0
		preClass.manaPerWIS = 1
		preClass.maxMight = 5
		// preClass.maxHealth = 5
		preClass.maxMana = 0
		preClass.healthPerLevel = 6
		preClass.str = 3
		preClass.con = 2
		preClass.dex = 3
		preClass.agi = 1
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		preClass.oneHanded = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 4
		applyFighterClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...velthash}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('shortsword')
		unpack('shortsword')
	}
}
function startKnight(event) {
	if (player.playerClass.name != 'Knight') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Knight'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('warrior-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('warrior-resource-bar')

		player.playerClass = knightClass
		player.guild = 'Warrior'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 1.0
		preClass.manaPerWIS = 1
		preClass.maxMight = 5
		// preClass.maxHealth = 5
		preClass.maxMana = 0
		preClass.healthPerLevel = 6
		preClass.str = 3
		preClass.con = 4
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		preClass.oneHanded = 1
		preClass.shields = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 4
		applyKnightClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...velthash}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('sword')
		unpack('shield')
	}
}

function startThief(event) {
	if (player.playerClass.name != 'Thief') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Thief'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('sinistral-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('sinistral-resource-bar')

		player.playerClass = thiefClass
		player.guild = 'Sinistral'
		preClass.healthPerLevel = 3.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 1.0
		preClass.manaPerWIS = 1
		preClass.maxAdrenaline = 50
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 3
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 3
		preClass.agi = 3
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		preClass.daggers = 1
		preClass.dodging = 1
		preClass.stealth = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 2
		applyThiefClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()


		fieldsTrainer = {...zell}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('dagger')
		unpack('dagger')
	}
}
function startAssassin(event) {
	if (player.playerClass.name != 'Assassin') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Assassin'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('sinistral-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('sinistral-resource-bar')

		player.playerClass = assassinClass
		player.guild = 'Sinistral'
		preClass.healthPerLevel = 3.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 1.0
		preClass.manaPerWIS = 1
		preClass.maxAdrenaline = 50
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 3
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 3
		preClass.agi = 3
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		preClass.daggers = 1
		preClass.dodging = 1
		preClass.stealth = 1
		preClass.dodge = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 2
		applyAssassinClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...zell}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]
		pack('right')
		pack('left')
		unpack('dagger')
		unpack('dagger')
	}
}
function startShadowblade(event) {
	if (player.playerClass.name != 'Shadowblade') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Shadowblade'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('sinistral-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('sinistral-resource-bar')

		player.playerClass = shadowbladeClass
		player.guild = 'Sinistral'
		preClass.healthPerLevel = 3.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 1.0
		preClass.manaPerWIS = 1
		preClass.maxAdrenaline = 50
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 3
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 3
		preClass.agi = 3
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 1
		preClass.daggers = 1
		preClass.dodging = 1
		preClass.stealth = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 2
		applyShadowbladeClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...zell}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
		unpack('dagger')
		unpack('dagger')
	}
}

function startMartialMonk(event) {
	if (player.playerClass.name != 'Martial Monk') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Martial Monk'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('monk-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('monk-resource-bar')

		player.playerClass = martialMonkClass
		player.guild = 'Monk'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 4.0
		preClass.manaPerWIS = 3
		preClass.maxFocus = 60
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 4
		preClass.str = 2
		preClass.con = 3
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 2
		preClass.unarmed = 1
		preClass.dodging = 1
		preClass.toughness = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 2
		applyMartialMonkClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...sitoria}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
	}
}
function startMysticMonk(event) {
	if (player.playerClass.name != 'Mystic Monk') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Mystic Monk'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('monk-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('monk-resource-bar')

		player.playerClass = mysticMonkClass
		player.guild = 'Monk'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 4.0
		preClass.manaPerWIS = 3
		preClass.maxFocus = 60
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 4
		preClass.str = 2
		preClass.con = 3
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 2
		preClass.unarmed = 1
		preClass.dodging = 1
		preClass.toughness = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 2
		applyMysticMonkClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...sitoria}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
	}
}
function startElementalMonk(event) {
	if (player.playerClass.name != 'Elemental Monk') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Elemental Monk'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('monk-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('monk-resource-bar')

		player.playerClass = elementalMonkClass
		player.guild = 'Monk'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 4.0
		preClass.manaPerWIS = 3
		preClass.maxFocus = 60
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 4
		preClass.str = 1
		preClass.con = 3
		preClass.dex = 2
		preClass.agi = 2
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 3
		preClass.unarmed = 1
		preClass.dodging = 1
		preClass.toughness = 1
		player.baseStats.advanceTimer = 2
		player.baseStats.retreatTimer = 2
		applyElementalMonkClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...sitoria}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.offer = fieldsTrainerOffer.offer
		fieldsTrainer.quest = fieldsTrainerQuest.quest
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
	}
}

function startPyromancer(event) {
	if (player.playerClass.name != 'Pyromancer') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Pyromancer'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('pyromancer-resource-bar')
		resourceText.textContent = ''
		resourceBar.classList.add('pyromancer-resource-bar')

		player.playerClass = pyromancerClass
		player.guild = 'Mage'
		preClass.healthPerLevel = 2.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 5.0
		preClass.manaPerWIS = 5.0
		// preClass.maxHealth = 0
		preClass.maxMana = 30
		preClass.healthPerLevel = 2
		preClass.manaPerLevel = 10
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 4
		preClass.wis = 4
		preClass.mys = 1
		player.baseStats.advanceTimer = 3
		player.baseStats.retreatTimer = 3
		preClass.fireflames = 1
		applyPyromancerClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...olivandra}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
	}
}
function startCryoMage(event) {
	if (player.playerClass.name != 'Cryo Mage') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Cryo Mage'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('cryo-mage-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('cryo-mage-resource-bar')

		player.playerClass = cryoMageClass
		player.guild = 'Mage'
		preClass.healthPerLevel = 2.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 5.0
		preClass.manaPerWIS = 5.0
		preClass.maxHealth = 0
		preClass.maxMana = 30
		preClass.healthPerLevel = 2
		preClass.manaPerLevel = 10
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 4
		preClass.wis = 4
		preClass.mys = 1
		player.baseStats.advanceTimer = 3
		player.baseStats.retreatTimer = 3
		preClass.frostfreeze = 1
		applyCryoMageClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...olivandra}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
	}
}
function startLightningMagus(event) {
	if (player.playerClass.name != 'Lightning Magus') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Lightning Magus'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('lightning-magus-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('lightning-magus-resource-bar')

		player.playerClass = lightningMagusClass
		player.guild = 'Mage'
		preClass.healthPerLevel = 2.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 5.0
		preClass.manaPerWIS = 5.0
		preClass.maxHealth = 0
		preClass.maxMana = 30
		preClass.healthPerLevel = 2
		preClass.manaPerLevel = 10
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 1
		preClass.agi = 1
		preClass.int = 4
		preClass.wis = 4
		preClass.mys = 1
		player.baseStats.advanceTimer = 3
		player.baseStats.retreatTimer = 3
		preClass.flashbolt = 1
		applyLightningMagusClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()

		fieldsTrainer = {...olivandra}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		// pack('right')
		// pack('left')
	}
}

function startRanger(event) {
	if (player.playerClass.name != 'Ranger') {
		removeStartingClassSkills()
		updatePlayerStats()
		let playerClass = document.getElementById('playerClass')
		playerClass.textContent = 'Ranger'
		if (cooldownBar.classList.length > 1) {
			let lastClass = cooldownBar.classList[cooldownBar.classList.length - 1]
			cooldownBar.classList.remove(lastClass)
		}
		cooldownBar.classList.add('ranger-resource-bar')
		resourceBar.className = ''
		resourceBar.classList.add('ranger-resource-bar')

		player.playerClass = rangerClass
		player.guild = 'Ranger'
		preClass.healthPerLevel = 4.0
		preClass.healthPerCON = 4
		preClass.manaPerLevel = 4.0
		preClass.manaPerWIS = 3
		preClass.maxFocus = 30
		// preClass.maxHealth = 5
		preClass.maxMana = 5
		preClass.healthPerLevel = 3
		preClass.str = 1
		preClass.con = 1
		preClass.dex = 2
		preClass.agi = 3
		preClass.int = 1
		preClass.wis = 1
		preClass.mys = 3
		preClass.bows = 1
		player.baseStats.advanceTimer = 3
		player.baseStats.retreatTimer = 3
		applyRangerClassDescription()
		combineClassAndRaceValues()
		updatePlayerStats()


		fieldsTrainer = {...tilwin}
		fieldsTrainer.speak = fieldsTrainerDialogue.speak
		fieldsTrainer.questSequence = fieldsTrainerQuestSequence
		crossroads_shops_and_fields.npc = [fieldsTrainer]

		pack('right')
		pack('left')
		unpack('bow')
	}
}

// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES 
// RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES RACES

function startHuman(event) {
	if (player.race != 'Human') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Human'
		player.race = 'Human'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 1
		preRace.dex = 1
		preRace.agi = 1
		preRace.int = 1
		preRace.wis = 1
		preRace.mys = 1
		preRace.con = 1

		applyHumanRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startDwarf(event) {
	if (player.race != 'Dwarf') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Dwarf'
		player.race = 'Dwarf'
		preRace.healthPerLevel = 2.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 2
		preRace.dex = 0
		preRace.agi = 0
		preRace.int = 0
		preRace.wis = 0
		preRace.mys = 0
		preRace.con = 5
		
		applyDwarfRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startElf(event) {
	if (player.race != 'Elf') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Elf'
		player.race = 'Elf'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 0
		preRace.agi = 1
		preRace.int = 2
		preRace.wis = 1
		preRace.mys = 2
		preRace.con = 0

		applyElfRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startHalfElf(event) {
	if (player.race != 'Half-Elf') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Half-Elf'
		player.race = 'Half-Elf'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 1
		preRace.agi = 2
		preRace.int = 1
		preRace.wis = 0
		preRace.mys = 2
		preRace.con = 0

		applyHalfElfRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		updatePlayerStats()
	}
}

function startHalfMinotaur() {
	if (player.race != 'Half-Minotaur') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Half-Minotaur'
		player.race = 'Half-Minotaur'
		preRace.healthPerLevel = 2.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 3
		preRace.dex = 0
		preRace.agi = 0
		preRace.int = 0
		preRace.wis = 0
		preRace.mys = 0
		preRace.con = 2

		applyHalfMinotaurRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
	}
}
function startTiefling() {
	if (player.race != 'Tiefling') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Human'
		player.race = 'Tiefling'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 0
		preRace.agi = 0
		preRace.int = 2
		preRace.wis = 3
		preRace.mys = 1
		preRace.con = 0



		applyTieflingRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startCatline() {
	if (player.race != 'Catline') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Catline'
		player.race = 'Catline'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 2
		preRace.agi = 2
		preRace.int = 0
		preRace.wis = 0
		preRace.mys = 1
		preRace.con = 0

		// preRace.maxHealth = 0
		// preRace.maxMana = 0

		applyCatlineRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startGnome() {
	if (player.race != 'Gnome') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Gnome'
		player.race = 'Gnome'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 2.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 0
		preRace.agi = 0
		preRace.int = 4
		preRace.wis = 2
		preRace.mys = 2
		preRace.con = 0

		// preRace.maxHealth = 0
		// preRace.maxMana = 0

		applyGnomeRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startHalfling() {
	if (player.race != 'Halfling') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Halfling'
		player.race = 'Halfling'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 2
		preRace.agi = 2
		preRace.int = 1
		preRace.wis = 0
		preRace.mys = 0
		preRace.con = 0

		// preRace.maxHealth = 0
		// preRace.maxMana = 0

		applyHalflingRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startFaerie() {
	if (player.race != 'Faerie') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Faerie'
		player.race = 'Faerie'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 2.0
		preRace.manaPerWIS = 1.0

		preRace.str = 0
		preRace.dex = 0
		preRace.agi = 0
		preRace.int = 2
		preRace.wis = 2
		preRace.mys = 4
		preRace.con = 0

		// preRace.maxHealth = 0
		// preRace.maxMana = 0

		applyFaerieRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}
function startDragonKin() {
	if (player.race != 'Dragonkin') {
		event.target.classList.add('class-race-select')
		removeStartingRaceSkills()
		let playerRace = document.getElementById('race')
		playerRace.textContent = 'Dragonkin'
		player.race = 'Dragonkin'
		preRace.healthPerLevel = 1.0
		preRace.healthPerCON = 1.0
		preRace.manaPerLevel = 1.0
		preRace.manaPerWIS = 1.0

		preRace.str = 1
		preRace.dex = 1
		preRace.agi = 1
		preRace.int = 0
		preRace.wis = 0
		preRace.mys = 1
		preRace.con = 1

		// preRace.maxHealth = 0
		// preRace.maxMana = 0

		applyDragonKinRaceDescription()
		combineClassAndRaceValues()
		updatePlayerStats()
		player.health = player.maxHealth
		player.mana = player.maxMana
		updatePlayerStats()
	}
}

function removePlayerClassClass() {
	// document.getElementById('warrior-button').classList.remove('class-race-select')
	// document.getElementById('rogue-button').classList.remove('class-race-select')
	// document.getElementById('monk-button').classList.remove('class-race-select')
	// classNode.classList.remove('class-race-select')
	// classNode2.classList.remove('class-race-select')
	// classNode3.classList.remove('class-race-select')
}

function removeRaceClass() {
	document.getElementById('human-button').classList.remove('class-race-select')
	document.getElementById('elf-button').classList.remove('class-race-select')
	document.getElementById('half-elf-button').classList.remove('class-race-select')
}

// const strButtonIncrease = document.getElementById('strIncrease')
// const conButtonIncrease = document.getElementById('conIncrease')
// const dexButtonIncrease = document.getElementById('dexIncrease')
// const agiButtonIncrease = document.getElementById('agiIncrease')
// const intButtonIncrease = document.getElementById('intIncrease')
// const wisButtonIncrease = document.getElementById('wisIncrease')

// strButtonIncrease.addEventListener('click', statButtonStrIncrease)
// conButtonIncrease.addEventListener('click', statButtonConIncrease)
// dexButtonIncrease.addEventListener('click', statButtonDexIncrease)
// agiButtonIncrease.addEventListener('click', statButtonAgiIncrease)
// intButtonIncrease.addEventListener('click', statButtonIntIncrease)
// wisButtonIncrease.addEventListener('click', statButtonWisIncrease)

// const strButtonDecrease = document.getElementById('strDecrease')
// const conButtonDecrease = document.getElementById('conDecrease')
// const dexButtonDecrease = document.getElementById('dexDecrease')
// const agiButtonDecrease = document.getElementById('agiDecrease')
// const intButtonDecrease = document.getElementById('intDecrease')
// const wisButtonDecrease = document.getElementById('wisDecrease')

// strButtonDecrease.addEventListener('click', statButtonStrDecrease)
// conButtonDecrease.addEventListener('click', statButtonConDecrease)
// dexButtonDecrease.addEventListener('click', statButtonDexDecrease)
// agiButtonDecrease.addEventListener('click', statButtonAgiDecrease)
// intButtonDecrease.addEventListener('click', statButtonIntDecrease)
// wisButtonDecrease.addEventListener('click', statButtonWisDecrease)

function statButtonIncrease(stat) {
	alert('works')
	player[stat]++
	updatePlayerStats
}

function statButtonStrIncrease() {
	if (player.attributePoints > 0) {
		player.str++
		player.attributePoints--
		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonConIncrease() {
	if (player.attributePoints > 0) {
		player.con++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonDexIncrease() {
	if (player.attributePoints > 0) {
		player.dex++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonAgiIncrease() {
	if (player.attributePoints > 0) {
		player.agi++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonIntIncrease() {
	if (player.attributePoints > 0) {
		player.int++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}
function statButtonWisIncrease() {
	if (player.attributePoints > 0) {
		player.wis++
		player.attributePoints--

		updatePlayerStats()
	} else {
		let line1 = document.createElement('div')
		customizeEachWord(`You do not have enough `, 'white', line1)
		customizeEachWord(`stat points `, 'light-blue', line1)
		customizeEachWord(`to increase this attribute`, 'white', line1)
	}
}

function statButtonStrDecrease() {
	player.str--
	player.attributePoints++
	updatePlayerStats()
}
function statButtonConDecrease() {
	player.con--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonDexDecrease() {
	player.dex--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonAgiDecrease() {
	player.agi--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonIntDecrease() {
	player.int--
	player.attributePoints++

	updatePlayerStats()
}
function statButtonWisDecrease() {
	player.wis--
	player.attributePoints++

	updatePlayerStats()
}

function addWeapons() {}
addWeapons()

currentArea = galvadiaWelcomeArea17_combatRoom1
player.x = currentArea.x
player.y = currentArea.y
player.z = currentArea.z
previousArea = currentArea

function displayClassSelection() {
	const classAndRaceContainer = document.createElement('div')
	classAndRaceContainer.setAttribute('id', 'class-and-race-container')
	classAndRaceContainer.classList.add('class-and-race-container')

	let characterCreationWindow = document.createElement('div')
	// let characterCreationNode = document.createTextNode('Character creation')
	characterCreationWindow.classList.add('character-creation')
	// characterCreationWindow.appendChild(characterCreationNode)

	// classAndRaceContainer.appendChild(characterCreationWindow)

	const confirmationMainDiv = document.createElement('div')
	const confirmationMainNode = document.createTextNode(`To begin playing, you must create your character by selecting the class and race you want to play. Each class has its own set of unique abilities and playstyle. Each race comes with their own stat and skill bonuses. Your class will dictate your combat gameplay while your race adds roleplay flavor and can supplement your class's base stats.`)
	confirmationMainDiv.classList.add('character-confirmation')
	confirmationMainDiv.appendChild(confirmationMainNode)
	classAndRaceContainer.appendChild(confirmationMainDiv)

	const classMainContainer = document.createElement('div')
	const classHeadingContainer = document.createElement('div')
	const classHeadingNode = document.createTextNode(`Choose your class`)
	classMainContainer.classList.add('main-class-container')
	classHeadingContainer.classList.add('start-heading-container')

	const classDescriptionAndDetailsContainer = document.createElement('div')
	const classDescriptionContainer = document.createElement('div')
	const classDetailsContainer = document.createElement('div')

	classDescriptionAndDetailsContainer.classList.add('class-description-and-details-container')
	classDescriptionContainer.classList.add('start-description')
	classDetailsContainer.classList.add('start-details')
	classDescriptionAndDetailsContainer.appendChild(classDescriptionContainer)
	classDescriptionAndDetailsContainer.appendChild(classDetailsContainer)
	/////////////////////////////////////////////////////////////////////
	//WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR WARRIOR
	//BERSERKER BERSERKER BERSERKER BERSERKER BERSERKER BERSERKER BERSERKER 
	const berserkerSelectDiv = document.createElement('div')
	const berserkerHeadingDiv = document.createElement('div')
	berserkerHeadingDiv.textContent = 'Berserker'
	berserkerSelectDiv.classList.add('class-option', 'berserker', 'warrior')

	berserkerSelectDiv.addEventListener('click', startBerserker)
	berserkerSelectDiv.appendChild(berserkerHeadingDiv)
	classDescriptionContainer.appendChild(berserkerSelectDiv)
	//
	//BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN BARBARIAN
	const fighterSelectDiv = document.createElement('div')
	const fighterHeadingDiv = document.createElement('div')
	fighterHeadingDiv.textContent = 'Fighter'
	fighterSelectDiv.classList.add('class-option', 'fighter', 'warrior')

	fighterSelectDiv.addEventListener('click', startFighter)
	fighterSelectDiv.appendChild(fighterHeadingDiv)
	classDescriptionContainer.appendChild(fighterSelectDiv)
	//
	//KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT KNIGHT
	const knightSelectDiv = document.createElement('div')
	const knightHeadingDiv = document.createElement('div')
	knightHeadingDiv.textContent = 'Knight'
	knightSelectDiv.classList.add('class-option', 'knight', 'warrior')

	knightSelectDiv.addEventListener('click', startKnight)
	knightSelectDiv.appendChild(knightHeadingDiv)
	classDescriptionContainer.appendChild(knightSelectDiv)
	//
	//ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN ASSASSIN
	const assassinSelectDiv = document.createElement('div')
	const assassinHeadingDiv = document.createElement('div')
	assassinHeadingDiv.textContent = 'Assassin'
	assassinSelectDiv.classList.add('class-option', 'assassin', 'sinistral-icon')
	
	assassinSelectDiv.addEventListener('click', startAssassin)
	assassinSelectDiv.appendChild(assassinHeadingDiv)
	classDescriptionContainer.appendChild(assassinSelectDiv)
	
	//
	//THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF THIEF 
	const thiefSelectDiv = document.createElement('div')
	const thiefHeadingDiv = document.createElement('div')
	thiefHeadingDiv.textContent = 'Thief'
	thiefSelectDiv.classList.add('class-option', 'thief', 'sinistral-icon')

	thiefSelectDiv.addEventListener('click', startThief)
	thiefSelectDiv.appendChild(thiefHeadingDiv)
	classDescriptionContainer.appendChild(thiefSelectDiv)
	//
	//SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE SHADOWBLADE 
	const shadowbladeSelectDiv = document.createElement('div')
	const shadowbladeHeadingDiv = document.createElement('div')
	shadowbladeHeadingDiv.textContent = 'Shadowblade'
	shadowbladeSelectDiv.classList.add('class-option', 'shadowblade', 'sinistral-icon')

	shadowbladeSelectDiv.addEventListener('click', startShadowblade)
	shadowbladeSelectDiv.appendChild(shadowbladeHeadingDiv)
	classDescriptionContainer.appendChild(shadowbladeSelectDiv)
	//

	//MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK MARTIAL-MONK 
	const martialMonkSelectDiv = document.createElement('div')
	const martialMonkHeadingDiv = document.createElement('div')
	martialMonkHeadingDiv.textContent = 'Martial Monk'
	martialMonkSelectDiv.classList.add('class-option', 'martialMonk', 'monk')

	martialMonkSelectDiv.addEventListener('click', startMartialMonk)
	martialMonkSelectDiv.appendChild(martialMonkHeadingDiv)
	classDescriptionContainer.appendChild(martialMonkSelectDiv)
	//
	//MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK MYSTIC-MONK
	const mysticMonkSelectDiv = document.createElement('div')
	const mysticMonkHeadingDiv = document.createElement('div')
	mysticMonkHeadingDiv.textContent = 'Mystic Monk'
	mysticMonkSelectDiv.classList.add('class-option', 'mysticMonk', 'monk')

	mysticMonkSelectDiv.addEventListener('click', startMysticMonk)
	mysticMonkSelectDiv.appendChild(mysticMonkHeadingDiv)
	classDescriptionContainer.appendChild(mysticMonkSelectDiv)
	//
	//ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK ELEMENTALMONK 
	const elementalMonkSelectDiv = document.createElement('div')
	const elementalMonkHeadingDiv = document.createElement('div')
	elementalMonkHeadingDiv.textContent = 'Elemental Monk'
	elementalMonkSelectDiv.classList.add('class-option', 'elementalMonk', 'monk')

	elementalMonkSelectDiv.addEventListener('click', startElementalMonk)
	elementalMonkSelectDiv.appendChild(elementalMonkHeadingDiv)
	classDescriptionContainer.appendChild(elementalMonkSelectDiv)
	//
	//SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER
	const mageSelectDiv = document.createElement('div')
	const mageHeadingDiv = document.createElement('div')
	mageHeadingDiv.textContent = 'Pyromancer'
	mageSelectDiv.classList.add('class-option', 'pyromancer')
	mageSelectDiv.addEventListener('click', startPyromancer)
	mageSelectDiv.appendChild(mageHeadingDiv)
	classDescriptionContainer.appendChild(mageSelectDiv)

	const iceMageSelectDiv = document.createElement('div')
	const iceMageHeadingDiv = document.createElement('div')
	iceMageHeadingDiv.textContent = 'Cryo Mage'
	iceMageSelectDiv.classList.add('class-option', 'cryoMage')
	iceMageSelectDiv.addEventListener('click', startCryoMage)
	iceMageSelectDiv.appendChild(iceMageHeadingDiv)
	classDescriptionContainer.appendChild(iceMageSelectDiv)

	const lightningMageSelectDiv = document.createElement('div')
	const lightningMageHeadingDiv = document.createElement('div')
	lightningMageHeadingDiv.textContent = 'Lightning Magus'
	lightningMageSelectDiv.classList.add('class-option', 'lightningMagus')
	lightningMageSelectDiv.addEventListener('click', startLightningMagus)
	lightningMageSelectDiv.appendChild(lightningMageHeadingDiv)
	classDescriptionContainer.appendChild(lightningMageSelectDiv)
	//SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER SORCERER
	//RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER RANGER
	const rangerSelectDiv = document.createElement('div')
	const rangerHeadingDiv = document.createElement('div')
	rangerHeadingDiv.textContent = 'Ranger'
	// const rangerP1 = document.createElement('p')
	// const rangerP2 = document.createElement('p')
	// const rangerP3 = document.createElement('p')
	// rangerP1.textContent = '.'
	// rangerP2.textContent = '.'
	// rangerP3.textContent = '.'
	rangerSelectDiv.classList.add('class-option', 'ranger')

	rangerSelectDiv.addEventListener('click', startRanger)
	rangerSelectDiv.appendChild(rangerHeadingDiv)
	// rangerSelectDiv.appendChild(rangerP1)
	// rangerSelectDiv.appendChild(rangerP2)
	// rangerSelectDiv.appendChild(rangerP3)
	classDescriptionContainer.appendChild(rangerSelectDiv)
	// classAndDescriptionsContainer.appendChild(classDescriptionContainer)
	//
	classHeadingContainer.appendChild(classHeadingNode)

	classMainContainer.appendChild(classHeadingContainer)
	classMainContainer.appendChild(classDescriptionAndDetailsContainer)

	classAndRaceContainer.appendChild(classMainContainer)
	masterArea.appendChild(classAndRaceContainer)
	// Add event listeners to class options
	let classOptions = document.querySelectorAll('.class-option')
	classOptions.forEach(option => {
		option.addEventListener('click', selectClass)
	})
	// Function to handle class selection
	function selectClass() {
		// Deselect all options
		classOptions.forEach(option => {
			option.classList.remove('selected')
		})
		// Select the clicked option
		this.classList.add('selected')
	}
}

function displayRaceSelection() {
	const raceMainContainer = document.createElement('div')
	const raceHeadingContainer = document.createElement('div')
	const raceHeadingNode = document.createTextNode(`Choose your race`)

	raceMainContainer.classList.add('main-race-container')
	raceHeadingContainer.classList.add('start-heading-container')

	const raceDescriptionAndDetailsContainer = document.createElement('div')
	raceDescriptionAndDetailsContainer.classList.add('race-description-and-details-container')
	const raceContainer = document.createElement('div')
	const raceDetailsContainer = document.createElement('div')
	raceDescriptionAndDetailsContainer.appendChild(raceContainer)
	raceDescriptionAndDetailsContainer.appendChild(raceDetailsContainer)
	raceContainer.classList.add('race-description')
	raceDetailsContainer.classList.add('race-details')

	//HUMAN
	const humanSelectDiv = document.createElement('div')
	const humanHeadingDiv = document.createElement('div')
	humanHeadingDiv.textContent = 'Human'
	humanSelectDiv.classList.add('race-option', 'human')

	humanSelectDiv.addEventListener('click', startHuman)
	humanSelectDiv.appendChild(humanHeadingDiv)
	raceContainer.appendChild(humanSelectDiv)
	//DWARF
	const dwarfSelectDiv = document.createElement('div')
	const dwarfHeadingDiv = document.createElement('div')
	dwarfHeadingDiv.textContent = 'Dwarf'
	dwarfSelectDiv.classList.add('race-option', 'dwarf')

	dwarfSelectDiv.addEventListener('click', startDwarf)
	dwarfSelectDiv.appendChild(dwarfHeadingDiv)
	raceContainer.appendChild(dwarfSelectDiv)
	//ELF
	const elfSelectDiv = document.createElement('div')
	const elfHeadingDiv = document.createElement('div')
	elfHeadingDiv.textContent = 'Elf'
	const elfP1 = document.createElement('p')
	const elfP2 = document.createElement('p')
	const elfP3 = document.createElement('p')
	elfSelectDiv.classList.add('race-option', 'elf')
	
	elfSelectDiv.addEventListener('click', startElf)
	elfSelectDiv.appendChild(elfHeadingDiv)
	elfSelectDiv.appendChild(elfP1)
	elfSelectDiv.appendChild(elfP2)
	elfSelectDiv.appendChild(elfP3)
	raceContainer.appendChild(elfSelectDiv)
	//HALF-ELF
	const halfElfSelectDiv = document.createElement('div')
	const halfElfHeadingDiv = document.createElement('div')
	halfElfHeadingDiv.textContent = 'Half-Elf'
	halfElfSelectDiv.classList.add('race-option', 'halfElf')

	halfElfSelectDiv.addEventListener('click', startHalfElf)
	halfElfSelectDiv.appendChild(halfElfHeadingDiv)
	raceContainer.appendChild(halfElfSelectDiv)
	//HALF-MINOTAUR
	const halfMinotaurSelectDiv = document.createElement('div')
	const halfMinotaurHeadingDiv = document.createElement('div')
	halfMinotaurHeadingDiv.textContent = 'Half-Minotaur'
	halfMinotaurSelectDiv.classList.add('race-option', 'halfMinotaur')

	halfMinotaurSelectDiv.addEventListener('click', startHalfMinotaur)
	halfMinotaurSelectDiv.appendChild(halfMinotaurHeadingDiv)
	raceContainer.appendChild(halfMinotaurSelectDiv)
	//CENTAUR
	const tieflingSelectDiv = document.createElement('div')
	const tieflingHeadingDiv = document.createElement('div')
	tieflingHeadingDiv.textContent = 'Tiefling'
	tieflingSelectDiv.classList.add('race-option', 'tiefling')

	tieflingSelectDiv.addEventListener('click', startTiefling)
	tieflingSelectDiv.appendChild(tieflingHeadingDiv)
	raceContainer.appendChild(tieflingSelectDiv)
	//CATLINE
	const catlineSelectDiv = document.createElement('div')
	const catlineHeadingDiv = document.createElement('div')
	catlineHeadingDiv.textContent = 'Catline'
	catlineSelectDiv.classList.add('race-option', 'catline')

	catlineSelectDiv.addEventListener('click', startCatline)
	catlineSelectDiv.appendChild(catlineHeadingDiv)
	raceContainer.appendChild(catlineSelectDiv)
	//GNOME
	const gnomeSelectDiv = document.createElement('div')
	const gnomeHeadingDiv = document.createElement('div')
	gnomeHeadingDiv.textContent = 'Gnome'
	gnomeSelectDiv.classList.add('race-option', 'gnome')

	gnomeSelectDiv.addEventListener('click', startGnome)
	gnomeSelectDiv.appendChild(gnomeHeadingDiv)
	raceContainer.appendChild(gnomeSelectDiv)
	//HALFLING
	const halflingSelectDiv = document.createElement('div')
	const halflingHeadingDiv = document.createElement('div')
	halflingHeadingDiv.textContent = 'Halfling'
	halflingSelectDiv.classList.add('race-option', 'halfling')

	halflingSelectDiv.addEventListener('click', startHalfling)
	halflingSelectDiv.appendChild(halflingHeadingDiv)
	raceContainer.appendChild(halflingSelectDiv)
	//FAERIE
	const faerieSelectDiv = document.createElement('div')
	const faerieHeadingDiv = document.createElement('div')
	faerieHeadingDiv.textContent = 'Faerie'
	faerieSelectDiv.classList.add('race-option', 'faerie')

	faerieSelectDiv.addEventListener('click', startFaerie)
	faerieSelectDiv.appendChild(faerieHeadingDiv)
	raceContainer.appendChild(faerieSelectDiv)
	//DRAGONKIN
	const dragonKinSelectDiv = document.createElement('div')
	const dragonKinHeadingDiv = document.createElement('div')
	dragonKinHeadingDiv.textContent = 'DragonKin'
	dragonKinSelectDiv.classList.add('race-option', 'dragonKin')

	dragonKinSelectDiv.addEventListener('click', startDragonKin)
	dragonKinSelectDiv.appendChild(dragonKinHeadingDiv)
	raceContainer.appendChild(dragonKinSelectDiv)
	raceMainContainer.appendChild(raceDescriptionAndDetailsContainer)
	//Placeholder 1
	const placeholderSelectDiv = document.createElement('div')
	const placeholderHeadingDiv = document.createElement('div')
	placeholderHeadingDiv.textContent = ''
	placeholderSelectDiv.classList.add('race-option')

	// placeholderSelectDiv.addEventListener('click', startDragonKin)
	placeholderSelectDiv.appendChild(placeholderHeadingDiv)
	raceContainer.appendChild(placeholderSelectDiv)
	raceMainContainer.appendChild(raceDescriptionAndDetailsContainer)
	//Placeholder 2
	const placeholder2SelectDiv = document.createElement('div')
	const placeholder2HeadingDiv = document.createElement('div')
	placeholder2HeadingDiv.textContent = ''
	placeholder2SelectDiv.classList.add('race-option')

	// placeholder2SelectDiv.addEventListener('click', startDragonKin)
	placeholder2SelectDiv.appendChild(placeholder2HeadingDiv)
	raceContainer.appendChild(placeholder2SelectDiv)
	raceMainContainer.appendChild(raceDescriptionAndDetailsContainer)


	document.getElementById('class-and-race-container').appendChild(raceMainContainer)
	let classOptions = document.querySelectorAll('.race-option')
	classOptions.forEach(option => {
		option.addEventListener('click', selectClass)
	})
	// Function to handle class selection
	function selectClass() {
		// Deselect all options
		classOptions.forEach(option => {
			option.classList.remove('selected')
		})
		// Select the clicked option
		this.classList.add('selected')
	}
}

function displayClassDetails() {
	const warriorsGuildDescription = ``
	const descriptionText = ``
	const startDetailsContainer = document.querySelector('.start-details')

	const classDescriptionContainer = createDivElement('', ['classDescriptionContainer'])
	const classHeading = createDivElement(``, ['classHeading'])
	const classDescription = createDivElement(descriptionText, ['classDescription'])
	classDescriptionContainer.appendChild(classHeading)
	classDescriptionContainer.appendChild(classDescription)

	const startingStuffContainer = createDivElement(``, ['startingStuffContainer'])
	const startingStatsContainer = createDivElement(``, ['startingStatsContainer'])
	const statsHeading = createDivElement(``, ['statsHeading'])
	const statsDetails1 = createDivElement(``, ['statsDetails1'])
	const statsDetails2 = createDivElement(``, ['statsDetails2'])
	const statsDetails3 = createDivElement(``, ['statsDetails3'])
	const statsDetails4 = createDivElement(``, ['statsDetails4'])
	const statsDetails5 = createDivElement(``, ['statsDetails5'])
	const statsDetails6 = createDivElement(``, ['statsDetails6'])
	const statsDetails7 = createDivElement(``, ['statsDetails7'])
	const startingSkillsContainer = createDivElement(``, ['startingSkillsContainer'])
	const startingSkillsHeading = createDivElement(``, ['startingSkillsHeading'])
	const startingSkillsDetails1 = createDivElement(``, ['startingSkillsDetails1'])
	const startingSkillsDetails2 = createDivElement(``, ['startingSkillsDetails2'])
	const startingSkillsDetails3 = createDivElement(``, ['startingSkillsDetails3'])
	const startingSkillsDetails4 = createDivElement(``, ['startingSkillsDetails4'])
	const startingSkillsDetails5 = createDivElement(``, ['startingSkillsDetails5'])
	const startingSkillsDetails6 = createDivElement(``, ['startingSkillsDetails6'])
	const abilitiesContainer = createDivElement(``, ['abilitiesContainer'])
	const abilitiesHeading = createDivElement(``, ['abilitiesHeading'])
	const abilitiesDetails1 = createDivElement(``, ['abilitiesDetails1'])
	const abilitiesDetails2 = createDivElement(``, ['abilitiesDetails2'])
	const abilitiesDetails3 = createDivElement(``, ['abilitiesDetails3'])
	const abilitiesDetails4 = createDivElement(``, ['abilitiesDetails4'])
	const abilitiesDetails5 = createDivElement(``, ['abilitiesDetails5'])
	const abilitiesDetails6 = createDivElement(``, ['abilitiesDetails6'])
	startingStuffContainer.appendChild(startingStatsContainer)
	startingStuffContainer.appendChild(startingSkillsContainer)
	startingStuffContainer.appendChild(abilitiesContainer)
	startingStatsContainer.appendChild(statsHeading)
	startingStatsContainer.appendChild(statsDetails1)
	startingStatsContainer.appendChild(statsDetails2)
	startingStatsContainer.appendChild(statsDetails3)
	startingStatsContainer.appendChild(statsDetails4)
	startingStatsContainer.appendChild(statsDetails5)
	startingStatsContainer.appendChild(statsDetails6)
	startingStatsContainer.appendChild(statsDetails7)
	startingSkillsContainer.appendChild(startingSkillsHeading)
	startingSkillsContainer.appendChild(startingSkillsDetails1)
	startingSkillsContainer.appendChild(startingSkillsDetails2)
	startingSkillsContainer.appendChild(startingSkillsDetails3)
	startingSkillsContainer.appendChild(startingSkillsDetails4)
	startingSkillsContainer.appendChild(startingSkillsDetails5)
	startingSkillsContainer.appendChild(startingSkillsDetails6)
	abilitiesContainer.appendChild(abilitiesHeading)
	abilitiesContainer.appendChild(abilitiesDetails1)
	abilitiesContainer.appendChild(abilitiesDetails2)
	abilitiesContainer.appendChild(abilitiesDetails3)
	abilitiesContainer.appendChild(abilitiesDetails4)
	abilitiesContainer.appendChild(abilitiesDetails5)
	abilitiesContainer.appendChild(abilitiesDetails6)

	const guildDescriptionContainer = createDivElement(``, ['guildDescriptionContainer'])
	const guildHeading = createDivElement(``, ['guildHeading'])
	const guildDescription = createDivElement(warriorsGuildDescription, ['guildDescription'])
	guildDescriptionContainer.appendChild(guildHeading)
	guildDescriptionContainer.appendChild(guildDescription)

	startDetailsContainer.appendChild(classDescriptionContainer)
	startDetailsContainer.appendChild(startingStuffContainer)
	startDetailsContainer.appendChild(guildDescriptionContainer)
}
function displayRaceDetails() {
	const descriptionText = ''
	const raceDetailsContainer = document.querySelector('.race-details')

	const raceDescriptionContainer = createDivElement('', ['raceDescriptionContainer'])
	const raceDescriptionHeading = createDivElement(descriptionText, ['raceDescriptionHeading'])
	const raceDescription = createDivElement(descriptionText, ['raceDescription'])


	const raceStartingStuffContainer = createDivElement(``, ['startingStuffContainer'])
	const raceStatsContainer = createDivElement(``, ['startingStatsContainer'])
	const raceStatsHeading = createDivElement(``, ['raceStatsHeading'])
	const raceDetails1 = createDivElement(``, ['raceDetails1'])
	const raceDetails2 = createDivElement(``, ['raceDetails2'])
	const raceDetails3 = createDivElement(``, ['raceDetails3'])
	const raceDetails4 = createDivElement(``, ['raceDetails4'])
	const raceDetails5 = createDivElement(``, ['raceDetails5'])
	const raceDetails6 = createDivElement(``, ['raceDetails6'])
	const raceDetails7 = createDivElement(``, ['raceDetails7'])

	const raceSkillsContainer = createDivElement(``, ['raceSkillsContainer'])
	const raceSkillsHeading = createDivElement(``, ['raceSkillsHeading'])
	const raceSkillsDetails1 = createDivElement(``, ['raceSkillsDetails1'])
	const raceSkillsDetails2 = createDivElement(``, ['raceSkillsDetails2'])
	const raceSkillsDetails3 = createDivElement(``, ['raceSkillsDetails3'])
	const raceSkillsDetails4 = createDivElement(``, ['raceSkillsDetails4'])
	const raceSkillsDetails5 = createDivElement(``, ['raceSkillsDetails5'])
	const raceSkillsDetails6 = createDivElement(``, ['raceSkillsDetails6'])

	// raceDescriptionContainer.appendChild(raceHeading)
	raceDescriptionContainer.appendChild(raceDescriptionHeading)
	raceDescriptionContainer.appendChild(raceDescription)
	raceStartingStuffContainer.appendChild(raceStatsContainer)
	raceStartingStuffContainer.appendChild(raceSkillsContainer)
	raceStatsContainer.appendChild(raceStatsHeading)
	raceStatsContainer.appendChild(raceDetails1)
	raceStatsContainer.appendChild(raceDetails2)
	raceStatsContainer.appendChild(raceDetails3)
	raceStatsContainer.appendChild(raceDetails4)
	raceStatsContainer.appendChild(raceDetails5)
	raceStatsContainer.appendChild(raceDetails6)
	raceStatsContainer.appendChild(raceDetails7)

	raceSkillsContainer.appendChild(raceSkillsHeading)
	raceSkillsContainer.appendChild(raceSkillsDetails1)
	raceSkillsContainer.appendChild(raceSkillsDetails2)
	raceSkillsContainer.appendChild(raceSkillsDetails3)
	raceSkillsContainer.appendChild(raceSkillsDetails4)
	raceSkillsContainer.appendChild(raceSkillsDetails5)
	raceSkillsContainer.appendChild(raceSkillsDetails6)

	raceDetailsContainer.appendChild(raceDescriptionContainer)
	raceDetailsContainer.appendChild(raceStartingStuffContainer)
}
const warriorsGuildDescription = `The classes of the Warrior's Guild include Berserkers, Fighters, and Knights. They each prefer their own weapon types, but share the affinity to wear mail and plate armor, and will also make use of leather armor if need be. Warriors thrive in combat, eventually able to stay in combat with multiple enemies for extended periods of time. Because of this, and their lack of cowardice, they take longer to recover from retreating.`
const sinistralsGuildDescription = `Sinistrals include Asssassins, Thieves, and Shadowblades. All three use daggers as their weapon of choice, and prefer wearing leather armor.`
const monksGuildDescription = `The Monk's Guild consists of Martial Monks, Mystic Monks, and Elemental Monks. They all prefer using their fists as their weapon of choice. Monk's specialize in fast, multiple strikes. The classes vary in their armor preference, but most choose leather with some exceptions to wear cloth if it enhances their Mysticism. Monk's are very well rounded with their abilities allowing them to be quick, tough, strong, and even able to heal themselves.`
const magesGuildDescription = `Mages include Pyromancers, Cryo Mages, and the Lightning Magus. They each have powerful spells that affect both single and multiple targets. The only problem they face is dealing with elemental resistant enemies, but that can be dealt with by spell penetration. Early on, Mages might wear some leather for the armor value, but eventually move on to only wearing cloth armor to enhance their spell casting.`
const rangersGuildDescription = `The Ranger's Guild consists of only Ranger classes. They are unique in that they are the only class able to hit enemies without the need to engage combat. While they are also strong physically, they later learn how to use magic to enhance their combat capabilities, and even learn how to heal themselves.`
function applyBerserkerClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `The Berserker uses two handed weapons to devastate their foes. They specialize in powerful, single strikes, and eventually learn how to hit multiple enemies with a single swing. Berserkers find their home in the Warrior's Guild.`

	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Berserker`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Two Handed Weapons`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Ripslash`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Cyclone`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Cataclysm`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Warrior's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = warriorsGuildDescription
}
function applyFighterClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `The Fighter prefers dual wielding one handed weapons. They specialize in multiple, single target strikes. At higher levels, they become masters of one on one combat. Fighters find their home in the Warrior's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Fighter`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `One Handed Weapons`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Dualstrike`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Blade Blitz`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Shred`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Warrior's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = warriorsGuildDescription
}
function applyKnightClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Knights prefer fighting with a one handed weapon and shield. They are the most durable class, and are also able to deal significant damage of their own. At later levels, they excel at ataking on multiple enemies at once. Knights find their home in the Warrior's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Knight`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `One Handed Weapons`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Shields`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Valor Strike`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Shield Slam`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Booming Might`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Warrior's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = warriorsGuildDescription
}
function applyAssassinClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Assassins thrive in the shadows, and use daggers as their weapon of choice. Their most lethal attack comes from their Ambush ability that can only be used when stealthed. Assassins follow the leadership of the Sinistral's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Assassin`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Ambush`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Backstab`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Guillotine`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Sinistral's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = sinistralsGuildDescription
}
function applyThiefClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Thieves can use daggers or one handed weapons alongside their poison abilities. Applying poison to enemies, they are able to increase damage of their other abilties. Thieves follow the leadership of the Sinistral's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Thief`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Venomblade`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Contagion`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Bane`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Sinistral's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = sinistralsGuildDescription
}
function applyShadowbladeClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Shadowblades can train in either dagger or one handed weapon skill. Shadowblades follow the leadership of the Sinistral's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Shadowblade`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Shadow Daggers`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Shadowsurge`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Shadow Venom`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Sinistral's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = sinistralsGuildDescription
}
function applyMartialMonkClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Martial Monks are devouts of unarmed combat, primarily using their physicality in battle. Using their fists, they perform combos that weaken their enemies and empower their own attacks. They prefer leather armor, but can make use of mail and plate if their strength allows. Martial Monks reside in the Monk's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Martial Monk`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Unarmed`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Catalyst`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Tempest`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = ``
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Monk's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = monksGuildDescription
}
function applyMysticMonkClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Mystic Monks use both their physical and mystic prowess in combat by applying elemental Seals to the enemy, and then breaking them for powerful effects. Mystic Monks like to wear leather armor, and make use of cloth when it can improve their Mysticism. Mystic Monk's reside in the Monk's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Mystic Monk`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Unarmed`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Elemental Seals`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Body Slam`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Unleashed Power`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Monk's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = monksGuildDescription
}
function applyElementalMonkClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Elemental Monks use their fists as a delivery method for their elemental strikes. Their elemental strikes can be combined to create powerful effects. Elemental Monk's reside in the Monk's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Elemental Monk`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Unarmed`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Elemental Strikes`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Elemental Tempest`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Transcendence`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Monk's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = monksGuildDescription
}
function applyPyromancerClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Pyromancers use fire spells to blast their foes. They are are well equipped to deal with single or multiple enemies. Pyromancers are found in the Mage's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Pyromancer`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Devotion`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Fireflames`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Inferno`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Meteor`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Mage's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = magesGuildDescription
}
function applyCryoMageClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `Cryo Mages use ice spells to blast their foes. They are are well equipped to deal with single or multiple enemies. Pyromancers are found in the Mage's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Cryo Mage`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Devotion`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Frostfreeze`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Blizzard`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Cryoclast`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Mage's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = magesGuildDescription
}
function applyLightningMagusClassDescription() {
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = `The Lightning Magus use lightning spells to blast their foes. They are are well equipped to deal with single or multiple enemies. Pyromancers are found in the Mage's Guild.`
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Lightning Magus`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Devotion`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Flashbolt`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Chain Lightning`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Gigavolt`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Mage's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = magesGuildDescription
}
function applyRangerClassDescription() {	
	let strength = preClass.str > 1 ? `Strength: +${preClass.str - 1}` : ``
	let dexterity = preClass.dex > 1 ? `Dexterity: +${preClass.dex - 1}` : ``
	let agility = preClass.agi > 1 ? `Agility: +${preClass.agi - 1}` : ``
	let intelligence = preClass.int > 1 ? `Intelligence: +${preClass.int - 1}` : ``
	let wisdom = preClass.wis > 1 ? `Wisdom: +${preClass.wis - 1}` : ``
	let mysticism = preClass.mys > 1 ? `Mysticism: +${preClass.mys - 1}` : ``
	let constitution = preClass.con > 1 ? `Constitution: +${preClass.con - 1}` : ``
	const descriptionText = rangersGuildDescription
	const classHeading = document.querySelector('.classHeading')
	classHeading.textContent = `Ranger`
	const classDescription = document.querySelector('.classDescription')
	classDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.statsHeading')
	statsHeading.textContent = `Starting Stats`
	const statsDetails1 = document.querySelector('.statsDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.statsDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.statsDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.statsDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.statsDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.statsDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.statsDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.startingSkillsHeading')
	startingSkillsHeading.textContent = `Starting Skills`
	const startingSkillsDetails1 = document.querySelector('.startingSkillsDetails1')
	startingSkillsDetails1.textContent = `Bows`
	const startingSkillsDetails2 = document.querySelector('.startingSkillsDetails2')
	startingSkillsDetails2.textContent = ``
	const startingSkillsDetails3 = document.querySelector('.startingSkillsDetails3')
	startingSkillsDetails3.textContent = ``
	const startingSkillsDetails4 = document.querySelector('.startingSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.startingSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.startingSkillsDetails6')
	startingSkillsDetails6.textContent = ``
	const abilitiesHeading = document.querySelector('.abilitiesHeading')
	abilitiesHeading.textContent = `Abilities`
	const abilitiesDetails1 = document.querySelector('.abilitiesDetails1')
	abilitiesDetails1.textContent = `Piercing Arrow`
	const abilitiesDetails2 = document.querySelector('.abilitiesDetails2')
	abilitiesDetails2.textContent = `Rapid Fire`
	const abilitiesDetails3 = document.querySelector('.abilitiesDetails3')
	abilitiesDetails3.textContent = `Hydra Arrow`
	const guildHeading = document.querySelector('.guildHeading')
	guildHeading.textContent = `Ranger's Guild`
	const guildDescription = document.querySelector('.guildDescription')
	guildDescription.textContent = rangersGuildDescription
}
function applyHumanRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Human`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Daggers`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Dodging`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Stealth`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyDwarfRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``
	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Dwarf`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyElfRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``
	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Elf`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyHalfElfRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``
	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Half Elf`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyHalfMinotaurRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Half Minotaur`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyTieflingRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Tiefling`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyCatlineRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Catline`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyGnomeRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Gnome`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyHalflingRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Halfling`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyFaerieRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Faerie`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}
function applyDragonKinRaceDescription() {
	let strength = preRace.str > 0 ? `Strength: +${preRace.str}` : ``
	let dexterity = preRace.dex > 0 ? `Dexterity: +${preRace.dex}` : ``
	let agility = preRace.agi > 0 ? `Agility: +${preRace.agi}` : ``
	let intelligence = preRace.int > 0 ? `Intelligence: +${preRace.int}` : ``
	let wisdom = preRace.wis > 0 ? `Wisdom: +${preRace.wis}` : ``
	let mysticism = preRace.mys > 0 ? `Mysticism: +${preRace.mys}` : ``
	let constitution = preRace.con > 0 ? `Constitution: +${preRace.con}` : ``

	const descriptionText = ``
	const raceHeading = document.querySelector('.raceDescriptionHeading')
	raceHeading.textContent = `Dragon Kin`
	const raceDescription = document.querySelector('.raceDescription')
	raceDescription.textContent = descriptionText
	const statsHeading = document.querySelector('.raceStatsHeading')
	statsHeading.textContent = `Bonus Stats`
	const statsDetails1 = document.querySelector('.raceDetails1')
	statsDetails1.textContent = `${strength}`
	const statsDetails2 = document.querySelector('.raceDetails2')
	statsDetails2.textContent = `${dexterity}`
	const statsDetails3 = document.querySelector('.raceDetails3')
	statsDetails3.textContent = `${agility}`
	const statsDetails4 = document.querySelector('.raceDetails4')
	statsDetails4.textContent = `${intelligence}`
	const statsDetails5 = document.querySelector('.raceDetails5')
	statsDetails5.textContent = `${wisdom}`
	const statsDetails6 = document.querySelector('.raceDetails6')
	statsDetails6.textContent = `${mysticism}`
	const statsDetails7 = document.querySelector('.raceDetails7')
	statsDetails7.textContent = `${constitution}`
	const startingSkillsHeading = document.querySelector('.raceSkillsHeading')
	startingSkillsHeading.textContent = `Bonus Skills`
	const startingSkillsDetails1 = document.querySelector('.raceSkillsDetails1')
	startingSkillsDetails1.textContent = `Rest`
	const startingSkillsDetails2 = document.querySelector('.raceSkillsDetails2')
	startingSkillsDetails2.textContent = `Toughness`
	const startingSkillsDetails3 = document.querySelector('.raceSkillsDetails3')
	startingSkillsDetails3.textContent = `Dodge`
	const startingSkillsDetails4 = document.querySelector('.raceSkillsDetails4')
	startingSkillsDetails4.textContent = ``
	const startingSkillsDetails5 = document.querySelector('.raceSkillsDetails5')
	startingSkillsDetails5.textContent = ``
	const startingSkillsDetails6 = document.querySelector('.raceSkillsDetails6')
	startingSkillsDetails6.textContent = ``
}

function increaseWeaponSkill() {
	player.twoHanded.level = 30
	player.oneHanded.level = 30
	player.daggers.level = 30
	player.unarmed.level = 30
	player.bows.level = 30
	player.str = 10
	player.dex = 10
	player.agi = 10
	player.skillPoints = 100
	player.attributePoints = 100
	player.health = 1000
	player.maxHealth = 1000
	player.combat = false
	recall(-7, 4, 0)
	updatePlayerStats()
}
function decreaseWeaponSkill() {
	player.currentWeaponSkill.level--
	updatePlayerStats()
}

function gainLevel() {
	playerGainKillExperience(30)
	updatePlayerStats()
}
function loseLevel() {
	playerGainKillExperience(-30)
	updatePlayerStats()
}

let healthBarTest = document.querySelector('.health-bar-container')
let manaBarTest = document.querySelector('.mana-bar-container')
healthBarTest.addEventListener('click', gainLevel)
manaBarTest.addEventListener('click', loseLevel)


function welcome() {
	let welcomeWindow = document.createElement('img')
	// let welcomeNode = document.createElement('img')
	// welcomeNode.src = "images/banner and misc/galvadia_title2.jpg"
	welcomeWindow.src = "images/Galvadia Cropped Banner.png"
	welcomeWindow.classList.add('welcome')
	// welcomeWindow.appendChild(welcomeNode)
	masterArea.appendChild(welcomeWindow)
}

function confirmCharacterNameCheck(playerName) {
	// Trim any leading/trailing whitespace
	playerName = playerName.trim();

	if (playerName === "") {
		return { valid: false, message: "You need to come up with a name before confirming your character." };
	}
	if (/\s/.test(playerName)) {
		return { valid: false, message: "Your name cannot contain any spaces." };
	}
	if (!/^[a-zA-Z]+$/.test(playerName)) {
		return { valid: false, message: "Your name can only contain letters." };
	}
	playerName = playerName.charAt(0).toUpperCase() + playerName.slice(1).toLowerCase();
	
	// Return the formatted name and valid status
	return { valid: true, message: "Name is valid.", formattedName: playerName };
}

async function confirmationButtonFunction() {
	let mainAndStats = document.getElementById('main-and-stats')
	let body = document.querySelector('body')
	let galvadiaBanner = document.querySelector('.welcome')
	let nameInputElement = document.querySelector('#name-character-input')
	let playerName = nameInputElement.value
	let namePassOrFail = confirmCharacterNameCheck(playerName)
	const disappear = document.getElementById('class-and-race-container')
	const playerNameDisplay = document.querySelector('.name')

	if (!player.playerClass.name) {
		window.alert(`You need to select a class before confirming your character.`)
		return
	}
	if (player.race.length < 1) {
		window.alert(`You need to select a race before confirming your character.`)
		return
	}
	if (namePassOrFail.valid === false) {
		window.alert(namePassOrFail.message)
		return
	}
	let isPlayerReady = window.confirm(`
Name: ${namePassOrFail.formattedName}
Class: ${player.playerClass.name}
Race: ${player.race}
Do you wish to confirm your character and start the game?
`)
	if (!isPlayerReady) {return}
	player.name = namePassOrFail.formattedName
	playerNameDisplay.textContent = nameInputElement.value
	body.classList.remove('fade-in')
	body.classList.add('fade-out')
	await dialogueWait(4000)
	player.dialogueStasis = true
	disappear.remove()
	galvadiaBanner.remove()
	unhideElements([mainAndStats])
	body.classList.add('fade-in')
	body.classList.remove('fade-out')
	recall(0, 0, -2)
	masterArea.innerHTML = ''
	commandLine.focus()
	areaCompiler(currentArea)
	await dialogueWait(2000)
	gameStartMessage()
}

function gameStartMessage() {
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	customizeEachWord(`Welcome to Galvadia! Your adventure begins in the basement of the castle's Training Halls geared with nothing but an old man. He will walk you through the basics, teaching you how to navigate and interact with the world around you. For more detailed information, be sure to check the Player's Guide in the game folder. When you're ready to proceed, use the SPEAK or TALK command followed by his name. Try, 'speak egbert' or 'talk egbert' to begin your journey.`, 'white', line1)
	customizeEachWord(`NOTE: Every command can be typed lower case. There is no command that requires capitalization.`, 'white', line2)
	blankSpace()
}

function displayCharacterConfirmation() {
	const finishCharacterText = document.createElement(`div`)
	const nameCharacterHeading = document.createElement(`h2`)
	finishCharacterText.textContent = `When you are ready to start the game, name your character and click the confirmation button.`
	nameCharacterHeading.textContent = `Character Name`
	finishCharacterText.classList.add('name-character-heading')
	nameCharacterHeading.classList.add('name-character-heading')

	const nameCharacterInputContainer = document.createElement('div')
	const nameCharacterInput = document.createElement(`input`)
	nameCharacterInput.maxLength = 20
	nameCharacterInput.setAttribute('id', 'name-character-input')
	nameCharacterInputContainer.appendChild(nameCharacterInput)
	nameCharacterInputContainer.classList.add('name-character-input-container')

	const confirmationButtonDiv = document.createElement('div')
	const confirmationButton = document.createElement('button')

	confirmationButton.addEventListener('click', confirmationButtonFunction)
	confirmationButtonDiv.classList.add('character-confirmation')
	confirmationButton.textContent = 'Confirm Character'
	confirmationButton.classList.add('character-confirmation-button')
	confirmationButtonDiv.appendChild(confirmationButton)
	document.getElementById('class-and-race-container').appendChild(finishCharacterText)
	document.getElementById('class-and-race-container').appendChild(nameCharacterHeading)
	document.getElementById('class-and-race-container').appendChild(nameCharacterInputContainer)
	document.getElementById('class-and-race-container').appendChild(confirmationButtonDiv)
}

function advanceAndRetreatCheck() {
	let line1 = document.createElement('div')
	if (player.advancing) {
		customizeEachWord(`You are currently engaging your target and cannot perform another action for [`, 'white', line1)
		customizeEachWord(`${advanceTimer}`, 'yellow', line1)
		customizeEachWord(`] seconds`, 'white', line1)
		updateScroll()
		return true
	}
	if (player.retreating) {
		customizeEachWord(`You are currently retreating and cannot perform other another for [`, 'white', line1)
		customizeEachWord(`${retreatTimer}`, 'yellow', line1)
		customizeEachWord(`] seconds`, 'white', line1)
		updateScroll()
		return true
	}
}
function playerCombatCheck() {
	if (player.combat == true) {
		quickMessage(`You cannot do this while in combat!`)
	}
}
//class list
//Berserker
//Fighter
//Knight
//Assassin
//Thief
//Shadowblade
//Martial Monk
//Mystic Monk
//Elemental Monk
//Ranger
//Mage
function playerAbility1() {
	switch (player.playerClass.name) {
		case 'Berserker':
			ripslashFunction()
			break;
		case 'Fighter':
			dualStrikeFunction()
			break;
		case 'Knight':
			valorStrikeFunction()
			break;
		case 'Assassin':
			ambushFunction()
			break;
		case 'Thief':
			venomBladeFunction()
			break;
		case 'Shadowblade':
			shadowsurgeFunction()
			break;
		case 'Martial Monk':
			catalystFunction()
			break;
		case 'Mystic Monk':
			fireSealFunction()
			break;
		case 'Elemental Monk':
			blazingFistFunction()
			break;
		case 'Ranger':
			piercingArrowFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.fireflames)
			break;
		case 'Cryo Mage':
			spellFunction(player.frostfreeze)
			break;
		case 'Lightning Magus':
			spellFunction(player.flashbolt)
			break;
		default:
		quickMessage(`You are in stasis and cannot perform this action.`)
	}
	updateMonsterBox()
}
function playerAbility1Shift() {
	switch (player.playerClass.name) {
		case 'Martial Monk':
			tempestFunction()
			break;
		case 'Mystic Monk':
			waterSealFunction()
			break;
		case 'Elemental Monk':
			tidalFistFunction()
			break;
		default:
			quickMessage(`You are in stasis and cannot perform this action.`)
		}
	updateMonsterBox()
}
function playerAbility1Alt() {
	switch (player.playerClass.name) {
		case 'Martial Monk':
			tempestFunction()
			break;
		case 'Mystic Monk':
			earthSealFunction()
			break;
		case 'Elemental Monk':
			lightningFistFunction()
			break;
		default:
			quickMessage(`You are in stasis and cannot perform this action.`)
		}
	updateMonsterBox()
}
function playerAbility1ShiftAndAlt() {
	switch (player.playerClass.name) {
		case 'Elemental Monk':
			quakeFistFunction()
			break;
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility2Shift() {
	switch (player.playerClass.name) {
		case 'Martial Monk':
			callOfWindFunctionCombat()
			break;
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility2Alt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility2ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility3Shift() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility3Alt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility3ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4() {
	switch (player.playerClass.name) {
		case 'Shadowblade':
			shadowVenomFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.barrier)
			break;
		case 'Cryo Mage':
			spellFunction(player.barrier)
			break;
		case 'Lightning Magus':
			spellFunction(player.barrier)
			break;
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4Shift() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4Alt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}
function playerAbility4ShiftAndALt() {
	switch (player.playerClass.name) {
		default:
		quickMessage(`Nothing yet`)
		break;
	}
}

function playerAbility2() {
	switch (player.playerClass.name) {
		case 'Berserker':
			cycloneFunction()
			break;
		case 'Fighter':
			shredFunction()
			break;
		case 'Knight':
			shieldSlamFunction()
			break;
		case 'Assassin':
			backstabFunction()
			break;
		case 'Thief':
			contagionFunction()
			break;
		case 'Shadowblade':
			shadowDaggersFunction()
			break;
		case 'Martial Monk':
			callOfWindFunctionRanged()
			break;
		case 'Mystic Monk':
			mysticFistFunction()
			break;
		case 'Elemental Monk':
			elementalTempestFunction()
			break;
		case 'Ranger':
			rapidFireShotFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.inferno)
			break;
		case 'Cryo Mage':
			spellFunction(player.blizzard)
			break;
		case 'Lightning Magus':
			spellFunction(player.chainLightning)
			break;
		default:
			quickMessage(`You are in stasis and cannot perform this action.`)
		}
	updateMonsterBox()
}
function playerAbility3() {
	switch (player.playerClass.name) {
		case 'Berserker':
			cataclysmFunction()
			break;
		case 'Fighter':
			bladeBlitzFunction()
			break;
		case 'Knight':
			boomingMightFunction()
			break;
		case 'Assassin':
			guillotineFunction()
			break;
		case 'Thief':
			baneFunction()
			break;
		case 'Shadowblade':
			shadowNovaFunction()
			break;
		case 'Martial Monk':
			knuckleBlitzFunction()
			break;
		case 'Mystic Monk':
			unleashedPowerFunction()
			break;
		case 'Elemental Monk':
			transcendenceFunction()
			break;
		case 'Ranger':
			hydraArrowFunction()
			break;
		case 'Pyromancer':
			spellFunction(player.meteor)
			break;
		case 'Cryo Mage':
			spellFunction(player.cryoclast)
			break;
		case 'Lightning Magus':
			spellFunction(player.gigavolt)
			break;
		default:
			quickMessage(`You are in stasis and cannot perform this action.`)
		}
	updateMonsterBox()
}

function playerNormalAttack() {
	switch (player.playerClass.name) {
		case 'Berserker':
			attack()
			break;
		case 'Fighter':
			attack()
			break;
		case 'Knight':
			attack()
			break;
		case 'Assassin':
			attack()
			break;
		case 'Thief':
			attack()
			break;
		case 'Shadowblade':
			attack()
			break;
		case 'Martial Monk':
			attack()
			break;
		case 'Mystic Monk':
			attack()
			break;
		case 'Elemental Monk':
			attack()
			break;
		case 'Ranger':
			attack()
			break;
		case 'Mage':
			target()
			break;
		default:
			quickMessage(`You are in stasis and cannot perform this action.`)
		}
	updateMonsterBox()
}

function playerNormalAttackShift() {
	let targetEnemy = targetFirstEnemy()
	if (targetEnemy) {
		player.combat = true
		targetEnemy.combat = true
	}
	attackGodMode()
	// return
	// switch (player.playerClass.name) {
	// 	case 'Berserker':
	// 		if (player.charge.level > 0) {
	// 			chargeFunction()
	// 			return
	// 		}
	// 		attackGodMode()
	// 		break;
	// 	case 'Fighter':
	// 		if (player.charge.level > 0) {
	// 			chargeFunction()
	// 			return
	// 		}
	// 		attackGodMode()
	// 		break;
	// 	case 'Knight':
	// 		if (player.charge.level > 0) {
	// 			chargeFunction()
	// 			return
	// 		}
	// 		attackGodMode()
	// 		break;
	// 	}
}

function warriorKeybinds() {}
function rogueKeybinds() {}
function rangerKeybinds() {}
function mageKeybinds() {}

document.addEventListener('keydown', numPadFunctionality)
function numPadFunctionality(event) {
	const isNumpadKey = event.location === 3
  	if (isNumpadKey && document.activeElement === commandLine) {
	  event.preventDefault();
	}
	if (isNumpadKey) {
		let eventKey = !isNaN(event.key) ? parseInt(event.key) : event.key
		handleAction(eventKey, event)
	}
}
function handleAction(action, event) {
	if (advanceAndRetreatCheck()) {return}
	if (event.altKey && event.shiftKey && action == '/') {playerAbility1ShiftAndAlt()}
	else if (event.shiftKey && action == '/') {playerAbility1Shift()} 
	else if (event.altKey && action == '/') {playerAbility1Alt()}
	else if (action == '/') {playerAbility1()} 

	else if (event.altKey && event.shiftKey && action == '*') {playerAbility2ShiftAndAlt()}
	else if (event.shiftKey && action == '*') {playerAbility2Shift()} 
	else if (event.altKey && action == '*') {playerAbility2Alt()} 
	else if (action == '*') {playerAbility2()} 

	else if (event.altKey && event.shiftKey && action == '-') {playerAbility3ShiftAndAlt()}
	else if (event.shiftKey && action == '-') {playerAbility3Shift()} 
	else if (event.altKey && action == '-') {playerAbility3Alt()} 
	else if (action == '-') {playerAbility3()} 

	else if (event.altKey && event.shiftKey && action == '+') {playerAbility4ShiftAndAlt()}
	else if (event.shiftKey && action == '+') {playerAbility4Shift()} 
	else if (event.altKey && action == '+') {playerAbility4Alt()} 
	else if (action == '+') {playerAbility4()} 

	else if (event.key == 'Clear') {playerNormalAttackShift()}

	switch (action) {
	case 7:
		if (!player.combat && !player.stasis) {
			handleInputs('nw')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('nw')
		} else if (player.stasis) {
			handleCombatStasisInputs('nw')
		} 
		break;
	case 8:
		if (!player.combat && !player.stasis) {
			handleInputs('n')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('n')
		} else if (player.stasis) {
			handleCombatStasisInputs('n')
		} 
		break;
	case 9:
		if (!player.combat && !player.stasis) {
			handleInputs('ne')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('ne')
		} else if (player.stasis) {
			handleCombatStasisInputs('ne')
		} 
		break;
	case 4:
		if (!player.combat && !player.stasis) {
			handleInputs('w')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('w')
		} else if (player.stasis) {
			handleCombatStasisInputs('w')
		} 
		break;
	case 5:
		if (!player.combat && !player.stasis) {
			handleInputs('a')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('a')
		} else if (player.stasis) {
			handleCombatStasisInputs('a')
		} 
	  	// playerNormalAttack()
	  	break
	case 6:
		if (!player.combat && !player.stasis) {
			handleInputs('e')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('e')
		} else if (player.stasis) {
			handleCombatStasisInputs('e')
		} 
		break;
	case 1:
		if (!player.combat && !player.stasis) {
			handleInputs('sw')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('sw')
		} else if (player.stasis) {
			handleCombatStasisInputs('sw')
		} 
		break;
	case 2:
		if (!player.combat && !player.stasis) {
			handleInputs('s')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('s')
		} else if (player.stasis) {
			handleCombatStasisInputs('s')
		} 
		break;
	case 3:
		if (!player.combat && !player.stasis) {
			handleInputs('se')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('se')
		} else if (player.stasis) {
			handleCombatStasisInputs('se')
		} 
		break;
	case 0:
		if (!player.combat && !player.stasis) {
			handleInputs('d')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('d')
		} else if (player.stasis) {
			handleCombatStasisInputs('d')
		} 
		break;
	case '.':
		if (!player.combat && !player.stasis) {
			handleInputs('u')
		} else if (player.combat && !player.stasis) {
			handleCombatInputs('u')
		} else if (player.stasis) {
			handleCombatStasisInputs('u')
		} 
		break;
	default:
		// Handle invalid key
		console.log(action)
		console.log('Invalid key');
	}
  }
  const switchToDay = document.createElement('audio')
  const switchToNight = document.createElement('audio')
  switchToDay.setAttribute('src', './sounds/bird chirps/bird chirp robin 1.mp3')
  switchToNight.setAttribute('src', './sounds/wolves/wolves 1.mp3')

  class GameClock {
	constructor() {
		this.hours = 0;
		this.minutes = 0;
		this.seconds = 0;
		this.isDaytime = true; // Start during the day
		this.tickInterval = 1000; // 1 second interval for simulation
		this.timeScale = 1; // 5 minutes of real time per in-game hour
		this.timer = null;
	}
  
	start() {
		this.timer = setInterval(() => {
			this.updateTime();
			this.displayTime();
		}, this.tickInterval);
	}
	stop() {
		clearInterval(this.timer);
	}
	updateTime() {
		this.seconds += this.timeScale * (this.tickInterval / 1000); // Increment seconds based on time scale
		if (this.seconds >= 60) {
			this.minutes++;
			this.seconds = 0;
			playFlavorText()
		}
		if (this.minutes >= 60) {
			this.hours++;
			this.minutes = 0;
			this.toggleDayNight(); // Toggle day/night cycle every hour
			this.dayNightSwitch()
		}
		if (this.hours >= 24) {
			this.hours = 0; // Reset hours after 24 to simulate a day
		}
	}
	toggleDayNight() {
	this.isDaytime = !this.isDaytime; // Toggle between day and night
	//Day Night Switch Sounds
	}
	daySwitchSounds() {
		switchToDay.play()
	}
	nightSwitchSounds() {
		switchToNight.play()
	}
	dayNightSwitch() {
		if (this.isDaytime) {
			quickMessage(`The darkness dissapates as the light of day rises, casting a cozy glow across the land.`)
			this.daySwitchSounds()
		}
		if (!this.isDaytime) {
			quickMessage(`The soft glow of night materializes as daylight fades.`)
			this.nightSwitchSounds()
		}
	}

	displayTime() {
	let period = this.isDaytime ? 'AM' : 'PM';
	let displayHours = this.hours < 10 ? `0${this.hours}` : this.hours;
	let displayMinutes = this.minutes < 10 ? `0${this.minutes}` : this.minutes;
	let displaySeconds = this.seconds < 10 ? `0${Math.floor(this.seconds)}` : Math.floor(this.seconds);
	// console.log(`Current time: ${displayHours}:${displayMinutes}:${displaySeconds} ${period}`);
	}
  }
const clock = new GameClock();
clock.start();
//Clock messages
function playFlavorText() {
	if (currentArea.descriptions.zoneType == 'galvadia_town') {
		let randomNumber = randomNumberRange(1, 6)
		blankSpace()
		if (randomNumber == 1) {clockMessage1()}
		if (randomNumber == 2) {clockMessage2()}
		if (randomNumber == 3) {clockMessage3()}
		if (randomNumber == 4) {clockMessage4()}
		if (randomNumber == 5) {clockMessage5()}
		if (randomNumber == 6) {blacksmithHammerMessage()}
		if (randomNumber == 7) {wagonWheelMessage()}
		blankSpace()
	}
}
function clockMessage1() {
	quickMessage(`A group of giggling kids run past you, chasing one another.`)
}
function clockMessage2() {
	quickMessage(`Castle Guards on horseback trot through the square, keeping an eye on the peace.`)
}
function clockMessage3() {
	quickMessage(`A breeze blows through, carrying the mixed scent of freshly cut wood, baked goods, and blacksmith smoke.`)
}
function clockMessage4() {
	quickMessage(`A merchant pats his coin purse after a customer walks away.`)
}
function clockMessage5() {
	quickMessage(`You see a pack of scruffy looking dogs rummaging and sniffing about in an alley.`)
}

function blacksmithHammerMessage() {
	let randomNumber = randomNumberRange(1, 2)
	randomNumber == 1 ? blacksmithHammerSound.play() : blacksmithHammerSound2.play()
	quickMessage(`You hear the nearby sounds of the blacksmith hammering away at the forge.`)
}
function wagonWheelMessage() {
	let randomNumber = randomNumberRange(1, 2)
	randomNumber == 1 ? wagonWheelSound.play() : wagonWheelSound2.play()
	quickMessage(`A wagon rolls through the streets toward a stall, delivering goods to the shop.`)
}

async function fishFunction() {
	if (player.isAbilityQueued) {
		quickMessage(`You cannot fish while an ability is winding up.`)
		return
	}
	if (player.spellsConjured[0]) {
		quickMessage(`You cannot fish while a spell is conjured.`)
		return
	}
	let line1 = lineFunc()
	let line2 = lineFunc()
	blankSpace()
	if (player.isFishing) {
		let castBar1 = document.querySelector('.bar-4');
		let castBar1WidthNumber = parseFloat(castBar1.style.width.replace('%', ''));
		if (castBar1WidthNumber > fishBotEnd && castBar1WidthNumber < fishTopEnd) {
			customizeEachWord(`You reel in your catch and it plops to the ground.`, 'white', line1)
			customizeEachWord(`You caught a `, 'white', line2)
			customizeEachWord(`${selectedFish().name}`, selectedFish().color, line2)
			customizeEachWord(`!`, 'white', line2)
			blankSpace()
			playFishCatch()
			fishItemGen(selectedFish(currentArea))
		} else if (player.isReeling) {
			customizeEachWord(`The fish got away!`, 'white', line1)
		} else {
			customizeEachWord(`You reel in your line.`, 'white', line1)
		}
		stopAnimation()
		clearTimeout(fishBiteTimer)
		selectedFish = ''
		player.isFishing = false
		player.isReeling = false
		player.stasis = false
		return
	}
	if (!currentArea.descriptions.fishMods) {
		customizeEachWord(`You cannot fish here.`, 'white', line1)
		return
	}
	if (player?.fishing?.level < currentArea.descriptions.fishMods.levelRequirement) {
		customizeEachWord(`You need a fishing level of `, 'white', line1)
		customizeEachWord(`${currentArea.descriptions.fishMods.levelRequirement} `, 'green', line1)
		customizeEachWord(`to fish here.`, 'white', line1)
		return
	}
	player.isFishing = true
	player.stasis = true
	await dialogueWait(200)
	customizeEachWord(`You cast your line into the water.`, 'white', line1)
	playBobberSplash()
	let fishMods = currentArea.descriptions.fishMods
	let fishListLength = fishMods.fishList.length
	let randomNumber = randomNumberRange(0, 0)
	selectedFish = currentArea.descriptions.fishMods.fishPicker()
	let base = selectedFish().catchRange
	let highestRandomNumber = 100 - base
	fishBotEnd = randomNumberRange(1, highestRandomNumber)
	fishTopEnd = fishBotEnd + (base - 1)
	let biteTimer = selectedFish().timeTilBite
	console.log(biteTimer)
	fishBiteTimer = setTimeout(() => {
		initiateFishCatch(selectedFish, fishBotEnd, fishTopEnd)
	}, biteTimer)
	blankSpace()
}


async function initiateFishCatch(fish, fishBotEnd, fishTopEnd) {
	playFishSplash()
	await dialogueWait(200)
	let line1 = lineFunc()
	blankSpace()
	customizeEachWord(`Something snags your line!`, 'white', line1)
	blankSpace()
	player.isReeling = true
	const castBar1 = document.querySelector('.bar-4');
	castBar1.style.width = '0%'
	let barSpeed = fish().speed
	let startTime
	let animationId

	function animateBar(timestamp) {
		if (!startTime) {
			startTime = timestamp;
		}
		const progress = Math.max(1 - (timestamp - startTime) / barSpeed, 0); // Reverse progress calculation
		const width = progress * 100;

		castBar1.classList.add('fish-bar-blue')
		if (width > fishBotEnd && width < fishTopEnd) {
			castBar1.classList.add('fish-bar-red')
		} else {
			castBar1.classList.remove('fish-bar-red')
		}
		castBar1.style.width = `${width}%`;
		if (progress > 0) {
			castBarAnimationFrames.castBar1 = requestAnimationFrame(animateBar);
		} else {
			let line1 = lineFunc()
			blankSpace()
			customizeEachWord(`You attempt to reel in the fish, but it gets away..`, 'white', line1)
			blankSpace()
			player.isFishing = false
			player.stasis = false
			castBar1.style.width = '0%';
			let test = Array.from(castBar1.classList)
			castBar1.classList = test[0]
		}
	}

	castBarAnimationFrames.castBar1 = requestAnimationFrame(animateBar);

	function stopAnimation() {
		cancelAnimationFrame(castBarAnimationFrames.castBar1);
	}
}

function calculateFishRange(fish) {
	let base = fish.catchRange
	let highestRandomNumber = 100 - base
	let botEnd = randomNumberRange(1, highestRandomNumber)
	let topEnd = botEnd + (base - 1)
}

function stopAnimation() {
	cancelAnimationFrame(castBarAnimationFrames.castBar1);
	const castBar1 = document.querySelector('.bar-4');
	castBar1.style.width = '0%';
	let test = Array.from(castBar1.classList)
	castBar1.classList = test[0]
}





function gameStart() {
	let testing = true
	player.combat = false
	player.dialogueStasis = true
	if (testing) {
	player.stasis = false
	player.dialogueStasis = false
	//INITIALIZE NPCS AND MONSTER BEHAVIOR
	// strayKitty.npcBehavior()
	// annoyedSquire.npcBehavior()
	// villagerMalchus.npcBehavior()
	// villagerLinus.npcBehavior()
	// rissah.npcBehavior()
	// deylani.npcBehavior()
	// timtim.npcBehavior()
	// sally.npcBehavior()
	// frederickGregory.npcBehavior()
	// villager1.npcBehavior()

	pushMonster.push(trainingDummy(currentArea))
	pushMonster.push(trainingDummy2(currentArea))
	pushMonster.push(trainingDummy3(currentArea))
	pushMonster.push(trainingDummy4(currentArea))
	pushMonster.push(trainingDummy5(currentArea))
	pushMonster.push(trainingDummy6(currentArea))



	weaponGen(trainingShortsword())
	weaponGen(trainingShortsword())
	weaponGen(trainingTwoHandedSword())
	weaponGen(trainingStaff())
	weaponGen(trainingBow())
	weaponGen(trainingDagger())
	weaponGen(trainingDagger())
	weaponGen(trainingShield())
	pushItem[2].roomId = 'backpack'
	pushItem[3].roomId = 'backpack'
	pushItem[4].roomId = 'backpack'
	pushItem[5].roomId = 'backpack'
	pushItem[6].roomId = 'backpack'
	pushItem[7].roomId = 'backpack'
	pushItem[8].roomId = 'backpack'
	pushItem[9].roomId = 'backpack'
	updateScroll()
	updatePlayerStats()
	player.gold = 1000
	player.attributePoints = 100
	player.skillPoints = 1000
	recall(0, 0, -2)
	masterArea.innerHTML = ''
	} else {
		// till.npcBehavior()
		// krista.npcBehavior()
		// sylas.npcBehavior()
		// gaelwyn.npcBehavior()
		// lessa.npcBehavior()
	}
	openingTest()
	let mainAndStats = document.getElementById('main-and-stats')

	unhideElements([mainAndStats])
}

async function openingTest() {
	welcome()
	displayClassSelection()
	displayClassDetails()
	displayRaceSelection()
	displayRaceDetails()
	displayCharacterConfirmation()

	let mainAndStats = document.getElementById('main-and-stats')
	hideElements([mainAndStats])
}

function hideElements(elementsToHide) {
	//elementsToHide should be an array
	for (const element of elementsToHide) {
		element.classList.add('hide')
	}
}
function unhideElements(elementsToUnhide) {
	//elementsToUnhide should be an array
	for (const element of elementsToUnhide) {
		element.classList.remove('hide')
	}
}

const trainingFieldsRoomPack = [fields1, fields2, fields3, fields4, fields5, fields6, fields7, fields8, fields9]
const galvadiaSquareRoomPack = [galvadiaTownSquareNorthwest, galvadiaTownSquareNortheast, galvadiaTownSquare, galvadiaTownSquareEast, galvadiaTownSquareNorth, galvadiaTownSquareWest, galvadiaCitySouthwest, galvadiaTownSquareSouth, galvadiaCitySoutheast]


gameStart()

function serializeGameState(gameState) {
    return JSON.stringify(gameState, (key, value) => {
        if (typeof value === 'function') {
            return value.toString(); // Convert functions to strings
        }
        return value;
    });
}

function deserializeGameState(jsonString) {
    const parsedObject = JSON.parse(jsonString, (key, value) => {
        if (typeof value === 'string' && value.startsWith('function')) {
            // Reconstruct function from string
            return new Function('return ' + value)();
        }
        return value;
    });
    // If you need to restore prototypes or more complex structures, do it here
    return parsedObject;
}

function npcSaveQuestStage() {
	for (const npc of allNpcsArray) {
		if (npc.questStage) {
			player.npcQuestStageStorage[npc.refName] = npc.questStage
		}
	}
}

function saveGame(secondCommand) {
	npcSaveQuestStage()
	playerSetCurrentArea()
	playerSetPushItem()
	const jsonString = serializeGameState(player)
	const blob = new Blob([jsonString], { type: "application/json" });
	const link = document.createElement("a");
	link.download = secondCommand + ".json";
	link.href = URL.createObjectURL(blob);
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
}

// Load game function
function retrieveSaveFile() {
	//TO MAKE PLAYER SPECIFY FILENAME, ADD filename AS THE PARAMETER
	//AND THEN FOLLOW DIRECTIONS IN NEXT ALL CAPS COMMENTS
    // if (!filename) {
    //     console.error('No filename provided');
    //     return;
    // }
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';

    fileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
		//UNCOMMENT THE BELOW CODE TO HAVE THE FUNCTION CHECK IF A FILE NAME
		//WAS SPECIFIED - THEN DELETE THE NEAR IDENTICAL CODE BELOW THAT STARTS
		//WITH if (file) {

        // if (file && file.name === `${filename}.json`) {
        //     const reader = new FileReader();

        //     reader.onload = function(e) {
        //         const gameState = deserializeGameState(e.target.result)
        //         loadGame(gameState);
        //     };

        //     reader.readAsText(file);
        // } 
        if (file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                const gameState = deserializeGameState(e.target.result)
                loadGame(gameState);
            };

            reader.readAsText(file);
        } 
		else {
            console.error('File not found or incorrect filename');
        }
    });
    fileInput.click();  // Simulate clicking the file input to open the file dialog
}

function loadGame(savedPlayer) {
	player = savedPlayer
	addAllSkillsToPlayer()
	applyGettersAndSettersToPlayer()
	loadNpcsIntoAreas()
	playerLoadCurrentArea()
	playerLoadPushItem()
	areaCompiler(currentArea)
	updatePlayerStats()
	look()
}

function playerSetCurrentArea() {
	if (!currentArea?.descriptions?.areaName) {
		quickMessage(`Cannot save in this area (for some reason? As Taylor)`)
		return
	}
	player.currentArea = currentArea.descriptions.areaName
}

function playerLoadCurrentArea() {
	let areaToLoadPlayerInto = allAreas.find(area => area?.descriptions?.areaName == player.currentArea)
	currentArea = areaToLoadPlayerInto
	player.x = currentArea.x
	player.y = currentArea.y
	player.z = currentArea.z
}

class ReconstructPushItem {
	constructor(roomId, name, picture, color, keywords, botDamage, topDamage, mods,
		requirements, type, enchantment, skillUsed, price, sellValue, description
	) {
		this.roomId = roomId
		this.name = name
		this.picture = picture
		this.color = color
		this.keywords = keywords
		this.botDamage = botDamage
		this.topDamage = topDamage
		this.mods = mods
		this.requirements = requirements
		this.type = type
		this.enchantment = enchantment
		this.skillUsed = skillUsed
		this.price = price
		this.sellValue = sellValue
		this.description = description
		this.swing = (enemy, weapon) => oneHandedSwing1(enemy, weapon)
		this.miss = (enemy, weapon) => oneHandedSwing1(enemy, weapon)
	}

	desc() {
		itemDescription(this)
	}

}

function playerSetPushItem() {
	let serializedPushItem = serializeGameState(pushItem)
	console.log(serializedPushItem)
	player.pushItem = serializedPushItem
}
function playerLoadPushItem() {
	let deserializedPushItem = deserializeGameState(player.pushItem)
	let reconstructedItems = deserializedPushItem.map(itemData => {
			return new ReconstructPushItem(itemData.roomId, itemData.name, itemData.picture, itemData.color,
			itemData.keywords, itemData.botDamage, itemData.topDamage, itemData.mods, itemData.requirements,
			itemData.type, itemData.enchantment, itemData.skillUsed, itemData.price, itemData.sellValue,
			itemData.description, itemData.desc, itemData.swing, itemData.miss
		)
	})
	pushItem = reconstructedItems
	console.log(reconstructedItems)
	// pushItem = deserializedPushItem
}

function applyGettersAndSettersToPlayer() {
	console.log(player.baseStats.healthPerLevel)
	console.log(player.level)
	console.log(player.baseStats.healthPerCON)
	console.log(player.vigor.level)
	console.log(player.con)
	Object.defineProperty(player, 'str', {get() {return calculateStat(this, 'str')}})
	Object.defineProperty(player, 'dex', {get() {return calculateStat(this, 'dex')}})
	Object.defineProperty(player, 'agi', {get() {return calculateStat(this, 'agi')}})
	Object.defineProperty(player, 'wis', {get() {return calculateStat(this, 'wis')}})
	Object.defineProperty(player, 'mys', {get() {return calculateStat(this, 'mys')}})
	Object.defineProperty(player, 'con', {get() {return calculateStat(this, 'con')}})
	Object.defineProperty(player, 'maxMight', {get() {return calculateStat(this, 'maxMight')}})
	Object.defineProperty(player, 'maxFocus', {get() {return calculateStat(this, 'maxFocus')}})
	Object.defineProperty(player, 'sinisterMarksMax', {get() {return calculateStat(this, 'sinisterMarksMax')}})
	Object.defineProperty(player, 'weight', {get() {return calculateStat(this, 'weight')}})
	Object.defineProperty(player, 'advanceTimer', {get() {return calculateStat(this, 'advanceTimer')}})
	Object.defineProperty(player, 'retreatTimer', {get() {return calculateStat(this, 'retreatTimer')}})

	Object.defineProperty(player, 'dodge', {get() {return calculateStat(this, 'dodge') + player.dodging.rating() + (player.agi * 3) - player.burden}})
	Object.defineProperty(player, 'accuracy', {get() {return calculateStat(this, 'accuracy') - player.burden}})
	Object.defineProperty(player, 'slashingPen', {get() {return calculateStat(this, 'slashingPen') + player.slashingExpertise.amount()}})
	Object.defineProperty(player, 'piercingPen', {get() {return calculateStat(this, 'piercingPen') + player.piercingExpertise.amount()}})
	Object.defineProperty(player, 'bluntPen', {get() {return calculateStat(this, 'bluntPen') + player.bluntExpertise.amount()}})
	Object.defineProperty(player, 'slashingArmor', {get() {return calculateStat(this, 'slashingArmor') + player.toughness.rating()}})
	Object.defineProperty(player, 'piercingArmor', {get() {return calculateStat(this, 'piercingArmor') + player.toughness.rating()}})
	Object.defineProperty(player, 'bluntArmor', {get() {return calculateStat(this, 'bluntArmor') + player.toughness.rating()}})

	Object.defineProperty(player, 'fireResist', {get() {return calculateStat(this, 'fireResist')}})
	Object.defineProperty(player, 'iceResist', {get() {return calculateStat(this, 'iceResist')}})
	Object.defineProperty(player, 'lightningResist', {get() {return calculateStat(this, 'lightningResist')}})
	Object.defineProperty(player, 'waterResist', {get() {return calculateStat(this, 'waterResist')}})
	Object.defineProperty(player, 'windResist', {get() {return calculateStat(this, 'windResist')}})

	Object.defineProperty(player, 'burden', {get() {return Math.max(calculateStat(this, 'burden') - (player.str * 5), 0)}})

	Object.defineProperty(player, 'spellPower', {get() {
		let isSpellWeaponValid = (player.currentWeaponRight()?.mods?.spellPower ?? 0) * (player.spellWeapons?.bonus() ?? 0);
		let spellWeaponBonus = Math.max(0, isSpellWeaponValid || 0)
		let baseSpellpowerCalculation = Math.ceil((player.int * 2) + player.wis + spellWeaponBonus)
		console.log(spellWeaponBonus)
		console.log(baseSpellpowerCalculation)
		return calculateStat(this, 'spellPower') + baseSpellpowerCalculation
	}})
	Object.defineProperty(player, 'mysticPower', {get() {
		let isMysticWeaponValid =(player.currentWeaponRight()?.mods?.mysticPower ?? 0) * (player.spellWeapons?.bonus() ?? 0);
		let mysticWeaponBonus = Math.max(0, isMysticWeaponValid || 0)
		let baseMysticPowerCalculation = Math.ceil((player.mys * 2) + player.wis + mysticWeaponBonus)
		return calculateStat(this, 'mysticPower') + baseMysticPowerCalculation
	}})
	Object.defineProperty(player, 'maxHealth', {get() {

		let perLevelBonus = player.baseStats.healthPerLevel * player.level
		let perCONBonus = (player.baseStats.healthPerCON + player.vigor.level) * player.con

		return calculateStat(this, 'maxHealth') + perLevelBonus + perCONBonus
	}})
	Object.defineProperty(player, 'maxMana', {get() {
		let perLevelBonus = player.baseStats.manaPerLevel * player.level
		let perWISBonus = (player.baseStats.manaPerWIS + player.devotion.level) * player.wis
		return calculateStat(this, 'maxMana') + perLevelBonus + perWISBonus
	}})
}

function addAllSkillsToPlayer() {
	perception.addToPlayer()
	rest.addToPlayer()
	slashingExpertise.addToPlayer()
	piercingExpertise.addToPlayer()
	bluntExpertise.addToPlayer()
	firePenetration.addToPlayer()
	icePenetration.addToPlayer()
	lightningPenetration.addToPlayer()
	weakSpot.addToPlayer()
	vigor.addToPlayer()
	devotion.addToPlayer()
	cleave.addToPlayer()
	multipleStrikes.addToPlayer()
	doubleDraw.addToPlayer()
	extraStrike.addToPlayer()
	stunningBlows.addToPlayer()
	precision.addToPlayer()
	warcraft.addToPlayer()
	stealth.addToPlayer()
	block.addToPlayer()
	dodging.addToPlayer()
	supremeDodging.addToPlayer()
	toughness.addToPlayer()
	sideStep.addToPlayer()
	quickshot.addToPlayer()
	dodgeStrike.addToPlayer()
	preemptiveStrike.addToPlayer()
	lockpicking.addToPlayer()
	smokeBomb.addToPlayer()
	mindsEye.addToPlayer()
	arcaneKnowledge.addToPlayer()
	mysticismMastery.addToPlayer()
	sorceryMastery.addToPlayer()
	clearMind.addToPlayer()
	spellWeapons.addToPlayer()
	magicDexterity.addToPlayer()
	barrier.addToPlayer()
	battleRage.addToPlayer()
	resilience.addToPlayer()
	hardenedSkin.addToPlayer()
	knightsResolve.addToPlayer()
	blacksmithing.addToPlayer()
	herbalism.addToPlayer()
	leatherworking.addToPlayer()
	fishing.addToPlayer()
	evasiveRoll.addToPlayer()
	athletics.addToPlayer()
	ridingSkill.addToPlayer()
	tauntingShout.addToPlayer()
	berserking.addToPlayer()
	headshot.addToPlayer()
	backstabbing.addToPlayer()
	brutalBlows.addToPlayer()
	thrillOfTheKill.addToPlayer()
	counterAttack.addToPlayer()
	fleetFooted.addToPlayer()
	initiation.addToPlayer()
	vigilance.addToPlayer()
	tactics.addToPlayer()
	fistsOfFury.addToPlayer()
	fistsOfPrecision.addToPlayer()
	wayOfTheFist.addToPlayer()
	bleed.addToPlayer()
	burn.addToPlayer()
	frostbite.addToPlayer()
	charge.addToPlayer()
	ripslash.addToPlayer()
	cyclone.addToPlayer()
	cataclysm.addToPlayer()
	dualStrike.addToPlayer()
	shred.addToPlayer()
	bladeBlitz.addToPlayer()
	valorStrike.addToPlayer()
	shieldSlam.addToPlayer()
	boomingMight.addToPlayer()
	ambush.addToPlayer()
	backstab.addToPlayer()
	guillotine.addToPlayer()
	venomBlade.addToPlayer()
	contagion.addToPlayer()
	bane.addToPlayer()
	poison.addToPlayer()
	shadowsurge.addToPlayer()
	shadowDaggers.addToPlayer()
	shadowNova.addToPlayer()
	shadowVenom.addToPlayer()
	catalyst.addToPlayer()
	tempest.addToPlayer()
	blazingFist.addToPlayer()
	tidalFist.addToPlayer()
	quakeFist.addToPlayer()
	lightningFist.addToPlayer()
	elementalTempest.addToPlayer()
	transcendence.addToPlayer()
	callOfWind.addToPlayer()
	knuckleBlitz.addToPlayer()
	fireSeal.addToPlayer()
	waterSeal.addToPlayer()
	earthSeal.addToPlayer()
	mysticFist.addToPlayer()
	unleashedPower.addToPlayer()
	waveFist.addToPlayer()
	riptideFist.addToPlayer()
	markOfTheBeast.addToPlayer()
	shadowMark.addToPlayer()
	sinisterMark.addToPlayer()
	piercingArrow.addToPlayer()
	hydraArrow.addToPlayer()
	rapidFireShot.addToPlayer()
	aimedShot.addToPlayer()
	unarmed.addToPlayer()
	daggers.addToPlayer()
	oneHanded.addToPlayer()
	twoHanded.addToPlayer()
	bows.addToPlayer()
	shields.addToPlayer()
	fireflames.addToPlayer()
	inferno.addToPlayer()
	meteor.addToPlayer()
	frostfreeze.addToPlayer()
	blizzard.addToPlayer()
	cryoclast.addToPlayer()
	flashbolt.addToPlayer()
	chainLightning.addToPlayer()
	gigavolt.addToPlayer()
	heal.addToPlayer()
	lightningFistEnchant.addToPlayer()
	colossusPunch.addToPlayer()
	hydraStrike.addToPlayer()
	gigasUppercut.addToPlayer()
	atmaShock.addToPlayer()

}

async function testFetch() {
	const response = await fetch('https://www.dnd5eapi.co/api/spells/aid')
	const data = await response.json()
	console.log(data)
	return data
}
